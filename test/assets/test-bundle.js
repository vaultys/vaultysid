/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/node/index.js":
/*!****************************!*\
  !*** ./dist/node/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CryptoChannel = exports.GameOfLifeIcon = exports.KeyManager = exports.IdManager = exports.LocalStorage = exports.convertWebWritableStreamToNodeWritable = exports.convertWebReadableStreamToNodeReadable = exports.StreamChannel = exports.MemoryStorage = exports.MemoryChannel = exports.Challenger = exports.VaultysId = exports.Buffer = exports.crypto = void 0;
const Challenger_1 = __importDefault(__webpack_require__(/*! ./src/Challenger */ "./dist/node/src/Challenger.js"));
exports.Challenger = Challenger_1.default;
const IdManager_1 = __importDefault(__webpack_require__(/*! ./src/IdManager */ "./dist/node/src/IdManager.js"));
exports.IdManager = IdManager_1.default;
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./src/KeyManager */ "./dist/node/src/KeyManager.js"));
exports.KeyManager = KeyManager_1.default;
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./src/VaultysId */ "./dist/node/src/VaultysId.js"));
exports.VaultysId = VaultysId_1.default;
const MemoryChannel_1 = __webpack_require__(/*! ./src/MemoryChannel */ "./dist/node/src/MemoryChannel.js");
Object.defineProperty(exports, "MemoryChannel", ({ enumerable: true, get: function () { return MemoryChannel_1.MemoryChannel; } }));
Object.defineProperty(exports, "StreamChannel", ({ enumerable: true, get: function () { return MemoryChannel_1.StreamChannel; } }));
Object.defineProperty(exports, "convertWebReadableStreamToNodeReadable", ({ enumerable: true, get: function () { return MemoryChannel_1.convertWebReadableStreamToNodeReadable; } }));
Object.defineProperty(exports, "convertWebWritableStreamToNodeWritable", ({ enumerable: true, get: function () { return MemoryChannel_1.convertWebWritableStreamToNodeWritable; } }));
const MemoryStorage_1 = __webpack_require__(/*! ./src/MemoryStorage */ "./dist/node/src/MemoryStorage.js");
Object.defineProperty(exports, "MemoryStorage", ({ enumerable: true, get: function () { return MemoryStorage_1.MemoryStorage; } }));
Object.defineProperty(exports, "LocalStorage", ({ enumerable: true, get: function () { return MemoryStorage_1.LocalStorage; } }));
const GameOfLifeIcon_1 = __importDefault(__webpack_require__(/*! ./src/GameOfLifeIcon */ "./dist/node/src/GameOfLifeIcon.js"));
exports.GameOfLifeIcon = GameOfLifeIcon_1.default;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./src/cryptoChannel */ "./dist/node/src/cryptoChannel.js"));
exports.CryptoChannel = cryptoChannel_1.default;
//utils
const crypto = __importStar(__webpack_require__(/*! ./src/crypto */ "./dist/node/src/crypto.js"));
exports.crypto = crypto;
const Buffer = crypto.Buffer;
exports.Buffer = Buffer;
if (typeof Symbol.dispose === "undefined") {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    Symbol.dispose = Symbol("Symbol.dispose");
}


/***/ }),

/***/ "./dist/node/src/Challenger.js":
/*!*************************************!*\
  !*** ./dist/node/src/Challenger.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./VaultysId */ "./dist/node/src/VaultysId.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const ERROR = -2;
const UNINITIALISED = -1;
const INIT = 0;
const STEP1 = 1;
const COMPLETE = 2;
const writeString = (name, value) => buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii"), buffer_1.Buffer.from([0xa0 + value.length]), buffer_1.Buffer.from(value, "ascii")]);
const writeBuffer = (name, value) => {
    const nameHeader = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii")]);
    let lengthHeader;
    if (value.length <= 65535) {
        // bin16: binary data whose length is upto (2^16)-1 bytes
        lengthHeader = buffer_1.Buffer.from([0xc5, (value.length >> 8) & 0xff, value.length & 0xff]);
    }
    else {
        // bin32: binary data whose length is upto (2^32)-1 bytes
        lengthHeader = buffer_1.Buffer.from([0xc6, (value.length >> 24) & 0xff, (value.length >> 16) & 0xff, (value.length >> 8) & 0xff, value.length & 0xff]);
    }
    return buffer_1.Buffer.concat([nameHeader, lengthHeader, value]);
};
const writeInt = (name, value) => {
    // console.log(value)
    const start = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii")]);
    let end;
    if (value >= 0 && value <= 0x7f) {
        end = buffer_1.Buffer.from([value]);
    }
    else if (value < 0 && value >= -0x20) {
        end = buffer_1.Buffer.from([value]);
    }
    else if (value > 0 && value <= 0xff) {
        // uint8
        end = buffer_1.Buffer.from([0xcc, value]);
    }
    else if (value >= -0x80 && value <= 0x7f) {
        // int8
        end = buffer_1.Buffer.from([0xd0, value]);
    }
    else if (value > 0 && value <= 0xffff) {
        // uint16
        end = buffer_1.Buffer.from([0xcd, value >>> 8, value]);
    }
    else if (value >= -0x8000 && value <= 0x7fff) {
        // int16
        end = buffer_1.Buffer.from([0xd1, value >>> 8, value]);
    }
    else if (value > 0 && value <= 0xffffffff) {
        // uint32
        end = buffer_1.Buffer.from([0xce, value >>> 24, value >>> 16, value >>> 8, value]);
    }
    else if (value >= -0x80000000 && value <= 0x7fffffff) {
        // int32
        end = buffer_1.Buffer.from([0xd2, value >>> 24, value >>> 16, value >>> 8, value]);
    }
    else if (value > 0 && value <= 0xffffffffffffffffn) {
        // uint64
        // Split 64 bit number into two 32 bit numbers because JavaScript only regards
        // 32 bits for bitwise operations.
        const hi = value / 2 ** 32;
        const lo = value % 2 ** 32;
        end = buffer_1.Buffer.from([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);
    }
    else {
        end = buffer_1.Buffer.from([0x00]);
    }
    return buffer_1.Buffer.concat([start, end]);
};
const encode_v0 = ({ version, protocol, service, timestamp, pk1, pk2, nonce, metadata }) => {
    const p = buffer_1.Buffer.concat([
        buffer_1.Buffer.from([0x87]),
        writeString("protocol", protocol),
        writeString("service", service),
        writeInt("timestamp", timestamp),
        writeBuffer("pk1", pk1),
        writeBuffer("pk2", pk2),
        writeBuffer("nonce", nonce),
        buffer_1.Buffer.from([0xa0 + "metadata".length]),
        buffer_1.Buffer.from("metadata", "ascii"),
        buffer_1.Buffer.from([0x80]), // empty metadata
    ]);
    // console.log(p.toString("base64"));
    return p;
};
const encode_v0_full = ({ version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata }) => {
    const p = buffer_1.Buffer.concat([
        buffer_1.Buffer.from([0x89]),
        writeString("protocol", protocol),
        writeString("service", service),
        writeInt("timestamp", timestamp),
        writeBuffer("pk1", pk1),
        writeBuffer("pk2", pk2),
        writeBuffer("nonce", nonce),
        writeBuffer("sign1", sign1),
        writeBuffer("sign2", sign2),
        buffer_1.Buffer.from([0xa0 + "metadata".length]),
        buffer_1.Buffer.from("metadata", "ascii"),
        buffer_1.Buffer.from([0x80]), // empty metadata
    ]);
    //console.log(p.toString("ascii"))
    return p;
};
const deserialize = (challenge) => {
    const unpacked = (0, msgpack_1.decode)(challenge);
    const state = {
        state: ERROR,
        error: "",
    };
    if (!unpacked.version) {
        unpacked.version = 0;
    }
    const result = {
        ...unpacked,
        ...state,
    };
    try {
        if (!result.timestamp || !result.protocol || !result.service) {
            result.state = ERROR;
            result.error = "[ERROR] Challenge is missing values";
        }
        else if (!result.pk2 && !!result.pk1 && !result.sign1 && !result.sign2 && result.nonce?.length === 16) {
            result.state = INIT;
        }
        else if (!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {
            result.state = STEP1;
            const id2 = VaultysId_1.default.fromId(result.pk2);
            const challenge = serializeUnsigned(result);
            if (!id2.verifyChallenge(challenge, result.sign2, true)) {
                result.state = ERROR;
                result.error = "[STEP1] failed the verification of pk2";
            }
        }
        else if (!!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {
            result.state = COMPLETE;
            //console.log(result);
            const id1 = VaultysId_1.default.fromId(result.pk1);
            const id2 = VaultysId_1.default.fromId(result.pk2);
            if (id1.version !== unpacked.version || id2.version !== unpacked.version) {
                //console.log(id1.version, id2.version, unpacked.version);
                result.state = ERROR;
                result.error = "[COMPLETE] pk1 and pk2 are using different serialization version";
            }
            const challenge = serializeUnsigned(result);
            if (!id2.verifyChallenge(challenge, result.sign2, true)) {
                result.state = ERROR;
                result.error = "[COMPLETE] failed the verification of pk2";
            }
            if (!id1.verifyChallenge(challenge, result.sign1, true)) {
                result.state = ERROR;
                result.error = "[COMPLETE] failed the verification of pk1";
            }
        }
    }
    catch (error) {
        result.error = "[" + result.state + " -> ERROR] " + error;
        result.state = ERROR;
    }
    return result;
};
const serialize = (data) => {
    if (data.state == INIT) {
        const { version, protocol, service, timestamp, pk1, nonce, metadata } = data;
        const picked = { version, protocol, service, timestamp, pk1, nonce, metadata };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    if (data.state == STEP1) {
        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign2, metadata } = data;
        const picked = {
            version,
            protocol,
            service,
            timestamp,
            pk1,
            pk2,
            nonce,
            sign2,
            metadata,
        };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    if (data.state == COMPLETE) {
        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata } = data;
        const picked = {
            version,
            protocol,
            service,
            timestamp,
            pk1,
            pk2,
            nonce,
            sign1,
            sign2,
            metadata,
        };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    return null;
};
const serializeUnsigned = (challenge) => {
    const { version, protocol, service, timestamp, pk1, pk2, nonce, metadata } = challenge;
    const picked = { version, protocol, service, timestamp, pk1, pk2, nonce, metadata };
    return version === 0 ? encode_v0(picked) : buffer_1.Buffer.from((0, msgpack_1.encode)(picked));
};
const isLive = (challenge, liveliness, time = Date.now()) => {
    return challenge.timestamp > time - liveliness && challenge.timestamp < time + liveliness;
};
class Challenger {
    constructor(vaultysId, liveliness = 60 * 1000) {
        this.version = 0;
        this.state = UNINITIALISED;
        // create a copy of VaultysId
        this.vaultysId = VaultysId_1.default.fromSecret(vaultysId.getSecret());
        this.liveliness = liveliness;
    }
    static async verifyCertificate(certificate) {
        const deser = deserialize(certificate);
        return deser.state === COMPLETE;
    }
    static async fromCertificate(certificate, liveliness) {
        const deser = deserialize(certificate);
        if (!deser.version) {
            deser.version = 0;
        }
        if (deser.state === INIT) {
            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk1).toVersion(deser.version), liveliness);
            challenger.challenge = deser;
            challenger.mykey = deser.pk1;
            challenger.state = INIT;
        }
        else if (deser.state === STEP1) {
            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk2).toVersion(deser.version), liveliness);
            challenger.challenge = deser;
            challenger.mykey = deser.pk2;
            challenger.hisKey = deser.pk1;
            challenger.state = STEP1;
            return challenger;
        }
    }
    async setChallenge(challengeString) {
        if (this.state !== UNINITIALISED) {
            this.state = ERROR;
            throw new Error("Challenger already initialised, can't reset the state");
        }
        this.challenge = deserialize(challengeString);
        this.version = this.challenge.version;
        if (!isLive(this.challenge, this.liveliness)) {
            this.state = ERROR;
            this.challenge.error = "challenge timestamp failed the liveliness at first signature";
            throw new Error(this.challenge.error);
        }
        if (this.challenge.state === ERROR) {
            this.state = ERROR;
            throw new Error(this.challenge.error);
        }
        else if (this.challenge.state === INIT) {
            //this.vaultysId.toVersion(this.challenge.version);
            this.mykey = this.vaultysId.id;
            this.challenge.pk2 = this.mykey;
            this.hisKey = this.challenge.pk1;
            this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce || new Uint8Array(), (0, crypto_1.randomBytes)(16)]);
            const serialized = this.getUnsignedChallenge();
            if (!serialized)
                throw new Error("Error processing Challenge");
            this.challenge.sign2 = (await this.vaultysId.signChallenge(serialized)) || undefined;
            this.challenge.state = this.state = STEP1;
        }
        else if (this.challenge.state === COMPLETE) {
            //this.vaultysId.toVersion(this.challenge.version);
            this.mykey = this.vaultysId.id;
            if (!this.challenge.pk1?.equals(this.mykey) && !this.challenge.pk1?.equals(this.mykey)) {
                this.state = ERROR;
                throw new Error("Can't link the vaultys id to this challenge");
            }
            else {
                this.state = COMPLETE;
            }
        }
        else {
            throw new Error("Challenge is from a protocol already launched, this is completely unsafe");
        }
    }
    getContext() {
        return {
            protocol: this.challenge?.protocol,
            service: this.challenge?.service,
            metadata: this.challenge?.metadata,
        };
    }
    createChallenge(protocol, service, version = 0, metadata) {
        this.version = version;
        if (this.state == UNINITIALISED) {
            this.mykey = this.vaultysId.toVersion(version).id;
            // console.log(this)
            this.challenge = {
                version,
                protocol,
                service,
                metadata: metadata ? { pk1: metadata } : {},
                timestamp: Date.now(),
                pk1: this.mykey,
                nonce: (0, crypto_1.randomBytes)(16),
                state: INIT,
            };
            this.state = INIT;
        }
        else {
            this.state = ERROR;
            throw new Error("Challenger already initialised, can't reset the state");
        }
    }
    getCertificate() {
        if (!this.challenge)
            return buffer_1.Buffer.from([]);
        return serialize(this.challenge) || buffer_1.Buffer.from([]);
    }
    getUnsignedChallenge() {
        return serializeUnsigned(this.challenge);
    }
    getContactDid() {
        if (!this.hisKey)
            return null;
        return VaultysId_1.default.fromId(this.hisKey).did;
    }
    getContactId() {
        // to be sure this function is not misused, we get the id of the contact only once the protocol is complete
        if (this.isComplete()) {
            const contact = VaultysId_1.default.fromId(this.hisKey, this.getCertificate() || undefined);
            return contact;
        }
        else
            throw new Error("The challenge is not COMPLETE, it is unsafe to get the Contact ID before");
    }
    static fromString(vaultysId, challengeString) {
        const challenger = new Challenger(vaultysId);
        challenger.setChallenge(challengeString);
        return challenger;
    }
    hasFailed() {
        return this.state == ERROR;
    }
    isComplete() {
        return this.state == COMPLETE;
    }
    async init(challengeString) {
        if (this.state !== UNINITIALISED) {
            throw new Error("Can't init INITIALISED challenge");
        }
        const tempchallenge = deserialize(challengeString);
        this.version = tempchallenge.version = tempchallenge.version ? 1 : 0;
        this.vaultysId.toVersion(this.version);
        if (tempchallenge.state === INIT) {
            if (tempchallenge.pk2?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                this.state = ERROR;
                throw new Error("challenge is not corresponding to the right id");
            }
            this.challenge = tempchallenge;
            this.version = tempchallenge.version;
            this.mykey = this.challenge.pk2 = this.vaultysId.id;
            this.hisKey = this.challenge.pk1;
            this.challenge.state = this.state = INIT;
            return;
        }
        if (tempchallenge.state === STEP1) {
            if (tempchallenge.pk2?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                this.state = ERROR;
                throw new Error("challenge is not corresponding to the right id");
            }
            this.challenge = tempchallenge;
            this.version = tempchallenge.version;
            this.mykey = this.challenge.pk2;
            this.hisKey = this.challenge.pk1;
            this.state = this.challenge.state = STEP1;
            return;
        }
    }
    async update(challengeString, metadata) {
        if (this.state === ERROR) {
            throw new Error("Can't update errorneous challenge");
        }
        else if (this.state === COMPLETE) {
            throw new Error("Can't update COMPLETE challenge");
        }
        else {
            const tempchallenge = deserialize(challengeString);
            // console.log(this.state, tempchallenge.state);
            if (!tempchallenge) {
                this.state = ERROR;
                throw new Error("Can't read the new incoming challenge");
            }
            if (tempchallenge.state === ERROR) {
                //console.log(tempchallenge.pk1?.length, tempchallenge.pk2?.length);
                this.state = ERROR;
                throw new Error(tempchallenge.error);
            }
            if (!isLive(tempchallenge, this.liveliness)) {
                // console.log(this.liveliness);
                // const time = Date.now();
                // console.log(time - tempchallenge.timestamp, this.liveliness);
                // console.log(tempchallenge.timestamp > time - this.liveliness && tempchallenge.timestamp < time + this.liveliness);
                this.state = ERROR;
                throw new Error("challenge timestamp failed the liveliness");
            }
            this.version = tempchallenge.version;
            this.vaultysId.toVersion(this.version);
            if (this.state === UNINITIALISED && tempchallenge.state === INIT) {
                if (tempchallenge.metadata.pk2) {
                    this.state = ERROR;
                    throw new Error("Metadata is malformed: pk2 is already set");
                }
                this.challenge = tempchallenge;
                this.mykey = this.challenge.pk2 = this.vaultysId.id;
                this.hisKey = this.challenge.pk1;
                if (metadata)
                    this.challenge.metadata.pk2 = metadata;
                this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce, (0, crypto_1.randomBytes)(16)]);
                const serialized = this.getUnsignedChallenge();
                this.challenge.sign2 = await this.vaultysId.signChallenge(serialized);
                this.challenge.state = this.state = STEP1;
                return;
            }
            if (this.state === UNINITIALISED && tempchallenge.state === STEP1) {
                if (tempchallenge.pk1?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                    // console.log(this.vaultysId.version, this);
                    this.state = ERROR;
                    throw new Error("challenge is not corresponding to the right id");
                }
                const serialized = serializeUnsigned(tempchallenge);
                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);
                this.challenge = tempchallenge;
                this.mykey = this.challenge.pk1;
                this.hisKey = this.challenge.pk2;
                this.state = this.challenge.state = COMPLETE;
                return;
            }
            if (this.state === UNINITIALISED && tempchallenge.state === COMPLETE) {
                console.log("COMPLETE case?!!");
                return;
            }
            if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {
                this.state = ERROR;
                throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);
            }
            if (this.state === INIT && tempchallenge.state === STEP1) {
                // @ts-ignore
                if (!tempchallenge.nonce?.subarray(0, 16).equals(this.challenge.nonce.subarray(0, 16))) {
                    this.state = ERROR;
                    throw new Error("Nonce has been tampered with");
                }
                if (tempchallenge.timestamp !== this.challenge?.timestamp) {
                    this.state = ERROR;
                    throw new Error("Timestamp has been tampered with");
                }
                if (!this.mykey?.equals(tempchallenge.pk1)) {
                    this.state = ERROR;
                    throw new Error(`The challenge has been tampered with. Received pk1 = '${tempchallenge.pk1}', expected pk1 = '${this.mykey}'`);
                }
                const serialized = serializeUnsigned(tempchallenge);
                if (!serialized) {
                    this.state = ERROR;
                    throw new Error("Error processing Challenge");
                }
                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);
                this.challenge = tempchallenge;
                this.hisKey = tempchallenge.pk2;
                this.state = this.challenge.state = COMPLETE;
            }
            else if (this.state === STEP1 && tempchallenge.state === COMPLETE) {
                if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {
                    this.state = ERROR;
                    throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);
                }
                // @ts-ignore
                if (!tempchallenge.nonce?.subarray(16, 32).equals(this.challenge.nonce.subarray(16, 32))) {
                    this.state = ERROR;
                    throw new Error("Nonce has been tampered with");
                }
                if (tempchallenge.timestamp !== this.challenge?.timestamp) {
                    this.state = ERROR;
                    throw new Error("Timestamp has been tampered with");
                }
                // INFO: no need for liveliness check since the whole certificate is complete
                // if (!isLive(tempchallenge, this.liveliness)) {
                //   this.state = ERROR;
                //   throw new Error("challenge timestamp failed the liveliness at 2nd signature");
                // }
                if (!this.mykey.equals(tempchallenge.pk2)) {
                    this.state = ERROR;
                    throw new Error(`The challenge pk2 has been tampered with`);
                }
                this.challenge = tempchallenge;
                this.state = COMPLETE;
            }
            else {
                //console.log(tempchallenge);
                const error = `The challenge is in an expected state. Received state = '${tempchallenge.state}', expected state = '${this.state + 1}'`;
                this.state = ERROR;
                throw new Error(error);
            }
        }
    }
}
Challenger.deserializeCertificate = deserialize;
Challenger.serializeCertificate_v0 = encode_v0_full;
Challenger.serializeCertificate = serializeUnsigned;
exports["default"] = Challenger;


/***/ }),

/***/ "./dist/node/src/Fido2Manager.js":
/*!***************************************!*\
  !*** ./dist/node/src/Fido2Manager.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./dist/node/src/platform/webauthn.js");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const encodeBinary = (data) => {
    if (data.length <= 65535) {
        // bin16: binary data whose length is upto (2^16)-1 bytes
        return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
    }
    else {
        // bin32: binary data whose length is upto (2^32)-1 bytes
        return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
    }
};
const serializeID_v0 = (km) => {
    const version = buffer_1.Buffer.from([0x83, 0xa1, 0x76, km.version]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    const ckey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x63]), encodeBinary(km.ckey)]);
    return buffer_1.Buffer.concat([version, ckey, cypher]);
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const type = cbor_1.default.decode(ckey).get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2Manager extends KeyManager_1.default {
    constructor() {
        super();
        this._transports = 0;
        this.level = 1; // ROOT, no Proof Management
        this.encType = "X25519KeyAgreementKey2019";
        this.webAuthn = (0, webauthn_1.getWebAuthnProvider)();
    }
    get transports() {
        return getTransports(this._transports);
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2Manager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        //encrypting
        const entropy = (0, crypto_1.randomBytes)(32);
        const seed = sha512(entropy);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed.slice(0, 32));
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        f2m.entropy = entropy;
        return f2m;
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                c: this.ckey,
                e: this.cypher.publicKey,
            }));
    }
    get id_v0() {
        return serializeID_v0(this);
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return f2m;
    }
    static instantiate(obj) {
        const f2m = new Fido2Manager();
        f2m.version = obj.version ?? 0;
        f2m.level = obj.level;
        f2m.fid = typeof obj.fid === "string" ? buffer_1.Buffer.from(obj.fid, "base64") : obj.fid;
        f2m._transports = obj.t ? obj.t : 15;
        f2m.ckey = obj.ckey.data ? buffer_1.Buffer.from(obj.ckey.data) : buffer_1.Buffer.from(obj.ckey);
        f2m.signer = getSignerFromCkey(f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return f2m;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "public";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m.ckey = data.c;
        f2m.signer = getSignerFromCkey(data.c);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: data.e,
        };
        return f2m;
    }
    async getSigner() {
        return {
            sign: async (data) => {
                if (!navigator.credentials)
                    return null;
                // ugly request userinteraction (needed for Safari and iOS)
                try {
                    await window?.CredentialUserInteractionRequest();
                }
                catch (error) { }
                const challenge = (0, crypto_1.hash)("sha256", data);
                const publicKey = {
                    challenge,
                    userVerification: "preferred",
                    allowCredentials: [
                        {
                            type: "public-key",
                            id: this.fid,
                            transports: getTransports(this._transports),
                        },
                    ],
                };
                const { response } = (await this.webAuthn.get(publicKey));
                const publicKeyResponse = response;
                const output = {
                    s: buffer_1.Buffer.from(publicKeyResponse.signature),
                    c: buffer_1.Buffer.from(publicKeyResponse.clientDataJSON),
                    a: buffer_1.Buffer.from(publicKeyResponse.authenticatorData),
                };
                return buffer_1.Buffer.from((0, msgpack_1.encode)(output));
            },
        };
    }
    verify(data, signature, userVerification = false) {
        const signatureBuffer = buffer_1.Buffer.from(signature);
        const decoded = (0, msgpack_1.decode)(signatureBuffer);
        const response = {
            signature: decoded.s,
            clientDataJSON: decoded.c,
            authenticatorData: decoded.a,
            userHandle: buffer_1.Buffer.from([]).buffer,
        };
        const challenge = (0, crypto_1.hash)("sha256", data).toString("base64");
        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);
        if (challenge !== extractedChallenge) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    verifyCredentials(credentials, userVerification = false) {
        if (credentials.id !== this.fid.toString("base64")) {
            return false;
        }
        const response = credentials.response;
        const rpIdHash = buffer_1.Buffer.from(response.authenticatorData.slice(0, 32)).toString("hex");
        const myIdHash = sha256(buffer_1.Buffer.from(credentials.id, "base64")).toString("hex");
        if (rpIdHash !== myIdHash) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    async createRevocationCertificate() {
        // TODO use an external id
        return null;
    }
}
exports["default"] = Fido2Manager;


/***/ }),

/***/ "./dist/node/src/Fido2PRFManager.js":
/*!******************************************!*\
  !*** ./dist/node/src/Fido2PRFManager.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const decoded = cbor_1.default.decode(ckey, { extendedResults: true });
    const type = decoded.value.get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey, { extendedResults: true }).value;
    //console.log("getSignerFromCkey", k);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2PRFManager extends Fido2Manager_1.default {
    constructor() {
        super();
        this.prfsalt = buffer_1.Buffer.from("VaultysID salt");
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2PRFManager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        //console.log(attestation, f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        await f2m.getCypher();
        delete f2m.cypher.secretKey;
        return f2m;
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.publicKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2PRFManager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        f2m.cypher = { publicKey: data.e };
        return f2m;
    }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
    }
    async getCypher() {
        if (!this.cypher?.secretKey) {
            const publicKey = {
                challenge: buffer_1.Buffer.from([]),
                userVerification: "preferred",
                allowCredentials: [
                    {
                        type: "public-key",
                        id: this.fid,
                        transports: getTransports(this._transports),
                    },
                ],
                extensions: {
                    prf: {
                        eval: {
                            // Input the contextual information
                            first: this.prfsalt,
                            // There is a "second" optional field too
                            // Though it is intended for key rotation.
                        },
                    },
                },
            };
            const result = await this.webAuthn.get(publicKey);
            const { prf } = result.getClientExtensionResults();
            const first = prf?.results?.first;
            if (!first)
                throw new Error("PRF failed");
            const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(first));
            this.cypher = {
                publicKey: buffer_1.Buffer.from(cypher.publicKey),
                secretKey: buffer_1.Buffer.from(cypher.secretKey),
            };
        }
        return super.getCypher();
    }
    async createRevocationCertificate() {
        // impossible
        return null;
    }
}
exports["default"] = Fido2PRFManager;


/***/ }),

/***/ "./dist/node/src/GameOfLifeIcon.js":
/*!*****************************************!*\
  !*** ./dist/node/src/GameOfLifeIcon.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const squareSize = 10;
const boardTopx = 0;
const boardTopy = 0;
const createFrom256 = (hex) => hex.match(/.{1,4}/g)?.map((line) => parseInt(line, 16).toString(2).padStart(16, "0")) || [];
const createFromFingerprint = (fp) => createFrom256((0, crypto_1.hash)("sha256", (0, crypto_1.fromHex)(fp.replaceAll(" ", ""))).toString("hex"));
const nextstep = (bin, memo) => {
    const output = [];
    for (let i = 0; i < 16; i++) {
        let line = "";
        for (let j = 0; j < 16; j++) {
            let count = 0;
            for (let k = i - 1; k < i + 2; k++) {
                for (let l = j - 1; l < j + 2; l++) {
                    if (k > -1 && k < 16 && l > -1 && l < 16) {
                        if ((k != i || l != j) && bin[k][l] == "1")
                            count++;
                    }
                }
            }
            let live = false;
            if (count == 3)
                live = true;
            else if (count == 2 && bin[i][j] == "1")
                live = true;
            line += live ? "1" : "O";
            if (memo && live) {
                memo[i][j]++;
            }
        }
        output.push(line);
    }
    return output;
};
const run = (hex, max) => {
    const result = createFrom256(hex)?.map((line) => line.split("").map((c) => parseInt(c)));
    let step = createFrom256(hex);
    for (let a = 0; a < max; a++) {
        step = nextstep(step, result);
    }
    return result;
};
const renderStep = (context, step) => {
    for (let i = 0; i < 16; i++) {
        for (let j = 0; j < 16; j++) {
            context.fillStyle = step[i][j] == 1 ? "black" : "white";
            let xOffset = boardTopx + j * squareSize;
            let yOffset = boardTopy + i * squareSize;
            context.fillRect(xOffset, yOffset, squareSize, squareSize);
            context.fillRect(150 - xOffset, yOffset, squareSize, squareSize);
            context.fillRect(xOffset, 150 - yOffset, squareSize, squareSize);
            context.fillRect(150 - xOffset, 150 - yOffset, squareSize, squareSize);
        }
    }
};
const heatMapColorforValue = (value, offset = 1) => {
    var h = (1.0 - value) * 240 + offset;
    //return `rgba(0,0,0,${value})`
    return "hsl(" + h + ", 100%, 50%)";
};
const renderMemo = (data, mapcolors = 2, context) => {
    let min = 1000;
    let max = 0;
    const memo = JSON.parse(JSON.stringify(data));
    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            memo[i][j] =
                memo[15 - i][j] =
                    memo[i][15 - j] =
                        memo[15 - i][15 - j] =
                            memo[i][j] + memo[15 - i][j] + memo[i][15 - j] + memo[15 - i][15 - j];
            const val = memo[i][j];
            if (val < min)
                min = val;
            if (val > max)
                max = val;
        }
    }
    for (let i = 0; i < 16; i++) {
        for (let j = 0; j < 16; j++) {
            context.fillStyle = heatMapColorforValue(Math.floor(((memo[i][j] - min) * mapcolors) / max) / mapcolors, max * max);
            let xOffset = boardTopx + j * squareSize;
            let yOffset = boardTopy + i * squareSize;
            context.fillRect(xOffset, yOffset, squareSize, squareSize);
        }
    }
};
exports["default"] = {
    renderFingerprint: (fp, canvas, steps = 32) => {
        let step = createFromFingerprint(fp.replaceAll(" ", ""));
        let memo = step?.map((line) => line.split("").map((c) => parseInt(c)));
        const context = canvas.getContext("2d");
        if (!context || !memo)
            return;
        for (let t = 0; t < steps; t++) {
            step = nextstep(step, memo);
        }
        renderMemo(memo, 3, context);
        return canvas;
    },
    animateFingerprint: async (fp, canvas, steps = 32, speed = 500) => {
        let step = createFromFingerprint(fp.replaceAll(" ", ""));
        let memo = step?.map((line) => line.split("").map((c) => parseInt(c)));
        const context = canvas.getContext("2d");
        if (!context || !memo)
            return;
        for (let t = 0; t < steps; t++) {
            step = nextstep(step, memo);
            renderMemo(memo, 3, context);
            await new Promise((resolve) => setTimeout(resolve, speed));
        }
        renderMemo(memo, 3, context);
        return canvas;
    },
};


/***/ }),

/***/ "./dist/node/src/IdManager.js":
/*!************************************!*\
  !*** ./dist/node/src/IdManager.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Challenger_1 = __importDefault(__webpack_require__(/*! ./Challenger */ "./dist/node/src/Challenger.js"));
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const MemoryChannel_1 = __webpack_require__(/*! ./MemoryChannel */ "./dist/node/src/MemoryChannel.js");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./VaultysId */ "./dist/node/src/VaultysId.js"));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const Fido2PRFManager_1 = __importDefault(__webpack_require__(/*! ./Fido2PRFManager */ "./dist/node/src/Fido2PRFManager.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
// "vaultys/encryption/" + version = 0x01
const ENCRYPTION_HEADER = buffer_1.Buffer.from("7661756c7479732f656e6372797074696f6e2f01", "hex");
const PRF_NONCE_LENGTH = 32;
const getSignatureType = (challenge) => {
    if (challenge.startsWith("vaultys://connect?")) {
        return "LOGIN";
    }
    else if (challenge.startsWith("vaultys://signfile?")) {
        return "DOCUMENT";
    }
    else {
        return "UNKNOWN";
    }
};
const instanciateContact = (c) => {
    let vaultysId;
    if (c.type === 3) {
        vaultysId = new VaultysId_1.default(Fido2Manager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    else if (c.type === 4) {
        vaultysId = new VaultysId_1.default(Fido2PRFManager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    else {
        vaultysId = new VaultysId_1.default(KeyManager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    return vaultysId;
};
const instanciateApp = (a) => {
    return VaultysId_1.default.fromId(buffer_1.Buffer.from(a.serverId, "base64"), a.certificate);
};
class IdManager {
    constructor(vaultysId, store) {
        this.protocol_version = 0;
        // alias since this is symetric key encryption
        this.acceptEncryptFile = this.acceptDecryptFile;
        this.vaultysId = vaultysId;
        this.store = store;
        if (!this.store.get("metadata")) {
            this.store.set("metadata", {});
        }
        if (this.vaultysId.keyManager.entropy)
            this.store.set("entropy", this.vaultysId.keyManager.entropy);
        else
            this.store.set("secret", this.vaultysId.getSecret());
        this.store.save();
    }
    setProtocolVersion(version) {
        this.protocol_version = version;
    }
    static async fromStore(store) {
        const entropy = store.get("entropy");
        const secret = store.get("secret");
        if (secret) {
            if (entropy) {
                const secretBuffer = buffer_1.Buffer.from(secret, "base64");
                const type = secretBuffer[0];
                const vaultysId = await VaultysId_1.default.fromEntropy(entropy, type);
                return new IdManager(vaultysId, store);
            }
            else {
                const vaultysId = VaultysId_1.default.fromSecret(secret);
                return new IdManager(vaultysId, store);
            }
        }
        else if (entropy) {
            const vaultysId = await VaultysId_1.default.machineFromEntropy(entropy);
            return new IdManager(vaultysId, store);
        }
        else {
            const vaultysId = await VaultysId_1.default.generateMachine();
            return new IdManager(vaultysId, store);
        }
    }
    merge(otherStore, master = true) {
        // TODO: check if same profile ?
        // TODO: revamp contact metadata and sync
        const master_store = master ? otherStore : this.store;
        const slave_store = master ? this.store : otherStore;
        this.store.set("metadata", { ...slave_store.get("metadata"), ...master_store.get("metadata") });
        ["signatures", "wot"].forEach((table) => {
            const other = otherStore.substore(table);
            const me = this.store.substore(table);
            other.list().forEach((k) => {
                if (!me.get(k)) {
                    me.set(k, other.get(k));
                }
            });
        });
        const other = otherStore.substore("contacts");
        const me = this.store.substore("contacts");
        const m = master ? other : me;
        const s = master ? me : other;
        other.list().forEach((did) => {
            if (!me.get(did)) {
                me.set(did, other.get(did));
            }
            else {
                const contact = me.get(did);
                contact.metadata = { ...s.get(did).metadata, ...m.get(did).metadata };
                me.set(did, contact);
            }
        });
        this.store.save();
    }
    isHardware() {
        return this.vaultysId.isHardware();
    }
    async signIn() {
        if (!this.vaultysId.isHardware())
            return true;
        await window.CredentialUserInteractionRequest();
        const challenge = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);
        const keyManager = this.vaultysId.keyManager;
        const creds = (await navigator.credentials.get({
            publicKey: {
                challenge,
                allowCredentials: [
                    {
                        type: "public-key",
                        id: keyManager.fid,
                        transports: keyManager.transports,
                    },
                ],
                userVerification: "discouraged",
            },
        }));
        if (creds == null)
            return false;
        const response = creds.response;
        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);
        if (challenge.toString("base64") !== extractedChallenge) {
            return false;
        }
        return keyManager.verifyCredentials(creds);
    }
    get contacts() {
        const s = this.store.substore("contacts");
        return s
            .list()
            .map((did) => s.get(did))
            .map(instanciateContact)
            .map((contact) => contact.toVersion(this.vaultysId.version));
    }
    get apps() {
        const s = this.store.substore("registrations");
        return s
            .list()
            .map((did) => s.get(did))
            .map(instanciateApp)
            .map((app) => app.toVersion(this.vaultysId.version));
    }
    getContact(did) {
        const c = this.store.substore("contacts").get(did);
        if (!c)
            return null;
        return instanciateContact(c).toVersion(this.vaultysId.version);
    }
    getApp(did) {
        const app = this.store.substore("registrations").get(did);
        if (!app)
            return null;
        return instanciateApp(app).toVersion(this.vaultysId.version);
    }
    setContactMetadata(did, name, value) {
        const c = this.store.substore("contacts").get(did);
        if (c) {
            if (!c.metadata) {
                c.metadata = {};
            }
            c.metadata[name] = value;
        }
    }
    getContactMetadata(did, name) {
        const c = this.store.substore("contacts").get(did);
        if (c && c.metadata) {
            return c.metadata[name];
        }
        return null;
    }
    getContactMetadatas(did) {
        const c = this.store.substore("contacts").get(did);
        if (c && c.metadata) {
            return c.metadata;
        }
        return null;
    }
    async verifyRelationshipCertificate(did) {
        const c = this.store.substore("contacts").get(did) || this.store.substore("registrations").get(did);
        return Challenger_1.default.verifyCertificate(c.certificate);
    }
    set name(n) {
        this.store.get("metadata").name = n;
    }
    get name() {
        return this.store.get("metadata").name;
    }
    get displayName() {
        const metadata = this.store.get("metadata");
        const result = metadata.firstname ? metadata.firstname + " " + (metadata.name ?? "") : metadata.name;
        return result?.length > 0 ? result : "Anonymous " + this.vaultysId.fingerprint?.slice(-4);
    }
    set phone(n) {
        this.store.get("metadata").phone = n;
    }
    get phone() {
        return this.store.get("metadata").phone;
    }
    set email(n) {
        this.store.get("metadata").email = n;
    }
    get email() {
        return this.store.get("metadata").email;
    }
    // set avatar(n) {
    //   this.store.get("metadata").avatar = {
    //     data: Buffer.from(n.data).toString("base64"),
    //     type: n.type,
    //   };
    // }
    // get avatar() {
    //   const temp = this.store.get("metadata").avatar;
    //   if (!temp) return null;
    //   return {
    //     data: Buffer.from(temp.data, "base64"),
    //     type: temp.type,
    //   };
    // }
    async signChallenge(challenge) {
        const signature = await this.vaultysId.signChallenge(challenge);
        this.store.substore("signatures").set("" + Date.now(), {
            signature,
            challenge,
        });
        this.store.save();
        return signature;
    }
    async signFile(file) {
        const h = (0, crypto_1.hash)("sha256", file.arrayBuffer).toString("hex");
        const challenge = buffer_1.Buffer.from(`vaultys://signfile?hash=${h}&timestamp=${Date.now()}`, "utf-8");
        const payload = {
            challenge,
            signature: await this.vaultysId.signChallenge(challenge),
        };
        this.store.substore("signatures").set(Date.now() + "", payload);
        this.store.save();
        return payload;
    }
    verifyFile(file, fileSignature, contactId, userVerifiation = true) {
        const data = fileSignature.challenge.toString("utf8");
        if (!data.startsWith("vaultys://signfile?")) {
            return false;
        }
        const h = (0, crypto_1.hash)("sha256", file.arrayBuffer).toString("hex");
        const url = new URL(data);
        const fileHash = url.searchParams.get("hash");
        if (h !== fileHash) {
            return false;
        }
        if (url.search.match(/[a-z\d]+=[a-z\d]+/gi)?.length === 2 && url.searchParams.get("timestamp")) {
            return contactId.verifyChallenge(fileSignature.challenge, fileSignature.signature, userVerifiation);
        }
        return false;
    }
    async decryptFile(toDecrypt, channel) {
        // Extract nonce and ciphertext from arrayBuffer
        const data = new Uint8Array(toDecrypt.arrayBuffer);
        const header = data.slice(0, ENCRYPTION_HEADER.length);
        if (buffer_1.Buffer.from(header).toString("hex") !== ENCRYPTION_HEADER.toString("hex")) {
            throw new Error("Invalid header for encrypted file");
        }
        const prfNonceBytes = data.slice(ENCRYPTION_HEADER.length, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);
        const nonceBytes = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);
        const ciphertext = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);
        const prf = channel ? await this.requestPRF(channel, "encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption") : await this.vaultysId.hmac("prf|encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption|prf");
        if (prf?.length !== PRF_NONCE_LENGTH) {
            throw new Error("Invalid PRF generated");
        }
        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)
        const secretKey = (0, crypto_1.hash)("sha256", prf);
        (0, crypto_1.secureErase)(prf);
        // Decrypt using nacl.secretbox.open
        const decrypted = tweetnacl_1.default.secretbox.open(ciphertext, nonceBytes, secretKey);
        (0, crypto_1.secureErase)(secretKey);
        if (!decrypted) {
            throw new Error("Decryption failed");
        }
        return {
            name: toDecrypt.name,
            type: toDecrypt.type,
            arrayBuffer: buffer_1.Buffer.from(decrypted),
        };
    }
    async encryptFile(toEncrypt, channel) {
        // Generate a secure random nonce for both the PRF and the secretbox
        const prfNonceBytes = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);
        const prf = channel ? await this.requestPRF(channel, "encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption") : await this.vaultysId.hmac("prf|encryption/" + prfNonceBytes.toString("hex") + "/encryption|prf");
        if (prf?.length !== PRF_NONCE_LENGTH) {
            return null;
        }
        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)
        const secretKey = (0, crypto_1.hash)("sha256", prf);
        (0, crypto_1.secureErase)(prf);
        // Generate a random nonce for secretbox encryption
        const nonceBytes = tweetnacl_1.default.randomBytes(tweetnacl_1.default.secretbox.nonceLength);
        // Encrypt using nacl.secretbox
        const ciphertext = tweetnacl_1.default.secretbox(new Uint8Array(toEncrypt.arrayBuffer), nonceBytes, secretKey);
        (0, crypto_1.secureErase)(secretKey);
        // Combine encryption nonce and ciphertext into a single buffer
        const result = new Uint8Array(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length + ciphertext.length);
        result.set(ENCRYPTION_HEADER);
        result.set(prfNonceBytes, ENCRYPTION_HEADER.length);
        result.set(nonceBytes, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);
        result.set(ciphertext, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length);
        return {
            name: toEncrypt.name,
            type: toEncrypt.type,
            arrayBuffer: buffer_1.Buffer.from(result), // Buffer contains secretbox nonce + ciphertext
        };
    }
    getSignatures() {
        const store = this.store.substore("signatures");
        return store
            .list()
            .sort()
            .map((date) => {
            const payload = store.get(date);
            const challenge = buffer_1.Buffer.from(payload.challenge).toString("utf-8");
            return {
                date,
                payload,
                challenge,
                type: getSignatureType(challenge),
            };
        });
    }
    migrate(version) {
        this.vaultysId.toVersion(version);
        const s = this.store.substore("contacts");
        for (const did of s.list()) {
            const data = s.get(did);
            const contact = instanciateContact(data);
            const newContact = contact.toVersion(version);
            if (newContact.did !== did) {
                s.set(newContact.did, { ...contact, ...newContact, metadata: data.metadata, oldDid: did });
                s.delete(did);
                //console.log(did, "->", newContact.did);
            }
        }
        const apps = this.store.substore("registrations");
        for (const did of apps.list()) {
            const data = apps.get(did);
            const site = instanciateApp(data);
            if (site) {
                const newSite = site.toVersion(version);
                if (newSite.did !== did) {
                    const name = data.site === did ? newSite.did : data.site;
                    apps.set(newSite.did, { site: name, oldDid: did, serverId: newSite.id.toString("base64"), certificate: data.certificate, timestamp: data.timestamp });
                    apps.delete(did);
                    // console.log(did, "->", newSite.did);
                }
            }
        }
        this.store.save();
    }
    async verifyChallenge(challenge, signature) {
        return this.vaultysId.verifyChallenge(challenge, signature, true);
    }
    async upload(channel, stream) {
        const challenger = await this.startSRP(channel, "p2p", "transfer");
        if (challenger.isComplete()) {
            const { upload } = (0, MemoryChannel_1.StreamChannel)(channel);
            await upload(stream);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async download(channel, stream) {
        const challenger = await this.acceptSRP(channel, "p2p", "transfer");
        if (challenger.isComplete()) {
            const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
            await download(stream);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestDecrypt(channel, toDecrypt) {
        const challenger = await this.acceptSRP(channel, "p2p", "decrypt");
        if (challenger.isComplete()) {
            channel.send(toDecrypt);
            const new_encrypted = await channel.receive();
            const decrypted = await this.vaultysId.dhiesDecrypt(new_encrypted, challenger.getContactId().id);
            return decrypted;
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptDecrypt(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "decrypt", {}, accept);
        if (challenger.isComplete()) {
            const toDecrypt = await channel.receive();
            const decrypted = await this.vaultysId.decrypt(toDecrypt.toString("utf-8"));
            if (decrypted) {
                const encrypted = await this.vaultysId.dhiesEncrypt(decrypted, challenger.getContactId().id);
                channel.send(encrypted ?? buffer_1.Buffer.from([0]));
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestDecryptFile(channel, toDecrypt) {
        return this.decryptFile(toDecrypt, channel);
    }
    async requestEncryptFile(channel, toEncrypt) {
        return this.encryptFile(toEncrypt, channel);
    }
    async acceptDecryptFile(channel, accept) {
        let result_contact = null;
        await this.acceptPRF(channel, (contact, appid) => {
            if (appid.length > 63 && appid.startsWith("encryption/") && appid.endsWith("/encryption")) {
                result_contact = contact;
                //TODO: maybe by default should be in web of trust?
                return accept?.(contact) || Promise.resolve(true);
            }
            else
                return Promise.resolve(false);
        });
        return result_contact;
    }
    async requestSignFile(channel, file) {
        const challenger = await this.acceptSRP(channel, "p2p", "signfile");
        if (challenger.isComplete()) {
            channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(file)));
            const result = await channel.receive();
            const fileSignature = (0, msgpack_1.decode)(result);
            if (this.verifyFile(file, fileSignature, challenger.getContactId().toVersion(1))) {
                return fileSignature;
            }
            else
                return undefined;
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptSignFile(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "signfile");
        if (challenger.isComplete()) {
            const result = await channel.receive();
            const file = (0, msgpack_1.decode)(result);
            if (!accept || (await accept(challenger.getContactId(), file))) {
                const result = await this.signFile(file);
                channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(result)));
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestPRF(channel, appid) {
        if (appid.length < 3) {
            throw new Error("appid is too short, less than 3 characters");
        }
        if (appid.split("|").length > 1) {
            throw new Error("appid contains illegal character |");
        }
        const challenger = await this.acceptSRP(channel, "p2p", "prf");
        if (challenger.isComplete()) {
            channel.send(buffer_1.Buffer.from(appid, "utf-8"));
            const prf = await channel.receive();
            return buffer_1.Buffer.from(prf);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptPRF(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "prf");
        if (challenger.isComplete()) {
            const result = await channel.receive();
            const appid = result.toString("utf-8");
            if (appid.length < 3 || appid.split("|").length > 1) {
                // error if appid is too short or contains illegal character
                channel.send(buffer_1.Buffer.from([0]));
            }
            else if (!accept || (await accept(challenger.getContactId(), appid))) {
                const hmac = (await this.vaultysId.hmac("prf|" + appid + "|prf")) ?? buffer_1.Buffer.from([0]);
                channel.send(hmac);
                (0, crypto_1.secureErase)(hmac);
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    /***************************/
    /*   SIGNING PARTY HERE!   */
    /***************************/
    listCertificates() {
        const wot = this.store.substore("wot");
        return wot.list().map((timestamp) => {
            const c = wot.get(timestamp);
            if (c.timestamp) {
                return c;
            }
            else {
                const result = {
                    ...Challenger_1.default.deserializeCertificate(wot.get(timestamp)),
                    raw: c,
                };
                wot.set(timestamp, result);
                return result;
            }
        });
    }
    async startSRP(channel, protocol, service, metadata = {}, accept) {
        const challenger = new Challenger_1.default(this.vaultysId);
        challenger.createChallenge(protocol, service, this.protocol_version, metadata);
        //console.log(challenger);
        const cert = challenger.getCertificate();
        if (!cert) {
            channel.close();
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error("Error processing challenge");
        }
        channel.send(cert);
        try {
            const message = await channel.receive();
            // console.log("startSRP", message)
            const contact = Challenger_1.default.deserializeCertificate(message).pk2;
            if (!contact) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact pk2 is not sent");
            }
            if (accept && !(await accept(VaultysId_1.default.fromId(contact)))) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact refused");
            }
            await challenger.update(message);
        }
        catch (error) {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error(error);
        }
        if (challenger.isComplete()) {
            const certificate = challenger.getCertificate();
            if (!certificate) {
                channel.close();
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Error processing challenge");
            }
            // there is a caveat here, we are not sure that the last bit of information has been received
            channel.send(certificate);
            this.store.substore("wot").set(Date.now() + "", certificate);
            // TODO create/update merkle tree + sign it
            return challenger;
        }
        else {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error("Can't add a new contact if the protocol is not complete");
        }
    }
    async acceptSRP(channel, protocol, service, metadata = {}, accept) {
        const challenger = new Challenger_1.default(this.vaultysId);
        try {
            const message = await channel.receive();
            const chal = Challenger_1.default.deserializeCertificate(message);
            if (!chal.pk1) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact pk1 is not sent");
            }
            if (chal.protocol !== protocol) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("protocol is not the one expected: " + chal.protocol + " !=" + protocol);
            }
            if (chal.service !== service) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("service is not the one expected: " + chal.service + " !=" + service);
            }
            if (accept && !(await accept(VaultysId_1.default.fromId(chal.pk1)))) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact refused");
            }
            await challenger.update(message, metadata);
        }
        catch (error) {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error(error);
        }
        const cert = challenger.getCertificate();
        if (!cert) {
            channel.send(buffer_1.Buffer.from([0]));
            await channel.close();
            throw new Error("Error processing challenge");
        }
        // console.log("acceptSRP sending 1")
        channel.send(cert);
        // console.log("acceptSRP sending 2")
        try {
            const message = await channel.receive();
            // console.log("acceptSRP 2", message)
            await challenger.update(message);
        }
        catch (error) {
            await channel.close();
            //console.log(challenger);
            throw new Error(error);
        }
        if (challenger.isComplete()) {
            const certificate = challenger.getCertificate();
            this.store.substore("wot").set(Date.now() + "", certificate);
            // TODO create/update merkle tree + sign it
            return challenger;
        }
        else {
            await channel.close();
            throw new Error("Can't add a new contact if the protocol is not complete");
        }
    }
    saveApp(app, name) {
        app.toVersion(this.vaultysId.version);
        if (!app.isMachine()) {
            this.saveContact(app);
        }
        else {
            const appstore = this.store.substore("registrations");
            if (!appstore.get(app.did)) {
                appstore.set(app.did, {
                    site: name ?? app.did,
                    serverId: app.id.toString("base64"),
                    certificate: app.certificate,
                });
            }
        }
    }
    saveContact(contact) {
        contact.toVersion(this.vaultysId.version);
        if (contact.isMachine()) {
            this.saveApp(contact);
        }
        else {
            const contactstore = this.store.substore("contacts");
            if (!contactstore.get(contact.did)) {
                contactstore.set(contact.did, contact);
                this.store.save();
            }
        }
    }
    async askContact(channel, metadata = {}, accept) {
        const challenger = await this.startSRP(channel, "p2p", "auth", metadata, accept);
        const contact = challenger.getContactId();
        this.saveContact(contact);
        return contact;
    }
    async acceptContact(channel, metadata = {}, accept) {
        const challenger = await this.acceptSRP(channel, "p2p", "auth", metadata, accept);
        const contact = challenger.getContactId();
        this.saveContact(contact);
        return contact;
    }
}
exports["default"] = IdManager;


/***/ }),

/***/ "./dist/node/src/KeyManager.js":
/*!*************************************!*\
  !*** ./dist/node/src/KeyManager.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DHIES = void 0;
const saltpack_1 = __webpack_require__(/*! @vaultys/saltpack */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
ed25519_1.ed25519.CURVE = { ...ed25519_1.ed25519.CURVE };
// @ts-ignore hack to get compatibility with former @stricahq/bip32ed25519 lib
ed25519_1.ed25519.CURVE.adjustScalarBytes = (bytes) => {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 63; // 0b0001_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
};
////@ts-expect-error fix for wrong way of exporting bip32ed25519
//const bip32 = bip32fix.default ?? bip32fix;
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const serializeID_v0 = (km) => {
    const encodeBinary = (data) => {
        if (data.length <= 65535) {
            // bin16: binary data whose length is upto (2^16)-1 bytes
            return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
        }
        else {
            // bin32: binary data whose length is upto (2^32)-1 bytes
            return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
        }
    };
    const version = buffer_1.Buffer.from([0x84, 0xa1, 0x76, 0]);
    const proof = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x70]), encodeBinary(km.proof)]);
    const sign = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x78]), encodeBinary(km.signer.publicKey)]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    return buffer_1.Buffer.concat([version, proof, sign, cypher]);
};
/**
 * DHIES (Diffie-Hellman Integrated Encryption Scheme) for KeyManager
 * Provides authenticated encryption using Diffie-Hellman key exchange
 */
class DHIES {
    constructor(keyManager) {
        this.keyManager = keyManager;
    }
    /**
     * Encrypts a message for a recipient using DHIES
     *
     * @param message The plaintext message to encrypt
     * @param recipientPublicKey The recipient's public key
     * @returns Encrypted message with ephemeral public key and authentication tag, or null if encryption fails
     */
    async encrypt(message, recipientPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot encrypt with DHIES using a public KeyManager");
            return null;
        }
        const cypher = await this.keyManager.getCypher();
        // Convert message to Buffer if it's a string
        const messageBuffer = typeof message === "string" ? buffer_1.Buffer.from(message, "utf8") : message;
        try {
            const ephemeralKey = (0, crypto_1.randomBytes)(32); // Generate a random 32-byte key for ephemeral key
            // Derive shared secret using recipient's public key and sender secret key
            const dh = await cypher.diffieHellman(recipientPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys from shared secret
            const kdfOutput = this.kdf(sharedSecret, this.keyManager.cypher.publicKey, recipientPublicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Encrypt the message using XChaCha20-Poly1305
            const nonce = (0, crypto_1.randomBytes)(24); // 24 bytes nonce for XChaCha20-Poly1305
            const ciphertext = buffer_1.Buffer.from(tweetnacl_1.default.secretbox(messageBuffer, nonce, encryptionKey));
            // Compute MAC (Message Authentication Code)
            const dataToAuthenticate = buffer_1.Buffer.concat([this.keyManager.cypher.publicKey, nonce, ciphertext]);
            const mac = this.computeMAC(macKey, dataToAuthenticate);
            // Construct the final encrypted message: nonce + ephemeralKey + ciphertext + MAC
            const encryptedMessage = buffer_1.Buffer.concat([nonce, ephemeralKey, ciphertext, mac]);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(dh);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return encryptedMessage;
        }
        catch (error) {
            console.error("DHIES encryption failed:", error);
            return null;
        }
    }
    /**
     * Decrypts a message encrypted with DHIES
     *
     * @param encryptedMessage The complete encrypted message from the encrypt method
     * @returns Decrypted message as a Buffer, or null if decryption fails
     */
    async decrypt(encryptedMessage, senderPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot decrypt with DHIES using a public KeyManager");
            return null;
        }
        try {
            // Extract components from the encrypted message
            // Format: nonce (24 bytes) + ephemeralKey (32 bytes) + ciphertext + MAC (32 bytes)
            const nonce = encryptedMessage.slice(0, 24);
            const ephemeralKey = encryptedMessage.slice(24, 56);
            const mac = encryptedMessage.slice(encryptedMessage.length - 32);
            const ciphertext = encryptedMessage.slice(56, encryptedMessage.length - 32);
            const cypher = await this.keyManager.getCypher();
            // Derive shared secret using sender public key and recipient secret key
            const dh = await cypher.diffieHellman(senderPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys
            const kdfOutput = this.kdf(sharedSecret, senderPublicKey, this.keyManager.cypher.publicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Verify MAC
            const dataToAuthenticate = buffer_1.Buffer.concat([senderPublicKey, nonce, ciphertext]);
            const computedMac = this.computeMAC(macKey, dataToAuthenticate);
            if (!this.constantTimeEqual(mac, computedMac)) {
                //console.log(mac, computedMac);
                console.error("DHIES: MAC verification failed");
                return null;
            }
            // Decrypt the ciphertext
            const plaintext = tweetnacl_1.default.secretbox.open(ciphertext, nonce, encryptionKey);
            if (!plaintext) {
                console.error("DHIES: Decryption failed");
                return null;
            }
            const result = buffer_1.Buffer.from(plaintext);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return result;
        }
        catch (error) {
            console.error("DHIES decryption failed:", error);
            return null;
        }
    }
    /**
     * Key Derivation Function: Derives encryption and MAC keys from the shared secret
     */
    kdf(sharedSecret, ephemeralPublicKey, staticPublicKey) {
        // Create a context for the KDF to ensure different keys for different uses
        const context = buffer_1.Buffer.concat([buffer_1.Buffer.from("DHIES-KDF"), ephemeralPublicKey, staticPublicKey]);
        // Derive encryption key: HKDF-like construction
        const encryptionKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x01]), // Domain separation byte
        ]));
        // Derive MAC key (using a different domain separation byte)
        const macKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x02]), // Domain separation byte
        ]));
        // Use first 32 bytes of each as the actual keys (for NaCl's secretbox)
        return {
            encryptionKey: encryptionKeyMaterial.slice(0, 32),
            macKey: macKeyMaterial.slice(0, 32),
        };
    }
    /**
     * Computes MAC for authenticated encryption
     */
    computeMAC(macKey, data) {
        return (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([macKey, data]));
    }
    /**
     * Constant-time comparison of two buffers to prevent timing attacks
     */
    constantTimeEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        let result = 0;
        for (let i = 0; i < a.length; i++) {
            result |= a[i] ^ b[i];
        }
        return result === 0;
    }
}
exports.DHIES = DHIES;
class KeyManager {
    constructor() {
        this.level = 1;
        this.version = 1;
        this.capability = "private";
        this.authType = "Ed25519VerificationKey2020";
        this.encType = "X25519KeyAgreementKey2019";
    }
    static async create_Id25519_fromEntropy(entropy, swapIndex = 0) {
        const km = new KeyManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        const seed = sha512(entropy);
        // const derivedKey = privateDerivePath(await bip32.Bip32PrivateKey.fromEntropy(seed.slice(0, 32)), `m/1'/0'/${swapIndex}'`);
        km.proofKey = {
            publicKey: buffer_1.Buffer.from([]), //deprecated
        };
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", km.proofKey.publicKey);
        // const privateKey = privateDerivePath(derivedKey, "/0'");
        km.signer = {
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(seed.slice(0, 32))),
            secretKey: seed.slice(0, 32),
        };
        const swapIndexBuffer = buffer_1.Buffer.alloc(8);
        swapIndexBuffer.writeBigInt64LE(BigInt(swapIndex), 0);
        const seed2 = sha256(buffer_1.Buffer.concat([seed.slice(32, 64), swapIndexBuffer]));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_Id25519() {
        return KeyManager.create_Id25519_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                p: this.proof,
                x: this.signer.publicKey,
                e: this.cypher.publicKey,
            }));
    }
    async getCypher() {
        // todo fetch secretKey here
        const cypher = this.cypher;
        return {
            hmac: (message) => (cypher.secretKey ? (0, crypto_1.hmac)("sha256", buffer_1.Buffer.from(cypher.secretKey), "VaultysID/" + message + "/end") : undefined),
            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),
            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),
            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),
        };
    }
    getSigner() {
        // todo fetch secretKey here
        const secretKey = this.signer.secretKey;
        const sign = (data) => Promise.resolve(buffer_1.Buffer.from(ed25519_1.ed25519.sign(data, secretKey)));
        //console.log(secretKey.toString("hex"), new bip32.PrivateKey(secretKey).toPublicKey().toBytes().toString("hex"), Buffer.from(ed25519.getPublicKey(secretKey)).toString("hex"));
        return Promise.resolve({ sign });
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            x: this.signer.secretKey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.signer = {
            secretKey: data.x.slice(0, 32),
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(data.x.slice(0, 32))),
        };
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new KeyManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        const signer = await this.getSigner();
        return signer.sign(data);
    }
    verify(data, signature, userVerificationIgnored) {
        return ed25519_1.ed25519.verify(signature, data, this.signer.publicKey);
    }
    // async createRevocationCertificate(newId) {
    //   if (this.level == LEVEL_ROOT) {
    //     const seed = sha512(this.entropy);
    //     let node = derivePath(
    //       await Bip32PrivateKey.fromEntropy(seed.slice(0, 32)),
    //       "m/1'/0'/1'",
    //     );
    //     const proof = hash("sha256", node.toBip32PublicKey().toBytes());
    //     if (this.proof.toString("hex") == proof.toString("hex")) {
    //       const revocationCertificate = {
    //         xpub: node.toBytes(),
    //         id: this.id,
    //         newId,
    //       };
    //       revocationCertificate.signature = node.toPrivateKey().sign(revocationCertificate);
    //       return revocationCertificate;
    //     } else return null;
    //   } else return null;
    // }
    // async createSwapingCertificate() {
    //   if (this.level === LEVEL_ROOT && this.entropy) {
    //     const newKey = await KeyManager.create_Id25519_fromEntropy(this.entropy, this.swapIndex + 1);
    //     const hiscp: HISCP = {
    //       newId: newKey.id,
    //       proofKey: this.proofKey.publicKey,
    //       timestamp: Date.now(),
    //       signature: Buffer.from([]),
    //     };
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     hiscp.signature = new bip32.Bip32PrivateKey(this.proofKey.secretKey!).toPrivateKey().sign(hiscpBuffer);
    //     return hiscp;
    //   }
    //   return null;
    // }
    // async verifySwapingCertificate(hiscp: HISCP) {
    //   const proof = hash("sha256", hiscp.proofKey).toString("hex");
    //   if (proof === this.proof.toString("hex")) {
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const newKey = KeyManager.fromId(hiscp.newId);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     const proofVerifier = bip32.Bip32PublicKey.fromBytes(hiscp.proofKey);
    //     return proofVerifier.toPublicKey().verify(hiscpBuffer, hiscp.signature);
    //   } else {
    //     return false;
    //   }
    // }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
        if (this.signer?.secretKey) {
            (0, crypto_1.secureErase)(this.signer.secretKey);
            delete this.signer.secretKey;
        }
        if (this.entropy) {
            (0, crypto_1.secureErase)(this.entropy);
            delete this.entropy;
        }
    }
    /**
     * Performs a Diffie-Hellman key exchange with another KeyManager instance
     * @param otherKeyManager The other party's KeyManager instance
     * @returns A shared secret that can be used for symmetric encryption
     */
    async performDiffieHellman(otherKeyManager) {
        if (this.capability === "public") {
            console.error("Cannot perform DH key exchange with a public key capability");
            return null;
        }
        const cypher = await this.getCypher();
        const otherKey = otherKeyManager.cypher.publicKey;
        // Perform the X25519 scalar multiplication to derive the shared secret
        const sharedSecret = await cypher.diffieHellman(otherKey);
        // Hash the shared secret for better security (to derive a symmetric key)
        const derivedKey = sha256(sharedSecret);
        // Securely erase the shared secret from memory
        (0, crypto_1.secureErase)(sharedSecret);
        return derivedKey;
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two KeyManager instances
     * @param keyManager1 First KeyManager instance
     * @param keyManager2 Second KeyManager instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(keyManager1, keyManager2) {
        return keyManager1.performDiffieHellman(keyManager2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's KeyManager ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        const recipientKM = KeyManager.fromId(recipientId);
        //console.log(recipientKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.encrypt(message, recipientKM.cypher.publicKey);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        const senderKM = KeyManager.fromId(senderId);
        //console.log(senderKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.decrypt(encryptedMessage, senderKM.cypher.publicKey);
    }
    static async encrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        return await (0, saltpack_1.encryptAndArmor)(plaintext, null, publicKeys);
    }
    async signcrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        const cypher = await this.getCypher();
        return await cypher.signcrypt(plaintext, publicKeys);
    }
    async decrypt(encryptedMessage, senderId = null) {
        const cypher = await this.getCypher();
        const senderKey = senderId ? KeyManager.fromId(senderId).cypher.publicKey : null;
        const message = await cypher.decrypt(encryptedMessage, senderKey);
        return message.toString();
    }
    // use better hash to prevent attack
    getSecretHash(data) {
        const toHash = buffer_1.Buffer.concat([data, buffer_1.Buffer.from("secrethash"), this.cypher.secretKey]);
        return (0, crypto_1.hash)("sha256", toHash);
    }
}
exports["default"] = KeyManager;


/***/ }),

/***/ "./dist/node/src/MemoryChannel.js":
/*!****************************************!*\
  !*** ./dist/node/src/MemoryChannel.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryChannel = void 0;
exports.pipeChannels = pipeChannels;
exports.unpipeChannels = unpipeChannels;
exports.StreamChannel = StreamChannel;
exports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;
exports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./cryptoChannel */ "./dist/node/src/cryptoChannel.js"));
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Pipes two channels together, creating a bidirectional flow where
 * messages sent to one channel are automatically forwarded to the other.
 * @param channel1 The first channel to connect
 * @param channel2 The second channel to connect
 * @returns A Promise that resolves when both channels close
 */
function pipeChannels(channel1, channel2) {
    let running = true;
    // Start both piping directions
    const pipe1to2 = async () => {
        try {
            await channel1.start();
            await channel2.start();
            console.log("pipe1to2");
            while (running) {
                try {
                    const data = await channel1.receive();
                    console.log("pipe1to2", data);
                    if (!running || data.length === 0)
                        break;
                    channel2.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe1to2:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe1to2:", error);
        }
    };
    const pipe2to1 = async () => {
        try {
            while (running) {
                console.log("pipe2to1");
                try {
                    const data = await channel2.receive();
                    console.log("pipe2to1", data);
                    if (!running || data.length === 0)
                        break;
                    channel1.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe2to1:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe2to1:", error);
        }
    };
    // Start the pipes
    pipe1to2();
    pipe2to1();
    // Return function to stop piping
    return async () => {
        running = false;
        await Promise.all([channel1.close(), channel2.close()]);
    };
}
/**
 * Utility function that stops an active channel pipe
 * @param channel1 The first channel in the pipe
 * @param channel2 The second channel in the pipe
 */
async function unpipeChannels(channel1, channel2) {
    await Promise.all([channel1.close(), channel2.close()]);
}
function StreamChannel(channel) {
    const onData = async (callback) => {
        let message = await channel.receive();
        while (message) {
            callback(message);
            if (message.toString("utf-8") === "EOF") {
                return;
            }
            message = await channel.receive();
        }
    };
    const getWriteStream = () => {
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                channel.send(chunk);
                done();
            },
        });
        return stream;
    };
    const upload = async (stream) => {
        return new Promise((resolve) => {
            const writeStream = getWriteStream();
            stream.pipe(writeStream).once("finish", () => {
                channel.send(buffer_1.Buffer.from("EOF", "utf-8"));
                writeStream.end();
                resolve();
            });
        });
    };
    const uploadData = async (data) => {
        const stream = stream_1.Readable.from(data);
        await upload(stream);
    };
    const download = async (stream) => {
        const readStream = getReadStream();
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve();
        }));
        readStream.pipe(stream);
        await result;
    };
    const downloadData = async () => {
        const readStream = getReadStream();
        const chunks = [];
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve(buffer_1.Buffer.concat(chunks));
        }));
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                chunks.push(chunk);
                done();
            },
        });
        readStream.pipe(stream);
        return result;
    };
    const getReadStream = () => {
        let push;
        let temp;
        const stream = new stream_1.Stream.Readable({
            read() {
                push = (data) => this.push(data);
            },
        });
        onData((buf) => {
            if (buf.length === 3 && buf.toString("utf-8") === "EOF" && push) {
                temp && push(temp);
                push(null);
                stream.destroy();
            }
            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;
            if (push) {
                !push(temp) && (push = null);
                temp = null;
            }
        });
        return stream;
    };
    return {
        getReadStream,
        getWriteStream,
        upload,
        uploadData,
        download,
        downloadData,
    };
}
function convertWebWritableStreamToNodeWritable(webWritableStream) {
    const writer = webWritableStream.getWriter();
    return new stream_1.Writable({
        async write(chunk, encoding, callback) {
            try {
                // Get a writer from the Web WritableStream
                await writer.write(chunk);
                writer.releaseLock(); // Release the lock on the writer after writing
                callback(); // Signal that the chunk has been processed
            }
            catch (error) {
                callback(); // Signal an error if it occurred
            }
        },
        async final(callback) {
            try {
                // Close the Web WritableStream
                const writer = webWritableStream.getWriter();
                await writer.close();
                writer.releaseLock(); // Release the lock on the writer after closing
                callback(); // Signal that the stream is finished
            }
            catch (error) {
                callback(); // Signal an error if it occurred during close
            }
        },
        async destroy(error, callback) {
            try {
                // Abort the Web WritableStream in case of an error
                const writer = webWritableStream.getWriter();
                await writer.abort(error);
                writer.releaseLock(); // Release the lock on the writer after aborting
                callback(error); // Signal that the stream is destroyed
            }
            catch (abortError) {
                callback(null); // Signal an error if it occurred during abort
            }
        },
    });
}
function convertWebReadableStreamToNodeReadable(webReadableStream) {
    const reader = webReadableStream.getReader();
    return new stream_1.Readable({
        async read() {
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    //console.log(value);
                    if (done) {
                        this.push(null); // Signal the end of the stream
                        break;
                    }
                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer
                }
            }
            catch (error) {
                this.destroy();
            }
        },
    });
}
class MemoryChannel {
    constructor() {
        this.messageQueue = [];
        this.waitingResolvers = [];
        this.connected = false;
        this.connectedCallbacks = [];
        this.closed = false;
    }
    setChannel(chan, name) {
        this.name = name;
        this.otherend = chan;
    }
    static createBidirectionnal() {
        const input = new MemoryChannel();
        const output = new MemoryChannel();
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    onConnected(callback) {
        if (this.connected) {
            callback();
        }
        else {
            this.connectedCallbacks.push(callback);
        }
    }
    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {
        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    getConnectionString() {
        return "vaultys://memory";
    }
    fromConnectionString(string) {
        return string === "vaultys://memory" ? new MemoryChannel() : null;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setInjector(injector) {
        this.injector = injector;
    }
    async start() {
        this.connected = true;
        this.connectedCallbacks.forEach((callback) => callback());
        this.connectedCallbacks = []; // Clear callbacks after calling them
    }
    async send(data) {
        if (this.closed) {
            throw new Error("Cannot send on closed channel");
        }
        if (!this.otherend) {
            throw new Error("No other end connected to this channel");
        }
        // Log the data if a logger is set
        if (this.logger) {
            this.logger(data);
        }
        // Process data through injector if present
        let processedData = data;
        if (this.injector) {
            processedData = await this.injector(data);
        }
        // // Signal that this end is connected
        if (!this.connected) {
            await this.start();
        }
        // Deliver the message to the other end
        this.otherend.deliverMessage(processedData);
    }
    deliverMessage(data) {
        // If there are waiting receivers, deliver directly to the first one
        if (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            resolver(data);
        }
        else {
            // Otherwise queue the message
            this.messageQueue.push(data);
        }
    }
    async receive() {
        if (this.closed) {
            throw new Error("Cannot receive on closed channel");
        }
        //console.log(this);
        // If there are queued messages, return the first one
        if (this.messageQueue.length > 0) {
            return this.messageQueue.shift();
        }
        // Otherwise, wait for a message to arrive
        return new Promise((resolve) => {
            this.waitingResolvers.push(resolve);
        });
    }
    async close() {
        this.closed = true;
        // Clear any waiting receivers with an error
        while (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            // Resolve with empty buffer to indicate channel closed
            resolver(buffer_1.Buffer.alloc(0));
        }
        // Clear the message queue
        this.messageQueue = [];
    }
}
exports.MemoryChannel = MemoryChannel;


/***/ }),

/***/ "./dist/node/src/MemoryStorage.js":
/*!****************************************!*\
  !*** ./dist/node/src/MemoryStorage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const replacer = (key, value) => {
    //if(key=="1686045792046") console.log(value);
    if (!value)
        return value;
    if (key === "certificate")
        return "__C__" + buffer_1.Buffer.from(value).toString("base64");
    if (value.type === "Buffer") {
        return "_bx_" + buffer_1.Buffer.from(value.data).toString("base64");
    }
    if (value.constructor.name === "Array") {
        return "_bx_" + buffer_1.Buffer.from(value).toString("base64");
    }
    return value;
};
const reviver = (key, value) => {
    if (value && key === "certificate") {
        if (typeof value === "string" && value.startsWith("__C__")) {
            return buffer_1.Buffer.from(value.slice(5), "base64");
        }
        else
            return buffer_1.Buffer.from(value);
    }
    if (typeof value === "string" && value.startsWith("_bx_")) {
        return buffer_1.Buffer.from(value.slice(4), "base64");
    }
    return value;
};
const serialize = (data) => JSON.stringify(data, replacer);
exports.serialize = serialize;
const deserialize = (string) => JSON.parse(string, reviver);
exports.deserialize = deserialize;
const MemoryStorage = (save) => {
    let data = {};
    if (!save)
        save = () => (0, exports.serialize)(data);
    return storagify(data, save, () => "");
};
exports.MemoryStorage = MemoryStorage;
const LocalStorage = (key = "vaultysStorage") => {
    let data = {};
    const _id = Math.random();
    //console.log(key);
    if (!localStorage[key])
        localStorage[key] = "{}";
    else
        data = (0, exports.deserialize)(localStorage[key]);
    return storagify(data, () => {
        //console.log("save !!!!!", key, _id);
        localStorage.setItem(key, (0, exports.serialize)(data));
    }, () => localStorage.removeItem(key));
};
exports.LocalStorage = LocalStorage;
const storagify = (object, save, destroy) => {
    return {
        destroy,
        save,
        toString: () => (0, exports.serialize)(object),
        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),
        _raw: object,
        set: (key, value) => (object[key] = value),
        delete: (key) => delete object[key],
        get: (key) => object[key],
        list: () => Object.keys(object).filter((k) => !k.startsWith("!")),
        listSubstores: () => Object.keys(object)
            .filter((k) => k.startsWith("!"))
            .map((k) => k.slice(1)),
        deleteSubstore: (key) => delete object["!" + key],
        renameSubstore: (oldname, newname) => {
            if (oldname === newname || !!object["!" + newname])
                return;
            object["!" + newname] = object["!" + oldname];
            delete object["!" + oldname];
        },
        substore: (key) => {
            if (!object["!" + key])
                object["!" + key] = {};
            return storagify(object["!" + key], save, destroy);
        },
    };
};


/***/ }),

/***/ "./dist/node/src/PQManager.js":
/*!************************************!*\
  !*** ./dist/node/src/PQManager.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
class PQManager extends KeyManager_1.default {
    constructor() {
        super();
        this.authType = "DilithiumVerificationKey2025";
    }
    static async create_PQ_fromEntropy(entropy, swapIndex = 0) {
        const km = new PQManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        km.seed = sha512(entropy);
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from([]));
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_PQ() {
        return PQManager.create_PQ_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            s: this.seed,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.seed = buffer_1.Buffer.from(data.s);
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new PQManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        return (0, pqCrypto_1.signDilithium)(data, this.signer.secretKey);
    }
    verify(data, signature, userVerificationIgnored) {
        return (0, pqCrypto_1.verifyDilithium)(data, signature, this.signer.publicKey);
    }
}
exports["default"] = PQManager;


/***/ }),

/***/ "./dist/node/src/VaultysId.js":
/*!************************************!*\
  !*** ./dist/node/src/VaultysId.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const Fido2PRFManager_1 = __importDefault(__webpack_require__(/*! ./Fido2PRFManager */ "./dist/node/src/Fido2PRFManager.js"));
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./dist/node/src/platform/webauthn.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const PQManager_1 = __importDefault(__webpack_require__(/*! ./PQManager */ "./dist/node/src/PQManager.js"));
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const TYPE_MACHINE = 0;
const TYPE_PERSON = 1;
const TYPE_ORGANIZATION = 2;
const TYPE_FIDO2 = 3;
const TYPE_FIDO2PRF = 4;
class VaultysId {
    constructor(keyManager, certificate, type = TYPE_MACHINE) {
        this.encrypt = VaultysId.encrypt;
        this.type = type;
        this.keyManager = keyManager;
        this.certificate = certificate;
    }
    // // Set the index of the proof in case of previous key for this protocol/service have been compromised
    // setProofIndex(protocol, service, index) {
    //   this.proofIndices[`${protocol}-${service}`] = index;
    // }
    // createSwapingCertificate(protocol, service) {
    //   let proofIndex = this.proofIndices[`${protocol}-${service}`]
    //     ? this.proofIndices[`${protocol}-${service}`]
    //     : 0;
    //   const pk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex,
    //   });
    //   const newPk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex: proofIndex + 1,
    //   });
    //   const xPub = this.device.getProofXPub({
    //     protocol,
    //     service,
    //     index,
    //   });
    //   const derivation = PDM.getProofDerivation(protocol, service, index);
    //   const revocationCertificate = `vaultys://p2p/revocation?pk=${pk}&npk=${newPk}&xpub=${xpub}&index=${derivation}`;
    // }
    static fromId(id, certificate, encoding = "hex") {
        let cleanId = id;
        if (id.data) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id.data);
        }
        if (id instanceof Uint8Array) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id);
        }
        if (typeof id === "string") {
            cleanId = buffer_1.Buffer.from(id, encoding);
        }
        const type = cleanId[0];
        if (type === TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else if (type === TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else {
            if (cleanId.length > 1952) {
                const pqm = PQManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(pqm, certificate, type);
            }
            else {
                const km = KeyManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(km, certificate, type);
            }
        }
    }
    static async fromEntropy(entropy, type, pqc = false) {
        const cleanedEntropy = entropy;
        if (pqc) {
            const km = await PQManager_1.default.create_PQ_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
        else {
            const km = await KeyManager_1.default.create_Id25519_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
    }
    static async createWebauthn(passkey = true, onPRFEnabled) {
        const options = VaultysId.createPublicKeyCredentialCreationOptions(passkey);
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation, onPRFEnabled);
    }
    static async createPQC() {
        const options = VaultysId.createPublicKeyCredentialOptionsPQC();
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        //console.log(attestation);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation);
    }
    static async fido2FromAttestation(attestation, onPRFEnabled) {
        // should be somehow valid.
        SoftCredentials_1.default.verifyPackedAttestation(attestation.response, true);
        //console.log(SoftCredentials.verifyPackedAttestation(attestation.response as AuthenticatorAttestationResponse, true));
        if (attestation.getClientExtensionResults().prf?.enabled && (!onPRFEnabled || (await onPRFEnabled()))) {
            const f2m = await Fido2PRFManager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2PRF);
        }
        else {
            const f2m = await Fido2Manager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2);
        }
    }
    static async machineFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_MACHINE);
    }
    static async organizationFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_ORGANIZATION);
    }
    static async personFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_PERSON);
    }
    static fromSecret(secret, encoding = "hex") {
        const secretBuffer = buffer_1.Buffer.from(secret, encoding);
        const type = secretBuffer[0];
        if (type == TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else if (type == TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else {
            //console.log(secretBuffer.length);
            if (secretBuffer.length === 109) {
                const pqm = PQManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(pqm, undefined, type);
            }
            else {
                const km = KeyManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(km, undefined, type);
            }
        }
    }
    static async generatePerson(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
    }
    static async generateOrganization(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
    }
    static async generateMachine(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
    }
    get relationshipCertificate() {
        return this.certificate;
    }
    getSecret(encoding = "hex") {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.getSecret()]).toString(encoding);
    }
    get fingerprint() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return fp
            .slice(0, 40)
            .toUpperCase()
            .match(/.{1,4}/g)
            .join(" ");
    }
    get did() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return `did:vaultys:${fp.slice(0, 40)}`;
    }
    get didDocument() {
        return {
            "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2020/v1"],
            id: this.did,
            authentication: [
                {
                    id: `${this.did}#keys-1`,
                    type: this.keyManager.authType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.signer.publicKey).toString("base64"),
                },
            ],
            keyAgreement: [
                {
                    id: `${this.did}#keys-2`,
                    type: this.keyManager.encType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.cypher.publicKey).toString("base64"),
                },
            ],
        };
    }
    get id() {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.id]);
    }
    toVersion(v) {
        this.keyManager.version = v;
        return this;
    }
    get version() {
        return this.keyManager.version;
    }
    isHardware() {
        return this.type === TYPE_FIDO2 || this.type === TYPE_FIDO2PRF;
    }
    isMachine() {
        return this.type === TYPE_MACHINE;
    }
    isPerson() {
        return this.type === TYPE_PERSON;
    }
    getOTPHmac(timelock = 1 * 3600000) {
        const otp = Math.floor(new Date().getTime() / timelock);
        return this.keyManager.getSecretHash(buffer_1.Buffer.from(`OTP-${otp}`)).toString("hex");
    }
    // Need to think about insecure use of this function
    getOTP(prefix = "password", timelock = 24 * 3600000) {
        if (this.certificate) {
            const otp = Math.floor(new Date().getTime() / timelock);
            const toHash = buffer_1.Buffer.concat([buffer_1.Buffer.from(prefix, "utf-8"), buffer_1.Buffer.from(this.certificate), buffer_1.Buffer.from([otp])]);
            return (0, crypto_1.hash)("SHA256", toHash).toString("hex");
        }
        throw new Error("no certificate, cannot derive OTP");
    }
    async performDiffieHellman(otherVaultysId) {
        return this.keyManager.performDiffieHellman(otherVaultysId.keyManager);
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two VaultysId instances
     * @param vaultysId1 First VaultysId instance
     * @param vaultysId2 Second VaultysId instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(vaultysId1, vaultysId2) {
        return vaultysId1.performDiffieHellman(vaultysId2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's VaultysId ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        let cleanId;
        if (typeof recipientId === "string") {
            cleanId = buffer_1.Buffer.from(recipientId.slice(2), "hex");
        }
        else {
            cleanId = recipientId.slice(1);
        }
        return this.keyManager.dhiesEncrypt(message, cleanId);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message as Buffer or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        let cleanId;
        if (typeof senderId === "string") {
            cleanId = buffer_1.Buffer.from(senderId.slice(2), "hex");
        }
        else {
            cleanId = senderId.slice(1);
        }
        return this.keyManager.dhiesDecrypt(encryptedMessage, cleanId);
    }
    async signChallenge(challenge) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        const signature = await this.keyManager.sign(result);
        if (!signature)
            throw new Error("Could not sign challenge");
        else
            return signature;
    }
    verifyChallenge(challenge, signature, userVerification) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        if (typeof signature == "string") {
            signature = buffer_1.Buffer.from(signature, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        return this.keyManager.verify(result, signature, userVerification);
    }
    async signcrypt(plaintext, recipientIds) {
        return this.keyManager.signcrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    static async encrypt(plaintext, recipientIds) {
        return KeyManager_1.default.encrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    async decrypt(encryptedMessage, senderId) {
        let cleanId;
        if (senderId) {
            if (typeof senderId === "string")
                cleanId = buffer_1.Buffer.from(senderId.slice(2));
            // @ts-ignore
            else
                cleanId = senderId.subarray(1);
        }
        return this.keyManager.decrypt(encryptedMessage, cleanId);
    }
    async hmac(message) {
        const cypher = await this.keyManager.getCypher();
        return cypher.hmac(message);
    }
}
VaultysId.createPublicKeyCredentialOptionsPQC = () => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: "cross-platform",
            residentKey: "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [{ type: "public-key", alg: pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 }],
    };
    return options;
};
VaultysId.createPublicKeyCredentialCreationOptions = (passkey) => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = passkey ? "client-device" : "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: passkey ? "platform" : "cross-platform",
            residentKey: passkey ? "required" : "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7, // SECP256/ECDSA, Ed25519/EdDSA (-8) not supported natively on mobile or yubikey (crying)
            },
            {
                type: "public-key",
                alg: -8, // Ed25519/EdDSA prefered
            },
            {
                type: "public-key",
                alg: -257, // RS256
            },
            // {
            //   "type": "public-key",
            //   "alg": -36
            // },
            // {
            //   "type": "public-key",
            //   "alg": -37
            // },
            // {
            //   "type": "public-key",
            //   "alg": -38
            // },
            // {
            //   "type": "public-key",
            //   "alg": -39
            // },
            // {
            //   "type": "public-key",
            //   "alg": -258
            // },
            // {
            //   "type": "public-key",
            //   "alg": -259
            // }
        ],
    };
    return options;
};
exports["default"] = VaultysId;


/***/ }),

/***/ "./dist/node/src/crypto.js":
/*!*********************************!*\
  !*** ./dist/node/src/crypto.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hmac = exports.hash = exports.Buffer = void 0;
const tweetnacl_1 = __importStar(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
Object.defineProperty(exports, "Buffer", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const getAlgorithm = (alg) => {
    const cleanAlg = alg.replaceAll("-", "").toLowerCase();
    if (cleanAlg === "sha256")
        return sha2_1.sha256;
    if (cleanAlg === "sha512")
        return sha2_1.sha512;
    if (cleanAlg === "sha224")
        return sha2_1.sha224;
    return sha2_1.sha256;
};
const _randomBytes = (size) => buffer_1.Buffer.from((0, tweetnacl_1.randomBytes)(size));
exports.randomBytes = _randomBytes;
const hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).create().update(buffer).digest());
exports.hash = hash;
const _hmac = (alg, key, data) => buffer_1.Buffer.from((0, hmac_1.hmac)(getAlgorithm(alg), key, data));
exports.hmac = _hmac;
const secretbox = tweetnacl_1.default.secretbox;
exports.secretbox = secretbox;
const toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("base64");
exports.toBase64 = toBase64;
const toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("hex");
exports.toHex = toHex;
const toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("utf-8");
exports.toUTF8 = toUTF8;
const fromBase64 = (string) => buffer_1.Buffer.from(string, "base64");
exports.fromBase64 = fromBase64;
const fromHex = (string) => buffer_1.Buffer.from(string, "hex");
exports.fromHex = fromHex;
const fromUTF8 = (string) => buffer_1.Buffer.from(string, "utf-8");
exports.fromUTF8 = fromUTF8;
const secureErase = (buffer) => {
    for (let i = 0; i < buffer.length; i++) {
        buffer[i] = 0;
    }
};
exports.secureErase = secureErase;


/***/ }),

/***/ "./dist/node/src/cryptoChannel.js":
/*!****************************************!*\
  !*** ./dist/node/src/cryptoChannel.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);
const encrypt = (buffer, key) => {
    //console.log("encrypting: ", buffer, key)
    const keyUint8Array = key;
    const nonce = newNonce();
    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return buffer_1.Buffer.from(fullMessage);
};
exports.encrypt = encrypt;
const decrypt = (messageWithNonce, key) => {
    //console.log("decrypting: ", messageWithNonce, key)
    const keyUint8Array = key;
    const messageWithNonceAsUint8Array = messageWithNonce;
    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);
    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);
    if (!decrypted) {
        throw new Error("Could not decrypt message");
    }
    return buffer_1.Buffer.from(decrypted);
};
exports.decrypt = decrypt;
// upgrading a channel api with an encrypting layer. The API shoud be
// - send(Buffer):null
// - async receive():Buffer
const encryptChannel = (channel, key) => {
    const sendHandler = {
        apply(target, that, args) {
            return target.call(that, (0, exports.encrypt)(args[0], key));
        },
    };
    const receiveHandler = {
        async apply(target, that, args) {
            const result = await target.call(that);
            return (0, exports.decrypt)(result, key);
        },
    };
    channel.send = new Proxy(channel.send, sendHandler);
    channel.receive = new Proxy(channel.receive, receiveHandler);
    return channel;
};
const generateKey = () => (0, crypto_1.randomBytes)(32);
exports["default"] = {
    decrypt: exports.decrypt,
    encrypt: exports.encrypt,
    encryptChannel,
    generateKey,
};


/***/ }),

/***/ "./dist/node/src/platform/SoftCredentials.js":
/*!***************************************************!*\
  !*** ./dist/node/src/platform/SoftCredentials.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: to revamp and optimize
// import crypto from "crypto";
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
const p256_1 = __webpack_require__(/*! @noble/curves/p256 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js");
const p384_1 = __webpack_require__(/*! @noble/curves/p384 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js");
const p521_1 = __webpack_require__(/*! @noble/curves/p521 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js");
// import { BasicConstraintsExtension, X509Certificate } from "@peculiar/x509";
const pqCrypto_1 = __webpack_require__(/*! ../pqCrypto */ "./dist/node/src/pqCrypto.js");
const credentials = {};
//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;
const COSEKEYS = {
    kty: 1,
    alg: 3,
    crv: -1,
    x: -2,
    y: -3,
    n: -1,
    e: -2,
};
const COSEKTY = {
    OKP: 1,
    EC2: 2,
    RSA: 3,
    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,
};
const COSERSASCHEME = {
    "-3": "pss-sha256",
    "-39": "pss-sha512",
    "-38": "pss-sha384",
    "-65535": "pkcs1-sha1",
    "-257": "pkcs1-sha256",
    "-258": "pkcs1-sha384",
    "-259": "pkcs1-sha512",
};
const COSECRV = {
    1: p256_1.p256,
    2: p384_1.p384,
    3: p521_1.p521,
};
const COSEALGHASH = {
    "-257": "SHA-256",
    "-258": "SHA-384",
    "-259": "SHA-512",
    "-65535": "SHA-1",
    "-39": "SHA-512",
    "-38": "SHA-384",
    "-37": "SHA-256",
    "-260": "SHA-256",
    "-261": "SHA-512",
    "-7": "SHA-256",
    "-36": "SHA-512",
    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: "SHA-256", // DILITHIUM2 uses SHA-256 for hashing
};
const hash = (alg, message) => (0, crypto_1.hash)(alg.replace("-", ""), message);
const base64ToPem = (b64cert) => {
    let pemcert = "";
    for (let i = 0; i < b64cert.length; i += 64)
        pemcert += b64cert.slice(i, i + 64) + "\n";
    return "-----BEGIN CERTIFICATE-----\n" + pemcert + "-----END CERTIFICATE-----";
};
// const getCertificateInfo = (certificate: Buffer) => {
//   const x509 = new X509Certificate(certificate);
//   const subjectString = x509.subject;
//   const issuer = x509.issuer;
//   const issuerName = x509.issuerName.toString();
//   const subjectParts = subjectString.split(",");
//   const subject: Record<string, string> = {};
//   for (const field of subjectParts) {
//     const kv = field.split("=");
//     subject[kv[0].trim()] = kv[1];
//   }
//   // console.log(subject);
//   const { Version } = x509.toTextObject().Data as unknown as { Version: string };
//   const bc = x509.getExtension(BasicConstraintsExtension);
//   const basicConstraintsCA = bc ? bc.ca : false;
//   return {
//     issuer,
//     issuerName,
//     subject,
//     version: Version,
//     basicConstraintsCA,
//   };
// };
const parseAuthData = (buffer) => {
    const rpIdHash = buffer.slice(0, 32);
    buffer = buffer.slice(32);
    const flagsBuf = buffer.slice(0, 1);
    buffer = buffer.slice(1);
    const flagsInt = flagsBuf[0];
    const flags = {
        up: !!(flagsInt & 0x01),
        uv: !!(flagsInt & 0x04),
        at: !!(flagsInt & 0x40),
        ed: !!(flagsInt & 0x80),
        flagsInt,
    };
    const counterBuf = buffer.slice(0, 4);
    buffer = buffer.slice(4);
    const counter = counterBuf.readUInt32BE(0);
    let aaguid = undefined;
    let credID = undefined;
    let COSEPublicKey = undefined;
    if (flags.at) {
        aaguid = buffer.slice(0, 16);
        buffer = buffer.slice(16);
        const credIDLenBuf = buffer.slice(0, 2);
        buffer = buffer.slice(2);
        const credIDLen = credIDLenBuf.readUInt16BE(0);
        credID = buffer.slice(0, credIDLen);
        buffer = buffer.slice(credIDLen);
        COSEPublicKey = buffer;
    }
    //console.log(aaguid);
    return {
        rpIdHash,
        flagsBuf,
        flags,
        counter,
        counterBuf,
        aaguid,
        credID,
        COSEPublicKey,
    };
};
const verifyPackedAttestation = (response, userVerification = false) => {
    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
    if (attestationStruct.fmt == "none")
        return false;
    const authDataStruct = parseAuthData(attestationStruct.authData);
    // check if user has actually touched the device
    if (!authDataStruct.flags.up)
        return false;
    // check if did enter PIN code
    if (userVerification && !authDataStruct.flags.uv)
        return false;
    const clientDataHashBuf = hash("sha256", buffer_1.Buffer.from(response.clientDataJSON));
    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);
    const signature = attestationStruct.attStmt.sig;
    let signatureIsValid = false;
    /* ----- Verify FULL attestation ----- */
    // if (attestationStruct.attStmt.x5c) {
    //   const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString("base64"));
    //   const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);
    //   const subject = certInfo.subject as {
    //     OU: string;
    //     O: string;
    //     C: string;
    //     CN: string;
    //   };
    //   // console.log(certInfo);
    //   if (subject.OU !== "Authenticator Attestation") throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');
    //   if (!subject.CN) throw new Error("Batch certificate CN MUST no be empty!");
    //   if (!subject.O) throw new Error("Batch certificate O MUST no be empty!");
    //   if (!subject.C || subject.C.length !== 2) throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");
    //   if (certInfo.basicConstraintsCA) throw new Error("Batch certificate basic constraints CA MUST be false!");
    //   if (certInfo.version !== "v3 (2)") throw new Error("Batch certificate version MUST be 3(ASN1 2)!");
    //   signatureIsValid = crypto.createVerify("sha256").update(dataBuffer).verify(leafCert, signature);
    //   /* ----- Verify FULL attestation ENDS ----- */
    // } else
    if (attestationStruct.attStmt.ecdaaKeyId) {
        throw new Error("ECDAA IS NOT SUPPORTED!");
    }
    else {
        /* ----- Verify SURROGATE attestation ----- */
        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];
        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];
        const data = hash(hashAlg, dataBuffer);
        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {
            // ECDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            const y = pubKeyCose.get(COSEKEYS.y);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);
            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];
            const sig = ec.Signature.fromDER(signature);
            signatureIsValid = ec.verify(sig, data, pubKey);
        }
        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {
            // EdDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);
        }
        else {
            return false;
        }
        /* ----- Verify SURROGATE attestation ENDS ----- */
    }
    if (!signatureIsValid)
        throw new Error("Failed to verify the signature!");
    return true;
};
class MyPublicKeyCredential {
    constructor(creds) {
        this.type = "public-key";
        this.clientExtensionResults = {};
        const keys = ["id", "rawId", "response"];
        this.id = creds.id;
        this.rawId = buffer_1.Buffer.from(creds.rawId);
        this.response = creds.response;
    }
    getClientExtensionResults() {
        return {};
    }
}
const verifyECDSA = (data, publicKey, signature) => {
    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);
};
const verifyEdDSA = (data, publicKey, signature) => {
    return ed25519_1.ed25519.verify(signature, data, publicKey);
};
// Webauthn Partial Implementation for testing
class SoftCredentials {
    constructor() {
        this.signCount = 0;
        this.rawId = (0, crypto_1.randomBytes)(32);
        this.aaguid = buffer_1.Buffer.alloc(16);
    }
    // credentials request payload
    static createRequest(alg, prf = false) {
        const challenge = buffer_1.Buffer.from((0, crypto_1.randomBytes)(32).toString("base64"));
        const result = {
            publicKey: {
                challenge,
                rp: {
                    name: "Vaultys ID",
                    id: "Vaultys ID",
                },
                user: {
                    id: buffer_1.Buffer.from("Vaultys Wallet ID", "utf8"),
                    name: "Vaultys Wallet ID",
                    displayName: "Vaultys Wallet ID",
                },
                pubKeyCredParams: [
                    {
                        type: "public-key",
                        alg,
                    },
                ],
            },
        };
        if (prf) {
            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_1.randomBytes)(32) } } };
        }
        return result;
    }
    // static getCertificateInfo(response: AuthenticatorAttestationResponse) {
    //   const attestationBuffer = Buffer.from(response.attestationObject);
    //   const attestationStruct = cbor.decodeAllSync(attestationBuffer)[0];
    //   if (attestationStruct.attStmt.x5c) {
    //     return getCertificateInfo(attestationStruct.attStmt.x5c[0]);
    //   } else {
    //     return null;
    //   }
    // }
    static async create(options, origin = "test") {
        const credential = new SoftCredentials();
        const publicKey = options.publicKey;
        credential.options = publicKey;
        credential.rpId = publicKey.rp.id || publicKey.rp.name;
        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), "base64");
        credentials[credential.rawId.toString("base64")] = credential; // erase previous instance
        // Get the algorithm from pubKeyCredParams
        const pubKeyCredParams = publicKey.pubKeyCredParams;
        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)
        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
        // Set algorithm, prioritizing DILITHIUM if it's supported
        if (supportsDilithium) {
            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;
        }
        else {
            credential.alg = publicKey.pubKeyCredParams[0].alg;
        }
        if (credential.alg === -8) {
            const random = ed25519_1.ed25519.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: ed25519_1.ed25519.getPublicKey(random),
                algorithm: "EdDSA",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 1);
            credential.coseKey.set(3, -8);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(0, 32);
            credential.coseKey.set(-2, x);
        }
        else if (credential.alg === -7) {
            const random = p256_1.p256.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: p256_1.p256.getPublicKey(random, false),
                algorithm: "ES256",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 2);
            credential.coseKey.set(3, -7);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(1, 33);
            const y = credential.keyPair.publicKey.slice(33);
            credential.coseKey.set(-2, x);
            credential.coseKey.set(-3, y);
            // console.log(extpk,x,y)
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // Generate DILITHIUM key pair
            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();
            //console.log("PQC", dilithiumPk, dilithiumSk);
            credential.keyPair = {
                privateKey: dilithiumSk,
                publicKey: dilithiumPk,
                algorithm: "DILITHIUM2",
                isDILITHIUM: true,
            };
            // Create COSE key representation
            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);
            //console.log("PQC", credential);
        }
        const clientData = {
            type: "webauthn.create",
            challenge: publicKey.challenge,
            origin,
        };
        const rpIdHash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "ascii"));
        const flags = buffer_1.Buffer.from("41", "hex"); // attested_data + user_present
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);
        rawIdLength.writeUInt16BE(credential.rawId.length, 0);
        const coseKey = cbor_1.default.encode(credential.coseKey);
        const attestationObject = {
            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),
            fmt: "none",
            attStmt: {},
        };
        const pkCredentials = {
            id: credential.rawId.toString("base64"),
            rawId: credential.rawId,
            authenticatorAttachment: null,
            type: "public-key",
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    return { prf: { enabled: true } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                attestationObject: cbor_1.default.encode(attestationObject),
                getTransports: () => ["usb", "hybrid"],
                getAuthenticatorData: () => attestationObject.authData,
                getPublicKey: () => coseKey,
                getPublicKeyAlgorithm: () => -7,
            },
        };
        return pkCredentials;
    }
    static simpleVerify(COSEPublicKey, response, userVerification = false) {
        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;
        const rpIdHash = response.authenticatorData.slice(0, 32);
        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];
        const counter = response.authenticatorData.slice(33, 37);
        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);
        if (!goodflags)
            return false;
        const hash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(response.clientDataJSON));
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);
        if (ckey.get(3) == -7) {
            data = (0, crypto_1.hash)("sha256", data);
        }
        if (ckey.get(1) == 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) == 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(response.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);
        }
        return false;
    }
    static getCOSEPublicKey(attestation) {
        const response = attestation.response;
        const ato = cbor_1.default.decode(response.attestationObject);
        //console.log("getCOSEPublicKey", ato, parseAuthData(ato.authData));
        return parseAuthData(ato.authData).COSEPublicKey;
    }
    static verifyPackedAttestation(attestation, userVerification = false) {
        return verifyPackedAttestation(attestation, userVerification);
    }
    static async verify(attestation, assertion, userVerifiation = false) {
        //if (assertion.id !== attestation.id) return false;
        const hash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(assertion.response.clientDataJSON));
        const ass = assertion.response;
        const att = attestation.response;
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);
        const ato = cbor_1.default.decode(att.attestationObject);
        const authData = parseAuthData(ato.authData);
        // check if user has actually touched the device
        if (!authData.flags.up)
            return false;
        // check if the user has entered his PIN code or used biometric sensor
        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)
            return false;
        const ckey = cbor_1.default.decode(authData.COSEPublicKey);
        // Hash data for ES256
        if (ckey.get(3) == -7) {
            data = (0, crypto_1.hash)("sha256", data);
        }
        // Get key type
        const keyType = ckey.get(1);
        if (keyType === 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(ass.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);
        }
        return false;
    }
    static extractChallenge(clientDataJSON) {
        const clientData = JSON.parse(clientDataJSON.toString());
        const m = clientData.challenge.length % 4;
        return clientData.challenge
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), "=");
    }
    static async get({ publicKey }, origin = "test") {
        if (!publicKey.allowCredentials)
            throw new Error();
        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString("base64");
        const credential = credentials[id];
        credential.signCount += 1;
        // prepare signature
        const clientData = {
            type: "webauthn.get",
            challenge: buffer_1.Buffer.from(publicKey.challenge).toString("base64"),
            origin,
        };
        const clientDataHash = (0, crypto_1.hash)("sha256", (0, crypto_1.fromUTF8)(JSON.stringify(clientData)));
        const rpIdHash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "utf-8"));
        const flags = buffer_1.Buffer.from("05", "hex"); // user verification
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);
        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);
        let signature = new Uint8Array();
        if (credential.alg === -7) {
            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();
        }
        else if (credential.alg === -8) {
            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // DILITHIUM signing - this returns a Promise so we need to await it
            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);
        }
        const pkCredentials = {
            id,
            rawId: buffer_1.Buffer.from(id, "base64").buffer,
            type: "public-key",
            authenticatorAttachment: null,
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    // unsafe and not following w3c recommendation. for testing purpose only
                    return { prf: { results: { first: hash("sha256", publicKey.extensions?.prf?.eval?.first) } } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                authenticatorData,
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                signature: signature,
                userHandle: credential.userHandle,
            },
        };
        return pkCredentials;
    }
}
exports["default"] = SoftCredentials;


/***/ }),

/***/ "./dist/node/src/platform/webauthn.js":
/*!********************************************!*\
  !*** ./dist/node/src/platform/webauthn.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeWebAuthn = exports.BrowserWebAuthn = void 0;
exports.getWebAuthnProvider = getWebAuthnProvider;
exports.createCredentialRequest = createCredentialRequest;
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
// Browser implementation
class BrowserWebAuthn {
    isAvailable() {
        return typeof window !== "undefined" && typeof window.PublicKeyCredential !== "undefined";
    }
    async create(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.create({ publicKey: options }));
    }
    async get(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.get({ publicKey: options }));
    }
}
exports.BrowserWebAuthn = BrowserWebAuthn;
// Node.js implementation using SoftCredentials
class NodeWebAuthn {
    constructor(origin = "test") {
        this.origin = origin;
    }
    isAvailable() {
        return true; // Always available in mock mode
    }
    async create(options) {
        return await SoftCredentials_1.default.create({
            publicKey: options,
        }, this.origin);
    }
    async get(options) {
        return await SoftCredentials_1.default.get({
            publicKey: options,
        }, this.origin);
    }
}
exports.NodeWebAuthn = NodeWebAuthn;
// Factory function
function getWebAuthnProvider(options) {
    if (typeof window !== "undefined") {
        return new BrowserWebAuthn();
    }
    return new NodeWebAuthn(options?.origin);
}
// Helper to create credential request
function createCredentialRequest(alg, prf = false) {
    return SoftCredentials_1.default.createRequest(alg, prf);
}


/***/ }),

/***/ "./dist/node/src/pqCrypto.js":
/*!***********************************!*\
  !*** ./dist/node/src/pqCrypto.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Post-Quantum Cryptography Operations
 *
 * This file contains implementations for post-quantum cryptographic algorithms
 * starting with DILITHIUM for digital signatures.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;
exports.generateDilithiumKeyPair = generateDilithiumKeyPair;
exports.signDilithium = signDilithium;
exports.verifyDilithium = verifyDilithium;
exports.createDilithiumCoseKey = createDilithiumCoseKey;
exports.getDilithiumKeyInfo = getDilithiumKeyInfo;
const ml_dsa_js_1 = __webpack_require__(/*! @noble/post-quantum/ml-dsa.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
/**
 * COSE algorithm identifiers for post-quantum algorithms
 * Note: These values are provisional and may need to be updated as standards evolve
 */
exports.PQ_COSE_ALG = {
    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)
    DILITHIUM2: -46, // Level 2 (128-bit security)
    DILITHIUM3: -47, // Level 3 (192-bit security)
    DILITHIUM5: -48, // Level 5 (256-bit security)
};
/**
 * COSE key type for DILITHIUM
 */
exports.PQ_COSE_KEY_TYPE = {
    DILITHIUM: 4, // Custom key type for DILITHIUM
};
/**
 * COSE key parameter identifiers for DILITHIUM
 */
exports.PQ_COSE_KEY_PARAMS = {
    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)
    DILITHIUM_PK: -101, // Public key
    DILITHIUM_SK: -102, // Secret key
};
/**
 * Generate a DILITHIUM Level 2 key pair
 * @returns Promise resolving to an object containing the key pair
 */
function generateDilithiumKeyPair(seed) {
    if (!seed)
        seed = (0, crypto_1.randomBytes)(32);
    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);
    return {
        publicKey: buffer_1.Buffer.from(keyPair.publicKey),
        secretKey: buffer_1.Buffer.from(keyPair.secretKey),
    };
}
/**
 * Sign a message using DILITHIUM Level 2
 * @param message - The message to sign
 * @param privateKey - The DILITHIUM private key
 * @returns Promise resolving to signature as Uint8Array
 */
function signDilithium(message, secretKey) {
    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));
}
/**
 * Verify a DILITHIUM Level 2 signature
 * @param message - The original message
 * @param signature - The signature to verify
 * @param publicKey - The DILITHIUM public key
 * @returns Promise resolving to boolean indicating if signature is valid
 */
function verifyDilithium(message, signature, publicKey) {
    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);
}
/**
 * Create a COSE key representation for a DILITHIUM public key
 * @param publicKey - The DILITHIUM public key
 * @returns Map representing the COSE key
 */
function createDilithiumCoseKey(publicKey) {
    const coseKey = new Map();
    // Standard COSE key parameters
    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type
    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm
    // DILITHIUM-specific parameters
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);
    return coseKey;
}
/**
 * Get key size information for DILITHIUM
 * @returns Object with key size information
 */
function getDilithiumKeyInfo() {
    return {
        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key
        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key
        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)
/* harmony export */ });
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");

const DEFAULT_MAX_KEY_LENGTH = 16;
const DEFAULT_MAX_LENGTH_PER_KEY = 16;
class CachedKeyDecoder {
    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.hit = 0;
        this.miss = 0;
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        // avoid `new Array(N)`, which makes a sparse array,
        // because a sparse array is typically slower than a non-sparse array.
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
            this.caches.push([]);
        }
    }
    canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
    }
    find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK: for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
                if (recordBytes[j] !== bytes[inputOffset + j]) {
                    continue FIND_CHUNK;
                }
            }
            return record.str;
        }
        return null;
    }
    store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
            // `records` are full!
            // Set `record` to an arbitrary position.
            records[(Math.random() * records.length) | 0] = record;
        }
        else {
            records.push(record);
        }
    }
    decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
            this.hit++;
            return cachedValue;
        }
        this.miss++;
        const str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);
        // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
    }
}
//# sourceMappingURL=CachedKeyDecoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodeError: () => (/* binding */ DecodeError)
/* harmony export */ });
class DecodeError extends Error {
    constructor(message) {
        super(message);
        // fix the prototype chain in a cross-platform way
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError.name,
        });
    }
}
//# sourceMappingURL=DecodeError.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Decoder: () => (/* binding */ Decoder)
/* harmony export */ });
/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");
/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs");
/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs");
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");







const STATE_ARRAY = "array";
const STATE_MAP_KEY = "map_key";
const STATE_MAP_VALUE = "map_value";
const mapKeyConverter = (key) => {
    if (typeof key === "string" || typeof key === "number") {
        return key;
    }
    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError("The type of key must be string or number but " + typeof key);
};
class StackPool {
    constructor() {
        this.stack = [];
        this.stackHeadPosition = -1;
    }
    get length() {
        return this.stackHeadPosition + 1;
    }
    top() {
        return this.stack[this.stackHeadPosition];
    }
    pushArrayState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_ARRAY;
        state.position = 0;
        state.size = size;
        state.array = new Array(size);
    }
    pushMapState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_MAP_KEY;
        state.readCount = 0;
        state.size = size;
        state.map = {};
    }
    getUninitializedStateFromPool() {
        this.stackHeadPosition++;
        if (this.stackHeadPosition === this.stack.length) {
            const partialState = {
                type: undefined,
                size: 0,
                array: undefined,
                position: 0,
                readCount: 0,
                map: undefined,
                key: null,
            };
            this.stack.push(partialState);
        }
        return this.stack[this.stackHeadPosition];
    }
    release(state) {
        const topStackState = this.stack[this.stackHeadPosition];
        if (topStackState !== state) {
            throw new Error("Invalid stack state. Released state is not on top of the stack.");
        }
        if (state.type === STATE_ARRAY) {
            const partialState = state;
            partialState.size = 0;
            partialState.array = undefined;
            partialState.position = 0;
            partialState.type = undefined;
        }
        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
            const partialState = state;
            partialState.size = 0;
            partialState.map = undefined;
            partialState.readCount = 0;
            partialState.type = undefined;
        }
        this.stackHeadPosition--;
    }
    reset() {
        this.stack.length = 0;
        this.stackHeadPosition = -1;
    }
}
const HEAD_BYTE_REQUIRED = -1;
const EMPTY_VIEW = new DataView(new ArrayBuffer(0));
const EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
    // IE11: The spec says it should throw RangeError,
    // IE11: but in IE11 it throws TypeError.
    EMPTY_VIEW.getInt8(0);
}
catch (e) {
    if (!(e instanceof RangeError)) {
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
    }
}
const MORE_DATA = new RangeError("Insufficient data");
const sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__.CachedKeyDecoder();
class Decoder {
    constructor(options) {
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = new StackPool();
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionCodec.defaultCodec;
        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.rawStrings = options?.rawStrings ?? false;
        this.maxStrLength = options?.maxStrLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxBinLength = options?.maxBinLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxArrayLength = options?.maxArrayLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxMapLength = options?.maxMapLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxExtLength = options?.maxExtLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;
        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;
    }
    clone() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new Decoder({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder,
        });
    }
    reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.reset();
        // view, bytes, and pos will be re-initialized in setBuffer()
    }
    setBuffer(buffer) {
        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);
        this.bytes = bytes;
        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        this.pos = 0;
    }
    appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
            this.setBuffer(buffer);
        }
        else {
            const remainingData = this.bytes.subarray(this.pos);
            const newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);
            // concat remainingData + newData
            const newBuffer = new Uint8Array(remainingData.length + newData.length);
            newBuffer.set(remainingData);
            newBuffer.set(newData, remainingData.length);
            this.setBuffer(newBuffer);
        }
    }
    hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
    }
    createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
    }
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */
    decode(buffer) {
        if (this.entered) {
            const instance = this.clone();
            return instance.decode(buffer);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.setBuffer(buffer);
            const object = this.doDecodeSync();
            if (this.hasRemaining(1)) {
                throw this.createExtraByteError(this.pos);
            }
            return object;
        }
        finally {
            this.entered = false;
        }
    }
    *decodeMulti(buffer) {
        if (this.entered) {
            const instance = this.clone();
            yield* instance.decodeMulti(buffer);
            return;
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.setBuffer(buffer);
            while (this.hasRemaining(1)) {
                yield this.doDecodeSync();
            }
        }
        finally {
            this.entered = false;
        }
    }
    async decodeAsync(stream) {
        if (this.entered) {
            const instance = this.clone();
            return instance.decodeAsync(stream);
        }
        try {
            this.entered = true;
            let decoded = false;
            let object;
            for await (const buffer of stream) {
                if (decoded) {
                    this.entered = false;
                    throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                try {
                    object = this.doDecodeSync();
                    decoded = true;
                }
                catch (e) {
                    if (!(e instanceof RangeError)) {
                        throw e; // rethrow
                    }
                    // fallthrough
                }
                this.totalPos += this.pos;
            }
            if (decoded) {
                if (this.hasRemaining(1)) {
                    throw this.createExtraByteError(this.totalPos);
                }
                return object;
            }
            const { headByte, pos, totalPos } = this;
            throw new RangeError(`Insufficient data in parsing ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
        }
        finally {
            this.entered = false;
        }
    }
    decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
    }
    decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
    }
    async *decodeMultiAsync(stream, isArray) {
        if (this.entered) {
            const instance = this.clone();
            yield* instance.decodeMultiAsync(stream, isArray);
            return;
        }
        try {
            this.entered = true;
            let isArrayHeaderRequired = isArray;
            let arrayItemsLeft = -1;
            for await (const buffer of stream) {
                if (isArray && arrayItemsLeft === 0) {
                    throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                if (isArrayHeaderRequired) {
                    arrayItemsLeft = this.readArraySize();
                    isArrayHeaderRequired = false;
                    this.complete();
                }
                try {
                    while (true) {
                        yield this.doDecodeSync();
                        if (--arrayItemsLeft === 0) {
                            break;
                        }
                    }
                }
                catch (e) {
                    if (!(e instanceof RangeError)) {
                        throw e; // rethrow
                    }
                    // fallthrough
                }
                this.totalPos += this.pos;
            }
        }
        finally {
            this.entered = false;
        }
    }
    doDecodeSync() {
        DECODE: while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 0xe0) {
                // negative fixint (111x xxxx) 0xe0 - 0xff
                object = headByte - 0x100;
            }
            else if (headByte < 0xc0) {
                if (headByte < 0x80) {
                    // positive fixint (0xxx xxxx) 0x00 - 0x7f
                    object = headByte;
                }
                else if (headByte < 0x90) {
                    // fixmap (1000 xxxx) 0x80 - 0x8f
                    const size = headByte - 0x80;
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = {};
                    }
                }
                else if (headByte < 0xa0) {
                    // fixarray (1001 xxxx) 0x90 - 0x9f
                    const size = headByte - 0x90;
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = [];
                    }
                }
                else {
                    // fixstr (101x xxxx) 0xa0 - 0xbf
                    const byteLength = headByte - 0xa0;
                    object = this.decodeString(byteLength, 0);
                }
            }
            else if (headByte === 0xc0) {
                // nil
                object = null;
            }
            else if (headByte === 0xc2) {
                // false
                object = false;
            }
            else if (headByte === 0xc3) {
                // true
                object = true;
            }
            else if (headByte === 0xca) {
                // float 32
                object = this.readF32();
            }
            else if (headByte === 0xcb) {
                // float 64
                object = this.readF64();
            }
            else if (headByte === 0xcc) {
                // uint 8
                object = this.readU8();
            }
            else if (headByte === 0xcd) {
                // uint 16
                object = this.readU16();
            }
            else if (headByte === 0xce) {
                // uint 32
                object = this.readU32();
            }
            else if (headByte === 0xcf) {
                // uint 64
                if (this.useBigInt64) {
                    object = this.readU64AsBigInt();
                }
                else {
                    object = this.readU64();
                }
            }
            else if (headByte === 0xd0) {
                // int 8
                object = this.readI8();
            }
            else if (headByte === 0xd1) {
                // int 16
                object = this.readI16();
            }
            else if (headByte === 0xd2) {
                // int 32
                object = this.readI32();
            }
            else if (headByte === 0xd3) {
                // int 64
                if (this.useBigInt64) {
                    object = this.readI64AsBigInt();
                }
                else {
                    object = this.readI64();
                }
            }
            else if (headByte === 0xd9) {
                // str 8
                const byteLength = this.lookU8();
                object = this.decodeString(byteLength, 1);
            }
            else if (headByte === 0xda) {
                // str 16
                const byteLength = this.lookU16();
                object = this.decodeString(byteLength, 2);
            }
            else if (headByte === 0xdb) {
                // str 32
                const byteLength = this.lookU32();
                object = this.decodeString(byteLength, 4);
            }
            else if (headByte === 0xdc) {
                // array 16
                const size = this.readU16();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xdd) {
                // array 32
                const size = this.readU32();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xde) {
                // map 16
                const size = this.readU16();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xdf) {
                // map 32
                const size = this.readU32();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xc4) {
                // bin 8
                const size = this.lookU8();
                object = this.decodeBinary(size, 1);
            }
            else if (headByte === 0xc5) {
                // bin 16
                const size = this.lookU16();
                object = this.decodeBinary(size, 2);
            }
            else if (headByte === 0xc6) {
                // bin 32
                const size = this.lookU32();
                object = this.decodeBinary(size, 4);
            }
            else if (headByte === 0xd4) {
                // fixext 1
                object = this.decodeExtension(1, 0);
            }
            else if (headByte === 0xd5) {
                // fixext 2
                object = this.decodeExtension(2, 0);
            }
            else if (headByte === 0xd6) {
                // fixext 4
                object = this.decodeExtension(4, 0);
            }
            else if (headByte === 0xd7) {
                // fixext 8
                object = this.decodeExtension(8, 0);
            }
            else if (headByte === 0xd8) {
                // fixext 16
                object = this.decodeExtension(16, 0);
            }
            else if (headByte === 0xc7) {
                // ext 8
                const size = this.lookU8();
                object = this.decodeExtension(size, 1);
            }
            else if (headByte === 0xc8) {
                // ext 16
                const size = this.lookU16();
                object = this.decodeExtension(size, 2);
            }
            else if (headByte === 0xc9) {
                // ext 32
                const size = this.lookU32();
                object = this.decodeExtension(size, 4);
            }
            else {
                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
                // arrays and maps
                const state = stack.top();
                if (state.type === STATE_ARRAY) {
                    state.array[state.position] = object;
                    state.position++;
                    if (state.position === state.size) {
                        object = state.array;
                        stack.release(state);
                    }
                    else {
                        continue DECODE;
                    }
                }
                else if (state.type === STATE_MAP_KEY) {
                    if (object === "__proto__") {
                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError("The key __proto__ is not allowed");
                    }
                    state.key = this.mapKeyConverter(object);
                    state.type = STATE_MAP_VALUE;
                    continue DECODE;
                }
                else {
                    // it must be `state.type === State.MAP_VALUE` here
                    state.map[state.key] = object;
                    state.readCount++;
                    if (state.readCount === state.size) {
                        object = state.map;
                        stack.release(state);
                    }
                    else {
                        state.key = null;
                        state.type = STATE_MAP_KEY;
                        continue DECODE;
                    }
                }
            }
            return object;
        }
    }
    readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = this.readU8();
            // console.log("headByte", prettyByte(this.headByte));
        }
        return this.headByte;
    }
    complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
    }
    readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
            case 0xdc:
                return this.readU16();
            case 0xdd:
                return this.readU32();
            default: {
                if (headByte < 0xa0) {
                    return headByte - 0x90;
                }
                else {
                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized array type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);
                }
            }
        }
    }
    pushMapState(size) {
        if (size > this.maxMapLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.pushMapState(size);
    }
    pushArrayState(size) {
        if (size > this.maxArrayLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.pushArrayState(size);
    }
    decodeString(byteLength, headerOffset) {
        if (!this.rawStrings || this.stateIsMapKey()) {
            return this.decodeUtf8String(byteLength, headerOffset);
        }
        return this.decodeBinary(byteLength, headerOffset);
    }
    /**
     * @throws {@link RangeError}
     */
    decodeUtf8String(byteLength, headerOffset) {
        if (byteLength > this.maxStrLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
            throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {
            object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        }
        else {
            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
    }
    stateIsMapKey() {
        if (this.stack.length > 0) {
            const state = this.stack.top();
            return state.type === STATE_MAP_KEY;
        }
        return false;
    }
    /**
     * @throws {@link RangeError}
     */
    decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
            throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
    }
    decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(size, headOffset + 1 /* extType */);
        return this.extensionCodec.decode(data, extType, this.context);
    }
    lookU8() {
        return this.view.getUint8(this.pos);
    }
    lookU16() {
        return this.view.getUint16(this.pos);
    }
    lookU32() {
        return this.view.getUint32(this.pos);
    }
    readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
    }
    readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
    }
    readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
    }
    readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
    }
    readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
    }
    readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
    }
    readU64() {
        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
    }
    readI64() {
        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
    }
    readU64AsBigInt() {
        const value = this.view.getBigUint64(this.pos);
        this.pos += 8;
        return value;
    }
    readI64AsBigInt() {
        const value = this.view.getBigInt64(this.pos);
        this.pos += 8;
        return value;
    }
    readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
    }
    readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
    }
}
//# sourceMappingURL=Decoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),
/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),
/* harmony export */   Encoder: () => (/* binding */ Encoder)
/* harmony export */ });
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs");




const DEFAULT_MAX_DEPTH = 100;
const DEFAULT_INITIAL_BUFFER_SIZE = 2048;
class Encoder {
    constructor(options) {
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;
        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;
        this.sortKeys = options?.sortKeys ?? false;
        this.forceFloat32 = options?.forceFloat32 ?? false;
        this.ignoreUndefined = options?.ignoreUndefined ?? false;
        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
    }
    clone() {
        // Because of slightly special argument `context`,
        // type assertion is needed.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new Encoder({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat,
        });
    }
    reinitializeState() {
        this.pos = 0;
    }
    /**
     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
     *
     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
     */
    encodeSharedRef(object) {
        if (this.entered) {
            const instance = this.clone();
            return instance.encodeSharedRef(object);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.doEncode(object, 1);
            return this.bytes.subarray(0, this.pos);
        }
        finally {
            this.entered = false;
        }
    }
    /**
     * @returns Encodes the object and returns a copy of the encoder's internal buffer.
     */
    encode(object) {
        if (this.entered) {
            const instance = this.clone();
            return instance.encode(object);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.doEncode(object, 1);
            return this.bytes.slice(0, this.pos);
        }
        finally {
            this.entered = false;
        }
    }
    doEncode(object, depth) {
        if (depth > this.maxDepth) {
            throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
            this.encodeNil();
        }
        else if (typeof object === "boolean") {
            this.encodeBoolean(object);
        }
        else if (typeof object === "number") {
            if (!this.forceIntegerToFloat) {
                this.encodeNumber(object);
            }
            else {
                this.encodeNumberAsFloat(object);
            }
        }
        else if (typeof object === "string") {
            this.encodeString(object);
        }
        else if (this.useBigInt64 && typeof object === "bigint") {
            this.encodeBigInt64(object);
        }
        else {
            this.encodeObject(object, depth);
        }
    }
    ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
        }
    }
    resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
    }
    encodeNil() {
        this.writeU8(0xc0);
    }
    encodeBoolean(object) {
        if (object === false) {
            this.writeU8(0xc2);
        }
        else {
            this.writeU8(0xc3);
        }
    }
    encodeNumber(object) {
        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
            if (object >= 0) {
                if (object < 0x80) {
                    // positive fixint
                    this.writeU8(object);
                }
                else if (object < 0x100) {
                    // uint 8
                    this.writeU8(0xcc);
                    this.writeU8(object);
                }
                else if (object < 0x10000) {
                    // uint 16
                    this.writeU8(0xcd);
                    this.writeU16(object);
                }
                else if (object < 0x100000000) {
                    // uint 32
                    this.writeU8(0xce);
                    this.writeU32(object);
                }
                else if (!this.useBigInt64) {
                    // uint 64
                    this.writeU8(0xcf);
                    this.writeU64(object);
                }
                else {
                    this.encodeNumberAsFloat(object);
                }
            }
            else {
                if (object >= -0x20) {
                    // negative fixint
                    this.writeU8(0xe0 | (object + 0x20));
                }
                else if (object >= -0x80) {
                    // int 8
                    this.writeU8(0xd0);
                    this.writeI8(object);
                }
                else if (object >= -0x8000) {
                    // int 16
                    this.writeU8(0xd1);
                    this.writeI16(object);
                }
                else if (object >= -0x80000000) {
                    // int 32
                    this.writeU8(0xd2);
                    this.writeI32(object);
                }
                else if (!this.useBigInt64) {
                    // int 64
                    this.writeU8(0xd3);
                    this.writeI64(object);
                }
                else {
                    this.encodeNumberAsFloat(object);
                }
            }
        }
        else {
            this.encodeNumberAsFloat(object);
        }
    }
    encodeNumberAsFloat(object) {
        if (this.forceFloat32) {
            // float 32
            this.writeU8(0xca);
            this.writeF32(object);
        }
        else {
            // float 64
            this.writeU8(0xcb);
            this.writeF64(object);
        }
    }
    encodeBigInt64(object) {
        if (object >= BigInt(0)) {
            // uint 64
            this.writeU8(0xcf);
            this.writeBigUint64(object);
        }
        else {
            // int 64
            this.writeU8(0xd3);
            this.writeBigInt64(object);
        }
    }
    writeStringHeader(byteLength) {
        if (byteLength < 32) {
            // fixstr
            this.writeU8(0xa0 + byteLength);
        }
        else if (byteLength < 0x100) {
            // str 8
            this.writeU8(0xd9);
            this.writeU8(byteLength);
        }
        else if (byteLength < 0x10000) {
            // str 16
            this.writeU8(0xda);
            this.writeU16(byteLength);
        }
        else if (byteLength < 0x100000000) {
            // str 32
            this.writeU8(0xdb);
            this.writeU32(byteLength);
        }
        else {
            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
    }
    encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);
        this.pos += byteLength;
    }
    encodeObject(object, depth) {
        // try to encode objects with custom codec first of non-primitives
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
            this.encodeExtension(ext);
        }
        else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
        }
        else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
        }
        else if (typeof object === "object") {
            this.encodeMap(object, depth);
        }
        else {
            // symbol, function and other special object come here unless extensionCodec handles them.
            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
    }
    encodeBinary(object) {
        const size = object.byteLength;
        if (size < 0x100) {
            // bin 8
            this.writeU8(0xc4);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // bin 16
            this.writeU8(0xc5);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // bin 32
            this.writeU8(0xc6);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);
        this.writeU8a(bytes);
    }
    encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
            // fixarray
            this.writeU8(0x90 + size);
        }
        else if (size < 0x10000) {
            // array 16
            this.writeU8(0xdc);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // array 32
            this.writeU8(0xdd);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
            this.doEncode(item, depth + 1);
        }
    }
    countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
            if (object[key] !== undefined) {
                count++;
            }
        }
        return count;
    }
    encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
            keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
            // fixmap
            this.writeU8(0x80 + size);
        }
        else if (size < 0x10000) {
            // map 16
            this.writeU8(0xde);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // map 32
            this.writeU8(0xdf);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
            const value = object[key];
            if (!(this.ignoreUndefined && value === undefined)) {
                this.encodeString(key);
                this.doEncode(value, depth + 1);
            }
        }
    }
    encodeExtension(ext) {
        if (typeof ext.data === "function") {
            const data = ext.data(this.pos + 6);
            const size = data.length;
            if (size >= 0x100000000) {
                throw new Error(`Too large extension object: ${size}`);
            }
            this.writeU8(0xc9);
            this.writeU32(size);
            this.writeI8(ext.type);
            this.writeU8a(data);
            return;
        }
        const size = ext.data.length;
        if (size === 1) {
            // fixext 1
            this.writeU8(0xd4);
        }
        else if (size === 2) {
            // fixext 2
            this.writeU8(0xd5);
        }
        else if (size === 4) {
            // fixext 4
            this.writeU8(0xd6);
        }
        else if (size === 8) {
            // fixext 8
            this.writeU8(0xd7);
        }
        else if (size === 16) {
            // fixext 16
            this.writeU8(0xd8);
        }
        else if (size < 0x100) {
            // ext 8
            this.writeU8(0xc7);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // ext 16
            this.writeU8(0xc8);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // ext 32
            this.writeU8(0xc9);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
    }
    writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
    }
    writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
    }
    writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
    }
    writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
    }
    writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
    }
    writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
    }
    writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
    }
    writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
    }
    writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
    }
    writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);
        this.pos += 8;
    }
    writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);
        this.pos += 8;
    }
    writeBigUint64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigUint64(this.pos, value);
        this.pos += 8;
    }
    writeBigInt64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
    }
}
//# sourceMappingURL=Encoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtData: () => (/* binding */ ExtData)
/* harmony export */ });
/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */
class ExtData {
    constructor(type, data) {
        this.type = type;
        this.data = data;
    }
}
//# sourceMappingURL=ExtData.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)
/* harmony export */ });
/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs");
/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs");
// ExtensionCodec to handle MessagePack extensions


class ExtensionCodec {
    constructor() {
        // built-in extensions
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        // custom extensions
        this.encoders = [];
        this.decoders = [];
        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);
    }
    register({ type, encode, decode, }) {
        if (type >= 0) {
            // custom extensions
            this.encoders[type] = encode;
            this.decoders[type] = decode;
        }
        else {
            // built-in extensions
            const index = -1 - type;
            this.builtInEncoders[index] = encode;
            this.builtInDecoders[index] = decode;
        }
    }
    tryToEncode(object, context) {
        // built-in extensions
        for (let i = 0; i < this.builtInEncoders.length; i++) {
            const encodeExt = this.builtInEncoders[i];
            if (encodeExt != null) {
                const data = encodeExt(object, context);
                if (data != null) {
                    const type = -1 - i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        // custom extensions
        for (let i = 0; i < this.encoders.length; i++) {
            const encodeExt = this.encoders[i];
            if (encodeExt != null) {
                const data = encodeExt(object, context);
                if (data != null) {
                    const type = i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {
            // to keep ExtData as is
            return object;
        }
        return null;
    }
    decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
            return decodeExt(data, type, context);
        }
        else {
            // decode() does not fail, returns ExtData instead.
            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
        }
    }
}
ExtensionCodec.defaultCodec = new ExtensionCodec();
//# sourceMappingURL=ExtensionCodec.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeMulti: () => (/* binding */ decodeMulti)
/* harmony export */ });
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");

/**
 * It decodes a single MessagePack object in a buffer.
 *
 * This is a synchronous decoding function.
 * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.
 *
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decode(buffer, options) {
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);
    return decoder.decode(buffer);
}
/**
 * It decodes multiple MessagePack objects in a buffer.
 * This is corresponding to {@link decodeMultiStream}.
 *
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeMulti(buffer, options) {
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);
    return decoder.decodeMulti(buffer);
}
//# sourceMappingURL=decode.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeArrayStream: () => (/* binding */ decodeArrayStream),
/* harmony export */   decodeAsync: () => (/* binding */ decodeAsync),
/* harmony export */   decodeMultiStream: () => (/* binding */ decodeMultiStream)
/* harmony export */ });
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");
/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/stream.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs");


/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
async function decodeAsync(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeAsync(stream);
}
/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeArrayStream(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeArrayStream(stream);
}
/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeMultiStream(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeStream(stream);
}
//# sourceMappingURL=decodeAsync.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs");

/**
 * It encodes `value` in the MessagePack format and
 * returns a byte buffer.
 *
 * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.
 */
function encode(value, options) {
    const encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);
    return encoder.encodeSharedRef(value);
}
//# sourceMappingURL=encode.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodeError: () => (/* reexport safe */ _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__.DecodeError),
/* harmony export */   Decoder: () => (/* reexport safe */ _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__.Decoder),
/* harmony export */   EXT_TIMESTAMP: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.EXT_TIMESTAMP),
/* harmony export */   Encoder: () => (/* reexport safe */ _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__.Encoder),
/* harmony export */   ExtData: () => (/* reexport safe */ _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtData),
/* harmony export */   ExtensionCodec: () => (/* reexport safe */ _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionCodec),
/* harmony export */   decode: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decode),
/* harmony export */   decodeArrayStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeArrayStream),
/* harmony export */   decodeAsync: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeAsync),
/* harmony export */   decodeMulti: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeMulti),
/* harmony export */   decodeMultiStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeMultiStream),
/* harmony export */   decodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampExtension),
/* harmony export */   decodeTimestampToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampToTimeSpec),
/* harmony export */   encode: () => (/* reexport safe */ _encode_mjs__WEBPACK_IMPORTED_MODULE_0__.encode),
/* harmony export */   encodeDateToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeDateToTimeSpec),
/* harmony export */   encodeTimeSpecToTimestamp: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimeSpecToTimestamp),
/* harmony export */   encodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimestampExtension)
/* harmony export */ });
/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs");
/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs");
/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decodeAsync.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs");
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");
/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Encoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ExtData.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs");
/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./timestamp.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs");
// Main Functions:












// Utilities for Extension Types:






//# sourceMappingURL=index.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),
/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),
/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),
/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),
/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),
/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),
/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)
/* harmony export */ });
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type


const EXT_TIMESTAMP = -1;
const TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int
const TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int
function encodeTimeSpecToTimestamp({ sec, nsec }) {
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        // Here sec >= 0 && nsec >= 0
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
            // timestamp 32 = { sec32 (unsigned) }
            const rv = new Uint8Array(4);
            const view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
        }
        else {
            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
            const secHigh = sec / 0x100000000;
            const secLow = sec & 0xffffffff;
            const rv = new Uint8Array(8);
            const view = new DataView(rv.buffer);
            // nsec30 | secHigh2
            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));
            // secLow32
            view.setUint32(4, secLow);
            return rv;
        }
    }
    else {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);
        return rv;
    }
}
function encodeDateToTimeSpec(date) {
    const msec = date.getTime();
    const sec = Math.floor(msec / 1e3);
    const nsec = (msec - sec * 1e3) * 1e6;
    // Normalizes { sec, nsec } to ensure nsec is unsigned.
    const nsecInSec = Math.floor(nsec / 1e9);
    return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9,
    };
}
function encodeTimestampExtension(object) {
    if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
    }
    else {
        return null;
    }
}
function decodeTimestampToTimeSpec(data) {
    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // data may be 32, 64, or 96 bits
    switch (data.byteLength) {
        case 4: {
            // timestamp 32 = { sec32 }
            const sec = view.getUint32(0);
            const nsec = 0;
            return { sec, nsec };
        }
        case 8: {
            // timestamp 64 = { nsec30, sec34 }
            const nsec30AndSecHigh2 = view.getUint32(0);
            const secLow32 = view.getUint32(4);
            const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
            const nsec = nsec30AndSecHigh2 >>> 2;
            return { sec, nsec };
        }
        case 12: {
            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
            const sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);
            const nsec = view.getUint32(0);
            return { sec, nsec };
        }
        default:
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
    }
}
function decodeTimestampExtension(data) {
    const timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
const timestampExtension = {
    type: EXT_TIMESTAMP,
    encode: encodeTimestampExtension,
    decode: decodeTimestampExtension,
};
//# sourceMappingURL=timestamp.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),
/* harmony export */   getInt64: () => (/* binding */ getInt64),
/* harmony export */   getUint64: () => (/* binding */ getUint64),
/* harmony export */   setInt64: () => (/* binding */ setInt64),
/* harmony export */   setUint64: () => (/* binding */ setUint64)
/* harmony export */ });
// Integer Utility
const UINT32_MAX = 4294967295;
// DataView extension to handle int64 / uint64,
// where the actual range is 53-bits integer (a.k.a. safe integer)
function setUint64(view, offset, value) {
    const high = value / 4294967296;
    const low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
    const high = Math.floor(value / 4294967296);
    const low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
    const high = view.getInt32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
function getUint64(view, offset) {
    const high = view.getUint32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
//# sourceMappingURL=int.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prettyByte: () => (/* binding */ prettyByte)
/* harmony export */ });
function prettyByte(byte) {
    return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}
//# sourceMappingURL=prettyByte.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncIterableFromStream: () => (/* binding */ asyncIterableFromStream),
/* harmony export */   ensureAsyncIterable: () => (/* binding */ ensureAsyncIterable),
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)
/* harmony export */ });
// utility for whatwg streams
function isAsyncIterable(object) {
    return object[Symbol.asyncIterator] != null;
}
async function* asyncIterableFromStream(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                return;
            }
            yield value;
        }
    }
    finally {
        reader.releaseLock();
    }
}
function ensureAsyncIterable(streamLike) {
    if (isAsyncIterable(streamLike)) {
        return streamLike;
    }
    else {
        return asyncIterableFromStream(streamLike);
    }
}
//# sourceMappingURL=stream.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)
/* harmony export */ });
function isArrayBufferLike(buffer) {
    return (buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer));
}
function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
        return buffer;
    }
    else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    else if (isArrayBufferLike(buffer)) {
        return new Uint8Array(buffer);
    }
    else {
        // ArrayLike<number>
        return Uint8Array.from(buffer);
    }
}
//# sourceMappingURL=typedArrays.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   utf8Count: () => (/* binding */ utf8Count),
/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),
/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),
/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),
/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),
/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),
/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)
/* harmony export */ });
function utf8Count(str) {
    const strLength = str.length;
    let byteLength = 0;
    let pos = 0;
    while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            byteLength++;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            byteLength += 2;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    const extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                byteLength += 3;
            }
            else {
                // 4-byte
                byteLength += 4;
            }
        }
    }
    return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
    const strLength = str.length;
    let offset = outputOffset;
    let pos = 0;
    while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            output[offset++] = value;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    const extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
            else {
                // 4-byte
                output[offset++] = ((value >> 18) & 0x07) | 0xf0;
                output[offset++] = ((value >> 12) & 0x3f) | 0x80;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
        }
        output[offset++] = (value & 0x3f) | 0x80;
    }
}
// TextEncoder and TextDecoder are standardized in whatwg encoding:
// https://encoding.spec.whatwg.org/
// and available in all the modern browsers:
// https://caniuse.com/textencoder
// They are available in Node.js since v12 LTS as well:
// https://nodejs.org/api/globals.html#textencoder
const sharedTextEncoder = new TextEncoder();
// This threshold should be determined by benchmarking, which might vary in engines and input data.
// Run `npx ts-node benchmark/encode-string.ts` for details.
const TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
    if (str.length > TEXT_ENCODER_THRESHOLD) {
        utf8EncodeTE(str, output, outputOffset);
    }
    else {
        utf8EncodeJs(str, output, outputOffset);
    }
}
const CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
    let offset = inputOffset;
    const end = offset + byteLength;
    const units = [];
    let result = "";
    while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 0x80) === 0) {
            // 1 byte
            units.push(byte1);
        }
        else if ((byte1 & 0xe0) === 0xc0) {
            // 2 bytes
            const byte2 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 6) | byte2);
        }
        else if ((byte1 & 0xf0) === 0xe0) {
            // 3 bytes
            const byte2 = bytes[offset++] & 0x3f;
            const byte3 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
        }
        else if ((byte1 & 0xf8) === 0xf0) {
            // 4 bytes
            const byte2 = bytes[offset++] & 0x3f;
            const byte3 = bytes[offset++] & 0x3f;
            const byte4 = bytes[offset++] & 0x3f;
            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(((unit >>> 10) & 0x3ff) | 0xd800);
                unit = 0xdc00 | (unit & 0x3ff);
            }
            units.push(unit);
        }
        else {
            units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
            result += String.fromCharCode(...units);
            units.length = 0;
        }
    }
    if (units.length > 0) {
        result += String.fromCharCode(...units);
    }
    return result;
}
const sharedTextDecoder = new TextDecoder();
// This threshold should be determined by benchmarking, which might vary in engines and input data.
// Run `npx ts-node benchmark/decode-string.ts` for details.
const TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
    if (byteLength > TEXT_DECODER_THRESHOLD) {
        return utf8DecodeTD(bytes, inputOffset, byteLength);
    }
    else {
        return utf8DecodeJs(bytes, inputOffset, byteLength);
    }
}
//# sourceMappingURL=utf8.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js");
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.wNAF = wNAF;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, property, points) {
    const getz = property === 'pz' ? (p) => p.pz : (p) => p.ez;
    const toInv = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(getz));
    // @ts-ignore
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
function wNAF(c, bits) {
    return {
        constTimeNegate: negateCt,
        hasPrecomputes(elm) {
            return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder(elm, n, p = c.ZERO) {
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = calcWOpts(W, bits);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // i=1, bc we skip 0
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // Smaller version:
            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
            // TODO: check the scalar is less than group order?
            // wNAF behavior is undefined otherwise. But have to carefully remove
            // other checks before wNAF. ORDER == bits here.
            // Accumulators
            let p = c.ZERO;
            let f = c.BASE;
            // This code was first written with assumption that 'f' and 'p' will never be infinity point:
            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
            // there is negate now: it is possible that negated element from low value
            // would be the same as high element, which will create carry into next window.
            // It's not obvious how this can fail, but still worth investigating later.
            const wo = calcWOpts(W, bits);
            for (let window = 0; window < wo.windows; window++) {
                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) {
                    // bits are 0: add garbage to fake point
                    // Important part for const-time getPublicKey: add random "noise" point to f.
                    f = f.add(negateCt(isNegF, precomputes[offsetF]));
                }
                else {
                    // bits are 1: add to result point
                    p = p.add(negateCt(isNeg, precomputes[offset]));
                }
            }
            assert0(n);
            // Return both real and fake points: JIT won't eliminate f.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
            const wo = calcWOpts(W, bits);
            for (let window = 0; window < wo.windows; window++) {
                if (n === _0n)
                    break; // Early-exit, skip 0 value
                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) {
                    // Window bits are 0: skip processing.
                    // Move to next window.
                    continue;
                }
                else {
                    const item = precomputes[offset];
                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
                }
            }
            assert0(n);
            return acc;
        },
        getPrecomputes(W, P, transform) {
            // Calculate precomputes on a first run, reuse them after
            let comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    // Doing transform outside of if brings 15% perf hit
                    if (typeof transform === 'function')
                        comp = transform(comp);
                    pointPrecomputes.set(P, comp);
                }
            }
            return comp;
        },
        wNAFCached(P, n, transform) {
            const W = getW(P);
            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe(P, n, transform, prev) {
            const W = getW(P);
            if (W === 1)
                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster
            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
            validateW(W, bits);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        },
    };
}
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar  256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255  32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16  255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order);
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    return { Fp, Fn };
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.edwards = edwards;
exports.eddsa = eddsa;
exports.twistedEdwards = twistedEdwards;
/**
 * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.
 * For design rationale of types / exports, see weierstrass module documentation.
 * Untwisted Edwards curves exist, but they aren't used in real-world protocols.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
const VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('edwards', CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, { uvRatio: 'function' });
    // Important:
    // There are some places where Fp.BYTES is used instead of nByteLength.
    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.
    // TODO: test and find curves which behave otherwise.
    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);
    const modP = (n) => Fp.create(n); // Function overrides
    // sqrt(u/v)
    const uvRatio = curveOpts.uvRatio ||
        ((u, v) => {
            try {
                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
            }
            catch (e) {
                return { isValid: false, value: _0n };
            }
        });
    // Validate whether the passed curve params are valid.
    // equation ax + y = 1 + dxy should work for generator point.
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    /**
     * Asserts coordinate is valid: 0 <= n < MASK.
     * Coordinates >= Fp.ORDER are allowed for zip215.
     */
    function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);
        return n;
    }
    function aextpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null)
            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
            return { x: _0n, y: _1n };
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax + y = 1 + dxy
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X); // X
        const Y2 = modP(Y * Y); // Y
        const Z2 = modP(Z * Z); // Z
        const Z4 = modP(Z2 * Z2); // Z
        const aX2 = modP(X2 * a); // aX
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY
        if (left !== right)
            throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
            throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(ex, ey, ez, et) {
            this.ex = acoord('x', ex);
            this.ey = acoord('y', ey);
            this.ez = acoord('z', ez, true);
            this.et = acoord('t', et);
            Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point)
                throw new Error('extended point not allowed');
            const { x, y } = p || {};
            acoord('x', x);
            acoord('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, 'ez', points);
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        precompute(windowSize = 8, isLazy = true) {
            wnaf.setWindowSize(this, windowSize);
            if (!isLazy)
                this.multiply(_2n); // random number
            return this;
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            aextpoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
            const n = scalar;
            (0, utils_ts_1.aInRange)('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L
            const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);
            return Point.normalizeZ([p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
            const n = scalar;
            (0, utils_ts_1.aInRange)('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L
            if (n === _0n)
                return Point.ZERO;
            if (this.is0() || n === _1n)
                return this;
            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
            if (cofactor === _1n)
                return this;
            return this.multiplyUnsafe(cofactor);
        }
        static fromBytes(bytes, zip215 = false) {
            (0, utils_ts_1.abytes)(bytes);
            return this.fromHex(bytes, zip215);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_ts_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array
            (0, utils_ts_1.abool)('zip215', zip215);
            const normed = hex.slice(); // copy again, we'll manipulate it
            const lastByte = hex[len - 1]; // select last byte
            normed[len - 1] = lastByte & ~0x80; // clear last bit
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)('pointHex.y', y, _0n, max);
            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:
            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y - 1
            const v = modP(d * y2 - a); // v = d y + 1.
            let { isValid, value: x } = uvRatio(u, v); // (u/v)
            if (!isValid)
                throw new Error('Point.fromHex: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd)
                // if x=0 and x_0 = 1, fail
                throw new Error('Point.fromHex: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd)
                x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({ x, y });
        }
        static fromPrivateScalar(scalar) {
            return Point.BASE.multiply(scalar);
        }
        toBytes() {
            const { x, y } = this.toAffine();
            const bytes = (0, utils_ts_1.numberToBytesLE)(y, Fp.BYTES); // each y has 2 x values (x, -y)
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
            return bytes; // and use the last byte to encode sign of x
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
            return this.toBytes();
        }
        toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    // fields
    Point.Fp = Fp;
    Point.Fn = Fn;
    const wnaf = (0, curve_ts_1.wNAF)(Point, Fn.BYTES * 8); // Fn.BITS?
    return Point;
}
/**
 * Initializes EdDSA signatures over given Edwards curve.
 */
function eddsa(Point, eddsaOpts) {
    (0, utils_ts_1._validateObject)(eddsaOpts, {
        hash: 'function',
    }, {
        adjustScalarBytes: 'function',
        randomBytes: 'function',
        domain: 'function',
        prehash: 'function',
        mapToCurve: 'function',
    });
    const { prehash, hash: cHash } = eddsaOpts;
    const { BASE: G, Fp, Fn } = Point;
    const CURVE_ORDER = Fn.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes); // NOOP
    const domain = eddsaOpts.domain ||
        ((data, ctx, phflag) => {
            (0, utils_ts_1.abool)('phflag', phflag);
            if (ctx.length || phflag)
                throw new Error('Contexts/pre-hash are not supported');
            return data;
        }); // NOOP
    function modN(a) {
        return Fn.create(a);
    }
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        // Not using Fn.fromBytes: hash can be 2*Fn.BYTES
        return modN((0, utils_ts_1.bytesToNumberLE)(hash));
    }
    // Get the hashed private scalar per RFC8032 5.1.5
    function getPrivateScalar(key) {
        const len = Fp.BYTES;
        key = (0, utils_ts_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        return { head, prefix, scalar };
    }
    // Convenience method that creates public key from scalar. RFC8032 5.1.5
    function getExtendedPublicKey(key) {
        const { head, prefix, scalar } = getPrivateScalar(key);
        const point = G.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
    }
    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
    function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */
    function sign(msg, privKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        if (prehash)
            msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = G.multiply(r).toBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = modN(r + k * scalar); // S = (r + k * s) mod L
        (0, utils_ts_1.aInRange)('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l
        const L = Fp.BYTES;
        const res = (0, utils_ts_1.concatBytes)(R, (0, utils_ts_1.numberToBytesLE)(s, L));
        return (0, utils_ts_1.ensureBytes)('result', res, L * 2); // 64-byte signature
    }
    const verifyOpts = VERIFY_DEFAULT;
    /**
     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
     * An extended group equation is checked.
     */
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
        sig = (0, utils_ts_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, len);
        if (zip215 !== undefined)
            (0, utils_ts_1.abool)('zip215', zip215);
        if (prehash)
            msg = prehash(msg); // for ed25519ph, etc
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.slice(len, 2 * len));
        let A, R, SB;
        try {
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
        }
        catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder())
            return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // Extended group equation
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().is0();
    }
    G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    const utils = {
        getExtendedPublicKey,
        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
        randomPrivateKey: () => randomBytes_(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return { getPublicKey, sign, verify, utils, Point };
}
function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
    const eddsaOpts = {
        hash: c.hash,
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve,
    };
    return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa) {
    const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });
    return legacy;
}
// TODO: remove. Use eddsa
function twistedEdwards(c) {
    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
}
//# sourceMappingURL=edwards.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    if (!(0, utils_ts_1.isBytes)(_DST) && typeof _DST !== 'string')
        throw new Error('DST must be string or uint8array');
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const dst = defaults.DST ? defaults.DST : {};
            const opts = Object.assign({}, defaults, dst, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const dst = defaults.encodeDST ? defaults.encodeDST : {};
            const opts = Object.assign({}, defaults, dst, options);
            const u = hash_to_field(msg, 1, opts);
            return clear(map(u[0]));
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);
const _8n = /* @__PURE__ */ BigInt(8);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    // Throw if root^2 != n
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
    return root;
}
// TODO: Commented-out for now. Provide test vectors.
// Tonelli is too slow for extension fields Fp2.
// That means we can't use sqrt (c1, c2...) even for initialization constants.
// if (P % _16n === _9n) return sqrt9mod16;
// // prettier-ignore
// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {
//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;
//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic
//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4
//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1
//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1
//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1
//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x
//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x
//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x
//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2
// }
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < BigInt(3))
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P  3 (mod 4)
 * 2. P  5 (mod 8)
 * 3. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P  3 (mod 4) => n = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P  9 (mod 16) not implemented, see above
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p)  1    if a is a square (mod p), quadratic residue
 * * (a | p)  -1   if a is not a square (mod p), quadratic non residue
 * * (a | p)  0    if a  0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.montgomery = montgomery;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function validateOpts(curve) {
    (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: 'function',
        powPminus2: 'function',
    });
    return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === 'x25519';
    if (!is25519 && type !== 'x448')
        throw new Error('invalid type');
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    // RFC 7748 #5:
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and
    // (156326 - 2) / 4 = 39081 for curve448/X448
    // const a = is25519 ? 156326n : 486662n;
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    // RFC: x25519 "the resulting integer is of the form 2^254 plus
    // eight times a value between 0 and 2^251 - 1 (inclusive)"
    // x448: "2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)"
    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
    const maxAdded = is25519
        ? BigInt(8) * _2n ** BigInt(251) - _1n
        : BigInt(4) * _2n ** BigInt(445) - _1n;
    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)
    const modP = (n) => (0, modular_ts_1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);
        // RFC: When receiving such an array, implementations of X25519
        // (but not X448) MUST mask the most significant bit in the final byte.
        if (is25519)
            _u[31] &= 127; // 0b0111_1111
        // RFC: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.  The non-canonical
        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
        // - 1 through 2^448 - 1 for X448.
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        // Some public keys are useless, of low-order. Curve author doesn't think
        // it needs to be validated, but we do it nonetheless.
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('invalid private or public key received');
        return encodeU(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    // cswap from RFC7748 "example code"
    function cswap(swap, x_2, x_3) {
        // dummy = mask(swap) AND (x_2 XOR x_3)
        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2
        // and x_3, computed, e.g., as mask(swap) = 0 - swap.
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy
        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy
        return { x_2, x_3 };
    }
    /**
     * Montgomery x-only multiplication ladder.
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)('u', u, _0n, P);
        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent
        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))
    }
    return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey) => scalarMultBase(privateKey),
        utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
        GuBytes: GuBytes.slice(),
    };
}
//# sourceMappingURL=montgomery.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = exports.DERErr = void 0;
exports._legacyHelperEquat = _legacyHelperEquat;
exports._legacyHelperNormPriv = _legacyHelperNormPriv;
exports.weierstrassN = weierstrassN;
exports.weierstrassPoints = weierstrassPoints;
exports.ecdsa = ecdsa;
exports.weierstrass = weierstrass;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
/**
 * Short Weierstrass curve methods. The formula is: y = x + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = __webpack_require__(/*! @noble/hashes/hmac.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
function validateSigVerOpts(opts) {
    if (opts.lowS !== undefined)
        (0, utils_ts_1.abool)('lowS', opts.lowS);
    if (opts.prehash !== undefined)
        (0, utils_ts_1.abool)('prehash', opts.prehash);
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
// TODO: remove
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.
     * @returns y
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b
    }
    return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    // Validates if priv key is valid and converts it to bigint.
    function normPrivateKeyToScalar(key) {
        let num;
        if (typeof key === 'bigint') {
            num = key;
        }
        else {
            let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
            if (allowedPrivateKeyLengths) {
                if (!allowedPrivateKeyLengths.includes(bytes.length * 2))
                    throw new Error('invalid private key');
                const padded = new Uint8Array(expected);
                padded.set(bytes, padded.length - bytes.length);
                bytes = padded;
            }
            try {
                num = Fn.fromBytes(bytes);
            }
            catch (error) {
                throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
            }
        }
        if (wrapPrivateKey)
            num = Fn.create(num); // disabled by default, enabled for BLS
        if (!Fn.isValidNot0(num))
            throw new Error('invalid private key: out of range [1..N-1]');
        return num;
    }
    return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('weierstrass', CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = curveOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        }
    }
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1.abool)('isCompressed', isCompressed);
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1.abytes)(bytes);
        const L = Fp.BYTES;
        const LC = L + 1; // length compressed, e.g. 33 for 32-byte field
        const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === LC && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y = x + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === LU && head === 0x04) {
            // TODO: more checks
            const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));
            const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
        }
    }
    const toBytes = curveOpts.toBytes || pointToBytes;
    const fromBytes = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y == x + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y = x + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z)  (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        // Fast-path for normalized points
        if (Fp.eql(z, Fp.ONE))
            return { x, y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (curveOpts.allowInfinityPoint && !Fp.is0(p.py))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(px, py, pz) {
            this.px = acoord('x', px);
            this.py = acoord('y', py, true);
            this.pz = acoord('z', pz);
            Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, 'pz', points);
        }
        static fromBytes(bytes) {
            (0, utils_ts_1.abytes)(bytes);
            return Point.fromHex(bytes);
        }
        /** Converts hash string or Uint8Array to Point. */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        /** Multiplies generator point by privateKey. */
        static fromPrivateKey(privateKey) {
            const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        /** Multiscalar Multiplication */
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.setWindowSize(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        /** "Private method", don't use it directly */
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = curveOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.wNAFCached(this, n, Point.normalizeZ);
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = curveOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasPrecomputes(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
                // `wNAFCachedUnsafe` is 30% slower
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.wNAFCachedUnsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = curveOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = curveOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1.abool)('isCompressed', isCompressed);
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        /** @deprecated use `toBytes` */
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // fields
    Point.Fp = Fp;
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = (0, curve_ts_1.wNAF)(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point;
}
// _legacyWeierstrass
/** @deprecated use `weierstrassN` */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
function ecdsa(Point, ecdsaOpts, curveOpts = {}) {
    (0, utils_ts_1._validateObject)(ecdsaOpts, { hash: 'function' }, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac_ = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            aValidRS('r', r); // r in [1..N-1]
            aValidRS('s', s); // s in [1..N-1]
            this.r = r;
            this.s = s;
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const L = Fn.BYTES;
            const b = (0, utils_ts_1.ensureBytes)('compactSignature', hex, L * 2);
            return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        /**
         * @todo remove
         * @deprecated
         */
        assertValidity() { }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        // ProjPointType<bigint>
        recoverPublicKey(msgHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromHex((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toBytes(format) {
            if (format === 'compact')
                return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            throw new Error('invalid format');
        }
        // DER-encoded
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const n = CURVE_ORDER;
            return (0, modular_ts_1.mapHashToField)(randomBytes_((0, modular_ts_1.getMinHashLength)(n)), n);
        },
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const arr = (0, utils_ts_1.ensureBytes)('key', item);
        const length = arr.length;
        const L = Fp.BYTES;
        const LC = L + 1; // e.g. 33 for 32
        const LU = 2 * L + 1; // e.g. 65 for 32
        if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
            return undefined;
        }
        else {
            return length === LC || length === LU;
        }
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicB) === false)
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function (bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function (bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,
    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash } = ecdsaOpts;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        validateSigVerOpts(opts);
        if (prehash)
            msgHash = (0, utils_ts_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE.precompute(8);
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        // Verify opts
        validateSigVerOpts(opts);
        const { lowS, prehash, format } = opts;
        // TODO: remove
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        if (format !== undefined && !['compact', 'der', 'js'].includes(format))
            throw new Error('format must be "compact", "der" or "js"');
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            !format &&
            typeof sg === 'object' &&
            sg !== null &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        let _sig = undefined;
        let P;
        // deduce signature format
        try {
            // if (format === 'js') {
            //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);
            // } else if (format === 'compact') {
            //   _sig = Signature.fromCompact(sg);
            // } else if (format === 'der') {
            //   _sig = Signature.fromDER(sg);
            // } else {
            //   throw new Error('invalid format');
            // }
            if (isObj) {
                if (format === undefined || format === 'js') {
                    _sig = new Signature(sg.r, sg.s);
                }
                else {
                    throw new Error('invalid format');
                }
            }
            if (isHex) {
                // TODO: remove this malleable check
                // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).
                // Since DER can also be 2*Fn.BYTES bytes, we check for it first.
                try {
                    if (format !== 'compact')
                        _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                }
                if (!_sig && format !== 'der')
                    _sig = Signature.fromCompact(sg);
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            return false;
        }
        if (!_sig)
            return false;
        if (lowS && _sig.hasHighS())
            return false;
        // todo: optional.hash => hash
        if (prehash)
            msgHash = ecdsaOpts.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = Fn.inv(s); // s^-1
        const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
        const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
            return false;
        const v = Fn.create(R.x); // v = r.x mod n
        return v === r;
    }
    // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?
    // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);
    return Object.freeze({
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        utils,
        Point,
        Signature,
    });
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength);
    const curveOpts = {
        Fp,
        Fn,
        allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        wrapPrivateKey: c.wrapPrivateKey,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hash: c.hash,
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, ecdsaOpts };
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    // TODO: remove
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, ecdsa) {
    return Object.assign({}, ecdsa, {
        ProjectivePoint: ecdsa.Point,
        CURVE: c,
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./abstract/curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const edwards_ts_1 = __webpack_require__(/*! ./abstract/edwards.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const montgomery_ts_1 = __webpack_require__(/*! ./abstract/montgomery.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
// 2n**255n - 19n
// Removing Fp.create() will still work, and is 10% faster on sign
//     a: Fp.create(BigInt(-1)),
// d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
// Finite field 2n**255n - 19n
// Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
const ed25519_CURVE = {
    p: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'),
    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),
    h: _8n,
    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),
    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),
    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),
    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),
};
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE.p;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
    const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P; // x^31
    const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;
    const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;
    const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;
    const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;
    const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;
    const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;
    const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// (-1) aka (a) aka 2^((p-1)/4)
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ed25519_CURVE.p;
    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v
    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx
    const root1 = x; // First root candidate
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}
/** Weird / bogus points, useful for debugging. */
exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
];
const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, undefined, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/v
    uvRatio,
}))();
/**
 * ed25519 curve with EdDSA signatures.
 * @example
 * import { ed25519 } from '@noble/curves/ed25519';
 * const priv = ed25519.utils.randomPrivateKey();
 * const pub = ed25519.getPublicKey(priv);
 * const msg = new TextEncoder().encode('hello');
 * const sig = ed25519.sign(msg, priv);
 * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
 * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
 */
exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
        throw new Error('Context is too big');
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
}))();
exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512,
})))();
/**
 * ECDH using curve25519 aka x25519.
 * @example
 * import { x25519 } from '@noble/curves/ed25519';
 * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';
 * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';
 * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases
 * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
 * x25519.getPublicKey(x25519.utils.randomPrivateKey());
 */
exports.x25519 = (() => {
    const P = ed25519_CURVE.p;
    return (0, montgomery_ts_1.montgomery)({
        P,
        type: 'x25519',
        powPminus2: (x) => {
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
    });
})();
/**
 * Converts ed25519 public key to x25519 public key. Uses formula:
 * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
 * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
 * @example
 *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
 *   const aPriv = x25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
 */
function edwardsToMontgomeryPub(edwardsPub) {
    const bpub = (0, utils_ts_1.ensureBytes)('pub', edwardsPub);
    const { y } = exports.ed25519.Point.fromHex(bpub);
    const _1n = BigInt(1);
    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
}
exports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
/**
 * Converts ed25519 secret key to x25519 secret key.
 * @example
 *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
 *   const aPriv = ed25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
 */
function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true); // batch division
    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)
}
exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha512,
}))();
exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
function aristp(other) {
    if (!(other instanceof RistPoint))
        throw new Error('RistrettoPoint expected');
}
// (-1) aka (a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// (ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / (a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/(number)
const invertSqrt = (number) => uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
/**
 * Computes Elligator map for Ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
 * the [website](https://ristretto.group/formulas/elligator.html).
 */
function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod = exports.ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
    if (!Ns_D_is_sq)
        s = s_; // 7
    if (!Ns_D_is_sq)
        c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
/**
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
class RistPoint {
    // Private property to discourage combining ExtendedPoint + RistrettoPoint
    // Always use Ristretto encoding/decoding instead.
    constructor(ep) {
        this.ep = ep;
    }
    static fromAffine(ap) {
        return new RistPoint(exports.ed25519.Point.fromAffine(ap));
    }
    /**
     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
     * The hash-to-group operation applies Elligator twice and adds the results.
     * **Note:** this is one-way map, there is no conversion from point to hash.
     * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
     * the [website](https://ristretto.group/formulas/elligator.html).
     * @param hex 64-byte output of a hash function
     */
    static hashToCurve(hex) {
        hex = (0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new RistPoint(R1.add(R2));
    }
    static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return this.fromHex(bytes);
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
        hex = (0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
        return new RistPoint(new exports.ed25519.Point(x, y, _1n, t));
    }
    static msm(points, scalars) {
        const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
        return (0, curve_ts_1.pippenger)(RistPoint, Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y)); // 1
        const u2 = mod(x * y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * t); // 6
        let D; // 7
        if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2; // 8
        }
        if ((0, modular_ts_1.isNegativeLE)(x * zInv, P))
            y = mod(-y); // 9
        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
        return (0, utils_ts_1.numberToBytesLE)(s, 32); // 11
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
        return this.toBytes();
    }
    toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
        return this.toHex();
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
        aristp(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = Fp.create;
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    add(other) {
        aristp(other);
        return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        aristp(other);
        return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return new RistPoint(this.ep.double());
    }
    negate() {
        return new RistPoint(this.ep.negate());
    }
}
/**
 * Wrapper over Edwards Point for ristretto255 from
 * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE)
        RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
    if (!RistPoint.ZERO)
        RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
    return RistPoint;
})();
/**
 * hash-to-curve for ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).
 */
const hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === 'string' ? (0, utils_js_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
};
exports.hashToRistretto255 = hashToRistretto255;
/** @deprecated */
exports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy
//# sourceMappingURL=ed25519.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p521_hasher = exports.secp521r1 = exports.p521 = exports.p384_hasher = exports.secp384r1 = exports.p384 = exports.p256_hasher = exports.secp256r1 = exports.p256 = void 0;
/**
 * Internal module for NIST P256, P384, P521 curves.
 * Do not use for now.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js");
// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n
// a = Fp256.create(BigInt('-3'));
const p256_CURVE = {
    p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
    h: BigInt(1),
    a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
    b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n
const p384_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'),
    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),
    h: BigInt(1),
    a: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'),
    b: BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'),
    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),
    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),
};
// p = 2n**521n - 1n
const p521_CURVE = {
    p: BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),
    h: BigInt(1),
    a: BigInt('0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'),
    b: BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'),
    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),
    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),
};
const Fp256 = (0, modular_ts_1.Field)(p256_CURVE.p);
const Fp384 = (0, modular_ts_1.Field)(p384_CURVE.p);
const Fp521 = (0, modular_ts_1.Field)(p521_CURVE.p);
function createSWU(field, opts) {
    const map = (0, weierstrass_ts_1.mapToCurveSimpleSWU)(field, opts);
    return (scalars) => map(scalars[0]);
}
/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */
exports.p256 = (0, _shortw_utils_ts_1.createCurve)({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha2_js_1.sha256);
/** Alias to p256. */
exports.secp256r1 = exports.p256;
/** Hashing / encoding to p256 points / field. RFC 9380 methods. */
exports.p256_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p256.Point, createSWU(Fp256, {
        A: p256_CURVE.a,
        B: p256_CURVE.b,
        Z: Fp256.create(BigInt('-10')),
    }), {
        DST: 'P256_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',
        p: p256_CURVE.p,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha2_js_1.sha256,
    });
})();
/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */
exports.p384 = (0, _shortw_utils_ts_1.createCurve)({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha2_js_1.sha384);
/** Alias to p384. */
exports.secp384r1 = exports.p384;
/** Hashing / encoding to p384 points / field. RFC 9380 methods. */
exports.p384_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p384.Point, createSWU(Fp384, {
        A: p384_CURVE.a,
        B: p384_CURVE.b,
        Z: Fp384.create(BigInt('-12')),
    }), {
        DST: 'P384_XMD:SHA-384_SSWU_RO_',
        encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',
        p: p384_CURVE.p,
        m: 1,
        k: 192,
        expand: 'xmd',
        hash: sha2_js_1.sha384,
    });
})();
/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */
exports.p521 = (0, _shortw_utils_ts_1.createCurve)({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha2_js_1.sha512);
/** Alias to p521. */
exports.secp521r1 = exports.p521;
/** Hashing / encoding to p521 points / field. RFC 9380 methods. */
exports.p521_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p521.Point, createSWU(Fp521, {
        A: p521_CURVE.a,
        B: p521_CURVE.b,
        Z: Fp521.create(BigInt('-4')),
    }), {
        DST: 'P521_XMD:SHA-512_SSWU_RO_',
        encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',
        p: p521_CURVE.p,
        m: 1,
        k: 256,
        expand: 'xmd',
        hash: sha2_js_1.sha512,
    });
})();
//# sourceMappingURL=nist.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256r1 = exports.p256 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p256 = nist_ts_1.p256;
exports.secp256r1 = nist_ts_1.p256;
exports.hashToCurve = (() => nist_ts_1.p256_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p256_hasher.encodeToCurve)();
//# sourceMappingURL=p256.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp384r1 = exports.p384 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p384 = nist_ts_1.p384;
exports.secp384r1 = nist_ts_1.p384;
exports.hashToCurve = (() => nist_ts_1.p384_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p384_hasher.encodeToCurve)();
/** @deprecated Use `import { p384_hasher } from "@noble/curves/nist"` module. */
//# sourceMappingURL=p384.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp521r1 = exports.p521 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p521 = nist_ts_1.p521;
exports.secp521r1 = nist_ts_1.p521;
exports.hashToCurve = (() => nist_ts_1.p521_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p521_hasher.encodeToCurve)();
//# sourceMappingURL=p521.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
var utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js");
const u64 = __webpack_require__(/*! ./_u64.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */
const _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js");
// prettier-ignore
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
exports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */
exports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */
exports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */
exports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */
exports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */
exports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */
exports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */
exports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
exports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */
exports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();
//# sourceMappingURL=sha3.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XOF256 = exports.XOF128 = exports.genCrystals = void 0;
/**
 * Internal methods for lattice-based ML-KEM and ML-DSA.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js");
// TODO: benchmark
function bitReversal(n, bits = 8) {
    const padded = n.toString(2).padStart(8, '0');
    const sliced = padded.slice(-bits).padStart(7, '0');
    const revrsd = sliced.split('').reverse().join('');
    return Number.parseInt(revrsd, 2);
}
const genCrystals = (opts) => {
    // isKyber: true means Kyber, false means Dilithium
    const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits, isKyber } = opts;
    const mod = (a, modulo = Q) => {
        const result = a % modulo | 0;
        return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;
    };
    // -(Q-1)/2 < a <= (Q-1)/2
    const smod = (a, modulo = Q) => {
        const r = mod(a, modulo) | 0;
        return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;
    };
    // Generate zettas
    function getZettas() {
        const out = newPoly(N);
        for (let i = 0; i < N; i++) {
            const b = bitReversal(i, brvBits);
            const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);
            out[i] = Number(p) | 0;
        }
        return out;
    }
    const nttZetas = getZettas();
    // Number-Theoretic Transform
    // Explained: https://electricdusk.com/ntt.html
    // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,
    // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.
    // TODO: there should be less ugly way to define this.
    const LEN1 = isKyber ? 128 : N;
    const LEN2 = isKyber ? 1 : 0;
    const NTT = {
        encode: (r) => {
            for (let k = 1, len = 128; len > LEN2; len >>= 1) {
                for (let start = 0; start < N; start += 2 * len) {
                    const zeta = nttZetas[k++];
                    for (let j = start; j < start + len; j++) {
                        const t = mod(zeta * r[j + len]);
                        r[j + len] = mod(r[j] - t) | 0;
                        r[j] = mod(r[j] + t) | 0;
                    }
                }
            }
            return r;
        },
        decode: (r) => {
            for (let k = LEN1 - 1, len = 1 + LEN2; len < LEN1 + LEN2; len <<= 1) {
                for (let start = 0; start < N; start += 2 * len) {
                    const zeta = nttZetas[k--];
                    for (let j = start; j < start + len; j++) {
                        const t = r[j];
                        r[j] = mod(t + r[j + len]);
                        r[j + len] = mod(zeta * (r[j + len] - t));
                    }
                }
            }
            for (let i = 0; i < r.length; i++)
                r[i] = mod(F * r[i]);
            return r;
        },
    };
    // Encode polynominal as bits
    const bitsCoder = (d, c) => {
        const mask = (0, utils_ts_1.getMask)(d);
        const bytesLen = d * (N / 8);
        return {
            bytesLen,
            encode: (poly) => {
                const r = new Uint8Array(bytesLen);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {
                    buf |= (c.encode(poly[i]) & mask) << bufLen;
                    bufLen += d;
                    for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
                        r[pos++] = buf & (0, utils_ts_1.getMask)(bufLen);
                }
                return r;
            },
            decode: (bytes) => {
                const r = newPoly(N);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {
                    buf |= bytes[i] << bufLen;
                    bufLen += 8;
                    for (; bufLen >= d; bufLen -= d, buf >>= d)
                        r[pos++] = c.decode(buf & mask);
                }
                return r;
            },
        };
    };
    return { mod, smod, nttZetas, NTT, bitsCoder };
};
exports.genCrystals = genCrystals;
const createXofShake = (shake) => (seed, blockLen) => {
    if (!blockLen)
        blockLen = shake.blockLen;
    // Optimizations that won't mater:
    // - cached seed update (two .update(), on start and on the end)
    // - another cache which cloned into working copy
    // Faster than multiple updates, since seed less than blockLen
    const _seed = new Uint8Array(seed.length + 2);
    _seed.set(seed);
    const seedLen = seed.length;
    const buf = new Uint8Array(blockLen); // == shake128.blockLen
    let h = shake.create({});
    let calls = 0;
    let xofs = 0;
    return {
        stats: () => ({ calls, xofs }),
        get: (x, y) => {
            _seed[seedLen + 0] = x;
            _seed[seedLen + 1] = y;
            h.destroy();
            h = shake.create({}).update(_seed);
            calls++;
            return () => {
                xofs++;
                return h.xofInto(buf);
            };
        },
        clean: () => {
            h.destroy();
            buf.fill(0);
            _seed.fill(0);
        },
    };
};
exports.XOF128 = createXofShake(sha3_1.shake128);
exports.XOF256 = createXofShake(sha3_1.shake256);
//# sourceMappingURL=_crystals.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ml_dsa87 = exports.ml_dsa65 = exports.ml_dsa44 = exports.PARAMS = void 0;
/**
 * ML-DSA: Module Lattice-based Digital Signature Algorithm from
 * [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd). A.k.a. CRYSTALS-Dilithium.
 *
 * Has similar internals to ML-KEM, but their keys and params are different.
 * Check out [official site](https://www.pq-crystals.org/dilithium/index.shtml),
 * [repo](https://github.com/pq-crystals/dilithium).
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const _crystals_ts_1 = __webpack_require__(/*! ./_crystals.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js");
// Constants
const N = 256;
// 2**23  2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints
const Q = 8380417;
const ROOT_OF_UNITY = 1753;
// f = 256**1 mod q, pow(256, -1, q) = 8347681 (python3)
const F = 8347681;
const D = 13;
// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.
const GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;
const GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;
/** Internal params for different versions of ML-DSA  */
// prettier-ignore
exports.PARAMS = {
    2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },
    3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },
    5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },
};
const newPoly = (n) => new Int32Array(n);
const { mod, smod, NTT, bitsCoder } = (0, _crystals_ts_1.genCrystals)({
    N,
    Q,
    F,
    ROOT_OF_UNITY,
    newPoly,
    isKyber: false,
    brvBits: 8,
});
const id = (n) => n;
const polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {
    encode: (i) => compress(verify(i)),
    decode: (i) => verify(compress(i)),
});
const polyAdd = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] + b[i]);
    return a;
};
const polySub = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] - b[i]);
    return a;
};
const polyShiftl = (p) => {
    for (let i = 0; i < N; i++)
        p[i] <<= D;
    return p;
};
const polyChknorm = (p, B) => {
    // Not very sure about this, but FIPS204 doesn't provide any function for that :(
    for (let i = 0; i < N; i++)
        if (Math.abs(smod(p[i])) >= B)
            return true;
    return false;
};
const MultiplyNTTs = (a, b) => {
    // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,
    // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,
    // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).
    // Barrett reduction is slower than mod :(
    const c = newPoly(N);
    for (let i = 0; i < a.length; i++)
        c[i] = mod(a[i] * b[i]);
    return c;
};
// Return poly in NTT representation
function RejNTTPoly(xof) {
    // Samples a polynomial  Tq.
    const r = newPoly(N);
    // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(
    for (let j = 0; j < N;) {
        const b = xof();
        if (b.length % 3)
            throw new Error('RejNTTPoly: unaligned block');
        for (let i = 0; j < N && i <= b.length - 3; i += 3) {
            const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes
            if (t < Q)
                r[j++] = t;
        }
    }
    return r;
}
function getDilithium(opts) {
    const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;
    const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256 } = opts;
    if (![2, 4].includes(ETA))
        throw new Error('Wrong ETA');
    if (![1 << 17, 1 << 19].includes(GAMMA1))
        throw new Error('Wrong GAMMA1');
    if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))
        throw new Error('Wrong GAMMA2');
    const BETA = TAU * ETA;
    const decompose = (r) => {
        // Decomposes r into (r1, r0) such that r  r1(22) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 * GAMMA2) | 0;
        if (rPlus - r0 === Q - 1)
            return { r1: 0 | 0, r0: (r0 - 1) | 0 };
        const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;
        return { r1, r0 }; // r1 = HighBits, r0 = LowBits
    };
    const HighBits = (r) => decompose(r).r1;
    const LowBits = (r) => decompose(r).r0;
    const MakeHint = (z, r) => {
        // Compute hint bit indicating whether adding z to r alters the high bits of r.
        // From dilithium code
        const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;
        // from FIPS204:
        // // const r1 = HighBits(r);
        // // const v1 = HighBits(r + z);
        // // const res1 = +(r1 !== v1);
        // But they return different results! However, decompose is same.
        // So, either there is a bug in Dilithium ref implementation or in FIPS204.
        // For now, lets use dilithium one, so test vectors can be passed.
        // See
        // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints
        return res0;
    };
    const UseHint = (h, r) => {
        // Returns the high bits of r adjusted according to hint h
        const m = Math.floor((Q - 1) / (2 * GAMMA2));
        const { r1, r0 } = decompose(r);
        // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m
        // 4: if h = 1 and r0  0 return (r1  1) mod m
        if (h === 1)
            return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;
        return r1 | 0;
    };
    const Power2Round = (r) => {
        // Decomposes r into (r1, r0) such that r  r1*(2**d) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 ** D) | 0;
        return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };
    };
    const hintCoder = {
        bytesLen: OMEGA + K,
        encode: (h) => {
            if (h === false)
                throw new Error('hint.encode: hint is false'); // should never happen
            const res = new Uint8Array(OMEGA + K);
            for (let i = 0, k = 0; i < K; i++) {
                for (let j = 0; j < N; j++)
                    if (h[i][j] !== 0)
                        res[k++] = j;
                res[OMEGA + i] = k;
            }
            return res;
        },
        decode: (buf) => {
            const h = [];
            let k = 0;
            for (let i = 0; i < K; i++) {
                const hi = newPoly(N);
                if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA)
                    return false;
                for (let j = k; j < buf[OMEGA + i]; j++) {
                    if (j > k && buf[j] <= buf[j - 1])
                        return false;
                    hi[buf[j]] = 1;
                }
                k = buf[OMEGA + i];
                h.push(hi);
            }
            for (let j = k; j < OMEGA; j++)
                if (buf[j] !== 0)
                    return false;
            return h;
        },
    };
    const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i) => ETA - i, (i) => {
        if (!(-ETA <= i && i <= ETA))
            throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);
        return i;
    });
    const T0Coder = polyCoder(13, (i) => (1 << (D - 1)) - i);
    const T1Coder = polyCoder(10);
    // Requires smod. Need to fix!
    const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i) => smod(GAMMA1 - i));
    const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);
    const W1Vec = (0, utils_ts_1.vecCoder)(W1Coder, K);
    // Main structures
    const publicCoder = (0, utils_ts_1.splitCoder)(32, (0, utils_ts_1.vecCoder)(T1Coder, K));
    const secretCoder = (0, utils_ts_1.splitCoder)(32, 32, TR_BYTES, (0, utils_ts_1.vecCoder)(ETACoder, L), (0, utils_ts_1.vecCoder)(ETACoder, K), (0, utils_ts_1.vecCoder)(T0Coder, K));
    const sigCoder = (0, utils_ts_1.splitCoder)(C_TILDE_BYTES, (0, utils_ts_1.vecCoder)(ZCoder, L), hintCoder);
    const CoefFromHalfByte = ETA === 2
        ? (n) => (n < 15 ? 2 - (n % 5) : false)
        : (n) => (n < 9 ? 4 - n : false);
    // Return poly in NTT representation
    function RejBoundedPoly(xof) {
        // Samples an element a  Rq with coeffcients in [, ] computed via rejection sampling from .
        const r = newPoly(N);
        for (let j = 0; j < N;) {
            const b = xof();
            for (let i = 0; j < N && i < b.length; i += 1) {
                // half byte. Should be superfast with vector instructions. But very slow with js :(
                const d1 = CoefFromHalfByte(b[i] & 0x0f);
                const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);
                if (d1 !== false)
                    r[j++] = d1;
                if (j < N && d2 !== false)
                    r[j++] = d2;
            }
        }
        return r;
    }
    const SampleInBall = (seed) => {
        // Samples a polynomial c  Rq with coeffcients from {1, 0, 1} and Hamming weight 
        const pre = newPoly(N);
        const s = sha3_1.shake256.create({}).update(seed);
        const buf = new Uint8Array(sha3_1.shake256.blockLen);
        s.xofInto(buf);
        const masks = buf.slice(0, 8);
        for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {
            let b = i + 1;
            for (; b > i;) {
                b = buf[pos++];
                if (pos < sha3_1.shake256.blockLen)
                    continue;
                s.xofInto(buf);
                pos = 0;
            }
            pre[i] = pre[b];
            pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);
            if (maskBit >= 8) {
                maskPos++;
                maskBit = 0;
            }
        }
        return pre;
    };
    const polyPowerRound = (p) => {
        const res0 = newPoly(N);
        const res1 = newPoly(N);
        for (let i = 0; i < p.length; i++) {
            const { r0, r1 } = Power2Round(p[i]);
            res0[i] = r0;
            res1[i] = r1;
        }
        return { r0: res0, r1: res1 };
    };
    const polyUseHint = (u, h) => {
        for (let i = 0; i < N; i++)
            u[i] = UseHint(h[i], u[i]);
        return u;
    };
    const polyMakeHint = (a, b) => {
        const v = newPoly(N);
        let cnt = 0;
        for (let i = 0; i < N; i++) {
            const h = MakeHint(a[i], b[i]);
            v[i] = h;
            cnt += h;
        }
        return { v, cnt };
    };
    const signRandBytes = 32;
    const seedCoder = (0, utils_ts_1.splitCoder)(32, 64, 32);
    // API & argument positions are exactly as in FIPS204.
    const internal = {
        signRandBytes,
        keygen: (seed) => {
            // H(||IntegerToBytes(, 1)||IntegerToBytes(, 1), 128) 2:  expand seed
            const seedDst = new Uint8Array(32 + 2);
            const randSeed = seed === undefined;
            if (randSeed)
                seed = (0, utils_ts_1.randomBytes)(32);
            (0, utils_ts_1.ensureBytes)(seed, 32);
            seedDst.set(seed);
            if (randSeed)
                seed.fill(0);
            seedDst[32] = K;
            seedDst[33] = L;
            const [rho, rhoPrime, K_] = seedCoder.decode((0, sha3_1.shake256)(seedDst, { dkLen: seedCoder.bytesLen }));
            const xofPrime = XOF256(rhoPrime);
            const s1 = [];
            for (let i = 0; i < L; i++)
                s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s2 = [];
            for (let i = L; i < L + K; i++)
                s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s1Hat = s1.map((i) => NTT.encode(i.slice()));
            const t0 = [];
            const t1 = [];
            const xof = XOF128(rho);
            const t = newPoly(N);
            for (let i = 0; i < K; i++) {
                // t  NTT1(A*NTT(s1)) + s2
                t.fill(0); // don't-reallocate
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // super slow!
                    polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));
                }
                NTT.decode(t);
                const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0)  Power2Round(t, d)
                t0.push(r0);
                t1.push(r1);
            }
            const publicKey = publicCoder.encode([rho, t1]); // pk  pkEncode(, t1)
            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // tr  H(BytesToBits(pk), 512)
            const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk  skEncode(, K,tr, s1, s2, t0)
            xof.clean();
            xofPrime.clean();
            // STATS
            // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }
            // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }
            (0, utils_ts_1.cleanBytes)(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);
            return { publicKey, secretKey };
        },
        // NOTE: random is optional.
        sign: (secretKey, msg, random, externalMu = false) => {
            // This part can be pre-cached per secretKey, but there is only minor performance improvement,
            // since we re-use a lot of variables to computation.
            const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (, K,tr, s1, s2, t0)  skDecode(sk)
            // Cache matrix to avoid re-compute later
            const A = []; // A  ExpandA()
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const pv = [];
                for (let j = 0; j < L; j++)
                    pv.push(RejNTTPoly(xof.get(j, i)));
                A.push(pv);
            }
            xof.clean();
            for (let i = 0; i < L; i++)
                NTT.encode(s1[i]); // s1  NTT(s1)
            for (let i = 0; i < K; i++) {
                NTT.encode(s2[i]); // s2  NTT(s2)
                NTT.encode(t0[i]); // t0  NTT(t0)
            }
            // This part is per msg
            const mu = externalMu
                ? msg
                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6:   H(tr||M, 512)  Compute message representative 
            // Compute private random seed
            const rnd = random ? random : new Uint8Array(32);
            (0, utils_ts_1.ensureBytes)(rnd);
            const rhoprime = sha3_1.shake256
                .create({ dkLen: CRH_BYTES })
                .update(_K)
                .update(rnd)
                .update(mu)
                .digest(); //  H(K||rnd||, 512)
            (0, utils_ts_1.ensureBytes)(rhoprime, CRH_BYTES);
            const x256 = XOF256(rhoprime, ZCoder.bytesLen);
            //  Rejection sampling loop
            main_loop: for (let kappa = 0;;) {
                const y = [];
                // y  ExpandMask( , )
                for (let i = 0; i < L; i++, kappa++)
                    y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));
                const z = y.map((i) => NTT.encode(i.slice()));
                const w = [];
                for (let i = 0; i < K; i++) {
                    // w  NTT1(A  NTT(y))
                    const wi = newPoly(N);
                    for (let j = 0; j < L; j++)
                        polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));
                    NTT.decode(wi);
                    w.push(wi);
                }
                const w1 = w.map((j) => j.map(HighBits)); // w1  HighBits(w)
                // Commitment hash: c {0, 1 2 }  H(||w1Encode(w1), 2)
                const cTilde = sha3_1.shake256
                    .create({ dkLen: C_TILDE_BYTES })
                    .update(mu)
                    .update(W1Vec.encode(w1))
                    .digest();
                // Verifers challenge
                const cHat = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1); c  NTT(c)
                // cs1  NTT1(c s1)
                const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));
                for (let i = 0; i < L; i++) {
                    polyAdd(NTT.decode(cs1[i]), y[i]); // z  y + cs1
                    if (polyChknorm(cs1[i], GAMMA1 - BETA))
                        continue main_loop; // ||z||  1  
                }
                // cs1 is now z ( Signers response)
                let cnt = 0;
                const h = [];
                for (let i = 0; i < K; i++) {
                    const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // cs2  NTT1(c s2)
                    const r0 = polySub(w[i], cs2).map(LowBits); // r0  LowBits(w  cs2)
                    if (polyChknorm(r0, GAMMA2 - BETA))
                        continue main_loop; // ||r0||  2  
                    const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // ct0  NTT1(c t0)
                    if (polyChknorm(ct0, GAMMA2))
                        continue main_loop;
                    polyAdd(r0, ct0);
                    //  Signers hint
                    const hint = polyMakeHint(r0, w1[i]); // h  MakeHint(ct0, w cs2 + ct0)
                    h.push(hint.v);
                    cnt += hint.cnt;
                }
                if (cnt > OMEGA)
                    continue; // the number of 1s in h is greater than 
                x256.clean();
                const res = sigCoder.encode([cTilde, cs1, h]); //   sigEncode(c, z modq, h)
                // rho, _K, tr is subarray of secretKey, cannot clean.
                (0, utils_ts_1.cleanBytes)(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);
                return res;
            }
            // @ts-ignore
            throw new Error('Unreachable code path reached, report this error');
        },
        verify: (publicKey, msg, sig, externalMu = false) => {
            // ML-DSA.Verify(pk, M, ): Verifes a signature  for a message M.
            const [rho, t1] = publicCoder.decode(publicKey); // (, t1)  pkDecode(pk)
            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // 6: tr  H(BytesToBits(pk), 512)
            if (sig.length !== sigCoder.bytesLen)
                return false; // return false instead of exception
            const [cTilde, z, h] = sigCoder.decode(sig); // (c, z, h)  sigDecode(),  Signers commitment hash c , response z and hint
            if (h === false)
                return false; // if h =  then return false
            for (let i = 0; i < L; i++)
                if (polyChknorm(z[i], GAMMA1 - BETA))
                    return false;
            const mu = externalMu
                ? msg
                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7:   H(tr||M, 512)
            // Compute verifers challenge from c
            const c = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1)
            const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)
            for (let i = 0; i < L; i++)
                NTT.encode(zNtt[i]);
            const wTick1 = [];
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)
                const Az = newPoly(N); // // A * z
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace
                    polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));
                }
                // wApprox = A*z - c*t1 * (2**d)
                const wApprox = NTT.decode(polySub(Az, ct12d));
                // Reconstruction of signers commitment
                wTick1.push(polyUseHint(wApprox, h[i])); // w   UseHint(h, w'approx )
            }
            xof.clean();
            // c H (||w1Encode(w1), 2),  Hash it; this should match c
            const c2 = sha3_1.shake256
                .create({ dkLen: C_TILDE_BYTES })
                .update(mu)
                .update(W1Vec.encode(wTick1))
                .digest();
            // Additional checks in FIPS-204:
            // [[ ||z|| < 1   ]] and [[c  = c]] and [[number of 1s in h is  ]]
            for (const t of h) {
                const sum = t.reduce((acc, i) => acc + i, 0);
                if (!(sum <= OMEGA))
                    return false;
            }
            for (const t of z)
                if (polyChknorm(t, GAMMA1 - BETA))
                    return false;
            return (0, utils_ts_1.equalBytes)(cTilde, c2);
        },
    };
    return {
        internal,
        keygen: internal.keygen,
        signRandBytes: internal.signRandBytes,
        sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {
            const M = (0, utils_ts_1.getMessage)(msg, ctx);
            const res = internal.sign(secretKey, M, random);
            M.fill(0);
            return res;
        },
        verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {
            return internal.verify(publicKey, (0, utils_ts_1.getMessage)(msg, ctx), sig);
        },
        prehash: (hashName) => ({
            sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {
                const M = (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx);
                const res = internal.sign(secretKey, M, random);
                M.fill(0);
                return res;
            },
            verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {
                return internal.verify(publicKey, (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx), sig);
            },
        }),
    };
}
/** ML-DSA-44 for 128-bit security level. Not recommended after 2030, as per ASD. */
exports.ml_dsa44 = getDilithium({
    ...exports.PARAMS[2],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 32,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
/** ML-DSA-65 for 192-bit security level. Not recommended after 2030, as per ASD. */
exports.ml_dsa65 = getDilithium({
    ...exports.PARAMS[3],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 48,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
/** ML-DSA-87 for 256-bit security level. OK after 2030, as per ASD. */
exports.ml_dsa87 = getDilithium({
    ...exports.PARAMS[5],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 64,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
//# sourceMappingURL=ml-dsa.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EMPTY = exports.utf8ToBytes = exports.concatBytes = exports.randomBytes = exports.ensureBytes = void 0;
exports.equalBytes = equalBytes;
exports.splitCoder = splitCoder;
exports.vecCoder = vecCoder;
exports.cleanBytes = cleanBytes;
exports.getMask = getMask;
exports.getMessage = getMessage;
exports.getMessagePrehash = getMessagePrehash;
/**
 * Utilities for hex, bytearray and number handling.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_1.concatBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_1.utf8ToBytes; } }));
exports.ensureBytes = utils_1.abytes;
exports.randomBytes = utils_1.randomBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
function splitCoder(...lengths) {
    const getLength = (c) => (typeof c === 'number' ? c : c.bytesLen);
    const bytesLen = lengths.reduce((sum, a) => sum + getLength(a), 0);
    return {
        bytesLen,
        encode: (bufs) => {
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < lengths.length; i++) {
                const c = lengths[i];
                const l = getLength(c);
                const b = typeof c === 'number' ? bufs[i] : c.encode(bufs[i]);
                (0, exports.ensureBytes)(b, l);
                res.set(b, pos);
                if (typeof c !== 'number')
                    b.fill(0); // clean
                pos += l;
            }
            return res;
        },
        decode: (buf) => {
            (0, exports.ensureBytes)(buf, bytesLen);
            const res = [];
            for (const c of lengths) {
                const l = getLength(c);
                const b = buf.subarray(0, l);
                res.push(typeof c === 'number' ? b : c.decode(b));
                buf = buf.subarray(l);
            }
            return res;
        },
    };
}
// nano-packed.array (fixed size)
function vecCoder(c, vecLen) {
    const bytesLen = vecLen * c.bytesLen;
    return {
        bytesLen,
        encode: (u) => {
            if (u.length !== vecLen)
                throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < u.length; i++) {
                const b = c.encode(u[i]);
                res.set(b, pos);
                b.fill(0); // clean
                pos += b.length;
            }
            return res;
        },
        decode: (a) => {
            (0, exports.ensureBytes)(a, bytesLen);
            const r = [];
            for (let i = 0; i < a.length; i += c.bytesLen)
                r.push(c.decode(a.subarray(i, i + c.bytesLen)));
            return r;
        },
    };
}
// cleanBytes(new Uint8Array(), [new Uint16Array(), new Uint32Array()])
function cleanBytes(...list) {
    for (const t of list) {
        if (Array.isArray(t))
            for (const b of t)
                b.fill(0);
        else
            t.fill(0);
    }
}
function getMask(bits) {
    return (1 << bits) - 1; // 4 -> 0b1111
}
exports.EMPTY = new Uint8Array(0);
function getMessage(msg, ctx = exports.EMPTY) {
    (0, exports.ensureBytes)(msg);
    (0, exports.ensureBytes)(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    return (0, utils_1.concatBytes)(new Uint8Array([0, ctx.length]), ctx, msg);
}
// OIDS from https://csrc.nist.gov/projects/computer-security-objects-register/algorithm-registration
// TODO: maybe add 'OID' property to hashes themselves to improve tree-shaking?
const HASHES = {
    'SHA2-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040201'), hash: sha2_1.sha256 },
    'SHA2-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040202'), hash: sha2_1.sha384 },
    'SHA2-512': { oid: (0, utils_1.hexToBytes)('0609608648016503040203'), hash: sha2_1.sha512 },
    'SHA2-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040204'), hash: sha2_1.sha224 },
    'SHA2-512/224': { oid: (0, utils_1.hexToBytes)('0609608648016503040205'), hash: sha2_1.sha512_224 },
    'SHA2-512/256': { oid: (0, utils_1.hexToBytes)('0609608648016503040206'), hash: sha2_1.sha512_256 },
    'SHA3-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040207'), hash: sha3_1.sha3_224 },
    'SHA3-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040208'), hash: sha3_1.sha3_256 },
    'SHA3-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040209'), hash: sha3_1.sha3_384 },
    'SHA3-512': { oid: (0, utils_1.hexToBytes)('060960864801650304020A'), hash: sha3_1.sha3_512 },
    'SHAKE-128': {
        oid: (0, utils_1.hexToBytes)('060960864801650304020B'),
        hash: (msg) => (0, sha3_1.shake128)(msg, { dkLen: 32 }),
    },
    'SHAKE-256': {
        oid: (0, utils_1.hexToBytes)('060960864801650304020C'),
        hash: (msg) => (0, sha3_1.shake256)(msg, { dkLen: 64 }),
    },
};
function getMessagePrehash(hashName, msg, ctx = exports.EMPTY) {
    (0, exports.ensureBytes)(msg);
    (0, exports.ensureBytes)(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    if (!HASHES[hashName])
        throw new Error('unknown hash: ' + hashName);
    const { oid, hash } = HASHES[hashName];
    const hashed = hash(msg);
    return (0, utils_1.concatBytes)(new Uint8Array([1, ctx.length]), ctx, oid, hashed);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/armor.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/armor.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DearmorStream = exports.ArmorStream = exports.MessageType = exports.debug = void 0;
exports.armor = armor;
exports.dearmor = dearmor;
exports.encodeBlock = encodeBlock;
exports.decodeBlock = decodeBlock;
exports.efficientCharsSizes = efficientCharsSizes;
const message_header_1 = __webpack_require__(/*! ./message-header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js");
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const lodash_chunk_1 = __importDefault(__webpack_require__(/*! lodash.chunk */ "./node_modules/.pnpm/lodash.chunk@4.2.0/node_modules/lodash.chunk/index.js"));
exports.debug = false;
/** The Base62 alphabet */
const BASE62_ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/** The Base64 alphabet */
const BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
/** The Base85 alphabet */
const BASE85_ALPHABET = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu";
// Also accept message type "MESSAGE"
// (should really be "ENCRYPTED MESSAGE", "SIGNED MESSAGE" or "DETACHED SIGNATURE")
const HEADER_REGEX = /^[>\n\r\t ]*BEGIN[>\n\r\t ]+(([a-zA-Z0-9]+)[>\n\r\t ]+)?SALTPACK[>\n\r\t ]+(MESSAGE|ENCRYPTED[>\n\r\t ]+MESSAGE|SIGNED[>\n\r\t ]+MESSAGE|DETACHED[>\n\r\t ]+SIGNATURE)[>\n\r\t ]*$/;
const FOOTER_REGEX = /^[>\n\r\t ]*END[>\n\r\t ]+(([a-zA-Z0-9]+)[>\n\r\t ]+)?SALTPACK[>\n\r\t ]+(MESSAGE|ENCRYPTED[>\n\r\t ]+MESSAGE|SIGNED[>\n\r\t ]+MESSAGE|DETACHED[>\n\r\t ]+SIGNATURE)[>\n\r\t ]*$/;
var MessageType;
(function (MessageType) {
    MessageType["ENCRYPTED_MESSAGE"] = "ENCRYPTED MESSAGE";
    MessageType["SIGNED_MESSAGE"] = "SIGNED MESSAGE";
    MessageType["DETACHED_SIGNATURE"] = "DETACHED SIGNATURE";
    /** @private */
    // MESSAGE = 'MESSAGE',
})(MessageType || (exports.MessageType = MessageType = {}));
function modeToStringType(type) {
    switch (type) {
        case message_header_1.MessageType.ENCRYPTION:
            return MessageType.ENCRYPTED_MESSAGE;
        case message_header_1.MessageType.ATTACHED_SIGNING:
            return MessageType.SIGNED_MESSAGE;
        case message_header_1.MessageType.DETACHED_SIGNING:
            return MessageType.DETACHED_SIGNATURE;
        case message_header_1.MessageType.SIGNCRYPTION:
            return MessageType.ENCRYPTED_MESSAGE;
        default:
            return "MESSAGE";
    }
}
/** The default options used by the armor/dearmor methods. */
const DEFAULT_OPTIONS = {
    alphabet: BASE62_ALPHABET,
    block_size: 32,
    char_block_size: 43,
    raw: false,
    shift: false,
    message_type: "MESSAGE",
    app_name: null, // Application name (e.g. "KEYBASE")
};
/** Return the index of the specified +char+ in +alphabet+, raising an appropriate error if it is not found. */
function getCharIndex(alphabet, char) {
    const rval = alphabet.indexOf(char);
    if (rval === -1) {
        throw new Error("Could not find " + char + " in alphabet " + alphabet);
    }
    return rval;
}
/** Return the minimum number of characters needed to encode +bytes_size+ bytes using the given +alphabet+. */
function characterBlockSize(alphabet_size, bytes_size) {
    return Math.ceil((8 * bytes_size) / Math.log2(alphabet_size));
}
/** Return the maximum number of bytes needed to encode +chars_size+ characters using the given +alphabet+. */
function maxBytesSize(alphabet_size, chars_size) {
    return Math.floor((Math.log2(alphabet_size) / 8) * chars_size);
}
/**
 * Return the number of bits left over after using an alphabet of the specified +alphabet_size+ to encode a
 * payload of +bytes_size+ with +chars_size+ characters.
 */
function extraBits(alphabet_size, chars_size, bytes_size) {
    const total_bits = Math.floor(Math.log2(alphabet_size) * chars_size);
    return total_bits - 8 * bytes_size;
}
function armor(input, _options) {
    const options = Object.assign({}, DEFAULT_OPTIONS, _options);
    if (typeof options.message_type === "number")
        options.message_type = modeToStringType(options.message_type);
    const chunks = (0, util_1.chunkBuffer)(input, options.block_size);
    let output = "";
    for (const chunk of chunks) {
        output += encodeBlock(chunk, options.alphabet, options.shift);
    }
    if (options.raw) {
        const out_chunks = (0, util_1.chunkString)(output, 43);
        return out_chunks.join(" ");
    }
    const word_chunks = (0, util_1.chunkString)(output, 15);
    const sentences = (0, lodash_chunk_1.default)(word_chunks, 200);
    const joined = sentences.map((words) => words.join(" ")).join("\n");
    const app = options.app_name ? " " + options.app_name : "";
    const header = "BEGIN" + app + " SALTPACK " + options.message_type + ". ";
    const footer = ". END" + app + " SALTPACK " + options.message_type + ".";
    return header + joined + footer;
}
class ArmorStream extends stream_1.Transform {
    constructor(options) {
        super();
        this.in_buffer = Buffer.alloc(0);
        this.out_buffer = "";
        this.words = 0;
        this.i = 0;
        this.armor_options = Object.assign({}, DEFAULT_OPTIONS, options);
        if (typeof this.armor_options.message_type === "number") {
            // @ts-expect-error
            this.armor_options.message_type = modeToStringType(this.armor_options.message_type);
        }
        const app = this.armor_options.app_name ? " " + this.armor_options.app_name : "";
        this.armor_header = "BEGIN" + app + " SALTPACK " + this.armor_options.message_type + ". ";
        this.armor_footer = ". END" + app + " SALTPACK " + this.armor_options.message_type + ".";
        if (!this.armor_options.raw) {
            this.push(this.armor_header);
        }
    }
    _transform(data, encoding, callback) {
        if (exports.debug)
            console.log("Processing chunk #%d: %O", this.i++, data);
        this.in_buffer = Buffer.concat([this.in_buffer, data]);
        while (this.in_buffer.length > this.armor_options.block_size) {
            const block = this.in_buffer.slice(0, this.armor_options.block_size);
            this.in_buffer = this.in_buffer.slice(this.armor_options.block_size);
            this.out_buffer += encodeBlock(block, this.armor_options.alphabet, this.armor_options.shift);
        }
        if (this.armor_options.raw) {
            while (this.out_buffer.length > 43) {
                this.push(this.out_buffer.substr(0, 43) + " ");
                this.out_buffer = this.out_buffer.substr(43);
            }
        }
        else {
            while (this.out_buffer.length > 15) {
                const word = this.out_buffer.substr(0, 15);
                this.out_buffer = this.out_buffer.substr(15);
                this.words++;
                if (this.words >= 200) {
                    this.push(word + "\n");
                    this.words = 0;
                }
                else {
                    this.push(word + " ");
                }
            }
        }
        callback();
    }
    _flush(callback) {
        if (this.in_buffer.length > 0) {
            this.out_buffer += encodeBlock(this.in_buffer, this.armor_options.alphabet, this.armor_options.shift);
            this.in_buffer = Buffer.alloc(0);
        }
        if (this.armor_options.raw) {
            while (this.out_buffer.length > 43) {
                this.push(this.out_buffer.substr(0, 43) + " ");
                this.out_buffer = this.out_buffer.substr(43);
            }
        }
        else {
            while (this.out_buffer.length > 15) {
                const word = this.out_buffer.substr(0, 15);
                this.out_buffer = this.out_buffer.substr(15);
                this.words++;
                if (this.words >= 200) {
                    this.push(word + "\n");
                    this.words = 0;
                }
                else {
                    this.push(word + " ");
                }
            }
        }
        this.push(this.out_buffer);
        if (!this.armor_options.raw) {
            this.push(this.armor_footer);
        }
        callback();
    }
}
exports.ArmorStream = ArmorStream;
function dearmor(input, _options) {
    var _a;
    const options = Object.assign({}, DEFAULT_OPTIONS, _options);
    let header, header_info = null, footer, remaining = null, match;
    if (!options.raw) {
        [header, input, footer, remaining] = input.split(".", 4);
        remaining = Buffer.from(remaining);
        if (!(match = header.match(HEADER_REGEX))) {
            throw new Error("Invalid header");
        }
        header_info = {
            message_type: match[3],
            app_name: (_a = match[2]) !== null && _a !== void 0 ? _a : null,
        };
        if (!(match = footer.match(FOOTER_REGEX))) {
            throw new Error("Invalid footer");
        }
        if (header_info.message_type !== match[3] || header_info.app_name != match[2]) {
            throw new Error("Footer doesn't match header");
        }
    }
    input = input.replace(/[>\n\r\t ]/g, "");
    const chunks = (0, util_1.chunkString)(input, options.char_block_size);
    const output_chunks = chunks.map((chunk) => decodeBlock(chunk, options.alphabet, options.shift));
    const output = Buffer.concat(output_chunks);
    return Object.assign(output, {
        remaining: remaining,
        header_info: header_info,
    });
}
class DearmorStream extends stream_1.Transform {
    get header() {
        if (this.armor_options.raw)
            throw new Error("Header isn't available when decoding raw armored data");
        if (!this.armor_header)
            throw new Error("Header hasn't been decoded yet");
        return this.armor_header;
    }
    get footer() {
        if (this.armor_options.raw)
            throw new Error("Footer isn't available when decoding raw armored data");
        if (!this.armor_footer)
            throw new Error("Footer hasn't been decoded yet");
        return this.armor_footer;
    }
    get info() {
        if (this.armor_options.raw)
            throw new Error("Header isn't available when decoding raw armored data");
        if (!this.armor_header_info)
            throw new Error("Header hasn't been decoded yet");
        return this.armor_header_info;
    }
    constructor(options) {
        super();
        this.in_buffer = Buffer.alloc(0);
        this.out_buffer = "";
        this.armor_header_info = null;
        this.armor_header = null;
        this.armor_footer = null;
        this.words = 0;
        this.i = 0;
        this.armor_options = Object.assign({}, DEFAULT_OPTIONS, options);
    }
    _transform(data, encoding, callback) {
        var _a;
        if (exports.debug)
            console.log("Processing chunk #%d: %O", this.i++, data);
        if (!this.armor_options.raw && this.armor_header === null) {
            this.in_buffer = Buffer.concat([this.in_buffer, data]);
            const index = this.in_buffer.indexOf(".");
            if (index === -1)
                return callback();
            this.armor_header = this.in_buffer.slice(0, index).toString();
            data = this.in_buffer.slice(index + 1);
            const header_match = this.armor_header.match(HEADER_REGEX);
            if (!header_match) {
                const err = new Error("Invalid header");
                callback(err);
                throw err;
            }
            this.armor_header_info = {
                message_type: header_match[3],
                app_name: (_a = header_match[2]) !== null && _a !== void 0 ? _a : null,
            };
            if (exports.debug)
                console.log("Read header: %s", this.armor_header);
        }
        if (!this.armor_options.raw && this.armor_footer !== null) {
            this.armor_footer += data.toString();
            const remaining_index = this.armor_footer.indexOf(".");
            if (remaining_index !== -1) {
                this.armor_footer = this.armor_footer.substr(0, remaining_index);
                return callback();
            }
        }
        if (!this.armor_options.raw && this.armor_footer === null) {
            const index = data.indexOf(".");
            if (index !== -1) {
                this.armor_footer = data.slice(index + 1).toString();
                data = data.slice(0, index);
                this.out_buffer = data.toString().replace(/[>\n\r\t ]/g, "");
                const remaining_index = this.armor_footer.indexOf(".");
                if (remaining_index !== -1) {
                    this.armor_footer = this.armor_footer.substr(0, remaining_index);
                    return callback();
                }
                return callback();
            }
        }
        if (this.armor_options.raw || this.armor_footer === null) {
            this.out_buffer += data.toString().replace(/[>\n\r\t ]/g, "");
            while (this.out_buffer.length > this.armor_options.char_block_size) {
                const block = this.out_buffer.substr(0, this.armor_options.char_block_size);
                this.out_buffer = this.out_buffer.substr(this.armor_options.char_block_size);
                this.push(decodeBlock(block, this.armor_options.alphabet, this.armor_options.shift));
            }
        }
        callback();
    }
    _flush(callback) {
        var _a;
        while (this.out_buffer.length > this.armor_options.char_block_size) {
            const block = this.out_buffer.substr(0, this.armor_options.char_block_size);
            this.out_buffer = this.out_buffer.substr(this.armor_options.char_block_size);
            this.push(decodeBlock(block, this.armor_options.alphabet, this.armor_options.shift));
        }
        if (this.out_buffer.length > 0) {
            this.push(decodeBlock(this.out_buffer, this.armor_options.alphabet, this.armor_options.shift));
            this.out_buffer = "";
        }
        if (!this.armor_options.raw && this.armor_footer === null) {
            const err = new Error("Input stream doesn't contain a valid header and footer");
            callback(err);
            throw err;
        }
        if (!this.armor_options.raw) {
            const footer_match = (_a = this.armor_footer) === null || _a === void 0 ? void 0 : _a.match(FOOTER_REGEX);
            if (!footer_match) {
                throw new Error("Invalid footer");
            }
            if (this.armor_header_info.message_type !== footer_match[3] || this.armor_header_info.app_name != footer_match[2]) {
                throw new Error("Footer doesn't match header");
            }
            if (exports.debug)
                console.log("Read footer: %s", this.armor_footer);
        }
        callback();
    }
}
exports.DearmorStream = DearmorStream;
/**
 * Encode a single block of ascii-armored output from +bytes_block+ using the specified +alphabet+ and +shift+.
 */
function encodeBlock(bytes_block, alphabet = BASE62_ALPHABET, shift = false) {
    const block_size = characterBlockSize(alphabet.length, bytes_block.length);
    const extra = extraBits(alphabet.length, block_size, bytes_block.length);
    // Convert the bytes into an integer, big-endian
    let bytes_int = BigInt("0x" + bytes_block.toString("hex"));
    if (shift) {
        bytes_int <<= BigInt(extra);
    }
    const alphabet_size = BigInt(alphabet.length);
    const places = [];
    for (let i = 0; i < block_size; i++) {
        const rem = parseInt((bytes_int % alphabet_size).toString());
        places.unshift(rem);
        bytes_int = bytes_int / alphabet_size;
    }
    return places.map((i) => alphabet[i]).join("");
}
/**
 * Decode the specified ascii-armored +chars_block+ using the specified +alphabet+ and +shift+.
 */
function decodeBlock(chars_block, alphabet = BASE62_ALPHABET, shift = false) {
    const bytes_size = maxBytesSize(alphabet.length, chars_block.length);
    const expected_block_size = characterBlockSize(alphabet.length, bytes_size);
    if (chars_block.length !== expected_block_size) {
        throw new TypeError("Illegal block size " + chars_block.length + ", expected " + expected_block_size);
    }
    const extra = extraBits(alphabet.length, chars_block.length, bytes_size);
    let bytes_int = BigInt(getCharIndex(alphabet, chars_block[0]));
    for (let i = 1; i < chars_block.length; i++) {
        bytes_int = bytes_int * BigInt(alphabet.length);
        bytes_int = bytes_int + BigInt(getCharIndex(alphabet, chars_block[i]));
    }
    if (shift) {
        bytes_int >>= BigInt(extra);
    }
    return Buffer.from(bytes_int
        .toString(16)
        .padStart(bytes_size * 2, "0")
        .slice(0, bytes_size * 2), "hex");
}
function efficientCharsSizes(alphabet_size, chars_size_upper_bound = 50) {
    const out = [];
    let max_efficiency = 0;
    for (let chars_size = 1; chars_size < chars_size_upper_bound; chars_size++) {
        const bytes_size = maxBytesSize(alphabet_size, chars_size);
        const efficiency = bytes_size / chars_size;
        if (efficiency > max_efficiency) {
            out.push([chars_size, bytes_size, efficiency]);
            max_efficiency = efficiency;
        }
    }
    return out;
}
//# sourceMappingURL=armor.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/header.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/header.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const message_header_1 = __importStar(__webpack_require__(/*! ../message-header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js"));
const recipient_1 = __importDefault(__webpack_require__(/*! ./recipient */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/recipient.js"));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
class EncryptedMessageHeader extends message_header_1.default {
    constructor(public_key, sender_secretbox, recipients) {
        super();
        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {
            throw new TypeError("public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(sender_secretbox) || sender_secretbox.length !== 48) {
            throw new TypeError("sender_secretbox must be a 48 byte Uint8Array");
        }
        this.public_key = public_key;
        this.sender_secretbox = sender_secretbox;
        this.recipients = recipients;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded outer header data */
    get encoded() {
        return this.encoded_data[1];
    }
    /** The SHA512 hash of the MessagePack encoded inner header data */
    get hash() {
        return this.encoded_data[0];
    }
    static create(public_key, payload_key, sender_public_key, recipients) {
        if (!(0, util_1.isBufferOrUint8Array)(sender_public_key) || sender_public_key.length !== 32) {
            throw new TypeError("sender_public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(payload_key) || payload_key.length !== 32) {
            throw new TypeError("payload_key must be a 32 byte Uint8Array");
        }
        // 3. Encrypt the sender's long-term public key using crypto_secretbox with the payload key and the nonce saltpack_sender_key_sbox, to create the sender secretbox.
        // const sender_secretbox = sodium_crypto_secretbox($sender_public_key, self::SENDER_KEY_SECRETBOX_NONCE, $payload_key);
        const sender_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(sender_public_key), Uint8Array.from(EncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));
        return new this(public_key, sender_secretbox, recipients);
    }
    encode() {
        return EncryptedMessageHeader.encodeHeader(this.public_key, this.sender_secretbox, this.recipients);
    }
    static encodeHeader(public_key, sender, recipients) {
        const data = [
            "saltpack",
            [2, 0],
            message_header_1.MessageType.ENCRYPTION,
            public_key,
            sender,
            recipients.map((recipient) => {
                // [
                //     recipient public key,
                //     payload key box,
                // ]
                return [recipient.anonymous ? null : recipient.public_key, recipient.encrypted_payload_key];
            }),
        ];
        const encoded = (0, msgpack_1.encode)(data);
        const header_hash = Buffer.from(sha2_1.sha512.create().update(encoded).digest());
        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];
    }
    static decode(encoded, unwrapped = false) {
        const [header_hash, data] = super.decode1(encoded, unwrapped);
        if (data[2] !== message_header_1.MessageType.ENCRYPTION)
            throw new Error("Invalid data");
        const [, , , public_key, sender_secretbox, recipients] = data;
        if (!(recipients instanceof Array))
            throw new Error("Invalid data");
        return new this(public_key, sender_secretbox, recipients.map((recipient, index) => {
            if (!(recipient instanceof Array) || recipient.length < 2) {
                throw new TypeError("Invalid data");
            }
            return recipient_1.default.from(recipient[0], recipient[1], index);
        }));
    }
    /**
     * Decrypts and returns the payload key and recipient.
     */
    decryptPayloadKey(keypair) {
        // 5. Precompute the ephemeral shared secret using crypto_box_beforenm with the ephemeral public key and
        // the recipient's private key.
        const shared_secret = tweetnacl_1.box.before(this.public_key, keypair.secretKey);
        // 6. Try to open each of the payload key boxes in the recipients list using crypto_box_open_afternm,
        // the precomputed secret from #5, and the nonce saltpack_recipsbXXXXXXXX. XXXXXXXX is 8-byte big-endian
        // unsigned recipient index, where the first recipient is index 0. Successfully opening one gives the
        // payload key.
        for (const recipient of this.recipients) {
            if (recipient.public_key) {
                // If the recipient's public key is shown in the recipients list (that is, if the recipient is
                // not anonymous), clients may skip all the other payload key boxes in step #6.
                if (!Buffer.from(recipient.public_key).equals(keypair.publicKey))
                    continue;
            }
            const payload_key = recipient.decryptPayloadKey(this.public_key, keypair.secretKey, shared_secret);
            if (!payload_key)
                continue;
            recipient.setPublicKey(keypair.publicKey);
            return [payload_key, recipient];
        }
        throw new Error("keypair is not an intended recipient");
    }
    decryptSender(payload_key) {
        const sender_public_key = tweetnacl_1.secretbox.open(Uint8Array.from(this.sender_secretbox), Uint8Array.from(EncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));
        if (!sender_public_key) {
            throw new Error("Failed to decrypt sender public key");
        }
        return sender_public_key;
    }
}
EncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE = Buffer.from("saltpack_sender_key_sbox");
exports["default"] = EncryptedMessageHeader;
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/index.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecryptStream = exports.EncryptStream = void 0;
exports.debugSetKey = debugSetKey;
exports.debugSetKeypair = debugSetKeypair;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
const header_1 = __importDefault(__webpack_require__(/*! ./header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/header.js"));
const recipient_1 = __importDefault(__webpack_require__(/*! ./recipient */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/recipient.js"));
const payload_1 = __importDefault(__webpack_require__(/*! ./payload */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/payload.js"));
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const CHUNK_LENGTH = 1024 * 1024;
let debug = false;
let debug_fix_key = null;
let debug_fix_keypair = null;
function debugSetKey(key) {
    debug_fix_key = key;
}
function debugSetKeypair(keypair) {
    debug_fix_keypair = keypair;
}
function encrypt(data, keypair, recipients_keys) {
    return __awaiter(this, void 0, void 0, function* () {
        const chunks = (0, util_1.chunkBuffer)(data, CHUNK_LENGTH);
        // 1. Generate a random 32-byte payload key.
        const payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));
        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.
        const ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();
        keypair = keypair !== null && keypair !== void 0 ? keypair : ephemeral_keypair;
        const recipients = recipients_keys.map((key, index) => {
            return recipient_1.default.create(key, ephemeral_keypair.secretKey, payload_key, index);
        });
        const header = header_1.default.create(ephemeral_keypair.publicKey, payload_key, keypair.publicKey, recipients);
        for (const recipient of recipients) {
            recipient.generateMacKeyForSender(header.hash, ephemeral_keypair.secretKey, keypair.secretKey);
        }
        const payloads = [];
        for (const i in chunks) {
            const chunk = chunks[i];
            const final = chunks.length === parseInt(i) + 1;
            const payload = payload_1.default.create(header, payload_key, chunk, BigInt(i), final);
            payloads.push(payload);
        }
        return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);
    });
}
class EncryptStream extends stream_1.Transform {
    constructor(keypair, recipients_keys) {
        super();
        this.in_buffer = Buffer.alloc(0);
        this.payload_index = BigInt(0);
        this.i = 0;
        // 1. Generate a random 32-byte payload key.
        this.payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));
        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.
        this.ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();
        this.keypair = keypair !== null && keypair !== void 0 ? keypair : this.ephemeral_keypair;
        const recipients = recipients_keys.map((key, index) => {
            return recipient_1.default.create(key, this.ephemeral_keypair.secretKey, this.payload_key, index);
        });
        this.header = header_1.default.create(this.ephemeral_keypair.publicKey, this.payload_key, this.keypair.publicKey, recipients);
        this.push(this.header.encoded);
        for (const recipient of recipients) {
            recipient.generateMacKeyForSender(this.header.hash, this.ephemeral_keypair.secretKey, this.keypair.secretKey);
        }
    }
    _transform(data, encoding, callback) {
        if (debug)
            console.log("Processing chunk #%d: %s", this.i++, data);
        this.in_buffer = Buffer.concat([this.in_buffer, data]);
        while (this.in_buffer.length > CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);
            // This is never the final payload as there must be additional data in `in_buffer`
            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, /* final */ false);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
    _flush(callback) {
        while (this.in_buffer.length >= CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        if (this.in_buffer.length) {
            const chunk = this.in_buffer;
            this.in_buffer = Buffer.alloc(0);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
}
exports.EncryptStream = EncryptStream;
function decrypt(encrypted, keypair, sender) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        const stream = new stream_1.Readable();
        stream.push(encrypted);
        stream.push(null);
        const items = [];
        try {
            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                items.push(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const header_data = items.shift();
        const header = header_1.default.decode(header_data, true);
        const [payload_key, recipient] = header.decryptPayloadKey(keypair);
        const sender_public_key = header.decryptSender(payload_key);
        if (sender && !Buffer.from(sender_public_key).equals(sender)) {
            throw new Error("Sender public key doesn't match");
        }
        recipient.generateMacKeyForRecipient(header.hash, header.public_key, sender_public_key, keypair.secretKey);
        let output = Buffer.alloc(0);
        for (const i in items) {
            const message = items[i];
            const payload = payload_1.default.decode(message, true);
            const final = items.length === parseInt(i) + 1;
            if (payload.final && !final) {
                throw new Error("Found payload with invalid final flag, message extended?");
            }
            if (!payload.final && final) {
                throw new Error("Found payload with invalid final flag, message truncated?");
            }
            output = Buffer.concat([output, payload.decrypt(header, recipient, payload_key, BigInt(i))]);
        }
        if (!items.length) {
            throw new Error("No encrypted payloads, message truncated?");
        }
        return Object.assign(output, {
            sender_public_key,
        });
    });
}
class DecryptStream extends stream_1.Transform {
    constructor(keypair, sender) {
        super();
        this.keypair = keypair;
        this.decoder = new msgpack_1.Decoder({ extensionCodec: undefined });
        this.header_data = null;
        this.last_payload = null;
        this.payload_index = BigInt(-1);
        this.i = 0;
        this.sender = sender !== null && sender !== void 0 ? sender : null;
    }
    get header() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[0];
    }
    get payload_key() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[1];
    }
    get recipient() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[2];
    }
    get sender_public_key() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[3];
    }
    _transform(data, encoding, callback) {
        // @ts-ignore
        this.decoder.appendBuffer(data);
        try {
            let message;
            // @ts-ignore
            while ((message = this.decoder.doDecodeSync())) {
                // @ts-ignore
                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);
                // @ts-ignore
                this.decoder.setBuffer(remaining);
                this._handleMessage(message);
            }
        }
        catch (err) { }
        callback();
    }
    _handleMessage(data) {
        if (debug)
            console.log("Processing chunk #%d: %s", this.i++, data);
        if (!this.header_data) {
            const header = header_1.default.decode(data, true);
            const [payload_key, recipient] = header.decryptPayloadKey(this.keypair);
            const sender_public_key = header.decryptSender(payload_key);
            if (this.sender && !Buffer.from(sender_public_key).equals(this.sender)) {
                throw new Error("Sender public key doesn't match");
            }
            recipient.generateMacKeyForRecipient(header.hash, header.public_key, sender_public_key, this.keypair.secretKey);
            this.header_data = [header, payload_key, recipient, sender_public_key];
        }
        else {
            this.payload_index++;
            if (this.last_payload) {
                if (this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message extended?");
                }
                this.push(this.last_payload.decrypt(this.header, this.recipient, this.payload_key, this.payload_index - BigInt(1)));
            }
            const payload = payload_1.default.decode(data, true);
            this.last_payload = payload;
        }
    }
    _flush(callback) {
        try {
            if (this.last_payload) {
                if (!this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message truncated?");
                }
                this.push(this.last_payload.decrypt(this.header, this.recipient, this.payload_key, this.payload_index));
            }
            if (!this.last_payload) {
                throw new Error("No encrypted payloads, message truncated?");
            }
        }
        catch (err) {
            return callback(err);
        }
        callback();
    }
}
exports.DecryptStream = DecryptStream;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/payload.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/payload.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
// [
//     final flag,
//     authenticators list,
//     payload secretbox,
// ]
class EncryptedMessagePayload {
    constructor(final, authenticators, payload_secretbox) {
        this.final = final;
        this.authenticators = authenticators;
        this.payload_secretbox = payload_secretbox;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded payload data */
    get encoded() {
        return this.encoded_data;
    }
    static create(header, payload_key, data, index, final = false) {
        const index_buffer = Buffer.alloc(8);
        index_buffer.writeBigUInt64BE(index);
        const nonce = Buffer.concat([this.PAYLOAD_NONCE_PREFIX, index_buffer]);
        const payload_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(data), Uint8Array.from(nonce), Uint8Array.from(payload_key));
        const authenticator_hash = this.generateAuthenticatorHash(header.hash, payload_secretbox, nonce, final);
        return new this(final, header.recipients.map((recipient, i) => {
            if (!recipient.mac_key) {
                throw new Error("Recipient #" + i + " doesn't have a MAC key set");
            }
            // 3. For each recipient, compute the crypto_auth (HMAC-SHA512, truncated to 32 bytes) of the hash
            // from #2, using that recipient's MAC key.
            // return substr(sodium_crypto_auth($authenticator_hash, $recipient->mac_key), 0, 32);
            return Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, recipient.mac_key, authenticator_hash).slice(0, 32));
        }), payload_secretbox);
    }
    static generateAuthenticatorHash(header_hash, payload_secretbox, payload_secretbox_nonce, final) {
        // 1. Concatenate the header hash, the nonce for the payload secretbox, the final flag byte (0x00 or 0x01),
        // and the payload secretbox itself.
        // 2. Compute the crypto_hash (SHA512) of the bytes from #1.
        return Buffer.from(sha2_1.sha512
            .create()
            .update(header_hash)
            .update(payload_secretbox_nonce)
            .update(final ? "\x01" : "\x00")
            .update(payload_secretbox)
            .digest());
    }
    encode() {
        return EncryptedMessagePayload.encodePayload(this.final, this.authenticators, this.payload_secretbox);
    }
    static encodePayload(final, authenticators, payload_secretbox) {
        const data = [final, authenticators, payload_secretbox];
        return Buffer.from((0, msgpack_1.encode)(data));
    }
    static decode(encoded, unpacked = false) {
        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);
        if (data.length < 3)
            throw new Error("Invalid data");
        const [final, authenticators, payload_secretbox] = data;
        return new this(final, authenticators, payload_secretbox);
    }
    decrypt(header, recipient, payload_key, index) {
        if (!recipient.mac_key) {
            throw new Error("Recipient doesn't have a MAC key set");
        }
        // @ts-expect-error
        const authenticator = this.authenticators[recipient.index];
        const index_buffer = Buffer.alloc(8);
        index_buffer.writeBigUInt64BE(index);
        const nonce = Buffer.concat([EncryptedMessagePayload.PAYLOAD_NONCE_PREFIX, index_buffer]);
        const authenticator_hash = EncryptedMessagePayload.generateAuthenticatorHash(header.hash, this.payload_secretbox, nonce, this.final);
        // 3. For each recipient, compute the crypto_auth (HMAC-SHA512, truncated to 32 bytes) of the hash
        // from #2, using that recipient's MAC key.
        // const our_authenticator = substr(sodium_crypto_auth($authenticator_hash, $recipient->mac_key), 0, 32);
        const our_authenticator = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, recipient.mac_key, authenticator_hash).slice(0, 32));
        if (!authenticator || !our_authenticator.equals(authenticator)) {
            throw new Error("Invalid authenticator");
        }
        const decrypted = tweetnacl_1.secretbox.open(Uint8Array.from(this.payload_secretbox), Uint8Array.from(nonce), Uint8Array.from(payload_key));
        if (!decrypted) {
            throw new Error("Failed to decrypt data");
        }
        return decrypted;
    }
}
EncryptedMessagePayload.PAYLOAD_NONCE_PREFIX = Buffer.from("saltpack_ploadsb");
exports["default"] = EncryptedMessagePayload;
//# sourceMappingURL=payload.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/recipient.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/recipient.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
class EncryptedMessageRecipient {
    constructor(public_key, encrypted_payload_key, index, anonymous = false) {
        /** The MAC key for this recipient (this is used to generate the per-payload authenticators for this recipient) */
        this.mac_key = null;
        if (public_key !== null && (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32)) {
            throw new TypeError("recipient_public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(encrypted_payload_key) || encrypted_payload_key.length !== 48) {
            throw new TypeError("payload_key_box must be a 48 byte Uint8Array");
        }
        if (typeof index !== "bigint") {
            throw new TypeError("index must be a bigint");
        }
        if (typeof anonymous !== "boolean") {
            throw new TypeError("anonymous must be a boolean");
        }
        this.public_key = public_key;
        this.encrypted_payload_key = encrypted_payload_key;
        this.index = index;
        this.recipient_index = EncryptedMessageRecipient.generateRecipientIndex(index);
        this.anonymous = anonymous;
    }
    /** @private */
    setPublicKey(public_key) {
        // @ts-expect-error
        this.public_key = public_key;
    }
    static create(public_key, ephemeral_private_key, payload_key, index, anonymous = false) {
        if (typeof index === "number")
            index = BigInt(index);
        const recipient_index = this.generateRecipientIndex(index);
        // 4. For each recipient, encrypt the payload key using crypto_box with the recipient's public key, the ephemeral private key, and the nonce saltpack_recipsbXXXXXXXX. XXXXXXXX is 8-byte big-endian unsigned recipient index, where the first recipient is index zero. Pair these with the recipients' public keys, or null for anonymous recipients, and collect the pairs into the recipients list.
        const encrypted_payload_key = (0, tweetnacl_1.box)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key));
        return new this(public_key, encrypted_payload_key, index, anonymous);
    }
    static from(public_key, encrypted_payload_key, index) {
        if (typeof index === "number")
            index = BigInt(index);
        return new this(public_key, encrypted_payload_key, index, public_key === null);
    }
    static generateRecipientIndex(index) {
        const buffer = Buffer.alloc(8);
        buffer.writeBigUInt64BE(index);
        return Buffer.concat([this.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2, buffer]);
    }
    /**
     * Decrypts the payload key, returns null if wrong recipient.
     */
    decryptPayloadKey(ephemeral_public_key, recipient_private_key, secret = null) {
        const payload_key = secret
            ? tweetnacl_1.box.open.after(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(secret))
            : tweetnacl_1.box.open(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(ephemeral_public_key), Uint8Array.from(recipient_private_key));
        if (!payload_key)
            return null;
        return payload_key;
    }
    generateMacKeyForSender(header_hash, ephemeral_private_key, sender_private_key, public_key = null) {
        if (!public_key && this.public_key)
            public_key = this.public_key;
        if (!public_key)
            throw new Error("Generating MAC key requires the recipient's public key");
        // 9. Concatenate the first 16 bytes of the header hash from step 7 above, with the recipient index from
        // step 4 above. This is the basis of each recipient's MAC nonce.
        const index_buffer = Buffer.alloc(8);
        index_buffer.writeBigUInt64BE(this.index);
        const nonce = Buffer.concat([header_hash.slice(0, 16), index_buffer]);
        // 10. Clear the least significant bit of byte 15. That is: nonce[15] &= 0xfe.
        nonce[15] &= 0xfe;
        // 11. Encrypt 32 zero bytes using crypto_box with the recipient's public key, the sender's long-term
        // private key, and the nonce from the previous step.
        const box_1 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(nonce), Uint8Array.from(public_key), Uint8Array.from(sender_private_key));
        // 12. Modify the nonce from step 10 by setting the least significant bit of byte
        // 12.1. That is: nonce[15] |= 0x01.
        nonce[15] |= 0x01;
        // 13. Encrypt 32 zero bytes again, as in step 11, but using the ephemeral private key rather than the
        // sender's long term private key.
        const box_2 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(nonce), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key));
        // 14. Concatenate the last 32 bytes each box from steps 11 and 13. Take the SHA512 hash of that
        // concatenation. The recipient's MAC Key is the first 32 bytes of that hash.
        const mac_key = sha2_1.sha512.create().update(box_1.slice(-32)).update(box_2.slice(-32)).digest().slice(0, 32);
        // @ts-expect-error
        this.mac_key = mac_key;
        return Buffer.from(mac_key);
    }
    generateMacKeyForRecipient(header_hash, ephemeral_public_key, sender_public_key, private_key) {
        // 9. Concatenate the first 16 bytes of the header hash from step 7 above, with the recipient index from
        // step 4 above. This is the basis of each recipient's MAC nonce.
        const index_buffer = Buffer.alloc(8);
        index_buffer.writeBigUInt64BE(this.index);
        const nonce = Buffer.concat([header_hash.slice(0, 16), index_buffer]);
        // 10. Clear the least significant bit of byte 15. That is: nonce[15] &= 0xfe.
        nonce[15] &= 0xfe;
        // 11. Encrypt 32 zero bytes using crypto_box with the recipient's public key, the sender's long-term
        // private key, and the nonce from the previous step.
        const box_1 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(nonce), Uint8Array.from(sender_public_key), Uint8Array.from(private_key));
        // 12. Modify the nonce from step 10 by setting the least significant bit of byte
        // 12.1. That is: nonce[15] |= 0x01.
        nonce[15] |= 0x01;
        // 13. Encrypt 32 zero bytes again, as in step 11, but using the ephemeral private key rather than the
        // sender's long term private key.
        const box_2 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(nonce), Uint8Array.from(ephemeral_public_key), Uint8Array.from(private_key));
        // 14. Concatenate the last 32 bytes each box from steps 11 and 13. Take the SHA512 hash of that
        // concatenation. The recipient's MAC Key is the first 32 bytes of that hash.
        const mac_key = sha2_1.sha512.create().update(box_1.slice(-32)).update(box_2.slice(-32)).digest().slice(0, 32);
        // @ts-expect-error
        this.mac_key = mac_key;
        return Buffer.from(mac_key);
    }
}
EncryptedMessageRecipient.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2 = Buffer.from("saltpack_recipsb");
exports["default"] = EncryptedMessageRecipient;
//# sourceMappingURL=recipient.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/index.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DearmorAndDesigncryptStream = exports.SigncryptAndArmorStream = exports.dearmorAndDesigncrypt = exports.signcryptAndArmor = exports.verifyDetachedArmored = exports.signDetachedAndArmor = exports.DearmorAndVerifyStream = exports.SignAndArmorStream = exports.verifyArmored = exports.signAndArmor = exports.DearmorAndDecryptStream = exports.EncryptAndArmorStream = exports.dearmorAndDecrypt = exports.encryptAndArmor = exports.SymmetricKeyRecipient = exports.DesigncryptStream = exports.designcrypt = exports.SigncryptStream = exports.signcrypt = exports.verifyDetached = exports.signDetached = exports.VerifyStream = exports.verify = exports.SignStream = exports.sign = exports.DecryptStream = exports.decrypt = exports.EncryptStream = exports.encrypt = exports.MessageType = exports.DearmorStream = exports.dearmor = exports.ArmorStream = exports.armor = void 0;
var armor_1 = __webpack_require__(/*! ./armor */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/armor.js");
Object.defineProperty(exports, "armor", ({ enumerable: true, get: function () { return armor_1.armor; } }));
Object.defineProperty(exports, "ArmorStream", ({ enumerable: true, get: function () { return armor_1.ArmorStream; } }));
Object.defineProperty(exports, "dearmor", ({ enumerable: true, get: function () { return armor_1.dearmor; } }));
Object.defineProperty(exports, "DearmorStream", ({ enumerable: true, get: function () { return armor_1.DearmorStream; } }));
var message_header_1 = __webpack_require__(/*! ./message-header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js");
Object.defineProperty(exports, "MessageType", ({ enumerable: true, get: function () { return message_header_1.MessageType; } }));
var encryption_1 = __webpack_require__(/*! ./encryption */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/index.js");
Object.defineProperty(exports, "encrypt", ({ enumerable: true, get: function () { return encryption_1.encrypt; } }));
Object.defineProperty(exports, "EncryptStream", ({ enumerable: true, get: function () { return encryption_1.EncryptStream; } }));
Object.defineProperty(exports, "decrypt", ({ enumerable: true, get: function () { return encryption_1.decrypt; } }));
Object.defineProperty(exports, "DecryptStream", ({ enumerable: true, get: function () { return encryption_1.DecryptStream; } }));
var signing_1 = __webpack_require__(/*! ./signing */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/index.js");
Object.defineProperty(exports, "sign", ({ enumerable: true, get: function () { return signing_1.sign; } }));
Object.defineProperty(exports, "SignStream", ({ enumerable: true, get: function () { return signing_1.SignStream; } }));
Object.defineProperty(exports, "verify", ({ enumerable: true, get: function () { return signing_1.verify; } }));
Object.defineProperty(exports, "VerifyStream", ({ enumerable: true, get: function () { return signing_1.VerifyStream; } }));
Object.defineProperty(exports, "signDetached", ({ enumerable: true, get: function () { return signing_1.signDetached; } }));
Object.defineProperty(exports, "verifyDetached", ({ enumerable: true, get: function () { return signing_1.verifyDetached; } }));
var signcryption_1 = __webpack_require__(/*! ./signcryption */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/index.js");
Object.defineProperty(exports, "signcrypt", ({ enumerable: true, get: function () { return signcryption_1.signcrypt; } }));
Object.defineProperty(exports, "SigncryptStream", ({ enumerable: true, get: function () { return signcryption_1.SigncryptStream; } }));
Object.defineProperty(exports, "designcrypt", ({ enumerable: true, get: function () { return signcryption_1.designcrypt; } }));
Object.defineProperty(exports, "DesigncryptStream", ({ enumerable: true, get: function () { return signcryption_1.DesigncryptStream; } }));
var recipient_1 = __webpack_require__(/*! ./signcryption/recipient */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js");
Object.defineProperty(exports, "SymmetricKeyRecipient", ({ enumerable: true, get: function () { return recipient_1.SymmetricKeyRecipient; } }));
var with_armor_1 = __webpack_require__(/*! ./with-armor */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/with-armor.js");
Object.defineProperty(exports, "encryptAndArmor", ({ enumerable: true, get: function () { return with_armor_1.encryptAndArmor; } }));
Object.defineProperty(exports, "dearmorAndDecrypt", ({ enumerable: true, get: function () { return with_armor_1.dearmorAndDecrypt; } }));
Object.defineProperty(exports, "EncryptAndArmorStream", ({ enumerable: true, get: function () { return with_armor_1.EncryptAndArmorStream; } }));
Object.defineProperty(exports, "DearmorAndDecryptStream", ({ enumerable: true, get: function () { return with_armor_1.DearmorAndDecryptStream; } }));
Object.defineProperty(exports, "signAndArmor", ({ enumerable: true, get: function () { return with_armor_1.signAndArmor; } }));
Object.defineProperty(exports, "verifyArmored", ({ enumerable: true, get: function () { return with_armor_1.verifyArmored; } }));
Object.defineProperty(exports, "SignAndArmorStream", ({ enumerable: true, get: function () { return with_armor_1.SignAndArmorStream; } }));
Object.defineProperty(exports, "DearmorAndVerifyStream", ({ enumerable: true, get: function () { return with_armor_1.DearmorAndVerifyStream; } }));
Object.defineProperty(exports, "signDetachedAndArmor", ({ enumerable: true, get: function () { return with_armor_1.signDetachedAndArmor; } }));
Object.defineProperty(exports, "verifyDetachedArmored", ({ enumerable: true, get: function () { return with_armor_1.verifyDetachedArmored; } }));
Object.defineProperty(exports, "signcryptAndArmor", ({ enumerable: true, get: function () { return with_armor_1.signcryptAndArmor; } }));
Object.defineProperty(exports, "dearmorAndDesigncrypt", ({ enumerable: true, get: function () { return with_armor_1.dearmorAndDesigncrypt; } }));
Object.defineProperty(exports, "SigncryptAndArmorStream", ({ enumerable: true, get: function () { return with_armor_1.SigncryptAndArmorStream; } }));
Object.defineProperty(exports, "DearmorAndDesigncryptStream", ({ enumerable: true, get: function () { return with_armor_1.DearmorAndDesigncryptStream; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageType = void 0;
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
var MessageType;
(function (MessageType) {
    MessageType[MessageType["ENCRYPTION"] = 0] = "ENCRYPTION";
    MessageType[MessageType["ATTACHED_SIGNING"] = 1] = "ATTACHED_SIGNING";
    MessageType[MessageType["DETACHED_SIGNING"] = 2] = "DETACHED_SIGNING";
    MessageType[MessageType["SIGNCRYPTION"] = 3] = "SIGNCRYPTION";
})(MessageType || (exports.MessageType = MessageType = {}));
class Header {
    static decode1(encoded, unwrapped = false) {
        // 1-3
        const data = unwrapped ? encoded : (0, msgpack_1.decode)(encoded);
        const header_hash = sha2_1.sha512.create().update(data).digest();
        const inner = (0, msgpack_1.decode)(data);
        // 4
        if (!(inner instanceof Array) || inner.length < 3) {
            throw new Error("Invalid data");
        }
        const [format_name, version, mode] = inner;
        if (format_name !== "saltpack")
            throw new Error("Invalid data");
        if (!(version instanceof Array) || version.length !== 2) {
            throw new Error("Invalid data");
        }
        if (version[0] !== 2)
            throw new Error("Unsupported version");
        if (version[1] !== 0)
            throw new Error("Unsupported version");
        if (typeof mode !== "number")
            throw new Error("Invalid data");
        return [header_hash, inner];
    }
}
exports["default"] = Header;
//# sourceMappingURL=message-header.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/header.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/header.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const message_header_1 = __importStar(__webpack_require__(/*! ../message-header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js"));
const recipient_1 = __importDefault(__webpack_require__(/*! ./recipient */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js"));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
class SigncryptedMessageHeader extends message_header_1.default {
    constructor(public_key, sender_secretbox, recipients) {
        super();
        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {
            throw new TypeError("public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(sender_secretbox) || sender_secretbox.length !== 48) {
            throw new TypeError("sender_secretbox must be a 48 byte Uint8Array");
        }
        this.public_key = public_key;
        this.sender_secretbox = sender_secretbox;
        this.recipients = recipients;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded outer header data */
    get encoded() {
        return this.encoded_data[1];
    }
    /** The SHA512 hash of the MessagePack encoded inner header data */
    get hash() {
        return this.encoded_data[0];
    }
    static create(public_key, payload_key, sender_public_key, recipients) {
        if (sender_public_key !== null && (!(0, util_1.isBufferOrUint8Array)(sender_public_key) || sender_public_key.length !== 32)) {
            throw new TypeError("sender_public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(payload_key) || payload_key.length !== 32) {
            throw new TypeError("payload_key must be a 32 byte Uint8Array");
        }
        // If Alice wants to be anonymous to recipients as well, she can supply an all-zero signing public key in
        // step #3.
        if (!sender_public_key)
            sender_public_key = Buffer.alloc(32);
        // 3. Encrypt the sender's long-term public key signing key using crypto_secretbox with the payload key and
        // the nonce saltpack_sender_key_sbox, to create the sender secretbox.
        const sender_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(sender_public_key), Uint8Array.from(SigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));
        return new this(public_key, sender_secretbox, recipients);
    }
    encode() {
        return SigncryptedMessageHeader.encodeHeader(this.public_key, this.sender_secretbox, this.recipients);
    }
    static encodeHeader(public_key, sender, recipients) {
        const data = [
            "saltpack",
            [2, 0],
            message_header_1.MessageType.SIGNCRYPTION,
            public_key,
            sender,
            recipients.map((recipient) => {
                // [
                //     recipient identifier,
                //     payload key box,
                // ]
                return [recipient.recipient_identifier, recipient.encrypted_payload_key];
            }),
        ];
        const encoded = (0, msgpack_1.encode)(data);
        const header_hash = sha2_1.sha512.create().update(encoded).digest();
        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];
    }
    static decode(encoded, unwrapped = false) {
        const [header_hash, data] = super.decode1(encoded, unwrapped);
        if (data[2] !== message_header_1.MessageType.SIGNCRYPTION)
            throw new Error("Invalid data");
        const [, , , public_key, sender_secretbox, recipients] = data;
        if (!(recipients instanceof Array))
            throw new Error("Invalid data");
        return new this(public_key, sender_secretbox, recipients.map((recipient, index) => {
            if (!(recipient instanceof Array) || recipient.length < 2) {
                throw new TypeError("Invalid data");
            }
            return recipient_1.default.from(recipient[0], recipient[1], index);
        }));
    }
    /**
     * Decrypts and returns the payload key and recipient.
     */
    decryptPayloadKeyWithCurve25519Keypair(private_key) {
        // 5. Check to see if any of the recipient's Curve25519 private keys are in the recipients' list. For each
        // private key available, and for each recipient entry in the list, compute the identifier as in step #4
        // in the previous section. If any of the recipient entries match, decrypt the payload key and proceed to
        // step #7.
        for (const recipient of this.recipients) {
            const { recipient_identifier, shared_symmetric_key } = recipient_1.default.generateRecipientIdentifierForRecipient(this.public_key, private_key, recipient.recipient_index);
            if (!recipient_identifier.equals(recipient.recipient_identifier))
                continue;
            const payload_key = recipient.decryptPayloadKey(shared_symmetric_key);
            if (!payload_key) {
                throw new Error("Invalid shared symmetric key");
            }
            return [payload_key, recipient];
        }
        return null;
    }
    decryptPayloadKeyWithSymmetricKey(shared_symmetric_key, recipient_identifier) {
        // 6. If no Curve25519 keys matched in the previous step, check whether any of the recipient's symmetric
        // keys are in the message. The identifiers in this step are up to the application, and if the space of
        // possible keys is very large, the recipient might use server assistance to look up identifiers. If any
        // of the recipient entries match, decrypt the payload key. If not, decryption fails, and the client should
        // report that the current user isn't a recipient of this message.
        const derived_key = (0, hmac_1.hmac)(sha2_1.sha512, recipient_1.default.HMAC_KEY_SYMMETRIC, Buffer.concat([this.public_key, shared_symmetric_key])).slice(0, 32);
        const identifier = recipient_identifier ? Buffer.from(recipient_identifier) : null;
        for (const recipient of this.recipients) {
            if (identifier && !identifier.equals(recipient.recipient_identifier))
                continue;
            const payload_key = recipient.decryptPayloadKey(derived_key);
            if (!payload_key)
                continue;
            return [payload_key, recipient];
        }
        return null;
    }
    decryptSender(payload_key) {
        const sender_public_key = tweetnacl_1.secretbox.open(Uint8Array.from(this.sender_secretbox), Uint8Array.from(SigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));
        if (!sender_public_key) {
            throw new Error("Failed to decrypt sender public key");
        }
        if (Buffer.alloc(32).equals(sender_public_key)) {
            return null;
        }
        return sender_public_key;
    }
}
SigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE = Buffer.from("saltpack_sender_key_sbox");
exports["default"] = SigncryptedMessageHeader;
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/index.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/index.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DesigncryptStream = exports.SigncryptStream = void 0;
exports.debugSetKey = debugSetKey;
exports.debugSetKeypair = debugSetKeypair;
exports.signcrypt = signcrypt;
exports.designcrypt = designcrypt;
const header_1 = __importDefault(__webpack_require__(/*! ./header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/header.js"));
const recipient_1 = __importStar(__webpack_require__(/*! ./recipient */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js"));
const payload_1 = __importDefault(__webpack_require__(/*! ./payload */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/payload.js"));
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const CHUNK_LENGTH = 1024 * 1024;
let debug = false;
let debug_fix_key = null;
let debug_fix_keypair = null;
function debugSetKey(key) {
    debug_fix_key = key;
}
function debugSetKeypair(keypair) {
    debug_fix_keypair = keypair;
}
function signcrypt(data, keypair, recipients_keys) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const chunks = (0, util_1.chunkBuffer)(data, CHUNK_LENGTH);
        // 1. Generate a random 32-byte payload key.
        const payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : (0, tweetnacl_1.randomBytes)(32);
        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.
        const ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();
        const recipients = recipients_keys.map((key, index) => key instanceof recipient_1.SymmetricKeyRecipient
            ? recipient_1.default.createSymmetric(key.key, key.recipient_identifier, ephemeral_keypair.publicKey, payload_key, index)
            : recipient_1.default.create(key, ephemeral_keypair.secretKey, payload_key, index));
        const header = header_1.default.create(ephemeral_keypair.publicKey, payload_key, (_a = keypair === null || keypair === void 0 ? void 0 : keypair.publicKey) !== null && _a !== void 0 ? _a : null, recipients);
        const payloads = [];
        for (const i in chunks) {
            const chunk = chunks[i];
            const final = chunks.length === parseInt(i) + 1;
            const payload = payload_1.default.create(header, payload_key, (_b = keypair === null || keypair === void 0 ? void 0 : keypair.secretKey) !== null && _b !== void 0 ? _b : null, chunk, BigInt(i), final);
            payloads.push(payload);
        }
        return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);
    });
}
class SigncryptStream extends stream_1.Transform {
    constructor(keypair, recipients_keys) {
        var _a, _b;
        super();
        this.in_buffer = Buffer.alloc(0);
        this.payload_index = BigInt(0);
        this.i = 0;
        // 1. Generate a random 32-byte payload key.
        this.payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));
        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.
        this.ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();
        this.keypair = keypair;
        const recipients = recipients_keys.map((key, index) => key instanceof recipient_1.SymmetricKeyRecipient
            ? recipient_1.default.createSymmetric(key.key, key.recipient_identifier, this.ephemeral_keypair.publicKey, this.payload_key, index)
            : recipient_1.default.create(key, this.ephemeral_keypair.secretKey, this.payload_key, index));
        this.header = header_1.default.create(this.ephemeral_keypair.publicKey, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.publicKey) !== null && _b !== void 0 ? _b : null, recipients);
        this.push(this.header.encoded);
    }
    _transform(data, encoding, callback) {
        var _a, _b;
        if (debug)
            console.log("Processing chunk #%d: %s", this.i++, data);
        this.in_buffer = Buffer.concat([this.in_buffer, data]);
        while (this.in_buffer.length > CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);
            // This is never the final payload as there must be additional data in `in_buffer`
            const payload = payload_1.default.create(this.header, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.secretKey) !== null && _b !== void 0 ? _b : null, chunk, this.payload_index, /* final */ false);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
    _flush(callback) {
        var _a, _b, _c, _d;
        while (this.in_buffer.length >= CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.secretKey) !== null && _b !== void 0 ? _b : null, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        if (this.in_buffer.length) {
            const chunk = this.in_buffer;
            this.in_buffer = Buffer.alloc(0);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.payload_key, (_d = (_c = this.keypair) === null || _c === void 0 ? void 0 : _c.secretKey) !== null && _d !== void 0 ? _d : null, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
}
exports.SigncryptStream = SigncryptStream;
function designcrypt(signcrypted, recipient_keys, sender) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        const stream = new stream_1.Readable();
        stream.push(signcrypted);
        stream.push(null);
        const items = [];
        try {
            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                items.push(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const header_data = items.shift();
        const header = header_1.default.decode(header_data, true);
        const payload_key_and_recipient = recipient_keys instanceof recipient_1.SymmetricKeyRecipient
            ? header.decryptPayloadKeyWithSymmetricKey(recipient_keys.key, recipient_keys.recipient_identifier)
            : header.decryptPayloadKeyWithCurve25519Keypair(recipient_keys.secretKey);
        if (!payload_key_and_recipient)
            throw new Error("keypair is not an intended recipient");
        const [payload_key] = payload_key_and_recipient;
        const sender_public_key = header.decryptSender(payload_key);
        if (sender && (!sender_public_key || !Buffer.from(sender_public_key).equals(Buffer.from(sender)))) {
            throw new Error("Sender public key doesn't match");
        }
        let output = Buffer.alloc(0);
        for (const i in items) {
            const message = items[i];
            const payload = payload_1.default.decode(message, true);
            const final = items.length === parseInt(i) + 1;
            if (payload.final && !final) {
                throw new Error("Found payload with invalid final flag, message extended?");
            }
            if (!payload.final && final) {
                throw new Error("Found payload with invalid final flag, message truncated?");
            }
            output = Buffer.concat([output, payload.decrypt(header, sender_public_key, payload_key, BigInt(i))]);
        }
        if (!items.length) {
            throw new Error("No signcrypted payloads, message truncated?");
        }
        return Object.assign(output, {
            sender_public_key,
        });
    });
}
class DesigncryptStream extends stream_1.Transform {
    constructor(recipient_keys, sender) {
        super();
        this.recipient_keys = recipient_keys;
        this.decoder = new msgpack_1.Decoder();
        this.header_data = null;
        this.last_payload = null;
        this.payload_index = BigInt(-1);
        this.i = 0;
        this.sender = sender !== null && sender !== void 0 ? sender : null;
    }
    get header() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[0];
    }
    get payload_key() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[1];
    }
    get recipient() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[2];
    }
    get sender_public_key() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data[3];
    }
    _transform(data, encoding, callback) {
        // @ts-ignore
        this.decoder.appendBuffer(data);
        try {
            let message;
            // @ts-ignore
            while ((message = this.decoder.doDecodeSync())) {
                // @ts-ignore
                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);
                // @ts-ignore
                this.decoder.setBuffer(remaining);
                this._handleMessage(message);
            }
        }
        catch (err) { }
        callback();
    }
    _handleMessage(data) {
        if (debug)
            console.log("Processing chunk #%d: %s", this.i++, data);
        if (!this.header_data) {
            const header = header_1.default.decode(data, true);
            const payload_key_and_recipient = this.recipient_keys instanceof recipient_1.SymmetricKeyRecipient
                ? header.decryptPayloadKeyWithSymmetricKey(this.recipient_keys.key, this.recipient_keys.recipient_identifier)
                : header.decryptPayloadKeyWithCurve25519Keypair(this.recipient_keys.secretKey);
            if (!payload_key_and_recipient)
                throw new Error("keypair is not an intended recipient");
            const [payload_key, recipient] = payload_key_and_recipient;
            const sender_public_key = header.decryptSender(payload_key);
            if (this.sender && (!sender_public_key || !Buffer.from(sender_public_key).equals(Buffer.from(this.sender)))) {
                throw new Error("Sender public key doesn't match");
            }
            this.header_data = [header, payload_key, recipient, sender_public_key];
        }
        else {
            this.payload_index++;
            if (this.last_payload) {
                if (this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message extended?");
                }
                this.push(this.last_payload.decrypt(this.header, this.sender_public_key, this.payload_key, this.payload_index - BigInt(1)));
            }
            const payload = payload_1.default.decode(data, true);
            this.last_payload = payload;
        }
    }
    _flush(callback) {
        try {
            if (this.last_payload) {
                if (!this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message truncated?");
                }
                this.push(this.last_payload.decrypt(this.header, this.sender_public_key, this.payload_key, this.payload_index));
            }
            if (!this.last_payload) {
                throw new Error("No signcrypted payloads, message truncated?");
            }
        }
        catch (err) {
            return callback(err);
        }
        callback();
    }
}
exports.DesigncryptStream = DesigncryptStream;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/payload.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/payload.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
// [
//     signcrypted chunk,
//     final flag,
// ]
class SigncryptedMessagePayload {
    constructor(payload_secretbox, final) {
        this.payload_secretbox = payload_secretbox;
        this.final = final;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded payload data */
    get encoded() {
        return this.encoded_data;
    }
    static create(header, payload_key, private_key, data, index, final = false) {
        const nonce = this.generateNonce(header.hash, index, final);
        // 3. Sign the signature input with the sender's long-term private signing key, producing a 64-byte
        // Ed25519 signature. If the sender is anonymous, the signature is 64 zero bytes instead.
        const signature = private_key ? tweetnacl_1.sign.detached(Uint8Array.from(this.generateSignatureData(header.hash, nonce, final, data)), Uint8Array.from(private_key)) : Buffer.alloc(64);
        // 4. Prepend that signature onto the front of the plaintext chunk.
        // 5. Encrypt the attached signature from #4 using the payload key and the packet nonce.
        const payload_secretbox = Buffer.from((0, tweetnacl_1.secretbox)(Uint8Array.from(Buffer.concat([signature, data])), Uint8Array.from(nonce), Uint8Array.from(payload_key)));
        return new this(payload_secretbox, final);
    }
    static generateNonce(header_hash, index, final) {
        // 1. Compute the packet nonce. Take the first 16 bytes of the header hash. If this is the final packet,
        // set the least significant bit of the last of those bytes to one (nonce[15] |= 0x01), otherwise set it
        // to zero (nonce[15] &= 0xfe). Finally, append the 8-byte unsigned big-endian packet number, where the
        // first payload packet is zero.
        const nonce = Buffer.alloc(24, Buffer.from(header_hash));
        nonce[15] = final ? nonce[15] | 0x01 : nonce[15] & 0xfe;
        nonce.writeBigUInt64BE(index, 16);
        return nonce;
    }
    static generateSignatureData(header_hash, nonce, final, data) {
        // 2. Concatenate several values to form the signature input:
        //     - the constant string saltpack encrypted signature
        //     - a null byte, 0x00
        //     - the header hash
        //     - the packet nonce computed above
        //     - the final flag byte, 0x00 for false and 0x01 for true
        //     - the SHA512 hash of the plaintext
        return Buffer.concat([Buffer.from("saltpack encrypted signature"), Buffer.from([0x00]), header_hash, nonce, Buffer.from([final ? 0x01 : 0x00]), sha2_1.sha512.create().update(data).digest()]);
    }
    encode() {
        return SigncryptedMessagePayload.encodePayload(this.payload_secretbox, this.final);
    }
    static encodePayload(payload_secretbox, final) {
        const data = [payload_secretbox, final];
        return Buffer.from((0, msgpack_1.encode)(data));
    }
    static decode(encoded, unpacked = false) {
        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);
        if (data.length < 2)
            throw new Error("Invalid data");
        const [payload_secretbox, final] = data;
        return new this(payload_secretbox, final);
    }
    decrypt(header, public_key, payload_key, index) {
        // 1. Compute the packet nonce as above.
        const nonce = SigncryptedMessagePayload.generateNonce(header.hash, index, this.final);
        // 2. Decrypt the chunk using the payload key and the packet nonce.
        const signature_data = tweetnacl_1.secretbox.open(Uint8Array.from(this.payload_secretbox), Uint8Array.from(nonce), Uint8Array.from(payload_key));
        if (!signature_data) {
            throw new Error("Failed to decrypt data");
        }
        // 3. Take the first 64 bytes of the plaintext as the detached signature, and the rest as the payload chunk.
        const data = signature_data.slice(64);
        if (public_key) {
            const signature = signature_data.slice(0, 64);
            // 4. Compute the signature input as above.
            const sign_data = SigncryptedMessagePayload.generateSignatureData(header.hash, nonce, this.final, data);
            // 5. Verify the detached signature from step #3 against the signature input. If the sender's public key
            // is all zero bytes, however, then the sender is anonymous, and verification is skipped.
            if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(signature), Uint8Array.from(public_key))) {
                throw new Error("Invalid signature");
            }
        }
        // 6. If the signature was valid, output the payload chunk.
        return data;
    }
}
SigncryptedMessagePayload.PAYLOAD_NONCE_PREFIX = Buffer.from("saltpack_ploadsb");
exports["default"] = SigncryptedMessagePayload;
//# sourceMappingURL=payload.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SymmetricKeyRecipient = void 0;
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
class SymmetricKeyRecipient {
    constructor(recipient_identifier, key) {
        this.recipient_identifier = recipient_identifier;
        this.key = key;
    }
}
exports.SymmetricKeyRecipient = SymmetricKeyRecipient;
class SigncryptedMessageRecipient {
    constructor(recipient_identifier /*shared_symmetric_key: Uint8Array | null,*/, encrypted_payload_key, index) {
        if (!(0, util_1.isBufferOrUint8Array)(recipient_identifier) || recipient_identifier.length !== 32) {
            throw new TypeError("recipient_identifier must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(encrypted_payload_key) || encrypted_payload_key.length !== 48) {
            throw new TypeError("payload_key_box must be a 48 byte Uint8Array");
        }
        if (typeof index !== "bigint") {
            throw new TypeError("index must be a bigint");
        }
        this.recipient_identifier = recipient_identifier;
        // this.shared_symmetric_key = shared_symmetric_key;
        this.encrypted_payload_key = encrypted_payload_key;
        this.index = index;
        this.recipient_index = SigncryptedMessageRecipient.generateRecipientIndex(index);
    }
    static create(public_key, ephemeral_private_key, payload_key, index) {
        if (typeof index === "number")
            index = BigInt(index);
        const recipient_index = this.generateRecipientIndex(index);
        const { shared_symmetric_key, recipient_identifier } = this.generateRecipientIdentifierForSender(public_key, ephemeral_private_key, recipient_index);
        // Secretbox the payload key using this derived symmetric key, with the nonce saltpack_recipsbXXXXXXXX,
        // where XXXXXXXX is the 8-byte big-endian unsigned recipient index.
        const encrypted_payload_key = (0, tweetnacl_1.secretbox)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(shared_symmetric_key));
        return new this(recipient_identifier, /*shared_symmetric_key,*/ encrypted_payload_key, index);
    }
    static createSymmetric(shared_symmetric_key, recipient_identifier, ephemeral_public_key, payload_key, index) {
        if (typeof index === "number")
            index = BigInt(index);
        // For recipient symmetric keys, first derive a shared symmetric key. Concatenate the ephemeral
        // public Curve25519 key and the recipient symmetric key, and HMAC-SHA512 them under the key saltpack
        // signcryption derived symmetric key. The derived key is the first 32 bytes of that HMAC.
        const derived_key = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY_SYMMETRIC, Buffer.concat([ephemeral_public_key, shared_symmetric_key])).slice(0, 32));
        const recipient_index = this.generateRecipientIndex(index);
        // Secretbox the payload key using this derived symmetric key, with the nonce saltpack_recipsbXXXXXXXX,
        // where XXXXXXXX is the 8-byte big-endian unsigned recipient index.
        const encrypted_payload_key = (0, tweetnacl_1.secretbox)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(derived_key));
        return new this(recipient_identifier, encrypted_payload_key, index);
    }
    static from(recipient_identifier, encrypted_payload_key, index) {
        if (typeof index === "number")
            index = BigInt(index);
        return new this(recipient_identifier, /*null,*/ encrypted_payload_key, index);
    }
    static generateRecipientIndex(index) {
        const buffer = Buffer.alloc(8);
        buffer.writeBigUInt64BE(index);
        return Buffer.concat([this.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2, buffer]);
    }
    /**
     * Decrypts the payload key.
     */
    decryptPayloadKey(shared_symmetric_key) {
        return tweetnacl_1.secretbox.open(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(shared_symmetric_key));
    }
    static generateRecipientIdentifierForSender(public_key, ephemeral_private_key, recipient_index) {
        // For Curve25519 recipient public keys, first derive a shared symmetric key by boxing 32 zero bytes with
        // the recipient public key, the ephemeral private key, and the nonce saltpack_derived_sboxkey, and taking
        // the last 32 bytes of the resulting box.
        const shared_symmetric_key = Buffer.from((0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(this.SHARED_KEY_NONCE), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key))).slice(-32);
        // To compute the recipient identifier, concatenate the derived symmetric key and the
        // saltpack_recipsbXXXXXXXX nonce together, and HMAC-SHA512 them under the key saltpack signcryption box
        // key identifier. The identifier is the first 32 bytes of that HMAC.
        const recipient_identifier = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY, Buffer.concat([shared_symmetric_key, recipient_index])).slice(0, 32));
        return { shared_symmetric_key, recipient_identifier };
    }
    static generateRecipientIdentifierForRecipient(ephemeral_public_key, private_key, recipient_index) {
        // For Curve25519 recipient public keys, first derive a shared symmetric key by boxing 32 zero bytes with
        // the recipient public key, the ephemeral private key, and the nonce saltpack_derived_sboxkey, and taking
        // the last 32 bytes of the resulting box.
        const shared_symmetric_key = Buffer.from((0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill("\0")), Uint8Array.from(this.SHARED_KEY_NONCE), Uint8Array.from(ephemeral_public_key), Uint8Array.from(private_key))).slice(-32);
        // To compute the recipient identifier, concatenate the derived symmetric key and the
        // saltpack_recipsbXXXXXXXX nonce together, and HMAC-SHA512 them under the key saltpack signcryption box
        // key identifier. The identifier is the first 32 bytes of that HMAC.
        const recipient_identifier = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY, Buffer.concat([shared_symmetric_key, recipient_index])).slice(0, 32));
        return { shared_symmetric_key, recipient_identifier };
    }
}
SigncryptedMessageRecipient.SHARED_KEY_NONCE = Buffer.from("saltpack_derived_sboxkey");
SigncryptedMessageRecipient.HMAC_KEY = Buffer.from("saltpack signcryption box key identifier");
SigncryptedMessageRecipient.HMAC_KEY_SYMMETRIC = Buffer.from("saltpack signcryption derived symmetric key");
SigncryptedMessageRecipient.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2 = Buffer.from("saltpack_recipsb");
exports["default"] = SigncryptedMessageRecipient;
//# sourceMappingURL=recipient.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/header.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/header.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const message_header_1 = __importStar(__webpack_require__(/*! ../message-header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js"));
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
// [
//     format name,
//     version,
//     mode,
//     sender public key,
//     nonce,
// ]
class SignedMessageHeader extends message_header_1.default {
    constructor(public_key, nonce, attached = true) {
        super();
        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {
            throw new TypeError("public_key must be a 32 byte Uint8Array");
        }
        if (!(0, util_1.isBufferOrUint8Array)(nonce) || nonce.length !== 32) {
            throw new TypeError("nonce must be a 32 byte Uint8Array");
        }
        if (typeof attached !== "boolean") {
            throw new TypeError("attached must be a boolean");
        }
        this.public_key = public_key;
        this.nonce = nonce;
        this.attached = attached;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded outer header data */
    get encoded() {
        return this.encoded_data[1];
    }
    /** The SHA512 hash of the MessagePack encoded inner header data */
    get hash() {
        return this.encoded_data[0];
    }
    static create(public_key, attached = true) {
        var _a;
        const nonce = (_a = this.debug_fix_nonce) !== null && _a !== void 0 ? _a : (0, tweetnacl_1.randomBytes)(32);
        return new this(public_key, nonce, attached);
    }
    encode() {
        return SignedMessageHeader.encodeHeader(this.public_key, this.nonce, this.attached);
    }
    static encodeHeader(public_key, nonce, attached) {
        const data = ["saltpack", [2, 0], attached ? message_header_1.MessageType.ATTACHED_SIGNING : message_header_1.MessageType.DETACHED_SIGNING, public_key, nonce];
        const encoded = (0, msgpack_1.encode)(data);
        const header_hash = sha2_1.sha512.create().update(encoded).digest();
        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];
    }
    static decode(encoded, unwrapped = false) {
        const [, data] = super.decode1(encoded, unwrapped);
        if (data[2] !== message_header_1.MessageType.ATTACHED_SIGNING && data[2] !== message_header_1.MessageType.DETACHED_SIGNING)
            throw new Error("Invalid data");
        const [, , , public_key, nonce] = data;
        return new this(public_key, nonce, data[2] === message_header_1.MessageType.ATTACHED_SIGNING);
    }
    signDetached(data, private_key) {
        if (this.attached) {
            throw new Error("Header attached is true");
        }
        const hash = sha2_1.sha512.create().update(this.hash).update(data).digest();
        const sign_data = Buffer.concat([SignedMessageHeader.DETACHED_SIGNATURE_PREFIX, hash]);
        return Buffer.from(tweetnacl_1.sign.detached(Uint8Array.from(sign_data), Uint8Array.from(private_key)));
    }
    verifyDetached(signature, data, public_key) {
        if (this.attached) {
            throw new Error("Header attached is true");
        }
        const hash = sha2_1.sha512.create().update(this.hash).update(data).digest();
        const sign_data = Buffer.concat([SignedMessageHeader.DETACHED_SIGNATURE_PREFIX, hash]);
        if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(signature), Uint8Array.from(public_key))) {
            throw new Error("Invalid signature");
        }
    }
}
SignedMessageHeader.DETACHED_SIGNATURE_PREFIX = Buffer.from("saltpack detached signature\0");
SignedMessageHeader.debug_fix_nonce = process.env.TEST ? Buffer.alloc(32).fill(0) : null;
exports["default"] = SignedMessageHeader;
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/index.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/index.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerifyStream = exports.SignStream = exports.CHUNK_LENGTH = void 0;
exports.sign = sign;
exports.verify = verify;
exports.signDetached = signDetached;
exports.verifyDetached = verifyDetached;
const header_1 = __importDefault(__webpack_require__(/*! ./header */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/header.js"));
const payload_1 = __importDefault(__webpack_require__(/*! ./payload */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/payload.js"));
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js");
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
let debug = false;
exports.CHUNK_LENGTH = 1024 * 1024;
function sign(data, keypair) {
    const chunks = (0, util_1.chunkBuffer)(data, exports.CHUNK_LENGTH);
    const header = header_1.default.create(keypair.publicKey, true);
    const payloads = [];
    for (const i in chunks) {
        const chunk = chunks[i];
        const final = chunks.length === parseInt(i) + 1;
        const payload = payload_1.default.create(header, keypair.secretKey, chunk, BigInt(i), final);
        payloads.push(payload);
    }
    return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);
}
class SignStream extends stream_1.Transform {
    constructor(keypair) {
        super();
        this.keypair = keypair;
        this.in_buffer = Buffer.alloc(0);
        this.payload_index = BigInt(0);
        this.header = header_1.default.create(keypair.publicKey, true);
        this.push(this.header.encoded);
    }
    _transform(data, encoding, callback) {
        if (debug)
            console.log("Processing chunk #d: %s", -1, data);
        this.in_buffer = Buffer.concat([this.in_buffer, data]);
        while (this.in_buffer.length > exports.CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, exports.CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(exports.CHUNK_LENGTH);
            // This is never the final payload as there must be additional data in `in_buffer`
            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, /* final */ false);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
    _flush(callback) {
        while (this.in_buffer.length >= exports.CHUNK_LENGTH) {
            const chunk = this.in_buffer.slice(0, exports.CHUNK_LENGTH);
            this.in_buffer = this.in_buffer.slice(exports.CHUNK_LENGTH);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        if (this.in_buffer.length) {
            const chunk = this.in_buffer;
            this.in_buffer = Buffer.alloc(0);
            const final = !this.in_buffer.length;
            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, final);
            this.push(payload.encoded);
            this.payload_index++;
        }
        callback();
    }
}
exports.SignStream = SignStream;
function verify(signed, public_key) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        const stream = new stream_1.Readable();
        stream.push(signed);
        stream.push(null);
        const items = [];
        try {
            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                items.push(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const header_data = items.shift();
        const header = header_1.default.decode(header_data, true);
        if (public_key && !Buffer.from(header.public_key).equals(public_key)) {
            throw new Error("Sender public key doesn't match");
        }
        let output = Buffer.alloc(0);
        for (const i in items) {
            const message = items[i];
            const final = items.length === parseInt(i) + 1;
            const payload = payload_1.default.decode(message, true);
            payload.verify(header, header.public_key, BigInt(i));
            if (payload.final && !final) {
                throw new Error("Found payload with invalid final flag, message extended?");
            }
            if (!payload.final && final) {
                throw new Error("Found payload with invalid final flag, message truncated?");
            }
            output = Buffer.concat([output, payload.data]);
        }
        if (!items.length) {
            throw new Error("No signed payloads, message truncated?");
        }
        return Object.assign(output, {
            public_key: new Uint8Array(header.public_key),
        });
    });
}
class VerifyStream extends stream_1.Transform {
    constructor(public_key) {
        super();
        this.decoder = new msgpack_1.Decoder();
        this.header_data = null;
        this.last_payload = null;
        this.payload_index = BigInt(-1);
        this.i = 0;
        this._public_key = public_key !== null && public_key !== void 0 ? public_key : null;
    }
    get header() {
        if (!this.header_data)
            throw new Error("Header hasn't been decoded yet");
        return this.header_data;
    }
    get public_key() {
        return this.header.public_key;
    }
    _transform(data, encoding, callback) {
        // @ts-ignore
        this.decoder.appendBuffer(data);
        try {
            let message;
            // @ts-ignore
            while ((message = this.decoder.doDecodeSync())) {
                // @ts-ignore
                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);
                // @ts-ignore
                this.decoder.setBuffer(remaining);
                this._handleMessage(message);
            }
        }
        catch (err) { }
        callback();
    }
    _handleMessage(data) {
        if (debug)
            console.log("Processing chunk #%d: %O", this.i++, data);
        if (!this.header_data) {
            const header = header_1.default.decode(data, true);
            if (this._public_key && !Buffer.from(header.public_key).equals(this._public_key)) {
                throw new Error("Sender public key doesn't match");
            }
            this.header_data = header;
            // @ts-expect-error
            header.public_key = new Uint8Array(header.public_key);
        }
        else {
            this.payload_index++;
            if (this.last_payload) {
                if (this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message extended?");
                }
                this.push(this.last_payload.data);
            }
            const payload = payload_1.default.decode(data, true);
            payload.verify(this.header, this.header.public_key, this.payload_index);
            this.last_payload = payload;
        }
    }
    _flush(callback) {
        try {
            if (this.last_payload) {
                if (!this.last_payload.final) {
                    throw new Error("Found payload with invalid final flag, message truncated?");
                }
                this.push(this.last_payload.data);
            }
            if (!this.last_payload) {
                throw new Error("No signed payloads, message truncated?");
            }
        }
        catch (err) {
            return callback(err);
        }
        callback();
    }
}
exports.VerifyStream = VerifyStream;
function signDetached(data, keypair) {
    const header = header_1.default.create(keypair.publicKey, false);
    return Buffer.concat([header.encoded, (0, msgpack_1.encode)(header.signDetached(Buffer.from(data), keypair.secretKey))]);
}
function verifyDetached(signature, data, public_key) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        const stream = new stream_1.Readable();
        stream.push(signature);
        stream.push(null);
        const items = [];
        try {
            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                items.push(item);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        const [header_data, signature_data] = items;
        const header = header_1.default.decode(header_data, true);
        if (public_key && !Buffer.from(header.public_key).equals(public_key)) {
            throw new Error("Sender public key doesn't match");
        }
        header.verifyDetached(signature_data, Buffer.from(data), header.public_key);
        return {
            public_key: new Uint8Array(header.public_key),
        };
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/payload.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/payload.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js");
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
// [
//     final flag,
//     signature,
//     payload chunk,
// ]
class SignedMessagePayload {
    constructor(final, signature, data) {
        this.final = final;
        this.signature = signature;
        this.data = data;
    }
    get encoded_data() {
        return Object.defineProperty(this, "encoded_data", {
            value: this.encode(),
        }).encoded_data;
    }
    /** The MessagePack encoded payload data */
    get encoded() {
        return this.encoded_data;
    }
    static create(header, private_key, data, index, final = false) {
        if (typeof index === "number")
            index = BigInt(index);
        const sign_data = this.generateSignData(header.hash, index, final, data);
        const signature = tweetnacl_1.sign.detached(Uint8Array.from(sign_data), Uint8Array.from(private_key));
        return new this(final, signature, data);
    }
    static generateSignData(header_hash, index, final, data) {
        // To make each signature, the sender first takes the SHA512 hash of the concatenation of four values:
        // the header hash from above
        // the packet sequence number, as a 64-bit big-endian unsigned integer, where the first payload packet is zero
        // the final flag, a 0x00 byte for false and a 0x01 byte for true
        // the payload chunk
        const index_buffer = Buffer.alloc(8);
        index_buffer.writeBigUInt64BE(index);
        return Buffer.concat([
            this.PAYLOAD_SIGNATURE_PREFIX,
            sha2_1.sha512
                .create()
                .update(header_hash)
                .update(index_buffer)
                .update(final ? "\x01" : "\x00")
                .update(data)
                .digest(),
        ]);
    }
    encode() {
        return SignedMessagePayload.encodePayload(this.final, this.signature, this.data);
    }
    static encodePayload(final, signature, payload_chunk) {
        return Buffer.from((0, msgpack_1.encode)([final, signature, payload_chunk]));
    }
    static decode(encoded, unpacked = false) {
        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);
        if (data.length < 3)
            throw new Error("Invalid data");
        const [final, signature, payload_chunk] = data;
        return new this(final, signature, payload_chunk);
    }
    verify(header, public_key, index) {
        const sign_data = SignedMessagePayload.generateSignData(header.hash, index, this.final, this.data);
        if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(this.signature), Uint8Array.from(public_key))) {
            throw new Error("Invalid signature");
        }
    }
}
SignedMessagePayload.PAYLOAD_SIGNATURE_PREFIX = Buffer.from("saltpack attached signature\0");
exports["default"] = SignedMessagePayload;
//# sourceMappingURL=payload.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBufferOrUint8Array = isBufferOrUint8Array;
exports.chunkBuffer = chunkBuffer;
exports.chunkString = chunkString;
function isBufferOrUint8Array(buffer) {
    return buffer instanceof Buffer || buffer instanceof Uint8Array;
}
function chunkBuffer(_buffer, length) {
    if (_buffer === undefined)
        return _buffer;
    let buffer = _buffer instanceof Buffer ? _buffer : Buffer.from(_buffer);
    const result = [];
    while (buffer.length > length) {
        const chunk = buffer.slice(0, length);
        buffer = buffer.slice(length);
        result.push(chunk);
    }
    if (buffer.length) {
        result.push(buffer);
    }
    return result;
}
function chunkString(string, length) {
    const result = [];
    while (string.length > length) {
        const chunk = string.substr(0, length);
        string = string.substr(length);
        result.push(chunk);
    }
    if (string.length) {
        result.push(string);
    }
    return result;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/with-armor.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/with-armor.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DearmorAndDesigncryptStream = exports.SigncryptAndArmorStream = exports.DearmorAndVerifyStream = exports.SignAndArmorStream = exports.DearmorAndDecryptStream = exports.EncryptAndArmorStream = void 0;
exports.encryptAndArmor = encryptAndArmor;
exports.dearmorAndDecrypt = dearmorAndDecrypt;
exports.signAndArmor = signAndArmor;
exports.verifyArmored = verifyArmored;
exports.signDetachedAndArmor = signDetachedAndArmor;
exports.verifyDetachedArmored = verifyDetachedArmored;
exports.signcryptAndArmor = signcryptAndArmor;
exports.dearmorAndDesigncrypt = dearmorAndDesigncrypt;
const encryption_1 = __webpack_require__(/*! ./encryption */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/index.js");
const signing_1 = __webpack_require__(/*! ./signing */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/index.js");
const signcryption_1 = __webpack_require__(/*! ./signcryption */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/index.js");
const armor_1 = __webpack_require__(/*! ./armor */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/armor.js");
const pumpify_1 = __importDefault(__webpack_require__(/*! pumpify */ "./node_modules/.pnpm/pumpify@2.0.1/node_modules/pumpify/index.js"));
function encryptAndArmor(data, keypair, recipients_keys) {
    return __awaiter(this, void 0, void 0, function* () {
        const encrypted = yield (0, encryption_1.encrypt)(data, keypair, recipients_keys);
        return (0, armor_1.armor)(encrypted, { message_type: armor_1.MessageType.ENCRYPTED_MESSAGE });
    });
}
function dearmorAndDecrypt(encrypted, keypair, sender) {
    return __awaiter(this, void 0, void 0, function* () {
        const dearmored = (0, armor_1.dearmor)(encrypted);
        return Object.assign(yield (0, encryption_1.decrypt)(dearmored, keypair, sender), {
            remaining: dearmored.remaining,
            header_info: dearmored.header_info,
        });
    });
}
class EncryptAndArmorStream extends pumpify_1.default {
    constructor(keypair, recipients_keys, armor_options) {
        const encrypt = new encryption_1.EncryptStream(keypair, recipients_keys);
        const armor = new armor_1.ArmorStream(Object.assign({
            message_type: armor_1.MessageType.ENCRYPTED_MESSAGE,
        }, armor_options));
        super(encrypt, armor);
    }
}
exports.EncryptAndArmorStream = EncryptAndArmorStream;
class DearmorAndDecryptStream extends pumpify_1.default {
    constructor(keypair, sender, armor_options) {
        const dearmor = new armor_1.DearmorStream(armor_options);
        const decrypt = new encryption_1.DecryptStream(keypair, sender);
        super(dearmor, decrypt);
        this.dearmor = dearmor;
        this.decrypt = decrypt;
    }
    get info() {
        return this.dearmor.info;
    }
    get sender_public_key() {
        return this.decrypt.sender_public_key;
    }
}
exports.DearmorAndDecryptStream = DearmorAndDecryptStream;
function signAndArmor(data, keypair) {
    return __awaiter(this, void 0, void 0, function* () {
        const signed = (0, signing_1.sign)(data, keypair);
        return (0, armor_1.armor)(signed, { message_type: armor_1.MessageType.SIGNED_MESSAGE });
    });
}
function verifyArmored(signed, public_key) {
    return __awaiter(this, void 0, void 0, function* () {
        const dearmored = (0, armor_1.dearmor)(signed);
        return Object.assign(yield (0, signing_1.verify)(dearmored, public_key), {
            remaining: dearmored.remaining,
            header_info: dearmored.header_info,
        });
    });
}
class SignAndArmorStream extends pumpify_1.default {
    constructor(keypair, armor_options) {
        const sign = new signing_1.SignStream(keypair);
        const armor = new armor_1.ArmorStream(Object.assign({
            message_type: armor_1.MessageType.SIGNED_MESSAGE,
        }, armor_options));
        super(sign, armor);
    }
}
exports.SignAndArmorStream = SignAndArmorStream;
class DearmorAndVerifyStream extends pumpify_1.default {
    constructor(public_key, armor_options) {
        const dearmor = new armor_1.DearmorStream(armor_options);
        const verify = new signing_1.VerifyStream(public_key);
        super(dearmor, verify);
        this.dearmor = dearmor;
        this.verify = verify;
    }
    get info() {
        return this.dearmor.info;
    }
    get public_key() {
        return this.verify.public_key;
    }
}
exports.DearmorAndVerifyStream = DearmorAndVerifyStream;
function signDetachedAndArmor(data, keypair) {
    return __awaiter(this, void 0, void 0, function* () {
        const signed = (0, signing_1.signDetached)(data, keypair);
        return (0, armor_1.armor)(signed, { message_type: armor_1.MessageType.DETACHED_SIGNATURE });
    });
}
function verifyDetachedArmored(signature, data, public_key) {
    return __awaiter(this, void 0, void 0, function* () {
        const dearmored = (0, armor_1.dearmor)(signature);
        const result = yield (0, signing_1.verifyDetached)(dearmored, data, public_key);
        return {
            remaining: dearmored.remaining,
            header_info: dearmored.header_info,
            public_key: result.public_key,
        };
    });
}
function signcryptAndArmor(data, keypair, recipients_keys) {
    return __awaiter(this, void 0, void 0, function* () {
        const encrypted = yield (0, signcryption_1.signcrypt)(data, keypair, recipients_keys);
        return (0, armor_1.armor)(encrypted, { message_type: armor_1.MessageType.ENCRYPTED_MESSAGE });
    });
}
function dearmorAndDesigncrypt(signcrypted, keypair, sender) {
    return __awaiter(this, void 0, void 0, function* () {
        const dearmored = (0, armor_1.dearmor)(signcrypted);
        return Object.assign(yield (0, signcryption_1.designcrypt)(dearmored, keypair, sender), {
            remaining: dearmored.remaining,
            header_info: dearmored.header_info,
        });
    });
}
class SigncryptAndArmorStream extends pumpify_1.default {
    constructor(keypair, recipients_keys, armor_options) {
        const encrypt = new signcryption_1.SigncryptStream(keypair, recipients_keys);
        const armor = new armor_1.ArmorStream(Object.assign({
            message_type: armor_1.MessageType.ENCRYPTED_MESSAGE,
        }, armor_options));
        super(encrypt, armor);
    }
}
exports.SigncryptAndArmorStream = SigncryptAndArmorStream;
class DearmorAndDesigncryptStream extends pumpify_1.default {
    constructor(keys, armor_options) {
        const dearmor = new armor_1.DearmorStream(armor_options);
        const decrypt = new signcryption_1.DesigncryptStream(keys);
        super(dearmor, decrypt);
        this.dearmor = dearmor;
        this.decrypt = decrypt;
    }
    get info() {
        return this.dearmor.info;
    }
    get sender_public_key() {
        return this.decrypt.sender_public_key;
    }
}
exports.DearmorAndDesigncryptStream = DearmorAndDesigncryptStream;
//# sourceMappingURL=with-armor.js.map

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js");
var _require2 = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js").types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__(/*! object.assign/polyfill */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js")();
var objectIs = __webpack_require__(/*! object-is/polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js")();
var RegExpPrototypeTest = __webpack_require__(/*! call-bind/callBound */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js")('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js");
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require.inspect;
var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js");
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js").types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = __webpack_require__(/*! possible-typed-array-names */ "./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__(/*! ./reflectApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js ***!
  \****************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js");

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var applyBind = __webpack_require__(/*! call-bind-apply-helpers/applyBind */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js");

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Commented = __webpack_require__(/*! ./commented */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js");
const Diagnose = __webpack_require__(/*! ./diagnose */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const Simple = __webpack_require__(/*! ./simple */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js");
const Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js");
const Map = __webpack_require__(/*! ./map */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js");
const SharedValueEncoder = __webpack_require__(/*! ./sharedValueEncoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js");

module.exports = {
  Commented,
  Diagnose,
  Decoder,
  Encoder,
  Simple,
  Tagged,
  Map,
  SharedValueEncoder,

  /**
   * Convenience name for {@linkcode Commented.comment}.
   */
  comment: Commented.comment,

  /**
   * Convenience name for {@linkcode Decoder.decodeAll}.
   */
  decodeAll: Decoder.decodeAll,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirst}.
   */
  decodeFirst: Decoder.decodeFirst,

  /**
   * Convenience name for {@linkcode Decoder.decodeAllSync}.
   */
  decodeAllSync: Decoder.decodeAllSync,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirstSync}.
   */
  decodeFirstSync: Decoder.decodeFirstSync,

  /**
   * Convenience name for {@linkcode Diagnose.diagnose}.
   */
  diagnose: Diagnose.diagnose,

  /**
   * Convenience name for {@linkcode Encoder.encode}.
   */
  encode: Encoder.encode,

  /**
   * Convenience name for {@linkcode Encoder.encodeCanonical}.
   */
  encodeCanonical: Encoder.encodeCanonical,

  /**
   * Convenience name for {@linkcode Encoder.encodeOne}.
   */
  encodeOne: Encoder.encodeOne,

  /**
   * Convenience name for {@linkcode Encoder.encodeAsync}.
   */
  encodeAsync: Encoder.encodeAsync,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirstSync}.
   */
  decode: Decoder.decodeFirstSync,

  /**
   * The codec information for
   * {@link https://github.com/Level/encoding-down encoding-down}, which is a
   * codec framework for leveldb.  CBOR is a particularly convenient format for
   * both keys and values, as it can deal with a lot of types that JSON can't
   * handle without losing type information.
   *
   * @example
   * const level = require('level')
   * const cbor = require('cbor')
   *
   * async function putget() {
   *   const db = level('./db', {
   *     keyEncoding: cbor.leveldb,
   *     valueEncoding: cbor.leveldb,
   *   })
   *
   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)
   *   const val = await db.get({a: 1})
   * }
   */
  leveldb: {
    decode: Decoder.decodeFirstSync,
    encode: Encoder.encode,
    buffer: true,
    name: 'cbor',
  },

  /**
   * Reset everything that we can predict a plugin might have altered in good
   * faith.  For now that includes the default set of tags that decoding and
   * encoding will use.
   */
  reset() {
    Encoder.reset();
    Tagged.reset();
  },
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const {MT, NUMBYTES, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

function plural(c) {
  if (c > 1) {
    return 's';
  }
  return '';
}

/**
 * @typedef CommentOptions
 * @property {number} [max_depth=10] How many times to indent
 *   the dashes.
 * @property {number} [depth=1] Initial indentation depth.
 * @property {boolean} [no_summary=false] If true, omit the summary
 *   of the full bytes read at the end.
 * @property {object} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it
 *   is a string.
 */
/**
 * @callback commentCallback
 * @param {Error} [error] If one was generated.
 * @param {string} [commented] The comment string.
 * @returns {void}
 */
/**
 * Normalize inputs to the static functions.
 *
 * @param {CommentOptions|commentCallback|string|number} opts Encoding,
 *   max_depth, or callback.
 * @param {commentCallback} [cb] Called on completion.
 * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.
 * @throws {TypeError} Unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {commentCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'number':
      return {options: {max_depth: opts}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Generate the expanded format of RFC 8949, section 3.2.2.
 *
 * @extends stream.Transform
 */
class Commented extends stream.Transform {
  /**
   * Create a CBOR commenter.
   *
   * @param {CommentOptions} [options={}] Stream options.
   */
  constructor(options = {}) {
    const {
      depth = 1,
      max_depth = 10,
      no_summary = false,
      // Decoder options
      tags = {},
      preferWeb,
      encoding,
      // Stream.Transform options
      ...superOpts
    } = options;

    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: false,
    });

    this.depth = depth;
    this.max_depth = max_depth;
    this.all = new NoFilter();

    if (!tags[24]) {
      tags[24] = this._tag_24.bind(this);
    }
    this.parser = new Decoder({
      tags,
      max_depth,
      preferWeb,
      encoding,
    });
    this.parser.on('value', this._on_value.bind(this));
    this.parser.on('start', this._on_start.bind(this));
    this.parser.on('start-string', this._on_start_string.bind(this));
    this.parser.on('stop', this._on_stop.bind(this));
    this.parser.on('more-bytes', this._on_more.bind(this));
    this.parser.on('error', this._on_error.bind(this));
    if (!no_summary) {
      this.parser.on('data', this._on_data.bind(this));
    }
    this.parser.bs.on('read', this._on_read.bind(this));
  }

  /**
   * @param {Buffer} v Descend into embedded CBOR.
   * @private
   */
  _tag_24(v) {
    const c = new Commented({depth: this.depth + 1, no_summary: true});

    c.on('data', b => this.push(b));
    c.on('error', er => this.emit('error', er));
    c.end(v);
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    // TODO: find the test that covers this, and look at the return value
    return this.parser._flush(cb);
  }

  /**
   * Comment on an input Buffer or string, creating a string passed to the
   * callback.  If callback not specified, a promise is returned.
   *
   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray
   *   |DataView|stream.Readable} input Something to parse.
   * @param {CommentOptions|commentCallback|string|number} [options={}]
   *   Encoding, max_depth, or callback.
   * @param {commentCallback} [cb] If specified, called on completion.
   * @returns {Promise} If cb not specified.
   * @throws {Error} Input required.
   */
  static comment(input, options = {}, cb = null) {
    if (input == null) {
      throw new Error('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const bs = new NoFilter();
    const {encoding = 'hex', ...opts} = options;
    const d = new Commented(opts);
    let p = null;

    if (typeof cb === 'function') {
      d.on('end', () => {
        cb(null, bs.toString('utf8'));
      });
      d.on('error', cb);
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => {
          resolve(bs.toString('utf8'));
        });
        d.on('error', reject);
      });
    }
    d.pipe(bs);
    utils.guessEncoding(input, encoding).pipe(d);
    return p;
  }

  /**
   * @ignore
   */
  _on_error(er) {
    this.push('ERROR: ');
    this.push(er.toString());
    this.push('\n');
  }

  /**
   * @ignore
   */
  _on_read(buf) {
    this.all.write(buf);
    const hex = buf.toString('hex');

    this.push(new Array(this.depth + 1).join('  '));
    this.push(hex);

    let ind = ((this.max_depth - this.depth) * 2) - hex.length;
    if (ind < 1) {
      ind = 1;
    }
    this.push(new Array(ind + 1).join(' '));
    this.push('-- ');
  }

  /**
   * @ignore
   */
  _on_more(mt, len, _parent_mt, _pos) {
    let desc = '';

    this.depth++;
    switch (mt) {
      case MT.POS_INT:
        desc = 'Positive number,';
        break;
      case MT.NEG_INT:
        desc = 'Negative number,';
        break;
      case MT.ARRAY:
        desc = 'Array, length';
        break;
      case MT.MAP:
        desc = 'Map, count';
        break;
      case MT.BYTE_STRING:
        desc = 'Bytes, length';
        break;
      case MT.UTF8_STRING:
        desc = 'String, length';
        break;
      case MT.SIMPLE_FLOAT:
        if (len === 1) {
          desc = 'Simple value,';
        } else {
          desc = 'Float,';
        }
        break;
    }
    this.push(`${desc} next ${len} byte${plural(len)}\n`);
  }

  /**
   * @ignore
   */
  _on_start_string(mt, len, _parent_mt, _pos) {
    let desc = '';

    this.depth++;
    switch (mt) {
      case MT.BYTE_STRING:
        desc = `Bytes, length: ${len}`;
        break;
      case MT.UTF8_STRING:
        desc = `String, length: ${len.toString()}`;
        break;
    }
    this.push(`${desc}\n`);
  }

  /**
   * @ignore
   */
  _on_start(mt, tag, parent_mt, pos) {
    this.depth++;
    switch (parent_mt) {
      case MT.ARRAY:
        this.push(`[${pos}], `);
        break;
      case MT.MAP:
        if (pos % 2) {
          this.push(`{Val:${Math.floor(pos / 2)}}, `);
        } else {
          this.push(`{Key:${Math.floor(pos / 2)}}, `);
        }
        break;
    }
    switch (mt) {
      case MT.TAG:
        this.push(`Tag #${tag}`);
        if (tag === 24) {
          this.push(' Encoded CBOR data item');
        }
        break;
      case MT.ARRAY:
        if (tag === SYMS.STREAM) {
          this.push('Array (streaming)');
        } else {
          this.push(`Array, ${tag} item${plural(tag)}`);
        }
        break;
      case MT.MAP:
        if (tag === SYMS.STREAM) {
          this.push('Map (streaming)');
        } else {
          this.push(`Map, ${tag} pair${plural(tag)}`);
        }
        break;
      case MT.BYTE_STRING:
        this.push('Bytes (streaming)');
        break;
      case MT.UTF8_STRING:
        this.push('String (streaming)');
        break;
    }
    this.push('\n');
  }

  /**
   * @ignore
   */
  _on_stop(_mt) {
    this.depth--;
  }

  /**
   * @private
   */
  _on_value(val, parent_mt, pos, ai) {
    if (val !== SYMS.BREAK) {
      switch (parent_mt) {
        case MT.ARRAY:
          this.push(`[${pos}], `);
          break;
        case MT.MAP:
          if (pos % 2) {
            this.push(`{Val:${Math.floor(pos / 2)}}, `);
          } else {
            this.push(`{Key:${Math.floor(pos / 2)}}, `);
          }
          break;
      }
    }
    const str = utils.cborValueToString(val, -Infinity);

    if ((typeof val === 'string') ||
        (Buffer.isBuffer(val))) {
      if (val.length > 0) {
        this.push(str);
        this.push('\n');
      }
      this.depth--;
    } else {
      this.push(str);
      this.push('\n');
    }

    switch (ai) {
      case NUMBYTES.ONE:
      case NUMBYTES.TWO:
      case NUMBYTES.FOUR:
      case NUMBYTES.EIGHT:
        this.depth--;
    }
  }

  /**
   * @ignore
   */
  _on_data() {
    this.push('0x');
    this.push(this.all.read().toString('hex'));
    this.push('\n');
  }
}

module.exports = Commented;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @enum {number}
 */
exports.MT = {
  POS_INT: 0,
  NEG_INT: 1,
  BYTE_STRING: 2,
  UTF8_STRING: 3,
  ARRAY: 4,
  MAP: 5,
  TAG: 6,
  SIMPLE_FLOAT: 7,
};

/**
 * @enum {number}
 */
exports.TAG = {
  DATE_STRING: 0,
  DATE_EPOCH: 1,
  POS_BIGINT: 2,
  NEG_BIGINT: 3,
  DECIMAL_FRAC: 4,
  BIGFLOAT: 5,
  BASE64URL_EXPECTED: 21,
  BASE64_EXPECTED: 22,
  BASE16_EXPECTED: 23,
  CBOR: 24,
  URI: 32,
  BASE64URL: 33,
  BASE64: 34,
  REGEXP: 35,
  MIME: 36,
  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  SET: 258,
};

/**
 * @enum {number}
 */
exports.NUMBYTES = {
  ZERO: 0,
  ONE: 24,
  TWO: 25,
  FOUR: 26,
  EIGHT: 27,
  INDEFINITE: 31,
};

/**
 * @enum {number}
 */
exports.SIMPLE = {
  FALSE: 20,
  TRUE: 21,
  NULL: 22,
  UNDEFINED: 23,
};

exports.SYMS = {
  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),
  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),
  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),
  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),
  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),
};

exports.SHIFT32 = 0x100000000;

exports.BI = {
  MINUS_ONE: BigInt(-1),
  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),
  MAXINT32: BigInt('0xffffffff'),
  MAXINT64: BigInt('0xffffffffffffffff'),
  SHIFT32: BigInt(exports.SHIFT32),
};



/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BinaryParseStream = __webpack_require__(/*! ../vendor/binary-parse-stream */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js");
const Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js");
const Simple = __webpack_require__(/*! ./simple */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {MT, NUMBYTES, SYMS, BI} = constants;
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

const COUNT = Symbol('count');
const MAJOR = Symbol('major type');
const ERROR = Symbol('error');
const NOT_FOUND = Symbol('not found');

function parentArray(parent, typ, count) {
  const a = [];

  a[COUNT] = count;
  a[SYMS.PARENT] = parent;
  a[MAJOR] = typ;
  return a;
}

function parentBufferStream(parent, typ) {
  const b = new NoFilter();

  b[COUNT] = -1;
  b[SYMS.PARENT] = parent;
  b[MAJOR] = typ;
  return b;
}

class UnexpectedDataError extends Error {
  constructor(byte, value) {
    super(`Unexpected data: 0x${byte.toString(16)}`);
    this.name = 'UnexpectedDataError';
    this.byte = byte;
    this.value = value;
  }
}

/**
 * Things that can act as inputs, from which a NoFilter can be created.
 *
 * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView
 *   |DataView|import('stream').Readable} BufferLike
 */
/**
 * @typedef ExtendedResults
 * @property {any} value The value that was found.
 * @property {number} length The number of bytes of the original input that
 *   were read.
 * @property {Buffer} bytes The bytes of the original input that were used
 *   to produce the value.
 * @property {Buffer} [unused] The bytes that were left over from the original
 *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or
 *   {@linkcode Decoder.decodeFirstSync} was called.
 */
/**
 * @typedef DecoderOptions
 * @property {number} [max_depth=-1] The maximum depth to parse.
 *   Use -1 for "until you run out of memory".  Set this to a finite
 *   positive number for un-trusted inputs.  Most standard inputs won't nest
 *   more than 100 or so levels; I've tested into the millions before
 *   running out of memory.
 * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferMap=false] If true, prefer to generate Map
 *   instances to plain objects, even if there are no entries in the map
 *   or if all of the keys are strings.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] The encoding of the input.
 *   Ignored if input is a Buffer.
 * @property {boolean} [required=false] Should an error be thrown when no
 *   data is in the input?
 * @property {boolean} [extendedResults=false] If true, emit extended
 *   results, which will be an object with shape {@link ExtendedResults}.
 *   The value will already have been null-checked.
 * @property {boolean} [preventDuplicateKeys=false] If true, error is
 *   thrown if a map has duplicate keys.
 */
/**
 * @callback decodeCallback
 * @param {Error} [error] If one was generated.
 * @param {any} [value] The decoded value.
 * @returns {void}
 */
/**
 * @param {DecoderOptions|decodeCallback|string} opts Options,
 *   the callback, or input incoding.
 * @param {decodeCallback} [cb] Called on completion.
 * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.
 * @throws {TypeError} On unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {decodeCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends BinaryParseStream
 */
class Decoder extends BinaryParseStream {
  /**
   * Create a parsing stream.
   *
   * @param {DecoderOptions} [options={}] Options.
   */
  constructor(options = {}) {
    const {
      tags = {},
      max_depth = -1,
      preferMap = false,
      preferWeb = false,
      required = false,
      encoding = 'hex',
      extendedResults = false,
      preventDuplicateKeys = false,
      ...superOpts
    } = options;

    super({defaultEncoding: encoding, ...superOpts});

    this.running = true;
    this.max_depth = max_depth;
    this.tags = tags;
    this.preferMap = preferMap;
    this.preferWeb = preferWeb;
    this.extendedResults = extendedResults;
    this.required = required;
    this.preventDuplicateKeys = preventDuplicateKeys;

    if (extendedResults) {
      this.bs.on('read', this._onRead.bind(this));
      this.valueBytes = /** @type {NoFilter} */ (new NoFilter());
    }
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @param {any} val The value to check.
   * @returns {any} The corrected value.
   * @throws {Error} Nothing was found.
   * @static
   * @example
   * myDecoder.on('data', val => {
   *   val = Decoder.nullcheck(val)
   *   // ...
   * })
   */
  static nullcheck(val) {
    switch (val) {
      case SYMS.NULL:
        return null;
      case SYMS.UNDEFINED:
        return undefined;
      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure
      // it can't happen.
      /* istanbul ignore next */
      case NOT_FOUND:
        /* istanbul ignore next */
        throw new Error('Value not found');
      default:
        return val;
    }
  }

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw
   * an exception if the input is not valid CBOR, or if there are more bytes
   * left over at the end (if options.extendedResults is not true).
   *
   * @param {BufferLike} input If a Readable stream, must have
   *   received the `readable` event already, or you will get an error
   *   claiming "Insufficient data".
   * @param {DecoderOptions|string} [options={}] Options or encoding for input.
   * @returns {ExtendedResults|any} The decoded value.
   * @throws {UnexpectedDataError} Data is left over after decoding.
   * @throws {Error} Insufficient data.
   */
  static decodeFirstSync(input, options = {}) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options} = normalizeOptions(options));
    const {encoding = 'hex', ...opts} = options;
    const c = new Decoder(opts);
    const s = utils.guessEncoding(input, encoding);

    // For/of doesn't work when you need to call next() with a value
    // generator created by parser will be "done" after each CBOR entity
    // parser will yield numbers of bytes that it wants
    const parser = c._parse();
    let state = parser.next();

    while (!state.done) {
      const b = s.read(state.value);

      if ((b == null) || (b.length !== state.value)) {
        throw new Error('Insufficient data');
      }
      if (c.extendedResults) {
        c.valueBytes.write(b);
      }
      state = parser.next(b);
    }

    let val = null;
    if (c.extendedResults) {
      val = state.value;
      val.unused = s.read();
    } else {
      val = Decoder.nullcheck(state.value);
      if (s.length > 0) {
        const nextByte = s.read(1);

        s.unshift(nextByte);
        throw new UnexpectedDataError(nextByte[0], val);
      }
    }
    return val;
  }

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|string} [options={}] Options or encoding
   *   for input.
   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.
   * @throws {TypeError} No input provided.
   * @throws {Error} Insufficient data provided.
   */
  static decodeAllSync(input, options = {}) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options} = normalizeOptions(options));
    const {encoding = 'hex', ...opts} = options;
    const c = new Decoder(opts);
    const s = utils.guessEncoding(input, encoding);
    const res = [];

    while (s.length > 0) {
      const parser = c._parse();
      let state = parser.next();

      while (!state.done) {
        const b = s.read(state.value);

        if ((b == null) || (b.length !== state.value)) {
          throw new Error('Insufficient data');
        }
        if (c.extendedResults) {
          c.valueBytes.write(b);
        }
        state = parser.next(b);
      }
      res.push(Decoder.nullcheck(state.value));
    }
    return res;
  }

  /**
   * Decode the first CBOR item in the input.  This will error if there are
   * more bytes left over at the end (if options.extendedResults is not true),
   * and optionally if there were no valid CBOR bytes in the input.  Emits the
   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the
   * `required` option is false.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the
   *   callback, or input encoding.
   * @param {decodeCallback} [cb] Callback.
   * @returns {Promise<ExtendedResults|any>} Returned even if callback is
   *   specified.
   * @throws {TypeError} No input provided.
   */
  static decodeFirst(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', required = false, ...opts} = options;

    const c = new Decoder(opts);
    let v = /** @type {any} */ (NOT_FOUND);
    const s = utils.guessEncoding(input, encoding);
    const p = new Promise((resolve, reject) => {
      c.on('data', val => {
        v = Decoder.nullcheck(val);
        c.close();
      });
      c.once('error', er => {
        if (c.extendedResults && (er instanceof UnexpectedDataError)) {
          v.unused = c.bs.slice();
          return resolve(v);
        }
        if (v !== NOT_FOUND) {
          // Typescript work-around
          // eslint-disable-next-line dot-notation
          er['value'] = v;
        }
        v = ERROR;
        c.close();
        return reject(er);
      });
      c.once('end', () => {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return reject(new Error('No CBOR found'));
            }
            return resolve(v);
          // Pretty sure this can't happen, but not *certain*.
          /* istanbul ignore next */
          case ERROR:
            /* istanbul ignore next */
            return undefined;
          default:
            return resolve(v);
        }
      });
    });

    if (typeof cb === 'function') {
      p.then(val => cb(null, val), cb);
    }
    s.pipe(c);
    return p;
  }

  /**
   * @callback decodeAllCallback
   * @param {Error} error If one was generated.
   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded
   *   values, wrapped in an Array.
   */

  /**
   * Decode all of the CBOR items in the input.  This will error if there are
   * more bytes left over at the end.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|decodeAllCallback|string} [options={}]
   *   Decoding options, the callback, or the input encoding.
   * @param {decodeAllCallback} [cb] Callback.
   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback
   *   is specified.
   * @throws {TypeError} No input specified.
   */
  static decodeAll(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', ...opts} = options;

    const c = new Decoder(opts);
    const vals = [];

    c.on('data', val => vals.push(Decoder.nullcheck(val)));

    const p = new Promise((resolve, reject) => {
      c.on('error', reject);
      c.on('end', () => resolve(vals));
    });

    if (typeof cb === 'function') {
      p.then(v => cb(undefined, v), er => cb(er, undefined));
    }
    utils.guessEncoding(input, encoding).pipe(c);
    return p;
  }

  /**
   * Stop processing.
   */
  close() {
    this.running = false;
    this.__fresh = true;
  }

  /**
   * Only called if extendedResults is true.
   *
   * @ignore
   */
  _onRead(data) {
    this.valueBytes.write(data);
  }

  /**
   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,
   *   returns anything, next returns a Buffer.
   * @throws {Error} Maximum depth exceeded.
   * @yields {number} Number of bytes to read.
   * @ignore
   */
  *_parse() {
    let parent = null;
    let depth = 0;
    let val = null;

    while (true) {
      if ((this.max_depth >= 0) && (depth > this.max_depth)) {
        throw new Error(`Maximum depth ${this.max_depth} exceeded`);
      }

      const [octet] = yield 1;
      if (!this.running) {
        this.bs.unshift(Buffer.from([octet]));
        throw new UnexpectedDataError(octet);
      }
      const mt = octet >> 5;
      const ai = octet & 0x1f;
      const parent_major = (parent == null) ? undefined : parent[MAJOR];
      const parent_length = (parent == null) ? undefined : parent.length;

      switch (ai) {
        case NUMBYTES.ONE:
          this.emit('more-bytes', mt, 1, parent_major, parent_length);
          [val] = yield 1;
          break;
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT: {
          const numbytes = 1 << (ai - 24);

          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);
          const buf = yield numbytes;
          val = (mt === MT.SIMPLE_FLOAT) ?
            buf :
            utils.parseCBORint(ai, buf);
          break;
        }
        case 28:
        case 29:
        case 30:
          this.running = false;
          throw new Error(`Additional info not implemented: ${ai}`);
        case NUMBYTES.INDEFINITE:
          switch (mt) {
            case MT.POS_INT:
            case MT.NEG_INT:
            case MT.TAG:
              throw new Error(`Invalid indefinite encoding for MT ${mt}`);
          }
          val = -1;
          break;
        default:
          val = ai;
      }
      switch (mt) {
        case MT.POS_INT:
          // Val already decoded
          break;
        case MT.NEG_INT:
          if (val === Number.MAX_SAFE_INTEGER) {
            val = BI.NEG_MAX;
          } else {
            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val;
          }
          break;
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          switch (val) {
            case 0:
              this.emit('start-string', mt, val, parent_major, parent_length);
              if (mt === MT.UTF8_STRING) {
                val = '';
              } else {
                val = this.preferWeb ?
                  new Uint8Array(0) :
                  Buffer.allocUnsafe(0);
              }
              break;
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentBufferStream(parent, mt);
              depth++;
              continue;
            default:
              this.emit('start-string', mt, val, parent_major, parent_length);
              val = yield val;
              if (mt === MT.UTF8_STRING) {
                val = utils.utf8(val);
              } else if (this.preferWeb) {
                val = new Uint8Array(val.buffer, val.byteOffset, val.length);
              }
          }
          break;
        case MT.ARRAY:
        case MT.MAP:
          switch (val) {
            case 0:
              if (mt === MT.MAP) {
                val = (this.preferMap) ? new Map() : {};
              } else {
                val = [];
              }
              break;
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentArray(parent, mt, -1);
              depth++;
              continue;
            default:
              this.emit('start', mt, val, parent_major, parent_length);
              parent = parentArray(parent, mt, val * (mt - 3));
              depth++;
              continue;
          }
          break;
        case MT.TAG:
          this.emit('start', mt, val, parent_major, parent_length);
          parent = parentArray(parent, mt, 1);
          parent.push(val);
          depth++;
          continue;
        case MT.SIMPLE_FLOAT:
          if (typeof val === 'number') {
            if ((ai === NUMBYTES.ONE) && (val < 32)) {
              throw new Error(
                `Invalid two-byte encoding of simple value ${val}`
              );
            }
            const hasParent = (parent != null);
            val = Simple.decode(
              val,
              hasParent,
              hasParent && (parent[COUNT] < 0)
            );
          } else {
            val = utils.parseCBORfloat(val);
          }
      }
      this.emit('value', val, parent_major, parent_length, ai);
      let again = false;
      while (parent != null) {
        if (val === SYMS.BREAK) {
          parent[COUNT] = 1;
        } else if (Array.isArray(parent)) {
          parent.push(val);
        } else {
          // Assert: parent instanceof NoFilter
          const pm = parent[MAJOR];

          if ((pm != null) && (pm !== mt)) {
            this.running = false;
            throw new Error('Invalid major type in indefinite encoding');
          }
          parent.write(val);
        }

        if ((--parent[COUNT]) !== 0) {
          again = true;
          break;
        }
        --depth;
        delete parent[COUNT];

        if (Array.isArray(parent)) {
          switch (parent[MAJOR]) {
            case MT.ARRAY:
              val = parent;
              break;
            case MT.MAP: {
              let allstrings = !this.preferMap;

              if ((parent.length % 2) !== 0) {
                throw new Error(`Invalid map length: ${parent.length}`);
              }
              for (
                let i = 0, len = parent.length;
                allstrings && (i < len);
                i += 2
              ) {
                if ((typeof parent[i] !== 'string') ||
                    (parent[i] === '__proto__')) {
                  allstrings = false;
                  break;
                }
              }
              if (allstrings) {
                val = {};
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  if (this.preventDuplicateKeys &&
                    Object.prototype.hasOwnProperty.call(val, parent[i])) {
                    throw new Error('Duplicate keys in a map');
                  }
                  val[parent[i]] = parent[i + 1];
                }
              } else {
                val = new Map();
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  if (this.preventDuplicateKeys && val.has(parent[i])) {
                    throw new Error('Duplicate keys in a map');
                  }
                  val.set(parent[i], parent[i + 1]);
                }
              }
              break;
            }
            case MT.TAG: {
              const t = new Tagged(parent[0], parent[1]);

              val = t.convert(this.tags);
              break;
            }
          }
        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {
          // Only parent types are Array and NoFilter for (Array/Map) and
          // (bytes/string) respectively.
          switch (parent[MAJOR]) {
            case MT.BYTE_STRING:
              val = parent.slice();
              if (this.preferWeb) {
                val = new Uint8Array(
                  /** @type {Buffer} */ (val).buffer,
                  /** @type {Buffer} */ (val).byteOffset,
                  /** @type {Buffer} */ (val).length
                );
              }
              break;
            case MT.UTF8_STRING:
              val = parent.toString('utf-8');
              break;
          }
        }
        this.emit('stop', parent[MAJOR]);

        const old = parent;
        parent = parent[SYMS.PARENT];
        delete old[SYMS.PARENT];
        delete old[MAJOR];
      }
      if (!again) {
        if (this.extendedResults) {
          const bytes = this.valueBytes.slice();
          const ret = {
            value: Decoder.nullcheck(val),
            bytes,
            length: bytes.length,
          };

          this.valueBytes = new NoFilter();
          return ret;
        }
        return val;
      }
    }
  }
}

Decoder.NOT_FOUND = NOT_FOUND;
module.exports = Decoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const {MT, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * Things that can act as inputs, from which a NoFilter can be created.
 *
 * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView
 *   |DataView|stream.Readable} BufferLike
 */

/**
 * @typedef DiagnoseOptions
 * @property {string} [separator='\n'] Output between detected objects.
 * @property {boolean} [stream_errors=false] Put error info into the
 *   output stream.
 * @property {number} [max_depth=-1] The maximum depth to parse.
 *   Use -1 for "until you run out of memory".  Set this to a finite
 *   positive number for un-trusted inputs.  Most standard inputs won't nest
 *   more than 100 or so levels; I've tested into the millions before
 *   running out of memory.
 * @property {object} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if
 *   input is not string.
 */
/**
 * @callback diagnoseCallback
 * @param {Error} [error] If one was generated.
 * @param {string} [value] The diagnostic value.
 * @returns {void}
 */
/**
 * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,
 *   the callback, or input incoding.
 * @param {diagnoseCallback} [cb] Called on completion.
 * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.
 * @throws {TypeError} Unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 * @extends stream.Transform
 */
class Diagnose extends stream.Transform {
  /**
   * Creates an instance of Diagnose.
   *
   * @param {DiagnoseOptions} [options={}] Options for creation.
   */
  constructor(options = {}) {
    const {
      separator = '\n',
      stream_errors = false,
      // Decoder options
      tags,
      max_depth,
      preferWeb,
      encoding,
      // Stream.Transform options
      ...superOpts
    } = options;
    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: false,
    });

    this.float_bytes = -1;
    this.separator = separator;
    this.stream_errors = stream_errors;
    this.parser = new Decoder({
      tags,
      max_depth,
      preferWeb,
      encoding,
    });
    this.parser.on('more-bytes', this._on_more.bind(this));
    this.parser.on('value', this._on_value.bind(this));
    this.parser.on('start', this._on_start.bind(this));
    this.parser.on('stop', this._on_stop.bind(this));
    this.parser.on('data', this._on_data.bind(this));
    this.parser.on('error', this._on_error.bind(this));
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    this.parser._flush(er => {
      if (this.stream_errors) {
        if (er) {
          this._on_error(er);
        }
        return cb();
      }
      return cb(er);
    });
  }

  /**
   * Convenience function to return a string in diagnostic format.
   *
   * @param {BufferLike} input The CBOR bytes to format.
   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]
   *   Options, the callback, or the input encoding.
   * @param {diagnoseCallback} [cb] Callback.
   * @returns {Promise} If callback not specified.
   * @throws {TypeError} Input not provided.
   */
  static diagnose(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', ...opts} = options;

    const bs = new NoFilter();
    const d = new Diagnose(opts);
    let p = null;
    if (typeof cb === 'function') {
      d.on('end', () => cb(null, bs.toString('utf8')));
      d.on('error', cb);
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => resolve(bs.toString('utf8')));
        d.on('error', reject);
      });
    }
    d.pipe(bs);
    utils.guessEncoding(input, encoding).pipe(d);
    return p;
  }

  /**
   * @ignore
   */
  _on_error(er) {
    if (this.stream_errors) {
      this.push(er.toString());
    } else {
      this.emit('error', er);
    }
  }

  /** @private */
  _on_more(mt, len, _parent_mt, _pos) {
    if (mt === MT.SIMPLE_FLOAT) {
      this.float_bytes = {
        2: 1,
        4: 2,
        8: 3,
      }[len];
    }
  }

  /** @private */
  _fore(parent_mt, pos) {
    switch (parent_mt) {
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
      case MT.ARRAY:
        if (pos > 0) {
          this.push(', ');
        }
        break;
      case MT.MAP:
        if (pos > 0) {
          if (pos % 2) {
            this.push(': ');
          } else {
            this.push(', ');
          }
        }
    }
  }

  /** @private */
  _on_value(val, parent_mt, pos) {
    if (val === SYMS.BREAK) {
      return;
    }
    this._fore(parent_mt, pos);
    const fb = this.float_bytes;
    this.float_bytes = -1;
    this.push(utils.cborValueToString(val, fb));
  }

  /** @private */
  _on_start(mt, tag, parent_mt, pos) {
    this._fore(parent_mt, pos);
    switch (mt) {
      case MT.TAG:
        this.push(`${tag}(`);
        break;
      case MT.ARRAY:
        this.push('[');
        break;
      case MT.MAP:
        this.push('{');
        break;
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        this.push('(');
        break;
    }
    if (tag === SYMS.STREAM) {
      this.push('_ ');
    }
  }

  /** @private */
  _on_stop(mt) {
    switch (mt) {
      case MT.TAG:
        this.push(')');
        break;
      case MT.ARRAY:
        this.push(']');
        break;
      case MT.MAP:
        this.push('}');
        break;
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        this.push(')');
        break;
    }
  }

  /** @private */
  _on_data() {
    this.push(this.separator);
  }
}

module.exports = Diagnose;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {
  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,
} = constants;
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

const HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO;
const FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR;
const DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT;
const TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE;
const FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE;
const UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED;
const NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL;

const BREAK = Buffer.from([0xff]);
const BUF_NAN = Buffer.from('f97e00', 'hex');
const BUF_INF_NEG = Buffer.from('f9fc00', 'hex');
const BUF_INF_POS = Buffer.from('f97c00', 'hex');
const BUF_NEG_ZERO = Buffer.from('f98000', 'hex');

/**
 * Generate the CBOR for a value.  If you are using this, you'll either need
 * to call {@link Encoder.write} with a Buffer, or look into the internals of
 * Encoder to reuse existing non-documented behavior.
 *
 * @callback EncodeFunction
 * @param {Encoder} enc The encoder to use.
 * @param {any} val The value to encode.
 * @returns {boolean} True on success.
 */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, EncodeFunction>} SemanticMap
 */

/**
 * @type {SemanticMap}
 * @private
 */
const SEMANTIC_TYPES = {};

/**
 * @type {SemanticMap}
 * @private
 */
let current_SEMANTIC_TYPES = {};

/**
 * @param {string} str String to normalize.
 * @returns {"number"|"float"|"int"|"string"} Normalized.
 * @throws {TypeError} Invalid input.
 * @private
 */
function parseDateType(str) {
  if (!str) {
    return 'number';
  }
  switch (str.toLowerCase()) {
    case 'number':
      return 'number';
    case 'float':
      return 'float';
    case 'int':
    case 'integer':
      return 'int';
    case 'string':
      return 'string';
  }
  throw new TypeError(`dateType invalid, got "${str}"`);
}

/**
 * @typedef ObjectOptions
 * @property {boolean} [indefinite = false] Force indefinite encoding for this
 *   object.
 * @property {boolean} [skipTypes = false] Do not use available type mappings
 *   for this object, but encode it as a "normal" JS object would be.
 */

/**
 * @typedef EncodingOptions
 * @property {any[]|object} [genTypes=[]] Array of pairs of
 *   `type`, `function(Encoder)` for semantic types to be encoded.  Not
 *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.
 *   If an object, the keys are the constructor names for the types.
 * @property {boolean} [canonical=false] Should the output be
 *   canonicalized.
 * @property {boolean|WeakSet} [detectLoops=false] Should object loops
 *   be detected?  This will currently add memory to track every part of the
 *   object being encoded in a WeakSet.  Do not encode
 *   the same object twice on the same encoder, without calling
 *   `removeLoopDetectors` in between, which will clear the WeakSet.
 *   You may pass in your own WeakSet to be used; this is useful in some
 *   recursive scenarios.
 * @property {("number"|"float"|"int"|"string")} [dateType="number"] -
 *   how should dates be encoded?  "number" means float or int, if no
 *   fractional seconds.
 * @property {any} [encodeUndefined=undefined] How should an
 *   "undefined" in the input be encoded.  By default, just encode a CBOR
 *   undefined.  If this is a buffer, use those bytes without re-encoding
 *   them.  If this is a function, the function will be called (which is a
 *   good time to throw an exception, if that's what you want), and the
 *   return value will be used according to these rules.  Anything else will
 *   be encoded as CBOR.
 * @property {boolean} [disallowUndefinedKeys=false] Should
 *   "undefined" be disallowed as a key in a Map that is serialized?  If
 *   this is true, encode(new Map([[undefined, 1]])) will throw an
 *   exception.  Note that it is impossible to get a key of undefined in a
 *   normal JS object.
 * @property {boolean} [collapseBigIntegers=false] Should integers
 *   that come in as ECMAscript bigint's be encoded
 *   as normal CBOR integers if they fit, discarding type information?
 * @property {number} [chunkSize=4096] Number of characters or bytes
 *   for each chunk, if obj is a string or Buffer, when indefinite encoding.
 * @property {boolean} [omitUndefinedProperties=false] When encoding
 *   objects or Maps, do not include a key if its corresponding value is
 *   `undefined`.
 */

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends stream.Transform
 */
class Encoder extends stream.Transform {
  /**
   * Creates an instance of Encoder.
   *
   * @param {EncodingOptions} [options={}] Options for the encoder.
   */
  constructor(options = {}) {
    const {
      canonical = false,
      encodeUndefined,
      disallowUndefinedKeys = false,
      dateType = 'number',
      collapseBigIntegers = false,
      detectLoops = false,
      omitUndefinedProperties = false,
      genTypes = [],
      ...superOpts
    } = options;

    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: true,
    });

    this.canonical = canonical;
    this.encodeUndefined = encodeUndefined;
    this.disallowUndefinedKeys = disallowUndefinedKeys;
    this.dateType = parseDateType(dateType);
    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;

    /** @type {WeakSet?} */
    this.detectLoops = undefined;
    if (typeof detectLoops === 'boolean') {
      if (detectLoops) {
        this.detectLoops = new WeakSet();
      }
    } else if (detectLoops instanceof WeakSet) {
      this.detectLoops = detectLoops;
    } else {
      throw new TypeError('detectLoops must be boolean or WeakSet');
    }
    this.omitUndefinedProperties = omitUndefinedProperties;

    this.semanticTypes = {...Encoder.SEMANTIC_TYPES};

    if (Array.isArray(genTypes)) {
      for (let i = 0, len = genTypes.length; i < len; i += 2) {
        this.addSemanticType(genTypes[i], genTypes[i + 1]);
      }
    } else {
      for (const [k, v] of Object.entries(genTypes)) {
        this.addSemanticType(k, v);
      }
    }
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} _encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, _encoding, cb) {
    const ret = this.pushAny(fresh);
    // Old transformers might not return bool.  undefined !== false
    cb((ret === false) ? new Error('Push Error') : undefined);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  // eslint-disable-next-line class-methods-use-this
  _flush(cb) {
    cb();
  }

  /**
   * @param {number} val Number(0-255) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt8(val) {
    const b = Buffer.allocUnsafe(1);
    b.writeUInt8(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number(0-65535) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt16BE(val) {
    const b = Buffer.allocUnsafe(2);
    b.writeUInt16BE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number(0..2**32-1) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt32BE(val) {
    const b = Buffer.allocUnsafe(4);
    b.writeUInt32BE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number to encode as 4-byte float.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushFloatBE(val) {
    const b = Buffer.allocUnsafe(4);
    b.writeFloatBE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number to encode as 8-byte double.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushDoubleBE(val) {
    const b = Buffer.allocUnsafe(8);
    b.writeDoubleBE(val, 0);
    return this.push(b);
  }

  /**
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNaN() {
    return this.push(BUF_NAN);
  }

  /**
   * @param {number} obj Positive or negative infinity.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushInfinity(obj) {
    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS;
    return this.push(half);
  }

  /**
   * Choose the best float representation for a number and encode it.
   *
   * @param {number} obj A number that is known to be not-integer, but not
   *   how many bytes of precision it needs.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushFloat(obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It's certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      const b2 = Buffer.allocUnsafe(2);
      if (utils.writeHalf(b2, obj)) {
        // I have convinced myself that there are no cases where writeHalf
        // will return true but `utils.parseHalf(b2) !== obj)`
        return this._pushUInt8(HALF) && this.push(b2);
      }
    }
    if (Math.fround(obj) === obj) {
      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
    }

    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
  }

  /**
   * Choose the best integer representation for a postive number and encode
   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I
   * don't remember why).
   *
   * @param {number} obj A positive number that is known to be an integer,
   *   but not how many bytes of precision it needs.
   * @param {number} mt The Major Type number to combine with the integer.
   *   Not yet shifted.
   * @param {number} [orig] The number before it was transformed to positive.
   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,
   *   then we'll encode this as a float rather than making the number
   *   negative again and losing precision.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushInt(obj, mt, orig) {
    const m = mt << 5;

    if (obj < 24) {
      return this._pushUInt8(m | obj);
    }
    if (obj <= 0xff) {
      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
    }
    if (obj <= 0xffff) {
      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
    }
    if (obj <= 0xffffffff) {
      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
    }
    let max = Number.MAX_SAFE_INTEGER;
    if (mt === MT.NEG_INT) {
      // Special case for Number.MIN_SAFE_INTEGER - 1
      max--;
    }
    if (obj <= max) {
      return this._pushUInt8(m | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&
        this._pushUInt32BE(obj % SHIFT32);
    }
    if (mt === MT.NEG_INT) {
      return this._pushFloat(orig);
    }
    return this._pushFloat(obj);
  }

  /**
   * Choose the best integer representation for a number and encode it.
   *
   * @param {number} obj A number that is known to be an integer,
   *   but not how many bytes of precision it needs.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushIntNum(obj) {
    if (Object.is(obj, -0)) {
      return this.push(BUF_NEG_ZERO);
    }

    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj);
    }
    return this._pushInt(obj, MT.POS_INT);
  }

  /**
   * @param {number} obj Plain JS number to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNumber(obj) {
    if (isNaN(obj)) {
      return this._pushNaN();
    }
    if (!isFinite(obj)) {
      return this._pushInfinity(obj);
    }
    if (Math.round(obj) === obj) {
      return this._pushIntNum(obj);
    }
    return this._pushFloat(obj);
  }

  /**
   * @param {string} obj String to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushString(obj) {
    const len = Buffer.byteLength(obj, 'utf8');
    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');
  }

  /**
   * @param {boolean} obj Bool to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE);
  }

  /**
   * @param {undefined} obj Ignored.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUndefined(obj) {
    switch (typeof this.encodeUndefined) {
      case 'undefined':
        return this._pushUInt8(UNDEFINED);
      case 'function':
        return this.pushAny(this.encodeUndefined(obj));
      case 'object': {
        const buf = utils.bufferishToBuffer(this.encodeUndefined);
        if (buf) {
          return this.push(buf);
        }
      }
    }
    return this.pushAny(this.encodeUndefined);
  }

  /**
   * @param {null} _obj Ignored.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNull(_obj) {
    return this._pushUInt8(NULL);
  }

  /**
   * @param {number} tag Tag number to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushTag(tag) {
    return this._pushInt(tag, MT.TAG);
  }

  /**
   * @param {bigint} obj BigInt to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushJSBigint(obj) {
    let m = MT.POS_INT;
    let tag = TAG.POS_BIGINT;
    // BigInt doesn't have -0
    if (obj < 0) {
      obj = -obj + BI.MINUS_ONE;
      m = MT.NEG_INT;
      tag = TAG.NEG_BIGINT;
    }

    if (this.collapseBigIntegers &&
        (obj <= BI.MAXINT64)) {
      // Special handiling for 64bits
      if (obj <= 0xffffffff) {
        return this._pushInt(Number(obj), m);
      }
      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&
        this._pushUInt32BE(Number(obj % BI.SHIFT32));
    }

    let str = obj.toString(16);
    if (str.length % 2) {
      str = `0${str}`;
    }
    const buf = Buffer.from(str, 'hex');
    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);
  }

  /**
   * @param {object} obj Object to encode.
   * @param {ObjectOptions} [opts] Options for encoding this object.
   * @returns {boolean} True on success.
   * @throws {Error} Loop detected.
   * @ignore
   */
  _pushObject(obj, opts) {
    if (!obj) {
      return this._pushNull(obj);
    }
    opts = {
      indefinite: false,
      skipTypes: false,
      ...opts,
    };
    if (!opts.indefinite) {
      // This will only happen the first time through for indefinite encoding
      if (this.detectLoops) {
        if (this.detectLoops.has(obj)) {
          throw new Error(`\
Loop detected while CBOR encoding.
Call removeLoopDetectors before resuming.`);
        } else {
          this.detectLoops.add(obj);
        }
      }
    }
    if (!opts.skipTypes) {
      const f = obj.encodeCBOR;
      if (typeof f === 'function') {
        return f.call(obj, this);
      }
      const converter = this.semanticTypes[obj.constructor.name];
      if (converter) {
        return converter.call(obj, this, obj);
      }
    }
    const keys = Object.keys(obj).filter(k => {
      const tv = typeof obj[k];
      return (tv !== 'function') &&
        (!this.omitUndefinedProperties || (tv !== 'undefined'));
    });
    const cbor_keys = {};
    if (this.canonical) {
      // Note: this can't be a normal sort, because 'b' needs to sort before
      // 'aa'
      keys.sort((a, b) => {
        // Always strings, so don't bother to pass options.
        // hold on to the cbor versions, since there's no need
        // to encode more than once
        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));

        return a_cbor.compare(b_cbor);
      });
    }
    if (opts.indefinite) {
      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!this._pushInt(keys.length, MT.MAP)) {
      return false;
    }
    let ck = null;
    for (let j = 0, len2 = keys.length; j < len2; j++) {
      const k = keys[j];
      if (this.canonical && ((ck = cbor_keys[k]))) {
        if (!this.push(ck)) { // Already a Buffer
          return false;
        }
      } else if (!this._pushString(k)) {
        return false;
      }
      if (!this.pushAny(obj[k])) {
        return false;
      }
    }
    if (opts.indefinite) {
      if (!this.push(BREAK)) {
        return false;
      }
    } else if (this.detectLoops) {
      this.detectLoops.delete(obj);
    }
    return true;
  }

  /**
   * @param {any[]} objs Array of supported things.
   * @returns {Buffer} Concatenation of encodings for the supported things.
   * @ignore
   */
  _encodeAll(objs) {
    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});
    this.pipe(bs);
    for (const o of objs) {
      this.pushAny(o);
    }
    this.end();
    return bs.read();
  }

  /**
   * Add an encoding function to the list of supported semantic types.  This
   * is useful for objects for which you can't add an encodeCBOR method.
   *
   * @param {string|Function} type The type to encode.
   * @param {EncodeFunction} fun The encoder to use.
   * @returns {EncodeFunction?} The previous encoder or undefined if there
   *   wasn't one.
   * @throws {TypeError} Invalid function.
   */
  addSemanticType(type, fun) {
    const typeName = (typeof type === 'string') ? type : type.name;
    const old = this.semanticTypes[typeName];

    if (fun) {
      if (typeof fun !== 'function') {
        throw new TypeError('fun must be of type function');
      }
      this.semanticTypes[typeName] = fun;
    } else if (old) {
      delete this.semanticTypes[typeName];
    }
    return old;
  }

  /**
   * Push any supported type onto the encoded stream.
   *
   * @param {any} obj The thing to encode.
   * @returns {boolean} True on success.
   * @throws {TypeError} Unknown type for obj.
   */
  pushAny(obj) {
    switch (typeof obj) {
      case 'number':
        return this._pushNumber(obj);
      case 'bigint':
        return this._pushJSBigint(obj);
      case 'string':
        return this._pushString(obj);
      case 'boolean':
        return this._pushBoolean(obj);
      case 'undefined':
        return this._pushUndefined(obj);
      case 'object':
        return this._pushObject(obj);
      case 'symbol':
        switch (obj) {
          case SYMS.NULL:
            return this._pushNull(null);
          case SYMS.UNDEFINED:
            return this._pushUndefined(undefined);
          // TODO: Add pluggable support for other symbols
          default:
            throw new TypeError(`Unknown symbol: ${obj.toString()}`);
        }
      default:
        throw new TypeError(
          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`
        );
    }
  }

  /**
   * Encode an array and all of its elements.
   *
   * @param {Encoder} gen Encoder to use.
   * @param {any[]} obj Array to encode.
   * @param {object} [opts] Options.
   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?
   * @returns {boolean} True on success.
   */
  static pushArray(gen, obj, opts) {
    opts = {
      indefinite: false,
      ...opts,
    };
    const len = obj.length;
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!gen._pushInt(len, MT.ARRAY)) {
      return false;
    }
    for (let j = 0; j < len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false;
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Remove the loop detector WeakSet for this Encoder.
   *
   * @returns {boolean} True when the Encoder was reset, else false.
   */
  removeLoopDetectors() {
    if (!this.detectLoops) {
      return false;
    }
    this.detectLoops = new WeakSet();
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Date} obj Date to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushDate(gen, obj) {
    switch (gen.dateType) {
      case 'string':
        return gen._pushTag(TAG.DATE_STRING) &&
          gen._pushString(obj.toISOString());
      case 'int':
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushIntNum(Math.round(obj.getTime() / 1000));
      case 'float':
        // Force float
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushFloat(obj.getTime() / 1000);
      case 'number':
      default:
        // If we happen to have an integral number of seconds,
        // use integer.  Otherwise, use float.
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen.pushAny(obj.getTime() / 1000);
    }
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Buffer} obj Buffer to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {NoFilter} obj Buffer to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushNoFilter(gen, obj) {
    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()));
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {RegExp} obj RegExp to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Set} obj Set to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushSet(gen, obj) {
    if (!gen._pushTag(TAG.SET)) {
      return false;
    }
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false;
    }
    for (const x of obj) {
      if (!gen.pushAny(x)) {
        return false;
      }
    }
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {URL} obj URL to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushURL(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {object} obj Boxed String, Number, or Boolean object to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushBoxed(gen, obj) {
    return gen.pushAny(obj.valueOf());
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Map} obj Map to encode.
   * @returns {boolean} True on success.
   * @throws {Error} Map key that is undefined.
   * @ignore
   */
  static _pushMap(gen, obj, opts) {
    opts = {
      indefinite: false,
      ...opts,
    };
    let entries = [...obj.entries()];
    if (gen.omitUndefinedProperties) {
      entries = entries.filter(([_k, v]) => v !== undefined);
    }
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!gen._pushInt(entries.length, MT.MAP)) {
      return false;
    }
    // Memoizing the cbor only helps in certain cases, and hurts in most
    // others.  Just avoid it.
    if (gen.canonical) {
      // Keep the key/value pairs together, so we don't have to do odd
      // gets with object keys later
      const enc = new Encoder({
        genTypes: gen.semanticTypes,
        canonical: gen.canonical,
        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector
        dateType: gen.dateType,
        disallowUndefinedKeys: gen.disallowUndefinedKeys,
        collapseBigIntegers: gen.collapseBigIntegers,
      });
      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark});
      enc.pipe(bs);
      entries.sort(([a], [b]) => {
        // Both a and b are the keys
        enc.pushAny(a);
        const a_cbor = bs.read();
        enc.pushAny(b);
        const b_cbor = bs.read();
        return a_cbor.compare(b_cbor);
      });
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined');
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false;
        }
      }
    } else {
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined');
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false;
        }
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false;
      }
    }
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {NodeJS.TypedArray} obj Array to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushTypedArray(gen, obj) {
    // See https://tools.ietf.org/html/rfc8746

    let typ = 0b01000000;
    let sz = obj.BYTES_PER_ELEMENT;
    const {name} = obj.constructor;

    if (name.startsWith('Float')) {
      typ |= 0b00010000;
      sz /= 2;
    } else if (!name.includes('U')) {
      typ |= 0b00001000;
    }
    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {
      typ |= 0b00000100;
    }
    typ |= {
      1: 0b00,
      2: 0b01,
      4: 0b10,
      8: 0b11,
    }[sz];
    if (!gen._pushTag(typ)) {
      return false;
    }
    return Encoder._pushBuffer(
      gen,
      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)
    );
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param { ArrayBuffer } obj Array to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushArrayBuffer(gen, obj) {
    return Encoder._pushBuffer(gen, Buffer.from(obj));
  }

  /**
   * Encode the given object with indefinite length.  There are apparently
   * some (IMO) broken implementations of poorly-specified protocols that
   * REQUIRE indefinite-encoding.  See the example for how to add this as an
   * `encodeCBOR` function to an object or class to get indefinite encoding.
   *
   * @param {Encoder} gen The encoder to use.
   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If
   *   null, use "this" instead.
   * @param {EncodingOptions} [options={}] Options for encoding.
   * @returns {boolean} True on success.
   * @throws {Error} No object to encode or invalid indefinite encoding.
   * @example <caption>Force indefinite encoding:</caption>
   * const o = {
   *   a: true,
   *   encodeCBOR: cbor.Encoder.encodeIndefinite,
   * }
   * const m = []
   * m.encodeCBOR = cbor.Encoder.encodeIndefinite
   * cbor.encodeOne([o, m])
   */
  static encodeIndefinite(gen, obj, options = {}) {
    if (obj == null) {
      if (this == null) {
        throw new Error('No object to encode');
      }
      obj = this;
    }

    // TODO: consider other options
    const {chunkSize = 4096} = options;

    let ret = true;
    const objType = typeof obj;
    let buf = null;
    if (objType === 'string') {
      // TODO: make sure not to split surrogate pairs at the edges of chunks,
      // since such half-surrogates cannot be legally encoded as UTF-8.
      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE);
      let offset = 0;
      while (offset < obj.length) {
        const endIndex = offset + chunkSize;
        ret = ret && gen._pushString(obj.slice(offset, endIndex));
        offset = endIndex;
      }
      ret = ret && gen.push(BREAK);
    } else if ((buf = utils.bufferishToBuffer(obj))) {
      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE);
      let offset = 0;
      while (offset < buf.length) {
        const endIndex = offset + chunkSize;
        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));
        offset = endIndex;
      }
      ret = ret && gen.push(BREAK);
    } else if (Array.isArray(obj)) {
      ret = ret && Encoder.pushArray(gen, obj, {
        indefinite: true,
      });
    } else if (obj instanceof Map) {
      ret = ret && Encoder._pushMap(gen, obj, {
        indefinite: true,
      });
    } else {
      if (objType !== 'object') {
        throw new Error('Invalid indefinite encoding');
      }
      ret = ret && gen._pushObject(obj, {
        indefinite: true,
        skipTypes: true,
      });
    }
    return ret;
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encode(...objs) {
    return new Encoder()._encodeAll(objs);
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encodeCanonical(...objs) {
    return new Encoder({
      canonical: true,
    })._encodeAll(objs);
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @param {any} obj The object to encode.
   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
   * @returns {Buffer} The encoded objects.
   */
  static encodeOne(obj, options) {
    return new Encoder(options)._encodeAll([obj]);
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj The object to encode.
   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
   * @returns {Promise<Buffer>} A promise for the encoded buffer.
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) => {
      const bufs = [];
      const enc = new Encoder(options);
      enc.on('data', buf => bufs.push(buf));
      enc.on('error', reject);
      enc.on('finish', () => resolve(Buffer.concat(bufs)));
      enc.pushAny(obj);
      enc.end();
    });
  }

  /**
   * The currently supported set of semantic types.  May be modified by plugins.
   *
   * @type {SemanticMap}
   */
  static get SEMANTIC_TYPES() {
    return current_SEMANTIC_TYPES;
  }

  static set SEMANTIC_TYPES(val) {
    current_SEMANTIC_TYPES = val;
  }

  /**
   * Reset the supported semantic types to the original set, before any
   * plugins modified the list.
   */
  static reset() {
    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES};
  }
}

Object.assign(SEMANTIC_TYPES, {
  Array: Encoder.pushArray,
  Date: Encoder._pushDate,
  Buffer: Encoder._pushBuffer,
  [Buffer.name]: Encoder._pushBuffer, // Might be mangled
  Map: Encoder._pushMap,
  NoFilter: Encoder._pushNoFilter,
  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled
  RegExp: Encoder._pushRegexp,
  Set: Encoder._pushSet,
  ArrayBuffer: Encoder._pushArrayBuffer,
  Uint8ClampedArray: Encoder._pushTypedArray,
  Uint8Array: Encoder._pushTypedArray,
  Uint16Array: Encoder._pushTypedArray,
  Uint32Array: Encoder._pushTypedArray,
  Int8Array: Encoder._pushTypedArray,
  Int16Array: Encoder._pushTypedArray,
  Int32Array: Encoder._pushTypedArray,
  Float32Array: Encoder._pushTypedArray,
  Float64Array: Encoder._pushTypedArray,
  URL: Encoder._pushURL,
  Boolean: Encoder._pushBoxed,
  Number: Encoder._pushBoxed,
  String: Encoder._pushBoxed,
});

// Safari needs to get better.
if (typeof BigUint64Array !== 'undefined') {
  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;
}
if (typeof BigInt64Array !== 'undefined') {
  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;
}

Encoder.reset();
module.exports = Encoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const {MT} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * Wrapper around a JavaScript Map object that allows the keys to be
 * any complex type.  The base Map object allows this, but will only
 * compare the keys by identity, not by value.  CborMap translates keys
 * to CBOR first (and base64's them to ensure by-value comparison).
 *
 * This is not a subclass of Object, because it would be tough to get
 * the semantics to be an exact match.
 *
 * @extends Map
 */
class CborMap extends Map {
  /**
   * Creates an instance of CborMap.
   *
   * @param {Iterable<any>} [iterable] An Array or other iterable
   *   object whose elements are key-value pairs (arrays with two elements, e.g.
   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added
   *   to the new CborMap; null values are treated as undefined.
   */
  constructor(iterable) {
    super(iterable);
  }

  /**
   * @ignore
   * @param {unknown} key
   * @returns {string}
   */
  static _encode(key) {
    return encoder.encodeCanonical(key).toString('base64');
  }

  /**
   * @ignore
   * @param {string} key
   * @returns {unknown}
   */
  static _decode(key) {
    return decoder.decodeFirstSync(key, 'base64');
  }

  /**
   * Retrieve a specified element.
   *
   * @param {any} key The key identifying the element to retrieve.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {any} The element if it exists, or <code>undefined</code>.
   */
  get(key) {
    return super.get(CborMap._encode(key));
  }

  /**
   * Adds or updates an element with a specified key and value.
   *
   * @param {any} key The key identifying the element to store.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @param {any} val The element to store.
   * @returns {this} This object.
   */
  set(key, val) {
    return super.set(CborMap._encode(key), val);
  }

  /**
   * Removes the specified element.
   *
   * @param {any} key The key identifying the element to delete. Can be any
   *   type, which will be serialized into CBOR and compared by value.
   * @returns {boolean} True if an element in the Map object existed and has
   *   been removed, or false if the element does not exist.
   */
  delete(key) {
    return super.delete(CborMap._encode(key));
  }

  /**
   * Does an element with the specified key exist?
   *
   * @param {any} key The key identifying the element to check.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean} True if an element with the specified key exists in
   *   the Map object; otherwise false.
   */
  has(key) {
    return super.has(CborMap._encode(key));
  }

  /**
   * Returns a new Iterator object that contains the keys for each element
   * in the Map object in insertion order.  The keys are decoded into their
   * original format.
   *
   * @returns {MapIterator<any>}
   */
  *keys() {
    for (const k of super.keys()) {
      yield CborMap._decode(k);
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator<any>} Key value pairs.
   * @yields {any[]} Key value pairs.
   */
  *entries() {
    for (const kv of super.entries()) {
      yield [CborMap._decode(kv[0]), kv[1]];
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator<any>} Key value pairs.
   */
  [Symbol.iterator]() {
    return this.entries();
  }

  /**
   * Executes a provided function once per each key/value pair in the Map
   * object, in insertion order.
   *
   * @param {function(any, any, Map<any,any>): undefined} fun Function to
   *   execute for each element, which takes a value, a key, and the Map
   *   being traversed.
   * @param {any} thisArg Value to use as this when executing callback.
   * @throws {TypeError} Invalid function.
   */
  forEach(fun, thisArg = this) {
    if (typeof fun !== 'function') {
      throw new TypeError('Must be function');
    }
    for (const kv of super.entries()) {
      fun.call(thisArg, kv[1], CborMap._decode(kv[0]), this);
    }
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {import('./encoder.js')} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    if (!gen._pushInt(this.size, MT.MAP)) {
      return false;
    }
    if (gen.canonical) {
      const entries = Array.from(super.entries())
        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);
      entries.sort((a, b) => a[0].compare(b[0]));
      for (const kv of entries) {
        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    } else {
      for (const kv of super.entries()) {
        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    }
    return true;
  }
}

module.exports = CborMap;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Record objects that pass by in a stream.  If the same object is used more
 * than once, it can be value-shared using shared values.
 *
 * @see {@link http://cbor.schmorp.de/value-sharing}
 */
class ObjectRecorder {
  constructor() {
    this.clear();
  }

  /**
   * Clear all of the objects that have been seen.  Revert to recording mode.
   */
  clear() {
    this.map = new WeakMap();
    this.count = 0;
    this.recording = true;
  }

  /**
   * Stop recording.
   */
  stop() {
    this.recording = false;
  }

  /**
   * Determine if wrapping a tag 28 or 29 around an object that has been
   * reused is appropriate.  This method stores state for which objects have
   * been seen.
   *
   * @param {object} obj Any object about to be serialized.
   * @returns {number} If recording: -1 for first use, index for second use.
   *   If not recording, -1 for never-duplicated, -2 for first use, index for
   *   subsequent uses.
   * @throws {Error} Recording does not match playback.
   */
  check(obj) {
    const val = this.map.get(obj);
    if (val) {
      if (val.length > 1) {
        if (val[0] || this.recording) {
          return val[1];
        }

        val[0] = true;
        return ObjectRecorder.FIRST;
      }
      if (!this.recording) {
        return ObjectRecorder.NEVER;
      }
      val.push(this.count++);
      // Second use while recording
      return val[1];
    }
    if (!this.recording) {
      throw new Error('New object detected when not recording');
    }
    this.map.set(obj, [false]);
    // First use while recording
    return ObjectRecorder.NEVER;
  }
}

ObjectRecorder.NEVER = -1;
ObjectRecorder.FIRST = -2;

module.exports = ObjectRecorder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const ObjectRecorder = __webpack_require__(/*! ./objectRecorder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js");
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

/**
 * Implement value sharing.
 *
 * @see {@link cbor.schmorp.de/value-sharing}
 */
class SharedValueEncoder extends Encoder {
  constructor(opts) {
    super(opts);
    this.valueSharing = new ObjectRecorder();
  }

  /**
   * @param {object} obj Object to encode.
   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding
   *   this object.
   * @returns {boolean} True on success.
   * @throws {Error} Loop detected.
   * @ignore
   */
  _pushObject(obj, opts) {
    if (obj !== null) {
      const shared = this.valueSharing.check(obj);
      switch (shared) {
        case ObjectRecorder.FIRST:
          // Prefix with tag 28
          this._pushTag(28);
          break;
        case ObjectRecorder.NEVER:
          // Do nothing
          break;
        default:
          return this._pushTag(29) && this._pushIntNum(shared);
      }
    }
    return super._pushObject(obj, opts);
  }

  /**
   * Between encoding runs, stop recording, and start outputing correct tags.
   */
  stopRecording() {
    this.valueSharing.stop();
  }

  /**
   * Remove the existing recording and start over.  Do this between encoding
   * pairs.
   */
  clearRecording() {
    this.valueSharing.clear();
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encode(...objs) {
    const enc = new SharedValueEncoder();
    // eslint-disable-next-line no-empty-function
    enc.on('data', () => {}); // Sink all writes

    for (const o of objs) {
      enc.pushAny(o);
    }
    enc.stopRecording();
    enc.removeAllListeners('data');
    return enc._encodeAll(objs);
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} _objs The objects to encode.
   * @returns {Buffer} Never.
   * @throws {Error} Always.  This combination doesn't work at the moment.
   */
  static encodeCanonical(..._objs) {
    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @param {any} obj The object to encode.
   * @param {import('./encoder').EncodingOptions} [options={}]
   *   Passed to the Encoder constructor.
   * @returns {Buffer} The encoded objects.
   * @static
   */
  static encodeOne(obj, options) {
    const enc = new SharedValueEncoder(options);
    // eslint-disable-next-line no-empty-function
    enc.on('data', () => {}); // Sink all writes
    enc.pushAny(obj);
    enc.stopRecording();
    enc.removeAllListeners('data');
    return enc._encodeAll([obj]);
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj The object to encode.
   * @param {import('./encoder').EncodingOptions} [options={}]
   *   Passed to the Encoder constructor.
   * @returns {Promise<Buffer>} A promise for the encoded buffer.
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) => {
      /** @type {Buffer[]} */
      const bufs = [];
      const enc = new SharedValueEncoder(options);
      // eslint-disable-next-line no-empty-function
      enc.on('data', () => {});
      enc.on('error', reject);
      enc.on('finish', () => resolve(Buffer.concat(bufs)));
      enc.pushAny(obj);
      enc.stopRecording();
      enc.removeAllListeners('data');
      enc.on('data', buf => bufs.push(buf));
      enc.pushAny(obj);
      enc.end();
    });
  }
}

module.exports = SharedValueEncoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {MT, SIMPLE, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * A CBOR Simple Value that does not map onto a known constant.
 */
class Simple {
  /**
   * Creates an instance of Simple.
   *
   * @param {number} value The simple value's integer value.
   */
  constructor(value) {
    if (typeof value !== 'number') {
      throw new Error(`Invalid Simple type: ${typeof value}`);
    }
    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {
      throw new Error(`value must be a small positive integer: ${value}`);
    }
    this.value = value;
  }

  /**
   * Debug string for simple value.
   *
   * @returns {string} Formated string of `simple(value)`.
   */
  toString() {
    return `simple(${this.value})`;
  }

  /**
   * Debug string for simple value.
   *
   * @param {number} _depth How deep are we?
   * @param {object} _opts Options.
   * @returns {string} Formatted string of `simple(value)`.
   */
  [Symbol.for('nodejs.util.inspect.custom')](_depth, _opts) {
    return `simple(${this.value})`;
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {object} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
  }

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj Object to test.
   * @returns {boolean} Is it Simple?
   */
  static isSimple(obj) {
    return obj instanceof Simple;
  }

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a "safe" symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {number} val The CBOR additional info to convert.
   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?
   * @param {boolean} [parent_indefinite=false] Is the parent element
   *   indefinitely encoded?
   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.
   * @throws {Error} Invalid BREAK.
   */
  static decode(val, has_parent = true, parent_indefinite = false) {
    switch (val) {
      case SIMPLE.FALSE:
        return false;
      case SIMPLE.TRUE:
        return true;
      case SIMPLE.NULL:
        if (has_parent) {
          return null;
        }
        return SYMS.NULL;
      case SIMPLE.UNDEFINED:
        if (has_parent) {
          return undefined;
        }
        return SYMS.UNDEFINED;
      case -1:
        if (!has_parent || !parent_indefinite) {
          throw new Error('Invalid BREAK');
        }
        return SYMS.BREAK;
      default:
        return new Simple(val);
    }
  }
}

module.exports = Simple;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const INTERNAL_JSON = Symbol('INTERNAL_JSON');

function setBuffersToJSON(obj, fn) {
  // The data item tagged can be a byte string or any other data item.  In the
  // latter case, the tag applies to all of the byte string data items
  // contained in the data item, except for those contained in a nested data
  // item tagged with an expected conversion.
  if (utils.isBufferish(obj)) {
    obj.toJSON = fn;
  } else if (Array.isArray(obj)) {
    for (const v of obj) {
      setBuffersToJSON(v, fn);
    }
  } else if (obj && (typeof obj === 'object')) {
    // FFS, complexity in the protocol.

    // There's some circular dependency in here.
    // eslint-disable-next-line no-use-before-define
    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {
      for (const v of Object.values(obj)) {
        setBuffersToJSON(v, fn);
      }
    }
  }
}

function b64this() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64(this);
}

function b64urlThis() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64url(this);
}

function hexThis() {
  // eslint-disable-next-line no-invalid-this
  return this.toString('hex');
}

function swapEndian(ab, size, byteOffset, byteLength) {
  const dv = new DataView(ab);
  const [getter, setter] = {
    2: [dv.getUint16, dv.setUint16],
    4: [dv.getUint32, dv.setUint32],
    8: [dv.getBigUint64, dv.setBigUint64],
  }[size];

  const end = byteOffset + byteLength;
  for (let offset = byteOffset; offset < end; offset += size) {
    setter.call(dv, offset, getter.call(dv, offset, true));
  }
}

/**
 * Convert a tagged value to a more interesting JavaScript type.  Errors
 * thrown in this function will be captured into the "err" property of the
 * original Tagged instance.
 *
 * @callback TagFunction
 * @param {any} value The value inside the tag.
 * @param {Tagged} tag The enclosing Tagged instance; useful if you want to
 *   modify it and return it.  Also available as "this".
 * @returns {any} The transformed value.
 */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, TagFunction>} TagMap
 */

/**
 * @type {TagMap}
 * @private
 */
const TAGS = {
  // Standard date/time string; see Section 3.4.1
  0: v => new Date(v),
  // Epoch-based date/time; see Section 3.4.2
  1: v => new Date(v * 1000),
  // Positive bignum; see Section 3.4.3
  2: v => utils.bufferToBigInt(v),
  // Negative bignum; see Section 3.4.3
  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),
  // Expected conversion to base64url encoding; see Section 3.4.5.2
  21: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64urlThis;
    } else {
      setBuffersToJSON(v, b64urlThis);
    }
    return tag;
  },
  // Expected conversion to base64 encoding; see Section 3.4.5.2
  22: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64this;
    } else {
      setBuffersToJSON(v, b64this);
    }
    return tag;
  },
  // Expected conversion to base16 encoding; see Section Section 3.4.5.2
  23: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = hexThis;
    } else {
      setBuffersToJSON(v, hexThis);
    }
    return tag;
  },
  // URI; see Section 3.4.5.3
  32: v => new URL(v),
  // Base64url; see Section 3.4.5.3
  33: (v, tag) => {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {
      throw new Error('Invalid base64url characters');
    }
    const last = v.length % 4;
    if (last === 1) {
      throw new Error('Invalid base64url length');
    }
    // -  the padding bits in a 2- or 3-character block are not 0, or
    if (last === 2) {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (last === 3) {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    }

    //    Or
    // -  the base64url encoding has padding characters,
    // (caught above)

    // the string is invalid.
    return tag;
  },
  // Base64; see Section 3.4.5.3
  34: (v, tag) => {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);
    if (!m) {
      throw new Error('Invalid base64 characters');
    }
    if ((v.length % 4) !== 0) {
      throw new Error('Invalid base64 length');
    }
    // -  the padding bits in a 2- or 3-character block are not 0, or
    if (m.groups.padding === '=') {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (m.groups.padding === '==') {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    }

    // -  the base64 encoding has the wrong number of padding characters,
    // (caught above)
    // the string is invalid.
    return tag;
  },
  // Regular expression; see Section 2.4.4.3
  35: v => new RegExp(v),
  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  258: v => new Set(v),
};

const TYPED_ARRAY_TAGS = {
  64: Uint8Array,
  65: Uint16Array,
  66: Uint32Array,
  // 67: BigUint64Array,  Safari doesn't implement
  68: Uint8ClampedArray,
  69: Uint16Array,
  70: Uint32Array,
  // 71: BigUint64Array,  Safari doesn't implement
  72: Int8Array,
  73: Int16Array,
  74: Int32Array,
  // 75: BigInt64Array,  Safari doesn't implement
  // 76: reserved
  77: Int16Array,
  78: Int32Array,
  // 79: BigInt64Array,  Safari doesn't implement
  // 80: not implemented, float16 array
  81: Float32Array,
  82: Float64Array,
  // 83: not implemented, float128 array
  // 84: not implemented, float16 array
  85: Float32Array,
  86: Float64Array,
  // 87: not implemented, float128 array
};

// Safari
if (typeof BigUint64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[67] = BigUint64Array;
  TYPED_ARRAY_TAGS[71] = BigUint64Array;
}
if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[75] = BigInt64Array;
  TYPED_ARRAY_TAGS[79] = BigInt64Array;
}

function toTypedArray(val, tagged) {
  if (!utils.isBufferish(val)) {
    throw new TypeError('val not a buffer');
  }
  const {tag} = tagged;
  // See https://tools.ietf.org/html/rfc8746
  const TypedClass = TYPED_ARRAY_TAGS[tag];
  if (!TypedClass) {
    throw new Error(`Invalid typed array tag: ${tag}`);
  }
  const little = tag & 0b00000100;
  const float = (tag & 0b00010000) >> 4;
  const sz = 2 ** (float + (tag & 0b00000011));

  if ((!little !== utils.isBigEndian()) && (sz > 1)) {
    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);
  }

  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
  return new TypedClass(ab);
}

for (const n of Object.keys(TYPED_ARRAY_TAGS)) {
  TAGS[n] = toTypedArray;
}

/**
 * @type {TagMap}
 * @private
 */
let current_TAGS = {};

/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */
class Tagged {
  /**
   * Creates an instance of Tagged.
   *
   * @param {number} tag The number of the tag.
   * @param {any} value The value inside the tag.
   * @param {Error} [err] The error that was thrown parsing the tag, or null.
   */
  constructor(tag, value, err) {
    this.tag = tag;
    this.value = value;
    this.err = err;
    if (typeof this.tag !== 'number') {
      throw new Error(`Invalid tag type (${typeof this.tag})`);
    }
    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {
      throw new Error(`Tag must be a positive integer: ${this.tag}`);
    }
  }

  toJSON() {
    if (this[INTERNAL_JSON]) {
      return this[INTERNAL_JSON].call(this.value);
    }
    const ret = {
      tag: this.tag,
      value: this.value,
    };
    if (this.err) {
      ret.err = this.err;
    }
    return ret;
  }

  /**
   * Convert to a String.
   *
   * @returns {string} String of the form '1(2)'.
   */
  toString() {
    return `${this.tag}(${JSON.stringify(this.value)})`;
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {object} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    gen._pushTag(this.tag);
    return gen.pushAny(this.value);
  }

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is 'null' instead
   * of a function.
   *
   * @param {object} converters Keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} The converted item.
   */
  convert(converters) {
    let f = (converters == null) ? undefined : converters[this.tag];
    if (f === null) { // === is intentional. null has semantic meaning as above
      return this;
    }
    if (typeof f !== 'function') {
      f = Tagged.TAGS[this.tag];
      if (typeof f !== 'function') {
        return this;
      }
    }
    try {
      return f.call(this, this.value, this);
    } catch (error) {
      if (error && error.message && (error.message.length > 0)) {
        this.err = error.message;
      } else {
        this.err = error;
      }
      return this;
    }
  }

  /**
   * The current set of supported tags.  May be modified by plugins.
   *
   * @type {TagMap}
   * @static
   */
  static get TAGS() {
    return current_TAGS;
  }

  static set TAGS(val) {
    current_TAGS = val;
  }

  /**
   * Reset the supported tags to the original set, before any plugins modified
   * the list.
   */
  static reset() {
    Tagged.TAGS = {...TAGS};
  }
}
Tagged.INTERNAL_JSON = INTERNAL_JSON;
Tagged.reset();
module.exports = Tagged;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {NUMBYTES, SHIFT32, BI, SYMS} = constants;
const MAX_SAFE_HIGH = 0x1fffff;

/**
 * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error
 * on invalid UTF8.  Byte Order Marks are not looked at or stripped.
 *
 * @private
 */
const td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true});
exports.utf8 = buf => td.decode(buf);
exports.utf8.checksUTF8 = true;

function isReadable(s) {
  // Is this a readable stream?  In the webpack version, instanceof isn't
  // working correctly.
  if (s instanceof stream.Readable) {
    return true;
  }
  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function');
}

exports.isBufferish = function isBufferish(b) {
  return b &&
    (typeof b === 'object') &&
    ((Buffer.isBuffer(b)) ||
      (b instanceof Uint8Array) ||
      (b instanceof Uint8ClampedArray) ||
      (b instanceof ArrayBuffer) ||
      (b instanceof DataView));
};

exports.bufferishToBuffer = function bufferishToBuffer(b) {
  if (Buffer.isBuffer(b)) {
    return b;
  } else if (ArrayBuffer.isView(b)) {
    return Buffer.from(b.buffer, b.byteOffset, b.byteLength);
  } else if (b instanceof ArrayBuffer) {
    return Buffer.from(b);
  }
  return null;
};

exports.parseCBORint = function parseCBORint(ai, buf) {
  switch (ai) {
    case NUMBYTES.ONE:
      return buf.readUInt8(0);
    case NUMBYTES.TWO:
      return buf.readUInt16BE(0);
    case NUMBYTES.FOUR:
      return buf.readUInt32BE(0);
    case NUMBYTES.EIGHT: {
      const f = buf.readUInt32BE(0);
      const g = buf.readUInt32BE(4);
      if (f > MAX_SAFE_HIGH) {
        return (BigInt(f) * BI.SHIFT32) + BigInt(g);
      }
      return (f * SHIFT32) + g;
    }
    default:
      throw new Error(`Invalid additional info for int: ${ai}`);
  }
};

exports.writeHalf = function writeHalf(buf, half) {
  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught

  // HACK: everyone settle in.  This isn't going to be pretty.
  // Translate cn-cbor's C code (from Carsten Borman):

  // uint32_t be32;
  // uint16_t be16, u16;
  // union {
  //   float f;
  //   uint32_t u;
  // } u32;
  // u32.f = float_val;

  const u32 = Buffer.allocUnsafe(4);
  u32.writeFloatBE(half, 0);
  const u = u32.readUInt32BE(0);

  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */

  // hildjj: If the lower 13 bits aren't 0,
  // we will lose precision in the conversion.
  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13
  if ((u & 0x1FFF) !== 0) {
    return false;
  }

  // Sign, exponent, mantissa
  //   int s16 = (u32.u >> 16) & 0x8000;
  //   int exp = (u32.u >> 23) & 0xff;
  //   int mant = u32.u & 0x7fffff;

  let s16 = (u >> 16) & 0x8000; // Top bit is sign
  const exp = (u >> 23) & 0xff; // Then 5 bits of exponent
  const mant = u & 0x7fffff;

  // Hildjj: zeros already handled.  Assert if you don't believe me.
  //   if (exp == 0 && mant == 0)
  //     ;              /* 0.0, -0.0 */

  //   else if (exp >= 113 && exp <= 142) /* normalized */
  //     s16 += ((exp - 112) << 10) + (mant >> 13);

  if ((exp >= 113) && (exp <= 142)) {
    s16 += ((exp - 112) << 10) + (mant >> 13);
  } else if ((exp >= 103) && (exp < 113)) {
    // Denormalized numbers
    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */
    //     if (mant & ((1 << (126 - exp)) - 1))
    //       goto float32;         /* loss of precision */
    //     s16 += ((mant + 0x800000) >> (126 - exp));

    if (mant & ((1 << (126 - exp)) - 1)) {
      return false;
    }
    s16 += ((mant + 0x800000) >> (126 - exp));
  } else {
  //   } else if (exp == 255 && mant == 0) { /* Inf */
  //     s16 += 0x7c00;

    // hildjj: Infinity already handled

    //   } else
    //     goto float32;           /* loss of range */

    return false;
  }

  // Done
  //   ensure_writable(3);
  //   u16 = s16;
  //   be16 = hton16p((const uint8_t*)&u16);
  buf.writeUInt16BE(s16);
  return true;
};

exports.parseHalf = function parseHalf(buf) {
  const sign = buf[0] & 0x80 ? -1 : 1;
  const exp = (buf[0] & 0x7C) >> 2;
  const mant = ((buf[0] & 0x03) << 8) | buf[1];
  if (!exp) {
    return sign * 5.9604644775390625e-8 * mant;
  } else if (exp === 0x1f) {
    return sign * (mant ? NaN : Infinity);
  }
  return sign * (2 ** (exp - 25)) * (1024 + mant);
};

exports.parseCBORfloat = function parseCBORfloat(buf) {
  switch (buf.length) {
    case 2:
      return exports.parseHalf(buf);
    case 4:
      return buf.readFloatBE(0);
    case 8:
      return buf.readDoubleBE(0);
    default:
      throw new Error(`Invalid float size: ${buf.length}`);
  }
};

exports.hex = function hex(s) {
  return Buffer.from(s.replace(/^0x/, ''), 'hex');
};

exports.bin = function bin(s) {
  s = s.replace(/\s/g, '');
  let start = 0;
  let end = (s.length % 8) || 8;
  const chunks = [];
  while (end <= s.length) {
    chunks.push(parseInt(s.slice(start, end), 2));
    start = end;
    end += 8;
  }
  return Buffer.from(chunks);
};

exports.arrayEqual = function arrayEqual(a, b) {
  if ((a == null) && (b == null)) {
    return true;
  }
  if ((a == null) || (b == null)) {
    return false;
  }
  return (a.length === b.length) && a.every((elem, i) => elem === b[i]);
};

exports.bufferToBigInt = function bufferToBigInt(buf) {
  return BigInt(`0x${buf.toString('hex')}`);
};

exports.cborValueToString = function cborValueToString(val, float_bytes = -1) {
  switch (typeof val) {
    case 'symbol': {
      switch (val) {
        case SYMS.NULL:
          return 'null';
        case SYMS.UNDEFINED:
          return 'undefined';
        case SYMS.BREAK:
          return 'BREAK';
      }
      // Impossible in node 10
      /* istanbul ignore if */
      if (val.description) {
        return val.description;
      }
      // On node10, Symbol doesn't have description.  Parse it out of the
      // toString value, which looks like `Symbol(foo)`.
      const s = val.toString();
      const m = s.match(/^Symbol\((?<name>.*)\)/);
      /* istanbul ignore if */
      if (m && m.groups.name) {
        // Impossible in node 12+
        /* istanbul ignore next */
        return m.groups.name;
      }
      return 'Symbol';
    }
    case 'string':
      return JSON.stringify(val);
    case 'bigint':
      return val.toString();
    case 'number': {
      const s = Object.is(val, -0) ? '-0' : String(val);
      return (float_bytes > 0) ? `${s}_${float_bytes}` : s;
    }
    case 'object': {
      if (!val) {
        return 'null';
      }
      const buf = exports.bufferishToBuffer(val);
      if (buf) {
        const hex = buf.toString('hex');
        return (float_bytes === -Infinity) ? hex : `h'${hex}'`;
      }
      if (val && typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {
        return val[Symbol.for('nodejs.util.inspect.custom')]();
      }
      // Shouldn't get non-empty arrays here
      if (Array.isArray(val)) {
        return '[]';
      }
      // This should be all that is left
      return '{}';
    }
  }
  return String(val);
};

exports.guessEncoding = function guessEncoding(input, encoding) {
  if (typeof input === 'string') {
    return new NoFilter(input, (encoding == null) ? 'hex' : encoding);
  }
  const buf = exports.bufferishToBuffer(input);
  if (buf) {
    return new NoFilter(buf);
  }
  if (isReadable(input)) {
    return input;
  }
  throw new Error('Unknown input type');
};

const B64URL_SWAPS = {
  '=': '',
  '+': '-',
  '/': '_',
};

/**
 * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf
 *   Buffer to convert.
 * @returns {string} Base64url string.
 * @private
 */
exports.base64url = function base64url(buf) {
  return exports.bufferishToBuffer(buf)
    .toString('base64')
    .replace(/[=+/]/g, c => B64URL_SWAPS[c]);
};

/**
 * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf
 *   Buffer to convert.
 * @returns {string} Base64 string.
 * @private
 */
exports.base64 = function base64(buf) {
  return exports.bufferishToBuffer(buf).toString('base64');
};

exports.isBigEndian = function isBigEndian() {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !((view[0] = 1) & array[0]);
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Tweaked version of nathan7's binary-parse-stream
// (see https://github.com/nathan7/binary-parse-stream)
// Uses NoFilter instead of the readable in the original.  Removes
// the ability to read -1, which was odd and un-needed.
// License for binary-parse-stream: MIT

// binary-parse-stream is now unmaintained, so I have rewritten it as
// more modern JS so I can get tsc to help check types.


// eslint-disable-next-line n/prefer-node-protocol
const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");

/**
 * BinaryParseStream is a TransformStream that consumes buffers and outputs
 * objects on the other end.  It expects your subclass to implement a `_parse`
 * method that is a generator.  When your generator yields a number, it'll be
 * fed a buffer of that length from the input.  When your generator returns,
 * the return value will be pushed to the output side.
 *
 * @extends stream.Transform
 */
class BinaryParseStream extends stream.Transform {
  /**
   * Creates an instance of BinaryParseStream.
   *
   * @memberof BinaryParseStream
   * @param {stream.TransformOptions} options Stream options.
   */
  constructor(options) {
    super(options);
    // Doesn't work to pass these in as opts, for some reason
    // also, work around typescript not knowing TransformStream internals
    // eslint-disable-next-line dot-notation
    this['_writableState'].objectMode = false;
    // eslint-disable-next-line dot-notation
    this['_readableState'].objectMode = true;

    this.bs = new NoFilter();
    this.__restart();
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} _encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, _encoding, cb) {
    this.bs.write(fresh);

    while (this.bs.length >= this.__needed) {
      let ret = null;
      const chunk = (this.__needed === null) ?
        undefined :
        this.bs.read(this.__needed);

      try {
        ret = this.__parser.next(chunk);
      } catch (e) {
        return cb(e);
      }

      if (this.__needed) {
        this.__fresh = false;
      }

      if (ret.done) {
        this.push(ret.value);
        this.__restart();
      } else {
        this.__needed = ret.value || Infinity;
      }
    }

    return cb();
  }

  /**
   * Subclasses must override this to set their parsing behavior.  Yield a
   * number to receive a Buffer of that many bytes.
   *
   * @abstract
   * @returns {Generator<number, any, Buffer>}
   */
  /* istanbul ignore next */
  *_parse() { // eslint-disable-line class-methods-use-this, require-yield
    throw new Error('Must be implemented in subclass');
  }

  __restart() {
    this.__needed = null;
    this.__parser = this._parse();
    this.__fresh = true;
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    cb(this.__fresh ? null : new Error('unexpected end of input'));
  }
}

module.exports = BinaryParseStream;


/***/ }),

/***/ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ "./node_modules/.pnpm/duplexify@4.1.3/node_modules/duplexify/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/duplexify@4.1.3/node_modules/duplexify/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
var stream = __webpack_require__(/*! readable-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js")
var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var shift = __webpack_require__(/*! stream-shift */ "./node_modules/.pnpm/stream-shift@1.0.3/node_modules/stream-shift/index.js")

var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
  ? Buffer.from([0])
  : new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var noop = function() {}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(null)
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
    cb(null)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else if (!this.destroyed) cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending && !this._writableState.destroyed) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify


/***/ }),

/***/ "./node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
var once = __webpack_require__(/*! once */ "./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js");

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};


/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");

var abs = __webpack_require__(/*! math-intrinsics/abs */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__(/*! math-intrinsics/floor */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
var max = __webpack_require__(/*! math-intrinsics/max */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
var min = __webpack_require__(/*! math-intrinsics/min */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
var pow = __webpack_require__(/*! math-intrinsics/pow */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
var round = __webpack_require__(/*! math-intrinsics/round */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
var sign = __webpack_require__(/*! math-intrinsics/sign */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();

var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__(/*! dunder-proto/get */ "./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js":
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(/*! ./gOPD */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js ***!
  \*************************************************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");

var $toString = callBound('Object.prototype.toString');

/** @type {import('.')} */
var isStandardArguments = function isArguments(value) {
	if (
		hasToStringTag
		&& value
		&& typeof value === 'object'
		&& Symbol.toStringTag in value
	) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

/** @type {import('.')} */
var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null
		&& typeof value === 'object'
		&& 'length' in value
		&& typeof value.length === 'number'
		&& value.length >= 0
		&& $toString(value) !== '[object Array]'
		&& 'callee' in value
		&& $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

/** @type {import('.')} */
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var safeRegexTest = __webpack_require__(/*! safe-regex-test */ "./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js");
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');

var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
/** @type {undefined | false | null | GeneratorFunctionConstructor} */
var GeneratorFunction;

/** @type {import('.')} */
module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex(fnToStr(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc
			// eslint-disable-next-line no-extra-parens
			? /** @type {GeneratorFunctionConstructor} */ (getProto(generatorFunc))
			: false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
var fn;

if (hasToStringTag) {
	/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
	var $exec = callBound('RegExp.prototype.exec');
	/** @type {object} */
	var isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
	var badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}

	/** @type {import('.')} */
	// @ts-expect-error TS can't figure out that the $exec call always throws
	// eslint-disable-next-line consistent-return
	fn = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			// eslint-disable-next-line no-extra-parens
			$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
		} catch (e) {
			return e === isRegexMarker;
		}
	};
} else {
	/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
	var $toString = callBound('Object.prototype.toString');
	/** @const @type {'[object RegExp]'} */
	var regexClass = '[object RegExp]';

	/** @type {import('.')} */
	fn = function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};
}

module.exports = fn;


/***/ }),

/***/ "./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ "./node_modules/.pnpm/lodash.chunk@4.2.0/node_modules/lodash.chunk/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/lodash.chunk@4.2.0/node_modules/lodash.chunk/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = chunk;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ./isNaN */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js")
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")
const td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})

/**
 * @typedef {object} NoFilterOptions
 * @property {string|Buffer} [input=null] Input source data.
 * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,
 *   ignored if input is not a String.
 * @property {number} [highWaterMark=16384] The maximum number of bytes to
 *   store in the internal buffer before ceasing to read from the underlying
 *   resource. Default=16kb, or 16 for objectMode streams.
 * @property {BufferEncoding} [encoding=null] If specified, then buffers
 *   will be decoded to strings using the specified encoding.
 * @property {boolean} [objectMode=false] Whether this stream should behave
 *   as a stream of objects. Meaning that stream.read(n) returns a single
 *   value instead of a Buffer of size n.
 * @property {boolean} [decodeStrings=true] Whether or not to decode
 *   strings into Buffers before passing them to _write().
 * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,
 *   setting this stream's objectMode based on the objectMode of the input
 *   stream.
 * @property {boolean} [readError=false] If true, when a read() underflows,
 *   throw an error.
 * @property {boolean} [allowHalfOpen=true] If set to false, then the
 *   stream will automatically end the writable side when the readable side
 *   ends.
 * @property {boolean} [autoDestroy=true] Whether this stream should
 *   automatically call .destroy() on itself after ending.
 * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding
 *   that is used when no encoding is specified as an argument to
 *   stream.write().
 * @property {boolean} [emitClose=true] Whether or not the stream should
 *   emit 'close' after it has been destroyed.
 * @property {number} [readableHighWaterMark] Sets highWaterMark for the
 *   readable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [readableObjectMode=false] Sets objectMode for
 *   readable side of the stream. Has no effect if objectMode is true.
 * @property {number} [writableHighWaterMark] Sets highWaterMark for the
 *   writable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [writableObjectMode=false] Sets objectMode for
 *   writable side of the stream. Has no effect if objectMode is true.
 */

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source and sink</caption>
 * const source = new NoFilter('Zm9v', 'base64')
 * source.pipe(process.stdout)
 * const sink = new Nofilter()
 * // NOTE: 'finish' fires when the input is done writing
 * sink.on('finish', () => console.log(n.toString('base64')))
 * process.stdin.pipe(sink)
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.
   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding
   *   name for input, ignored if input is not a String.
   * @param {NoFilterOptions} [options] Other options.
   */
  constructor(input, inputEncoding, options = {}) {
    let inp = null
    let inpE = /** @type {BufferEncoding?} */ (null)
    switch (typeof input) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
        } else if (input) {
          options = input
        }
        break
      case 'string':
        inp = input
        break
      case 'undefined':
        break
      default:
        throw new TypeError('Invalid input')
    }
    switch (typeof inputEncoding) {
      case 'object':
        if (inputEncoding) {
          options = inputEncoding
        }
        break
      case 'string':
        inpE = /** @type {BufferEncoding} */ (inputEncoding)
        break
      case 'undefined':
        break
      default:
        throw new TypeError('Invalid inputEncoding')
    }
    if (!options || typeof options !== 'object') {
      throw new TypeError('Invalid options')
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe == null ? true : options.watchPipe
    delete options.watchPipe
    const readError = Boolean(options.readError)
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        // @ts-ignore: TS2339 (using internal interface)
        const om = readable._readableState.objectMode
        // @ts-ignore: TS2339 (using internal interface)
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream'
          )
        }

        // @ts-ignore: TS2339 (using internal interface)
        this._readableState.objectMode = om
        // @ts-ignore: TS2339 (using internal interface)
        this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {object} obj The object to test.
   * @returns {boolean} True if obj is a NoFilter.
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 The first object to compare.
   * @param {NoFilter} nf2 The second object to compare.
   * @returns {number} -1, 0, 1 for less, equal, greater.
   * @throws {TypeError} Arguments not NoFilter instances.
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')]
   * arr.sort(NoFilter.compare)
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    }
    return nf1.compare(nf2)
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read.
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer.
   * @throws {TypeError} List not array of NoFilters.
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      // @ts-ignore: TS2322, tsc can't see the type checking above
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @ignore
   */
  _transform(chunk, encoding, callback) {
    // @ts-ignore: TS2339 (using internal interface)
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @returns {Buffer[]} The current internal buffers.  They are layed out
   *   end to end.
   * @ignore
   */
  _bufArray() {
    // @ts-ignore: TS2339 (using internal interface)
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer.
   * @throws Error If readError is true and there was underflow.
   * @fires NoFilter#read When read from.
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /**
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @param {Buffer|string|object} buf What was read.
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Read the full number of bytes asked for, no matter how long it takes.
   * Fail if an error occurs in the meantime, or if the stream finishes before
   * enough data is available.
   *
   * Note: This function won't work fully correctly if you are using
   * stream-browserify (for example, on the Web).
   *
   * @param {number} size The number of bytes to read.
   * @returns {Promise<string|Buffer>} A promise for the data read.
   */
  readFull(size) {
    let onReadable = null
    let onFinish = null
    let onError = null
    return new Promise((resolve, reject) => {
      if (this.length >= size) {
        resolve(this.read(size))
        return
      }

      // Added in Node 12.19.  This won't work with stream-browserify yet.
      // If it's needed, file a bug, and I'll do a work-around.
      if (this.writableFinished) {
        // Already finished writing, so no more coming.
        reject(new Error(`Stream finished before ${size} bytes were available`))
        return
      }

      onReadable = chunk => {
        if (this.length >= size) {
          resolve(this.read(size))
        }
      }
      onFinish = () => {
        reject(new Error(`Stream finished before ${size} bytes were available`))
      }
      onError = reject
      this.on('readable', onReadable)
      this.on('error', onError)
      this.on('finish', onFinish)
    }).finally(() => {
      if (onReadable) {
        this.removeListener('readable', onReadable)
        this.removeListener('error', onError)
        this.removeListener('finish', onFinish)
      }
    })
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {Function} [cb=null] Finished/error callback used in *addition*
   *   to the promise.
   * @returns {Promise<Buffer|string>} Fulfilled when complete.
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', er => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other The other object to compare.
   * @returns {number} -1, 0, 1 for less, equal, greater.
   * @throws {TypeError} Arguments must be NoFilters.
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    }

    const buf1 = this.slice()
    const buf2 = other.slice()
    // These will both be buffers because of the check above.
    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
      return buf1.compare(buf2)
    }
    throw new Error('Cannot compare streams in object mode')
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other Other NoFilter to compare against.
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {number} [start=0] Beginning offset.
   * @param {number} [end=length] Ending offset.
   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    // @ts-ignore: TS2339 (using internal interface)
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default: {
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
      }
    }
  }

  /**
   * Get a byte by offset.  I didn't want to get into metaprogramming
   * to give you the `NoFilter[0]` syntax.
   *
   * @param {number} index The byte to retrieve.
   * @returns {number} 0-255.
   */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so that
   * round-tripping will produce a Buffer.
   *
   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,
   *   the objects.  Otherwise, JSON text.
   * @example <caption>output for 'foo', not in object mode</caption>
   * ({
   *   type: 'Buffer',
   *   data: [102, 111, 111],
   * })
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    }
    return b
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?
   * @param {number} [start=0] Start offset.
   * @param {number} [end=length] End offset.
   * @returns {string} String version of the contents.
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if (!encoding || (encoding === 'utf8')) {
      return td.decode(buf)
    }
    return buf.toString(encoding)
  }

  /**
   * @ignore
   */
  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map(b => {
      if (Buffer.isBuffer(b)) {
        return options.stylize(b.toString('hex'), 'string')
      }
      return JSON.stringify(b)
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @returns {number} Length of the contents.
   */
  get length() {
    // @ts-ignore: TS2339 (using internal interface)
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val The value to write.
   * @returns {boolean} True on success.
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // Two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = `0${str}`
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number} [len=null] Number of bytes to read or all remaining
   *   if null.
   * @returns {bigint} A BigInt.
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt(`0x${b.toString('hex')}`)
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] Number of bytes to read or all remaining
   *   if null.
   * @returns {bigint} A BigInt.
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt(`0x${b.toString('hex')}`)
    // Negative?
    if (b[0] & 0x80) {
      // Two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret -= mask
    }
    return ret
  }

  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @param {number} value 0..255.
   * @returns {boolean} True on success.
   */
  writeUInt8(value) {
    const b = Buffer.from([value])
    return this.push(b)
  }

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @param {number} value 0..65535.
   * @returns {boolean} True on success.
   */
  writeUInt16LE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16LE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @param {number} value 0..65535.
   * @returns {boolean} True on success.
   */
  writeUInt16BE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16BE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @param {number} value 0..2**32-1.
   * @returns {boolean} True on success.
   */
  writeUInt32LE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32LE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @param {number} value 0..2**32-1.
   * @returns {boolean} True on success.
   */
  writeUInt32BE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32BE(value)
    return this.push(b)
  }

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @param {number} value (-128)..127.
   * @returns {boolean} True on success.
   */
  writeInt8(value) {
    const b = Buffer.from([value])
    return this.push(b)
  }

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @param {number} value (-32768)..32767.
   * @returns {boolean} True on success.
   */
  writeInt16LE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @param {number} value (-32768)..32767.
   * @returns {boolean} True on success.
   */
  writeInt16BE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16BE(value)
    return this.push(b)
  }

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @param {number} value (-2**31)..(2**31-1).
   * @returns {boolean} True on success.
   */
  writeInt32LE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @param {number} value (-2**31)..(2**31-1).
   * @returns {boolean} True on success.
   */
  writeInt32BE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32BE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @param {number} value 32-bit float.
   * @returns {boolean} True on success.
   */
  writeFloatLE(value) {
    const b = Buffer.alloc(4)
    b.writeFloatLE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @param {number} value 32-bit float.
   * @returns {boolean} True on success.
   */
  writeFloatBE(value) {
    const b = Buffer.alloc(4)
    b.writeFloatBE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.
   *
   * @param {number} value 64-bit float.
   * @returns {boolean} True on success.
   */
  writeDoubleLE(value) {
    const b = Buffer.alloc(8)
    b.writeDoubleLE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @param {number} value 64-bit float.
   * @returns {boolean} True on success.
   */
  writeDoubleBE(value) {
    const b = Buffer.alloc(8)
    b.writeDoubleBE(value)
    return this.push(b)
  }

  /**
   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value BigInt.
   * @returns {boolean} True on success.
   */
  writeBigInt64LE(value) {
    const b = Buffer.alloc(8)
    b.writeBigInt64LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value BigInt.
   * @returns {boolean} True on success.
   */
  writeBigInt64BE(value) {
    const b = Buffer.alloc(8)
    b.writeBigInt64BE(value)
    return this.push(b)
  }

  /**
   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value Non-negative BigInt.
   * @returns {boolean} True on success.
   */
  writeBigUInt64LE(value) {
    const b = Buffer.alloc(8)
    b.writeBigUInt64LE(value)
    return this.push(b)
  }

  /**
   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value Non-negative BigInt.
   * @returns {boolean} True on success.
   */
  writeBigUInt64BE(value) {
    const b = Buffer.alloc(8)
    b.writeBigUInt64BE(value)
    return this.push(b)
  }

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @returns {number} Value read.
   */
  readUInt8() {
    const b = this.read(1)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt8()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt16LE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt16LE()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt16BE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt16BE()
  }

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt32LE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt32LE()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt32BE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt32BE()
  }

  /**
   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @returns {number} Value read.
   */
  readInt8() {
    const b = this.read(1)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt8()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readInt16LE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt16LE()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readInt16BE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt16BE()
  }

  /**
   * Read a little-endian signed 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readInt32LE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt32LE()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readInt32BE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt32BE()
  }

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readFloatLE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readFloatLE()
  }

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readFloatBE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readFloatBE()
  }

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @returns {number} Value read.
   */
  readDoubleLE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readDoubleLE()
  }

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @returns {number} Value read.
   */
  readDoubleBE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readDoubleBE()
  }

  /**
   * Read a signed 64-bit little-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigInt64LE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigInt64LE()
  }

  /**
   * Read a signed 64-bit big-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigInt64BE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigInt64BE()
  }

  /**
   * Read an unsigned 64-bit little-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigUInt64LE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigUInt64LE()
  }

  /**
   * Read an unsigned 64-bit big-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigUInt64BE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigUInt64BE()
  }
}

module.exports = NoFilter


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = $Object(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = $Object(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


/***/ }),

/***/ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js");

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ "./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js":
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js ***!
  \**************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];


/***/ }),

/***/ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js ***!
  \****************************************************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
var once = __webpack_require__(/*! once */ "./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js")
var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js")
var fs

try {
  fs = __webpack_require__(/*! fs */ "?bfdd") // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ "./node_modules/.pnpm/pumpify@2.0.1/node_modules/pumpify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/pumpify@2.0.1/node_modules/pumpify/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pump = __webpack_require__(/*! pump */ "./node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Duplexify = __webpack_require__(/*! duplexify */ "./node_modules/.pnpm/duplexify@4.1.3/node_modules/duplexify/index.js")

var toArray = function(args) {
  if (!args.length) return []
  return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)
}

var define = function(opts) {
  var Pumpify = function() {
    var streams = toArray(arguments)
    if (!(this instanceof Pumpify)) return new Pumpify(streams)
    Duplexify.call(this, null, null, opts)
    if (streams.length) this.setPipeline(streams)
  }

  inherits(Pumpify, Duplexify)

  Pumpify.prototype.setPipeline = function() {
    var streams = toArray(arguments)
    var self = this
    var ended = false
    var w = streams[0]
    var r = streams[streams.length-1]

    r = r.readable ? r : null
    w = w.writable ? w : null

    var onclose = function() {
      streams[0].emit('error', new Error('stream was destroyed'))
    }

    this.on('close', onclose)
    this.on('prefinish', function() {
      if (!ended) self.cork()
    })

    pump(streams, function(err) {
      self.removeListener('close', onclose)
      if (err) return self.destroy(err.message === 'premature close' ? null : err)
      ended = true
      // pump ends after the last stream is not writable *but*
      // pumpify still forwards the readable part so we need to catch errors
      // still, so reenable autoDestroy in this case
      if (self._autoDestroy === false) self._autoDestroy = true
      self.uncork()
    })

    if (this.destroyed) return onclose()
    this.setWritable(w)
    this.setReadable(r)
  }

  return Pumpify
}

module.exports = define({autoDestroy:false, destroy:false})
module.exports.obj = define({autoDestroy: false, destroy:false, objectMode:true, highWaterMark:16})
module.exports.ctor = define


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ "?9bba");
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __webpack_require__(/*! ./end-of-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"),
  Buffer = _require.Buffer;
var _require2 = __webpack_require__(/*! util */ "?b231"),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes).ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \********************************************************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes).ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js");
exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js");


/***/ }),

/***/ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var isRegex = __webpack_require__(/*! is-regex */ "./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js");

var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

/** @type {import('.')} */
module.exports = function regexTester(regex) {
	if (!isRegex(regex)) {
		throw new $TypeError('`regex` must be a RegExp');
	}
	return function test(s) {
		return $exec(regex, s) !== null;
	};
};


/***/ }),

/***/ "./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter);
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/lib/_stream_readable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
Stream.Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/lib/_stream_duplex.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
Stream.Transform = __webpack_require__(/*! readable-stream/lib/_stream_transform.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/lib/_stream_passthrough.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js");
Stream.finished = __webpack_require__(/*! readable-stream/lib/internal/streams/end-of-stream.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
Stream.pipeline = __webpack_require__(/*! readable-stream/lib/internal/streams/pipeline.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js")

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/.pnpm/stream-shift@1.0.3/node_modules/stream-shift/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/stream-shift@1.0.3/node_modules/stream-shift/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    var idx = state.bufferIndex || 0
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    } else if (state.buffer.length - idx > 0 && state.buffer[idx]) {
      return state.buffer[idx].length
    }
  }

  return state.length
}


/***/ }),

/***/ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "?78b1");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (false) // removed by dead control flow
{ var debugEnv; }
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js ***!
  \***********************************************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "./src/MemoryChannel.ts":
/*!******************************!*\
  !*** ./src/MemoryChannel.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryChannel = void 0;
exports.pipeChannels = pipeChannels;
exports.unpipeChannels = unpipeChannels;
exports.StreamChannel = StreamChannel;
exports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;
exports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./cryptoChannel */ "./src/cryptoChannel.ts"));
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Pipes two channels together, creating a bidirectional flow where
 * messages sent to one channel are automatically forwarded to the other.
 * @param channel1 The first channel to connect
 * @param channel2 The second channel to connect
 * @returns A Promise that resolves when both channels close
 */
function pipeChannels(channel1, channel2) {
    let running = true;
    // Start both piping directions
    const pipe1to2 = async () => {
        try {
            await channel1.start();
            await channel2.start();
            console.log("pipe1to2");
            while (running) {
                try {
                    const data = await channel1.receive();
                    console.log("pipe1to2", data);
                    if (!running || data.length === 0)
                        break;
                    channel2.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe1to2:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe1to2:", error);
        }
    };
    const pipe2to1 = async () => {
        try {
            while (running) {
                console.log("pipe2to1");
                try {
                    const data = await channel2.receive();
                    console.log("pipe2to1", data);
                    if (!running || data.length === 0)
                        break;
                    channel1.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe2to1:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe2to1:", error);
        }
    };
    // Start the pipes
    pipe1to2();
    pipe2to1();
    // Return function to stop piping
    return async () => {
        running = false;
        await Promise.all([channel1.close(), channel2.close()]);
    };
}
/**
 * Utility function that stops an active channel pipe
 * @param channel1 The first channel in the pipe
 * @param channel2 The second channel in the pipe
 */
async function unpipeChannels(channel1, channel2) {
    await Promise.all([channel1.close(), channel2.close()]);
}
function StreamChannel(channel) {
    const onData = async (callback) => {
        let message = await channel.receive();
        while (message) {
            callback(message);
            if (message.toString("utf-8") === "EOF") {
                return;
            }
            message = await channel.receive();
        }
    };
    const getWriteStream = () => {
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                channel.send(chunk);
                done();
            },
        });
        return stream;
    };
    const upload = async (stream) => {
        return new Promise((resolve) => {
            const writeStream = getWriteStream();
            stream.pipe(writeStream).once("finish", () => {
                channel.send(buffer_1.Buffer.from("EOF", "utf-8"));
                writeStream.end();
                resolve();
            });
        });
    };
    const uploadData = async (data) => {
        const stream = stream_1.Readable.from(data);
        await upload(stream);
    };
    const download = async (stream) => {
        const readStream = getReadStream();
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve();
        }));
        readStream.pipe(stream);
        await result;
    };
    const downloadData = async () => {
        const readStream = getReadStream();
        const chunks = [];
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve(buffer_1.Buffer.concat(chunks));
        }));
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                chunks.push(chunk);
                done();
            },
        });
        readStream.pipe(stream);
        return result;
    };
    const getReadStream = () => {
        let push;
        let temp;
        const stream = new stream_1.Stream.Readable({
            read() {
                push = (data) => this.push(data);
            },
        });
        onData((buf) => {
            if (buf.length === 3 && buf.toString("utf-8") === "EOF" && push) {
                temp && push(temp);
                push(null);
                stream.destroy();
            }
            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;
            if (push) {
                !push(temp) && (push = null);
                temp = null;
            }
        });
        return stream;
    };
    return {
        getReadStream,
        getWriteStream,
        upload,
        uploadData,
        download,
        downloadData,
    };
}
function convertWebWritableStreamToNodeWritable(webWritableStream) {
    const writer = webWritableStream.getWriter();
    return new stream_1.Writable({
        async write(chunk, encoding, callback) {
            try {
                // Get a writer from the Web WritableStream
                await writer.write(chunk);
                writer.releaseLock(); // Release the lock on the writer after writing
                callback(); // Signal that the chunk has been processed
            }
            catch (error) {
                callback(); // Signal an error if it occurred
            }
        },
        async final(callback) {
            try {
                // Close the Web WritableStream
                const writer = webWritableStream.getWriter();
                await writer.close();
                writer.releaseLock(); // Release the lock on the writer after closing
                callback(); // Signal that the stream is finished
            }
            catch (error) {
                callback(); // Signal an error if it occurred during close
            }
        },
        async destroy(error, callback) {
            try {
                // Abort the Web WritableStream in case of an error
                const writer = webWritableStream.getWriter();
                await writer.abort(error);
                writer.releaseLock(); // Release the lock on the writer after aborting
                callback(error); // Signal that the stream is destroyed
            }
            catch (abortError) {
                callback(null); // Signal an error if it occurred during abort
            }
        },
    });
}
function convertWebReadableStreamToNodeReadable(webReadableStream) {
    const reader = webReadableStream.getReader();
    return new stream_1.Readable({
        async read() {
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    //console.log(value);
                    if (done) {
                        this.push(null); // Signal the end of the stream
                        break;
                    }
                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer
                }
            }
            catch (error) {
                this.destroy();
            }
        },
    });
}
class MemoryChannel {
    constructor() {
        this.messageQueue = [];
        this.waitingResolvers = [];
        this.connected = false;
        this.connectedCallbacks = [];
        this.closed = false;
    }
    setChannel(chan, name) {
        this.name = name;
        this.otherend = chan;
    }
    static createBidirectionnal() {
        const input = new MemoryChannel();
        const output = new MemoryChannel();
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    onConnected(callback) {
        if (this.connected) {
            callback();
        }
        else {
            this.connectedCallbacks.push(callback);
        }
    }
    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {
        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    getConnectionString() {
        return "vaultys://memory";
    }
    fromConnectionString(string) {
        return string === "vaultys://memory" ? new MemoryChannel() : null;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setInjector(injector) {
        this.injector = injector;
    }
    async start() {
        this.connected = true;
        this.connectedCallbacks.forEach((callback) => callback());
        this.connectedCallbacks = []; // Clear callbacks after calling them
    }
    async send(data) {
        if (this.closed) {
            throw new Error("Cannot send on closed channel");
        }
        if (!this.otherend) {
            throw new Error("No other end connected to this channel");
        }
        // Log the data if a logger is set
        if (this.logger) {
            this.logger(data);
        }
        // Process data through injector if present
        let processedData = data;
        if (this.injector) {
            processedData = await this.injector(data);
        }
        // // Signal that this end is connected
        if (!this.connected) {
            await this.start();
        }
        // Deliver the message to the other end
        this.otherend.deliverMessage(processedData);
    }
    deliverMessage(data) {
        // If there are waiting receivers, deliver directly to the first one
        if (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            resolver(data);
        }
        else {
            // Otherwise queue the message
            this.messageQueue.push(data);
        }
    }
    async receive() {
        if (this.closed) {
            throw new Error("Cannot receive on closed channel");
        }
        //console.log(this);
        // If there are queued messages, return the first one
        if (this.messageQueue.length > 0) {
            return this.messageQueue.shift();
        }
        // Otherwise, wait for a message to arrive
        return new Promise((resolve) => {
            this.waitingResolvers.push(resolve);
        });
    }
    async close() {
        this.closed = true;
        // Clear any waiting receivers with an error
        while (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            // Resolve with empty buffer to indicate channel closed
            resolver(buffer_1.Buffer.alloc(0));
        }
        // Clear the message queue
        this.messageQueue = [];
    }
}
exports.MemoryChannel = MemoryChannel;


/***/ }),

/***/ "./src/MemoryStorage.ts":
/*!******************************!*\
  !*** ./src/MemoryStorage.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const replacer = (key, value) => {
    //if(key=="1686045792046") console.log(value);
    if (!value)
        return value;
    if (key === "certificate")
        return "__C__" + buffer_1.Buffer.from(value).toString("base64");
    if (value.type === "Buffer") {
        return "_bx_" + buffer_1.Buffer.from(value.data).toString("base64");
    }
    if (value.constructor.name === "Array") {
        return "_bx_" + buffer_1.Buffer.from(value).toString("base64");
    }
    return value;
};
const reviver = (key, value) => {
    if (value && key === "certificate") {
        if (typeof value === "string" && value.startsWith("__C__")) {
            return buffer_1.Buffer.from(value.slice(5), "base64");
        }
        else
            return buffer_1.Buffer.from(value);
    }
    if (typeof value === "string" && value.startsWith("_bx_")) {
        return buffer_1.Buffer.from(value.slice(4), "base64");
    }
    return value;
};
const serialize = (data) => JSON.stringify(data, replacer);
exports.serialize = serialize;
const deserialize = (string) => JSON.parse(string, reviver);
exports.deserialize = deserialize;
const MemoryStorage = (save) => {
    let data = {};
    if (!save)
        save = () => (0, exports.serialize)(data);
    return storagify(data, save, () => "");
};
exports.MemoryStorage = MemoryStorage;
const LocalStorage = (key = "vaultysStorage") => {
    let data = {};
    const _id = Math.random();
    //console.log(key);
    if (!localStorage[key])
        localStorage[key] = "{}";
    else
        data = (0, exports.deserialize)(localStorage[key]);
    return storagify(data, () => {
        //console.log("save !!!!!", key, _id);
        localStorage.setItem(key, (0, exports.serialize)(data));
    }, () => localStorage.removeItem(key));
};
exports.LocalStorage = LocalStorage;
const storagify = (object, save, destroy) => {
    return {
        destroy,
        save,
        toString: () => (0, exports.serialize)(object),
        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),
        _raw: object,
        set: (key, value) => (object[key] = value),
        delete: (key) => delete object[key],
        get: (key) => object[key],
        list: () => Object.keys(object).filter((k) => !k.startsWith("!")),
        listSubstores: () => Object.keys(object)
            .filter((k) => k.startsWith("!"))
            .map((k) => k.slice(1)),
        deleteSubstore: (key) => delete object["!" + key],
        renameSubstore: (oldname, newname) => {
            if (oldname === newname || !!object["!" + newname])
                return;
            object["!" + newname] = object["!" + oldname];
            delete object["!" + oldname];
        },
        substore: (key) => {
            if (!object["!" + key])
                object["!" + key] = {};
            return storagify(object["!" + key], save, destroy);
        },
    };
};


/***/ }),

/***/ "./src/crypto.ts":
/*!***********************!*\
  !*** ./src/crypto.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hmac = exports.hash = exports.Buffer = void 0;
const tweetnacl_1 = __importStar(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
Object.defineProperty(exports, "Buffer", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const getAlgorithm = (alg) => {
    const cleanAlg = alg.replaceAll("-", "").toLowerCase();
    if (cleanAlg === "sha256")
        return sha2_1.sha256;
    if (cleanAlg === "sha512")
        return sha2_1.sha512;
    if (cleanAlg === "sha224")
        return sha2_1.sha224;
    return sha2_1.sha256;
};
const _randomBytes = (size) => buffer_1.Buffer.from((0, tweetnacl_1.randomBytes)(size));
exports.randomBytes = _randomBytes;
const hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).create().update(buffer).digest());
exports.hash = hash;
const _hmac = (alg, key, data) => buffer_1.Buffer.from((0, hmac_1.hmac)(getAlgorithm(alg), key, data));
exports.hmac = _hmac;
const secretbox = tweetnacl_1.default.secretbox;
exports.secretbox = secretbox;
const toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("base64");
exports.toBase64 = toBase64;
const toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("hex");
exports.toHex = toHex;
const toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("utf-8");
exports.toUTF8 = toUTF8;
const fromBase64 = (string) => buffer_1.Buffer.from(string, "base64");
exports.fromBase64 = fromBase64;
const fromHex = (string) => buffer_1.Buffer.from(string, "hex");
exports.fromHex = fromHex;
const fromUTF8 = (string) => buffer_1.Buffer.from(string, "utf-8");
exports.fromUTF8 = fromUTF8;
const secureErase = (buffer) => {
    for (let i = 0; i < buffer.length; i++) {
        buffer[i] = 0;
    }
};
exports.secureErase = secureErase;


/***/ }),

/***/ "./src/cryptoChannel.ts":
/*!******************************!*\
  !*** ./src/cryptoChannel.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);
const encrypt = (buffer, key) => {
    //console.log("encrypting: ", buffer, key)
    const keyUint8Array = key;
    const nonce = newNonce();
    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return buffer_1.Buffer.from(fullMessage);
};
exports.encrypt = encrypt;
const decrypt = (messageWithNonce, key) => {
    //console.log("decrypting: ", messageWithNonce, key)
    const keyUint8Array = key;
    const messageWithNonceAsUint8Array = messageWithNonce;
    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);
    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);
    if (!decrypted) {
        throw new Error("Could not decrypt message");
    }
    return buffer_1.Buffer.from(decrypted);
};
exports.decrypt = decrypt;
// upgrading a channel api with an encrypting layer. The API shoud be
// - send(Buffer):null
// - async receive():Buffer
const encryptChannel = (channel, key) => {
    const sendHandler = {
        apply(target, that, args) {
            return target.call(that, (0, exports.encrypt)(args[0], key));
        },
    };
    const receiveHandler = {
        async apply(target, that, args) {
            const result = await target.call(that);
            return (0, exports.decrypt)(result, key);
        },
    };
    channel.send = new Proxy(channel.send, sendHandler);
    channel.receive = new Proxy(channel.receive, receiveHandler);
    return channel;
};
const generateKey = () => (0, crypto_1.randomBytes)(32);
exports["default"] = {
    decrypt: exports.decrypt,
    encrypt: exports.encrypt,
    encryptChannel,
    generateKey,
};


/***/ }),

/***/ "./src/platform/SoftCredentials.ts":
/*!*****************************************!*\
  !*** ./src/platform/SoftCredentials.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: to revamp and optimize
// import crypto from "crypto";
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/crypto.ts");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
const p256_1 = __webpack_require__(/*! @noble/curves/p256 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js");
const p384_1 = __webpack_require__(/*! @noble/curves/p384 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js");
const p521_1 = __webpack_require__(/*! @noble/curves/p521 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js");
// import { BasicConstraintsExtension, X509Certificate } from "@peculiar/x509";
const pqCrypto_1 = __webpack_require__(/*! ../pqCrypto */ "./src/pqCrypto.ts");
const credentials = {};
//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;
const COSEKEYS = {
    kty: 1,
    alg: 3,
    crv: -1,
    x: -2,
    y: -3,
    n: -1,
    e: -2,
};
const COSEKTY = {
    OKP: 1,
    EC2: 2,
    RSA: 3,
    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,
};
const COSERSASCHEME = {
    "-3": "pss-sha256",
    "-39": "pss-sha512",
    "-38": "pss-sha384",
    "-65535": "pkcs1-sha1",
    "-257": "pkcs1-sha256",
    "-258": "pkcs1-sha384",
    "-259": "pkcs1-sha512",
};
const COSECRV = {
    1: p256_1.p256,
    2: p384_1.p384,
    3: p521_1.p521,
};
const COSEALGHASH = {
    "-257": "SHA-256",
    "-258": "SHA-384",
    "-259": "SHA-512",
    "-65535": "SHA-1",
    "-39": "SHA-512",
    "-38": "SHA-384",
    "-37": "SHA-256",
    "-260": "SHA-256",
    "-261": "SHA-512",
    "-7": "SHA-256",
    "-36": "SHA-512",
    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: "SHA-256", // DILITHIUM2 uses SHA-256 for hashing
};
const hash = (alg, message) => (0, crypto_1.hash)(alg.replace("-", ""), message);
const base64ToPem = (b64cert) => {
    let pemcert = "";
    for (let i = 0; i < b64cert.length; i += 64)
        pemcert += b64cert.slice(i, i + 64) + "\n";
    return "-----BEGIN CERTIFICATE-----\n" + pemcert + "-----END CERTIFICATE-----";
};
// const getCertificateInfo = (certificate: Buffer) => {
//   const x509 = new X509Certificate(certificate);
//   const subjectString = x509.subject;
//   const issuer = x509.issuer;
//   const issuerName = x509.issuerName.toString();
//   const subjectParts = subjectString.split(",");
//   const subject: Record<string, string> = {};
//   for (const field of subjectParts) {
//     const kv = field.split("=");
//     subject[kv[0].trim()] = kv[1];
//   }
//   // console.log(subject);
//   const { Version } = x509.toTextObject().Data as unknown as { Version: string };
//   const bc = x509.getExtension(BasicConstraintsExtension);
//   const basicConstraintsCA = bc ? bc.ca : false;
//   return {
//     issuer,
//     issuerName,
//     subject,
//     version: Version,
//     basicConstraintsCA,
//   };
// };
const parseAuthData = (buffer) => {
    const rpIdHash = buffer.slice(0, 32);
    buffer = buffer.slice(32);
    const flagsBuf = buffer.slice(0, 1);
    buffer = buffer.slice(1);
    const flagsInt = flagsBuf[0];
    const flags = {
        up: !!(flagsInt & 0x01),
        uv: !!(flagsInt & 0x04),
        at: !!(flagsInt & 0x40),
        ed: !!(flagsInt & 0x80),
        flagsInt,
    };
    const counterBuf = buffer.slice(0, 4);
    buffer = buffer.slice(4);
    const counter = counterBuf.readUInt32BE(0);
    let aaguid = undefined;
    let credID = undefined;
    let COSEPublicKey = undefined;
    if (flags.at) {
        aaguid = buffer.slice(0, 16);
        buffer = buffer.slice(16);
        const credIDLenBuf = buffer.slice(0, 2);
        buffer = buffer.slice(2);
        const credIDLen = credIDLenBuf.readUInt16BE(0);
        credID = buffer.slice(0, credIDLen);
        buffer = buffer.slice(credIDLen);
        COSEPublicKey = buffer;
    }
    //console.log(aaguid);
    return {
        rpIdHash,
        flagsBuf,
        flags,
        counter,
        counterBuf,
        aaguid,
        credID,
        COSEPublicKey,
    };
};
const verifyPackedAttestation = (response, userVerification = false) => {
    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
    if (attestationStruct.fmt == "none")
        return false;
    const authDataStruct = parseAuthData(attestationStruct.authData);
    // check if user has actually touched the device
    if (!authDataStruct.flags.up)
        return false;
    // check if did enter PIN code
    if (userVerification && !authDataStruct.flags.uv)
        return false;
    const clientDataHashBuf = hash("sha256", buffer_1.Buffer.from(response.clientDataJSON));
    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);
    const signature = attestationStruct.attStmt.sig;
    let signatureIsValid = false;
    /* ----- Verify FULL attestation ----- */
    // if (attestationStruct.attStmt.x5c) {
    //   const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString("base64"));
    //   const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);
    //   const subject = certInfo.subject as {
    //     OU: string;
    //     O: string;
    //     C: string;
    //     CN: string;
    //   };
    //   // console.log(certInfo);
    //   if (subject.OU !== "Authenticator Attestation") throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');
    //   if (!subject.CN) throw new Error("Batch certificate CN MUST no be empty!");
    //   if (!subject.O) throw new Error("Batch certificate O MUST no be empty!");
    //   if (!subject.C || subject.C.length !== 2) throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");
    //   if (certInfo.basicConstraintsCA) throw new Error("Batch certificate basic constraints CA MUST be false!");
    //   if (certInfo.version !== "v3 (2)") throw new Error("Batch certificate version MUST be 3(ASN1 2)!");
    //   signatureIsValid = crypto.createVerify("sha256").update(dataBuffer).verify(leafCert, signature);
    //   /* ----- Verify FULL attestation ENDS ----- */
    // } else
    if (attestationStruct.attStmt.ecdaaKeyId) {
        throw new Error("ECDAA IS NOT SUPPORTED!");
    }
    else {
        /* ----- Verify SURROGATE attestation ----- */
        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];
        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];
        const data = hash(hashAlg, dataBuffer);
        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {
            // ECDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            const y = pubKeyCose.get(COSEKEYS.y);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);
            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];
            const sig = ec.Signature.fromDER(signature);
            signatureIsValid = ec.verify(sig, data, pubKey);
        }
        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {
            // EdDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);
        }
        else {
            return false;
        }
        /* ----- Verify SURROGATE attestation ENDS ----- */
    }
    if (!signatureIsValid)
        throw new Error("Failed to verify the signature!");
    return true;
};
class MyPublicKeyCredential {
    constructor(creds) {
        this.type = "public-key";
        this.clientExtensionResults = {};
        const keys = ["id", "rawId", "response"];
        this.id = creds.id;
        this.rawId = buffer_1.Buffer.from(creds.rawId);
        this.response = creds.response;
    }
    getClientExtensionResults() {
        return {};
    }
}
const verifyECDSA = (data, publicKey, signature) => {
    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);
};
const verifyEdDSA = (data, publicKey, signature) => {
    return ed25519_1.ed25519.verify(signature, data, publicKey);
};
// Webauthn Partial Implementation for testing
class SoftCredentials {
    constructor() {
        this.signCount = 0;
        this.rawId = (0, crypto_1.randomBytes)(32);
        this.aaguid = buffer_1.Buffer.alloc(16);
    }
    // credentials request payload
    static createRequest(alg, prf = false) {
        const challenge = buffer_1.Buffer.from((0, crypto_1.randomBytes)(32).toString("base64"));
        const result = {
            publicKey: {
                challenge,
                rp: {
                    name: "Vaultys ID",
                    id: "Vaultys ID",
                },
                user: {
                    id: buffer_1.Buffer.from("Vaultys Wallet ID", "utf8"),
                    name: "Vaultys Wallet ID",
                    displayName: "Vaultys Wallet ID",
                },
                pubKeyCredParams: [
                    {
                        type: "public-key",
                        alg,
                    },
                ],
            },
        };
        if (prf) {
            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_1.randomBytes)(32) } } };
        }
        return result;
    }
    // static getCertificateInfo(response: AuthenticatorAttestationResponse) {
    //   const attestationBuffer = Buffer.from(response.attestationObject);
    //   const attestationStruct = cbor.decodeAllSync(attestationBuffer)[0];
    //   if (attestationStruct.attStmt.x5c) {
    //     return getCertificateInfo(attestationStruct.attStmt.x5c[0]);
    //   } else {
    //     return null;
    //   }
    // }
    static async create(options, origin = "test") {
        const credential = new SoftCredentials();
        const publicKey = options.publicKey;
        credential.options = publicKey;
        credential.rpId = publicKey.rp.id || publicKey.rp.name;
        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), "base64");
        credentials[credential.rawId.toString("base64")] = credential; // erase previous instance
        // Get the algorithm from pubKeyCredParams
        const pubKeyCredParams = publicKey.pubKeyCredParams;
        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)
        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
        // Set algorithm, prioritizing DILITHIUM if it's supported
        if (supportsDilithium) {
            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;
        }
        else {
            credential.alg = publicKey.pubKeyCredParams[0].alg;
        }
        if (credential.alg === -8) {
            const random = ed25519_1.ed25519.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: ed25519_1.ed25519.getPublicKey(random),
                algorithm: "EdDSA",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 1);
            credential.coseKey.set(3, -8);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(0, 32);
            credential.coseKey.set(-2, x);
        }
        else if (credential.alg === -7) {
            const random = p256_1.p256.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: p256_1.p256.getPublicKey(random, false),
                algorithm: "ES256",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 2);
            credential.coseKey.set(3, -7);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(1, 33);
            const y = credential.keyPair.publicKey.slice(33);
            credential.coseKey.set(-2, x);
            credential.coseKey.set(-3, y);
            // console.log(extpk,x,y)
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // Generate DILITHIUM key pair
            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();
            //console.log("PQC", dilithiumPk, dilithiumSk);
            credential.keyPair = {
                privateKey: dilithiumSk,
                publicKey: dilithiumPk,
                algorithm: "DILITHIUM2",
                isDILITHIUM: true,
            };
            // Create COSE key representation
            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);
            //console.log("PQC", credential);
        }
        const clientData = {
            type: "webauthn.create",
            challenge: publicKey.challenge,
            origin,
        };
        const rpIdHash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "ascii"));
        const flags = buffer_1.Buffer.from("41", "hex"); // attested_data + user_present
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);
        rawIdLength.writeUInt16BE(credential.rawId.length, 0);
        const coseKey = cbor_1.default.encode(credential.coseKey);
        const attestationObject = {
            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),
            fmt: "none",
            attStmt: {},
        };
        const pkCredentials = {
            id: credential.rawId.toString("base64"),
            rawId: credential.rawId,
            authenticatorAttachment: null,
            type: "public-key",
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    return { prf: { enabled: true } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                attestationObject: cbor_1.default.encode(attestationObject),
                getTransports: () => ["usb", "hybrid"],
                getAuthenticatorData: () => attestationObject.authData,
                getPublicKey: () => coseKey,
                getPublicKeyAlgorithm: () => -7,
            },
        };
        return pkCredentials;
    }
    static simpleVerify(COSEPublicKey, response, userVerification = false) {
        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;
        const rpIdHash = response.authenticatorData.slice(0, 32);
        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];
        const counter = response.authenticatorData.slice(33, 37);
        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);
        if (!goodflags)
            return false;
        const hash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(response.clientDataJSON));
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);
        if (ckey.get(3) == -7) {
            data = (0, crypto_1.hash)("sha256", data);
        }
        if (ckey.get(1) == 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) == 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(response.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);
        }
        return false;
    }
    static getCOSEPublicKey(attestation) {
        const response = attestation.response;
        const ato = cbor_1.default.decode(response.attestationObject);
        //console.log("getCOSEPublicKey", ato, parseAuthData(ato.authData));
        return parseAuthData(ato.authData).COSEPublicKey;
    }
    static verifyPackedAttestation(attestation, userVerification = false) {
        return verifyPackedAttestation(attestation, userVerification);
    }
    static async verify(attestation, assertion, userVerifiation = false) {
        //if (assertion.id !== attestation.id) return false;
        const hash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(assertion.response.clientDataJSON));
        const ass = assertion.response;
        const att = attestation.response;
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);
        const ato = cbor_1.default.decode(att.attestationObject);
        const authData = parseAuthData(ato.authData);
        // check if user has actually touched the device
        if (!authData.flags.up)
            return false;
        // check if the user has entered his PIN code or used biometric sensor
        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)
            return false;
        const ckey = cbor_1.default.decode(authData.COSEPublicKey);
        // Hash data for ES256
        if (ckey.get(3) == -7) {
            data = (0, crypto_1.hash)("sha256", data);
        }
        // Get key type
        const keyType = ckey.get(1);
        if (keyType === 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(ass.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);
        }
        return false;
    }
    static extractChallenge(clientDataJSON) {
        const clientData = JSON.parse(clientDataJSON.toString());
        const m = clientData.challenge.length % 4;
        return clientData.challenge
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), "=");
    }
    static async get({ publicKey }, origin = "test") {
        if (!publicKey.allowCredentials)
            throw new Error();
        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString("base64");
        const credential = credentials[id];
        credential.signCount += 1;
        // prepare signature
        const clientData = {
            type: "webauthn.get",
            challenge: buffer_1.Buffer.from(publicKey.challenge).toString("base64"),
            origin,
        };
        const clientDataHash = (0, crypto_1.hash)("sha256", (0, crypto_1.fromUTF8)(JSON.stringify(clientData)));
        const rpIdHash = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "utf-8"));
        const flags = buffer_1.Buffer.from("05", "hex"); // user verification
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);
        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);
        let signature = new Uint8Array();
        if (credential.alg === -7) {
            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();
        }
        else if (credential.alg === -8) {
            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // DILITHIUM signing - this returns a Promise so we need to await it
            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);
        }
        const pkCredentials = {
            id,
            rawId: buffer_1.Buffer.from(id, "base64").buffer,
            type: "public-key",
            authenticatorAttachment: null,
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    // unsafe and not following w3c recommendation. for testing purpose only
                    return { prf: { results: { first: hash("sha256", publicKey.extensions?.prf?.eval?.first) } } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                authenticatorData,
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                signature: signature,
                userHandle: credential.userHandle,
            },
        };
        return pkCredentials;
    }
}
exports["default"] = SoftCredentials;


/***/ }),

/***/ "./src/pqCrypto.ts":
/*!*************************!*\
  !*** ./src/pqCrypto.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Post-Quantum Cryptography Operations
 *
 * This file contains implementations for post-quantum cryptographic algorithms
 * starting with DILITHIUM for digital signatures.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;
exports.generateDilithiumKeyPair = generateDilithiumKeyPair;
exports.signDilithium = signDilithium;
exports.verifyDilithium = verifyDilithium;
exports.createDilithiumCoseKey = createDilithiumCoseKey;
exports.getDilithiumKeyInfo = getDilithiumKeyInfo;
const ml_dsa_js_1 = __webpack_require__(/*! @noble/post-quantum/ml-dsa.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
/**
 * COSE algorithm identifiers for post-quantum algorithms
 * Note: These values are provisional and may need to be updated as standards evolve
 */
exports.PQ_COSE_ALG = {
    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)
    DILITHIUM2: -46, // Level 2 (128-bit security)
    DILITHIUM3: -47, // Level 3 (192-bit security)
    DILITHIUM5: -48, // Level 5 (256-bit security)
};
/**
 * COSE key type for DILITHIUM
 */
exports.PQ_COSE_KEY_TYPE = {
    DILITHIUM: 4, // Custom key type for DILITHIUM
};
/**
 * COSE key parameter identifiers for DILITHIUM
 */
exports.PQ_COSE_KEY_PARAMS = {
    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)
    DILITHIUM_PK: -101, // Public key
    DILITHIUM_SK: -102, // Secret key
};
/**
 * Generate a DILITHIUM Level 2 key pair
 * @returns Promise resolving to an object containing the key pair
 */
function generateDilithiumKeyPair(seed) {
    if (!seed)
        seed = (0, crypto_1.randomBytes)(32);
    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);
    return {
        publicKey: buffer_1.Buffer.from(keyPair.publicKey),
        secretKey: buffer_1.Buffer.from(keyPair.secretKey),
    };
}
/**
 * Sign a message using DILITHIUM Level 2
 * @param message - The message to sign
 * @param privateKey - The DILITHIUM private key
 * @returns Promise resolving to signature as Uint8Array
 */
function signDilithium(message, secretKey) {
    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));
}
/**
 * Verify a DILITHIUM Level 2 signature
 * @param message - The original message
 * @param signature - The signature to verify
 * @param publicKey - The DILITHIUM public key
 * @returns Promise resolving to boolean indicating if signature is valid
 */
function verifyDilithium(message, signature, publicKey) {
    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);
}
/**
 * Create a COSE key representation for a DILITHIUM public key
 * @param publicKey - The DILITHIUM public key
 * @returns Map representing the COSE key
 */
function createDilithiumCoseKey(publicKey) {
    const coseKey = new Map();
    // Standard COSE key parameters
    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type
    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm
    // DILITHIUM-specific parameters
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);
    return coseKey;
}
/**
 * Get key size information for DILITHIUM
 * @returns Object with key size information
 */
function getDilithiumKeyInfo() {
    return {
        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key
        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key
        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature
    };
}


/***/ }),

/***/ "./test/challenger.test.ts":
/*!*********************************!*\
  !*** ./test/challenger.test.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const testCertificate = (rogueCert) => {
    try {
        const result = __1.Challenger.deserializeCertificate(rogueCert);
        return result;
    }
    catch (error) {
        return {
            state: -2,
        };
    }
};
const delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));
const challengeNext = async (vaultysId, newCertificate, oldCertificate) => {
    //console.log(newCertificate, oldCertificate);
    const challenger = new __1.Challenger(vaultysId);
    challenger.version = 1;
    if (oldCertificate) {
        await challenger.init(oldCertificate);
    }
    else if (!newCertificate) {
        challenger.createChallenge("p2p", "test", 1);
    }
    if (newCertificate)
        await challenger.update(newCertificate);
    return challenger.getCertificate();
};
describe("Symetric Proof of Relationship - SRG - v1", () => {
    it("Perform Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Protocol downgrading to v0", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 0);
        //console.log(challenger1.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Stateless Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const init = await challengeNext(vaultysId1);
        // console.log("init", Challenger.deserializeCertificate(init));
        const step1 = await challengeNext(vaultysId2, init);
        // console.log("step1", Challenger.deserializeCertificate(step1));
        const complete = await challengeNext(vaultysId1, step1);
        // console.log("complete", Challenger.deserializeCertificate(complete));
        const finalise = await challengeNext(vaultysId2, complete, step1);
        assert_1.default.equal(complete.toString("base64"), finalise.toString("base64"));
    });
    it("Perform Protocol attacking protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.protocol = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking service", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.service = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking nonce", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        // console.log(challengerattack.challenge);
        // console.log("boom");
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking timestamp", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.challenge.timestamp = Date.now();
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Timestamp has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered timestamp should have failed");
    });
    it("Perform Protocol attacking with legit but different certificate", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
        const challenger3 = new __1.Challenger(vaultysId1);
        const challenger4 = new __1.Challenger(vaultysId2);
        challenger3.createChallenge("p2p", "auth", 1);
        await challenger4.update(challenger3.getCertificate());
        await challenger3.update(challenger4.getCertificate());
        try {
            await challenger4.update(challenger1.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered legit certificate should have failed");
    });
    it("Fail for liveliness at first round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await delay(100);
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail for liveliness at second round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await delay(100);
        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Pass for liveliness at third round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 500);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 500);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await delay(200);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Fail with time deviation of 60s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail with time deviation of 60s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    /*
    it("Fail with tampered certificate (FIDO2)", async () => {
      const attestation1 = await navigator.credentials.create(
        SoftCredentials.createRequest(-7),
      );
      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);
      const challenger1 = new Challenger(vaultysId1);
  
      const attestation2 = await navigator.credentials.create(
        SoftCredentials.createRequest(-8),
      );
      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate all possibilities (FIDO2)", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        // TODO fix this malleability for
        // timestampDS_ a974696d657374616d70cf000001884453195fa3
        // timestampDS_ a974696d657374616d70d3000001884453195fa3
        // or use another serialisation for identifying certificate.
        if(i != 46 && i != rogueCert.length - 1) {
          for(let j = 0; j < 256; j++){
            if(j != back) {
              rogueCert[i] = j;
              const t = testCertificate(rogueCert);
              if(t.state == 2) {
                console.log(i, j, t);
                console.log(
                  Buffer.from(rogueCert).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(rogueCert).toString("hex").slice(i*2-20, i*2+20),
                  Buffer.from(challenger2.getCertificate()).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(challenger2.getCertificate()).toString("hex").slice(i*2-20, i*2+20)
                );
              }
              assert.notEqual(t.state, 2);
            }
          }
        }
        console.log(i, rogueCert.length);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("random", "test");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
    */
});


/***/ }),

/***/ "./test/challenger_v0.test.ts":
/*!************************************!*\
  !*** ./test/challenger_v0.test.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const cryptoChannel_1 = __webpack_require__(/*! ../src/cryptoChannel */ "./src/cryptoChannel.ts");
const delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));
const challengeNext = async (vaultysId, newCertificate, oldCertificate) => {
    //console.log(newCertificate, oldCertificate);
    const challenger = new __1.Challenger(vaultysId);
    challenger.version = 0;
    if (oldCertificate) {
        await challenger.init(oldCertificate);
    }
    else if (!newCertificate) {
        challenger.createChallenge("p2p", "test", 0);
    }
    if (newCertificate)
        await challenger.update(newCertificate);
    return challenger.getCertificate();
};
describe("Symetric Proof of Relationship - SRG - v0", () => {
    it("Perform Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Stateless Protocol", async () => {
        for (let i = 0; i < 10; i++) {
            const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
            const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
            const init = await challengeNext(vaultysId1);
            // console.log("init", Challenger.deserializeCertificate(init));
            const step1 = await challengeNext(vaultysId2, init);
            // console.log("step1", Challenger.deserializeCertificate(step1));
            const complete = await challengeNext(vaultysId1, step1);
            // console.log("complete", Challenger.deserializeCertificate(complete));
            const finalise = await challengeNext(vaultysId2, complete, step1);
            assert_1.default.equal(complete.toString("base64"), finalise.toString("base64"));
        }
    });
    it("Perform Protocol attacking protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.protocol = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking service", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.service = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking nonce", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        // console.log(challengerattack.challenge);
        // console.log("boom");
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking timestamp", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.challenge.timestamp = Date.now();
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Timestamp has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered timestamp should have failed");
    });
    it("Perform Protocol attacking version", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.version = challengerattack.version ? 1 : 0;
        challengerattack.challenge.version = challengerattack.challenge.version ? 1 : 0;
        try {
            await challenger2.update(challengerattack.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "challenge is not corresponding to the right id");
            return;
        }
        assert_1.default.fail("The protocol with tampered version should have failed");
    });
    it("Perform Protocol attacking with legit but different certificate", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
        const challenger3 = new __1.Challenger(vaultysId1);
        const challenger4 = new __1.Challenger(vaultysId2);
        challenger3.createChallenge("p2p", "auth");
        await challenger4.update(challenger3.getCertificate());
        await challenger3.update(challenger4.getCertificate());
        try {
            await challenger4.update(challenger1.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered legit certificate should have failed");
    });
    it("Fail for liveliness at first round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await delay(100);
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail for liveliness at second round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await delay(100);
        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Pass for liveliness at third round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 500);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 500);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await delay(20);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Fail with time deviation of 60s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail with time deviation of 60s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Should deserialize a succesful v0 certificate", async () => {
        const cert = "iahwcm90b2NvbKNwMnCnc2VydmljZahyZWdpc3Rlcql0aW1lc3RhbXDPAAABko9gLwijcGsxxHQBhKF2AKFwxQAgthOolbL2HWtbnAkuAyLHAjfbnS8njgLhHlxWlosbC6uheMUAIBXMRt4jV1gxWK5/TF1jNx0kD+v2qKTWFnfEDQsrOeIvoWXFACCwkdnz8o6yhL86amqfB4/nUoznXnmSs9wAIIT30iGhaaNwazLEdACEoXYAoXDFACARZg0feo56ckkSEU8xc0G/xCH5vjeLeQjP9/KtRC4X76F4xQAg9qbrfdWleMqBsN8y7qPmZ1/ObCqFxeQmIopZBwJGfa2hZcUAIHKiC8fHbhLl902mhMbl/h04JvVnWLBCyAGb22orn5dVpW5vbmNlxCAofLkkt7f/YFen3ve05OcpDl8AFJRnejfZbMC6q37gOqVzaWduMcRAby4aZAta/aZL/8NxtqX8NnDUMTfXZ44qEdW5QVl3Gp/nh7sNDtdJfpF3XdJ1bJ7FtinGDDtTkRCzW5Hm9S+EAqVzaWduMsRA0xyketeALY1yA/KbPo7gTWTGdBVyxmG4u60kQJ2WtTDdjhVnCVzlb56xZtWhtGX/DJxw43yEehPyPxI/HvgwB6htZXRhZGF0YYA=";
        const result = __1.Challenger.deserializeCertificate(buffer_1.Buffer.from(cert, "base64"));
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 2);
    });
    it("Should deserialize a succesful v0 certificate 2", async () => {
        const message = "QNGwy7yyIskbWees8qH39YHp6QpODl4Gsp970YFp3j+VjWbU2j1wAw7qLMWk0Ra0YeE6mVcENvohrXRfGdcM763qrYTgpFj72+jznW6szC+XxvDFkwCm9tba/qj6H+wpoDKphscI7UzJ8J1RoKytcLl3yg5BF6ikoJW0DMG58jE/T44tyEVhS0XVD5buSF6nGgam0Hge/rOMIh4Z0G6W5XQzEjMlobk7HYEV4nQAxRV8qaSLPtspF1ZcPgke2Q278n/KTwd65Nq+YYkr6cFPkxkmz9jZx9Zv0jKGiOw48MuirweOnD2AtvkpWq5fg6vi+pNZ/tymfIxwQ9LTnYbyKOwMR6/OzTulrbOBNftwDb2+PXLLT9Y=";
        const key = "9ee1d044677cac34984b2da0acbc66d238e884a5e944cde54b96be77e3fc1e8e";
        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, "base64"), buffer_1.Buffer.from(key, "hex"));
        // console.log(dearmorAndDecrypt(cert));
        // console.log(decode(cert));
        const result = __1.Challenger.deserializeCertificate(cert);
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 0);
    });
    it("Should deserialize a succesful v0 certificate 3", async () => {
        const message = "Cf+KnycFC0odoGv9Yxjc2JvUgZSYBNmzBN1UomUz/3VzXds3K/Fr2odh9ZI4q86ZmFsKu/bIxsXhDNg2sM7PhESvgpAJte+3QfVD8e1pzSG4+mqQs2HSkXm5xo6gcPfoN7OyJfzUbaDW5ts1Cy9dIWxJpr8JcT6BUofVgoQk4loi8LPsDdsA4Kxk6FaAE05CeqvuglYayaOnOk/u+cQFHN9rBHe2cpHCrgQAr4Qa+MeLMo4GU7pB4Qd4nA7AQxDBXJqR+tVvPIA2GZWb/EW2OGDFU7YzRJJLP7RdXnjcsSYRkUzuCPpI7l7vfaVy8nxNqy9PkEIPlzyO3TCHOHqHWlEy2YN8O1Mx";
        const key = "cc4dfd01327a30e10d9286344d485f2e4807ddb4c3e007f8b7fba20bb6c16985";
        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, "base64"), buffer_1.Buffer.from(key, "hex"));
        //console.log(dearmorAndDecrypt(cert));
        // console.log(decode(cert));
        const result = __1.Challenger.deserializeCertificate(cert);
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 0);
    });
    /*
    it("Fail with tampered certificate (FIDO2)", async () => {
      const attestation1 = await navigator.credentials.create(
        SoftCredentials.createRequest(-7),
      );
      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);
      const challenger1 = new Challenger(vaultysId1);
  
      const attestation2 = await navigator.credentials.create(
        SoftCredentials.createRequest(-8),
      );
      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate all possibilities (FIDO2)", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        // TODO fix this malleability for
        // timestampDS_ a974696d657374616d70cf000001884453195fa3
        // timestampDS_ a974696d657374616d70d3000001884453195fa3
        // or use another serialisation for identifying certificate.
        if(i != 46 && i != rogueCert.length - 1) {
          for(let j = 0; j < 256; j++){
            if(j != back) {
              rogueCert[i] = j;
              const t = testCertificate(rogueCert);
              if(t.state == 2) {
                console.log(i, j, t);
                console.log(
                  Buffer.from(rogueCert).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(rogueCert).toString("hex").slice(i*2-20, i*2+20),
                  Buffer.from(challenger2.getCertificate()).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(challenger2.getCertificate()).toString("hex").slice(i*2-20, i*2+20)
                );
              }
              assert.notEqual(t.state, 2);
            }
          }
        }
        console.log(i, rogueCert.length);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("random", "test");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
    */
});


/***/ }),

/***/ "./test/channel.test.ts":
/*!******************************!*\
  !*** ./test/channel.test.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const MemoryChannel_1 = __webpack_require__(/*! ../src/MemoryChannel */ "./src/MemoryChannel.ts");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
describe("Channel tests", () => {
    it("send/receive", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
        channel.send(buffer_1.Buffer.from("hello world", "utf-8"));
        const message = await channel.otherend?.receive();
        assert_1.default.equal("hello world", message?.toString("utf-8"));
    });
});
// describe("Channel pipe tests", () => {
//   it("should pipe data between two memory channels", async () => {
//     // Create endpoints for A and B
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     console.log("started");
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     channelA.setLogger(console.log);
//     channelB.setLogger(console.log);
//     // Start piping between the two channels
//     const unpipe = pipeChannels(channelA, channelB);
//     await delay(10);
//     const messageAtB = receiverB.receive();
//     // Send data from A to B
//     channelA.send(Buffer.from("hello from A", "utf-8"));
//     // Receive on B's side
//     console.log(await messageAtB);
//     console.log("Data sent from A to B");
//     // Send data from B to A
//     await channelB.send(Buffer.from("hello from B", "utf-8"));
//     // Receive on A's side
//     const messageAtA = await receiverA.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(messageAtB.toString("utf-8"), "hello from A");
//     assert.equal(messageAtA.toString("utf-8"), "hello from B");
//   });
//   it("should pipe data between encrypted memory channels", async () => {
//     // Create encrypted endpoints
//     const channelA = MemoryChannel.createEncryptedBidirectionnal();
//     const channelB = MemoryChannel.createEncryptedBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Send multiple messages from A to B
//     await channelA.send(Buffer.from("message 1", "utf-8"));
//     await channelA.send(Buffer.from("message 2", "utf-8"));
//     // Receive on B
//     const message1AtB = await receiverB.receive();
//     const message2AtB = await receiverB.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(message1AtB.toString("utf-8"), "message 1");
//     assert.equal(message2AtB.toString("utf-8"), "message 2");
//   });
//   it("should handle large data transfers", async () => {
//     // Create endpoints
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Create a large buffer (1MB)
//     const largeData = Buffer.alloc(1024 * 1024);
//     largeData.fill(42);
//     // Send large data from A to B
//     await channelA.send(largeData);
//     // Receive on B
//     const receivedData = await receiverB.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(receivedData.length, largeData.length);
//     assert.ok(receivedData.equals(largeData));
//   });
//   it("should handle bidirectional communication simultaneously", async () => {
//     // Create endpoints
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Send messages in both directions
//     await Promise.all([channelA.send(Buffer.from("from A to B", "utf-8")), channelB.send(Buffer.from("from B to A", "utf-8"))]);
//     // Receive in both directions
//     const [messageAtB, messageAtA] = await Promise.all([receiverB.receive(), receiverA.receive()]);
//     // Clean up
//     await unpipe();
//     // Verify bidirectional data transmission
//     assert.equal(messageAtB.toString("utf-8"), "from A to B");
//     assert.equal(messageAtA.toString("utf-8"), "from B to A");
//   });
// });


/***/ }),

/***/ "./test/file.browser_test.ts":
/*!***********************************!*\
  !*** ./test/file.browser_test.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const MemoryChannel_1 = __webpack_require__(/*! ../src/MemoryChannel */ "./src/MemoryChannel.ts");
const MemoryStorage_1 = __webpack_require__(/*! ../src/MemoryStorage */ "./src/MemoryStorage.ts");
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const fetchFile = async (url) => {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch file: ${response.statusText}`);
    }
    return await response.arrayBuffer();
};
describe("IdManager with files in browser", () => {
    it("Transfer data over encrypted Channel", async () => {
        for (let i = 0; i < 10; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const manager1 = new __1.IdManager(id1, s1);
            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            const inputBuffer = await fetchFile("assets/testfile.png");
            const input = new Blob([inputBuffer], { type: "image/png" });
            const outputChunks = [];
            const outputStream = new WritableStream({
                write(chunk) {
                    outputChunks.push(new Uint8Array(chunk));
                },
            });
            const promise = manager2.download(channel, (0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
            await manager1.upload(channel.otherend, (0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
            await promise;
            const outputBuffer = buffer_1.Buffer.concat(outputChunks);
            const hash1 = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(inputBuffer));
            const hash2 = (0, crypto_1.hash)("sha256", outputBuffer);
            assert_1.default.equal(hash1.toString("hex"), hash2.toString("hex"));
        }
    });
    it("sign a File over Channel", async () => {
        for (let i = 0; i < 10; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const manager1 = new __1.IdManager(id1, s1);
            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            const inputBuffer = await fetchFile("assets/testfile.png");
            const file = { arrayBuffer: buffer_1.Buffer.from(inputBuffer), type: "image/png" };
            manager1.acceptSignFile(channel);
            const result = await manager2.requestSignFile(channel.otherend, file);
            if (!result)
                return assert_1.default.fail("no result of the sign file request");
            const challenge = new URL(result.challenge.toString("utf8"));
            assert_1.default.equal(challenge.protocol, "vaultys:");
            assert_1.default.equal(challenge.host, "signfile");
            assert_1.default.equal(challenge.searchParams.get("hash"), "a73d53246950a93ee956e413f50ed326e36f9a052dcd6fc5388ae19290931f32");
            assert_1.default.notEqual(challenge.searchParams.get("timestamp"), null);
            assert_1.default.ok(manager2.verifyFile(file, result, manager1.vaultysId));
        }
    });
});
describe("Channel tests for browser", () => {
    it("stream file", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createBidirectionnal();
        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);
        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
        const inputBuffer = await fetchFile("assets/testfile.png");
        const input = new Blob([inputBuffer], { type: "image/png" });
        const outputChunks = [];
        const outputStream = new WritableStream({
            write(chunk) {
                outputChunks.push(new Uint8Array(chunk));
            },
        });
        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
        await promise;
        const outputBuffer = buffer_1.Buffer.concat(outputChunks);
        const hash1 = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(inputBuffer));
        const hash2 = (0, crypto_1.hash)("sha256", outputBuffer);
        assert_1.default.equal(hash1.toString("hex"), hash2.toString("hex"));
    });
    it("stream file over encrypted channel", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);
        const inputBuffer = await fetchFile("assets/testfile.png");
        const input = new Blob([inputBuffer], { type: "image/png" });
        const outputChunks = [];
        const outputStream = new WritableStream({
            write(chunk) {
                outputChunks.push(new buffer_1.Buffer(chunk));
            },
        });
        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
        await promise;
        const outputBuffer = buffer_1.Buffer.concat(outputChunks);
        const hash1 = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from(inputBuffer));
        const hash2 = (0, crypto_1.hash)("sha256", outputBuffer);
        assert_1.default.equal(hash1.toString("hex"), hash2.toString("hex"));
    });
});


/***/ }),

/***/ "./test/idManager.test.ts":
/*!********************************!*\
  !*** ./test/idManager.test.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const __1 = __webpack_require__(/*! .. */ "./dist/node/index.js");
const __2 = __webpack_require__(/*! .. */ "./dist/node/index.js");
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
describe("IdManager", () => {
    it("serder a vaultys secret", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const secret = id1.getSecret();
            const id2 = __2.VaultysId.fromSecret(secret);
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac1?.toString("base64"), hmac2?.toString("base64"));
        }
    });
    it("serder a vaultys secret in base64", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const secret = id1.getSecret("base64");
            const id2 = __2.VaultysId.fromSecret(secret, "base64");
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac1?.toString("base64"), hmac2?.toString("base64"));
        }
    });
    it("serder to public Idmanager", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id);
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac2, undefined);
        }
    });
    it("serder to public Idmanager stringified", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id = JSON.stringify(id1.id);
            const id2 = __2.VaultysId.fromId(JSON.parse(id));
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
        }
    });
    it("serder to public Idmanager as hex string", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id.toString("hex"));
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
        }
    });
    it("serder to public Idmanager as base64 string", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id.toString("base64"), undefined, "base64");
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
        }
    });
    it("sign unspecified data and log it in the store", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const s = (0, __2.MemoryStorage)(() => "");
            const manager = new __2.IdManager(id1, s);
            const signature = await manager.signChallenge(manager.vaultysId.id);
            if (signature == null)
                assert_1.default.fail();
            const signatures = manager.getSignatures();
            assert_1.default.equal(signatures.length, 1);
            assert_1.default.equal(signatures[0].payload.challenge.toString("hex"), manager.vaultysId.id.toString("hex"));
            assert_1.default.equal(signatures[0].payload.signature.toString("hex"), signature.toString("hex"));
            assert_1.default.equal(signatures[0].type, "UNKNOWN");
        }
    });
    it("sign random document hash and log it in the store", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const s = (0, __2.MemoryStorage)(() => "");
            const file = { arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(1024)), type: "random" };
            const h = (0, crypto_1.hash)("sha256", file.arrayBuffer);
            const manager = new __2.IdManager(id1, s);
            const payload = await manager.signFile(file);
            const signatures = manager.getSignatures();
            assert_1.default.equal(signatures.length, 1);
            const challenge = new URL(signatures[0].challenge);
            assert_1.default.equal(challenge.searchParams.get("hash"), h.toString("hex"));
            assert_1.default.ok(manager.verifyFile(file, signatures[0].payload, id1));
            if (payload.signature == null)
                assert_1.default.fail();
            assert_1.default.equal(signatures[0].payload.signature.toString("hex"), payload.signature.toString("hex"));
            //console.log(signatures[0]);
            assert_1.default.equal(signatures[0].type, "DOCUMENT");
        }
    });
    // it("sign login and log it in the store", async () => {
    //   const s = MemoryStorage(() => "");
    //   const loginMock = 'vaultys://login?host=https://sso.vaultys.net/interaction/1UfGEF9HDQiIreFPS3wlI&nonce=9c0c7621a790c6e697032093aeca614d183319d663aa5cc1a085e052c7f904d5&timestamp=1665498137687&challenge=dummy'
    //   const manager = new IdManager(await VaultysId.generatePerson(), s);
    //   const payload = await manager.signLogin(loginMock);
    //   const signatures = manager.getSignatures();
    //   assert.equal(signatures.length, 1);
    //   const challenge = new URL(signatures[0].challenge)
    //   assert.equal(challenge.searchParams.get('hash'), fileHashMock.toString("hex"));
    //   assert.ok(manager.verifyFile(signatures[0].payload.challenge.toString("hex"), signatures[0].payload.signature));
    //   assert.equal(signatures[0].payload.signature.toString("hex"), payload.signature.toString("hex"));
    //   //console.log(signatures[0]);
    //   assert.equal(signatures[0].type, 'LOGIN');
    // });
});
describe("SRG v0 challenge with IdManager", () => {
    it("pass a challenge", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // console.log(s2.substore("contacts"))
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            if (manager1.vaultysId.type === 0) {
                assert_1.default.equal(manager2.apps.length, 1);
                assert_1.default.equal(manager2.getApp(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            }
            else {
                assert_1.default.equal(manager2.contacts.length, 1);
                assert_1.default.equal(manager2.getContact(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
                manager2.setContactMetadata(manager1.vaultysId.did, "name", "salut");
                manager2.setContactMetadata(manager1.vaultysId.did, "group", "pro");
                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, "name"), "salut");
                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, "group"), "pro");
                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            }
        }
    });
    it("fail a challenge if user1 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("fail a challenge if user2 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("pass a challenge over encrypted Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
            };
            const metadata2 = {
                name: "d",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            manager1.setContactMetadata(manager2.vaultysId.did, "name", "salut");
            manager1.setContactMetadata(manager2.vaultysId.did, "group", "pro");
            // assert.deepStrictEqual(
            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),
            //   metadata2
            // );
            // assert.deepStrictEqual(
            //   manager1.getAllMetadata(manager2.vaultysId.did),
            //   {
            //     group: 'pro',
            //     name: 'salut',
            //     phone: 'f'
            //   }
            // );
            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
        }
    });
    it("perform PRF over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            manager1.acceptPRF(channel);
            const result = await manager2.requestPRF(channel.otherend, "nostr");
            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac("prf|nostr|prf"));
        }
    });
    it("perform decrypt over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const message = "test decrypt on demand";
            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);
            manager1.acceptDecrypt(channel);
            //console.log(toDecrypt);
            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, "utf-8"));
            assert_1.default.deepEqual(result?.toString("utf-8"), message);
        }
    });
    describe("IdManager File Encryption/Decryption", () => {
        it("should encrypt and decrypt a file between two IdManagers", async () => {
            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Create a sample file
            const fileContent = (0, crypto_1.randomBytes)(1024);
            const originalFile = {
                arrayBuffer: __2.crypto.Buffer.from(fileContent),
                type: "application/octet-stream",
                name: "test.bin",
            };
            // Set up the decryption handler on manager2
            manager2.acceptDecryptFile(channel.otherend);
            // Request encryption from manager1 to manager2
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption failed");
            assert_1.default.equal(encryptedFile.type, originalFile.type, "File type should be preserved");
            assert_1.default.equal(encryptedFile.name, originalFile.name, "File name should be preserved");
            assert_1.default.ok(encryptedFile.arrayBuffer, "Encrypted data should be present");
            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, "Encrypted data should be different from original");
            // Now decrypt the file
            channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption failed");
            assert_1.default.equal(decryptedFile.type, originalFile.type, "File type should be preserved after decryption");
            assert_1.default.equal(decryptedFile.name, originalFile.name, "File name should be preserved after decryption");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted file should match the original");
        });
        it("should work with different file types and sizes", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Test with different file types and sizes
            const testCases = [
                { size: 10, type: "text/plain", name: "small.txt" },
                { size: 1024, type: "application/pdf", name: "medium.pdf" },
                { size: 4096, type: "image/jpeg", name: "large.jpg" },
            ];
            for (const testCase of testCases) {
                const fileContent = (0, crypto_1.randomBytes)(testCase.size);
                const originalFile = {
                    arrayBuffer: __1.Buffer.from(fileContent),
                    type: testCase.type,
                    name: testCase.name,
                };
                manager2.acceptEncryptFile(channel.otherend);
                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);
                manager2.acceptDecryptFile(channel.otherend);
                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);
                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);
            }
        });
        it("should handle acceptDecryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create a sample file
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(512)),
                type: "text/plain",
                name: "test.txt",
            };
            // Test with accepting function that returns true
            let acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Test with accepting function that returns false
            acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async () => {
                acceptCalled = true;
                return false;
            });
            const failedResult = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(acceptCalled, "Accept function should be called even when rejecting");
            assert_1.default.equal(failedResult, null, "Encryption should fail when accept returns false");
        });
        it("should handle acceptEncryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create an encrypted file
            let acceptCalled = false;
            manager2.acceptEncryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            // Create a sample file and encrypt it
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(256)),
                type: "application/json",
                name: "data.json",
            };
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Verify we can decrypt it back
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption should succeed");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted content should match original");
        });
        it("should verify that acceptEncryptFile and acceptDecryptFile are the same function", async () => {
            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => ""));
            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, "acceptEncryptFile should be an alias of acceptDecryptFile");
        });
    });
    it("perform migration from version 0 to 1", async () => {
        const ids = [];
        for (let i = 0; i < 2; i++) {
            for (let i = 0; i < 4; i++) {
                const vid = await (0, utils_1.createRandomVaultysId)();
                const s1 = (0, __2.MemoryStorage)(() => "");
                const id1 = new __2.IdManager(vid, s1);
                for (let j = 0; j < 2; j++) {
                    for (let i = 0; i < 4; i++) {
                        const vid2 = await (0, utils_1.createRandomVaultysId)();
                        const s2 = (0, __2.MemoryStorage)(() => "");
                        const id2 = new __2.IdManager(vid2, s2);
                        id1.saveContact(id2.vaultysId);
                        id1.setContactMetadata(id2.vaultysId.did, "test", id2.vaultysId.did);
                    }
                }
                ids.push(id1);
            }
        }
        for (const id of ids) {
            id.migrate(0);
            assert_1.default.equal(id.contacts.length + id.apps.length, 8);
            id.migrate(1);
            assert_1.default.equal(id.contacts.length + id.apps.length, 8);
        }
    }).timeout(20000);
});
describe("SRG v1 challenge with IdManager", () => {
    it("pass a challenge", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            const challengers = await Promise.all([manager1.startSRP(channel, "p2p", "auth", metadata1), manager2.acceptSRP(channel.otherend, "p2p", "auth", metadata2)]);
            //console.log(challengers);
            // assert.equal(contacts[0].did, manager2.vaultysId.did);
            // assert.equal(contacts[1].did, manager1.vaultysId.did);
            ///console.log(s2, s1);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            // assert.equal(s1.substore("wot").list().length, 1);
            // assert.equal(s2.substore("wot").list().length, 1);
            // console.log(Challenger.deserializeCertificate(s2.substore("wot").get(s2.substore("wot").list()[0])));
            // if (manager1.vaultysId.type === 0) {
            //   assert.equal(manager2.apps.length, 1);
            //   assert.equal(manager2.getApp(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            // } else {
            //   assert.equal(manager2.contacts.length, 1);
            //   assert.equal(manager2.getContact(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
            //   manager2.setContactMetadata(manager1.vaultysId.did, "name", "salut");
            //   manager2.setContactMetadata(manager1.vaultysId.did, "group", "pro");
            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, "name"), "salut");
            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, "group"), "pro");
            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            // }
        }
    });
    it("fail a challenge if user1 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("fail a challenge if user2 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("pass a challenge over encrypted Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
            };
            const metadata2 = {
                name: "d",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            manager1.setContactMetadata(manager2.vaultysId.did, "name", "salut");
            manager1.setContactMetadata(manager2.vaultysId.did, "group", "pro");
            // assert.deepStrictEqual(
            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),
            //   metadata2
            // );
            // assert.deepStrictEqual(
            //   manager1.getAllMetadata(manager2.vaultysId.did),
            //   {
            //     group: 'pro',
            //     name: 'salut',
            //     phone: 'f'
            //   }
            // );
            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
        }
    });
    it("perform PRF over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            manager1.acceptPRF(channel);
            const result = await manager2.requestPRF(channel.otherend, "nostr");
            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac("prf|nostr|prf"));
        }
    });
    it("perform decrypt over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const message = "test decrypt on demand";
            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);
            manager1.acceptDecrypt(channel);
            //console.log(toDecrypt);
            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, "utf-8"));
            assert_1.default.deepEqual(result?.toString("utf-8"), message);
        }
    });
    describe("IdManager File Encryption/Decryption", () => {
        it("should encrypt and decrypt a file between two IdManagers", async () => {
            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Create a sample file
            const fileContent = (0, crypto_1.randomBytes)(1024);
            const originalFile = {
                arrayBuffer: __2.crypto.Buffer.from(fileContent),
                type: "application/octet-stream",
                name: "test.bin",
            };
            // Set up the decryption handler on manager2
            manager2.acceptDecryptFile(channel.otherend);
            // Request encryption from manager1 to manager2
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption failed");
            assert_1.default.equal(encryptedFile.type, originalFile.type, "File type should be preserved");
            assert_1.default.equal(encryptedFile.name, originalFile.name, "File name should be preserved");
            assert_1.default.ok(encryptedFile.arrayBuffer, "Encrypted data should be present");
            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, "Encrypted data should be different from original");
            // Now decrypt the file
            channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption failed");
            assert_1.default.equal(decryptedFile.type, originalFile.type, "File type should be preserved after decryption");
            assert_1.default.equal(decryptedFile.name, originalFile.name, "File name should be preserved after decryption");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted file should match the original");
        });
        it("should work with different file types and sizes", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Test with different file types and sizes
            const testCases = [
                { size: 10, type: "text/plain", name: "small.txt" },
                { size: 1024, type: "application/pdf", name: "medium.pdf" },
                { size: 4096, type: "image/jpeg", name: "large.jpg" },
            ];
            for (const testCase of testCases) {
                const fileContent = (0, crypto_1.randomBytes)(testCase.size);
                const originalFile = {
                    arrayBuffer: __1.Buffer.from(fileContent),
                    type: testCase.type,
                    name: testCase.name,
                };
                manager2.acceptEncryptFile(channel.otherend);
                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);
                manager2.acceptDecryptFile(channel.otherend);
                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);
                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);
            }
        });
        it("should handle acceptDecryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create a sample file
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(512)),
                type: "text/plain",
                name: "test.txt",
            };
            // Test with accepting function that returns true
            let acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Test with accepting function that returns false
            acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async () => {
                acceptCalled = true;
                return false;
            });
            const failedResult = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(acceptCalled, "Accept function should be called even when rejecting");
            assert_1.default.equal(failedResult, null, "Encryption should fail when accept returns false");
        });
        it("should handle acceptEncryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create an encrypted file
            let acceptCalled = false;
            manager2.acceptEncryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            // Create a sample file and encrypt it
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(256)),
                type: "application/json",
                name: "data.json",
            };
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Verify we can decrypt it back
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption should succeed");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted content should match original");
        });
        it("should verify that acceptEncryptFile and acceptDecryptFile are the same function", async () => {
            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => ""));
            manager.setProtocolVersion(1);
            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, "acceptEncryptFile should be an alias of acceptDecryptFile");
        });
    });
});


/***/ }),

/***/ "./test/keymanager.test.ts":
/*!*********************************!*\
  !*** ./test/keymanager.test.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
// import { publicDerivePath, privateDerivePath, HISCP } from "../src/KeyManager";
// import * as bip32 from "@stricahq/bip32ed25519";
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
//// @ts-expect-error weird import for @stricahq/bip32ed25519
// const bip32fix = bip32.default ?? bip32;
// const writeVector = (km: KeyManager) => {
//   return;
//   console.log("## NOT Published");
//   console.log("### proof sk:\n", new bip32fix.Bip32PrivateKey(km.proofKey.secretKey!).toPrivateKey().toBytes().toString("hex"));
//   console.log("### proof pk:\n", new bip32fix.Bip32PrivateKey(km.proofKey.publicKey).toBip32PublicKey().toPublicKey().toBytes().toString("hex"));
//   console.log("### sk = derive(proof sk, m/0'):\n", new bip32fix.Bip32PrivateKey(km.signer.secretKey!).toPrivateKey().toBytes().toString("hex"));
//   console.log("## Published");
//   console.log("### proof = sha256(proof pk):\n", km.proof.toString("hex"));
//   console.log("### pk:", km.signer.publicKey.toString("hex"));
// };
// const writeCertificate = (hiscp: HISCP) => {
//   return;
//   const hiscpDisplay = {
//     newId: hiscp.newId.toString("hex"),
//     proofKey: hiscp.proofKey.toString("hex"),
//     timestamp: hiscp.timestamp,
//   };
//   console.log("## HISCP Certificate");
//   console.log("### hiscp data:\n", JSON.stringify(hiscpDisplay, null, 2));
//   console.log("### Signature of hiscp = [newID || proofKey || timestamp] by proof sk\n", hiscp.signature.toString("hex"));
// };
describe("KeyManager tests", () => {
    // it("derive correctly keys (strica)", async () => {
    //   const node = await bip32fix.Bip32PrivateKey.fromEntropy(randomBytes(32));
    //   const publicNode = node.toBip32PublicKey();
    //   const derivedNode = privateDerivePath(node, "m/1/2/3");
    //   const publicDerivedNode = publicDerivePath(publicNode, "m/1/2/3");
    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString("hex"), publicDerivedNode.toBytes().toString("hex"));
    // });
    // it("derive correctly keys (noble)", async () => {
    //   const privateKey = ed.utils.randomPrivateKey();
    //   const node = await Bip32PrivateKey.fromEntropy(randomBytes(32));
    //   const publicNode = node.toBip32PublicKey();
    //   const derivedNode = derivePath(node, "1/2/3");
    //   const publicDerivedNode = derivePath(publicNode, "m/1/2/3");
    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString("hex"), publicDerivedNode.toBytes().toString("hex"));
    // });
    it("serder a KeyManager losing entropy", async () => {
        const km = await __1.KeyManager.generate_Id25519();
        const secret = km.getSecret();
        const km2 = __1.KeyManager.fromSecret(secret);
        assert_1.default.equal(km.id.toString("hex"), km2.id.toString("hex"));
    });
    it("serder a private KeyManager to a public KeyManager", async () => {
        const km = await __1.KeyManager.generate_Id25519();
        const id = km.id;
        const publicKM = __1.KeyManager.fromId(id);
        assert_1.default.equal(id.toString("hex"), publicKM.id.toString("hex"));
    });
    it("sign and verify a message", async () => {
        const signer = await __1.KeyManager.generate_Id25519();
        const id = signer.id;
        const verifier = __1.KeyManager.fromId(id);
        const message = buffer_1.Buffer.from("this is a message to be verified man", "utf-8");
        const signature = await signer.sign(message);
        if (!signature)
            assert_1.default.fail();
        assert_1.default.notEqual(signature, null);
        assert_1.default.ok(verifier.verify(message, signature));
    });
    // it("create and verify a HISCP Certificate", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    // });
    // it("create vector for HISCP", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   writeVector(km);
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   writeCertificate(hiscp);
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    // });
    // it("create vector for HISCP Certificate Chaining", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   writeVector(km);
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   writeCertificate(hiscp);
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    //   // create the new Keymanager iterating on the index
    //   if (!km.entropy) assert.fail();
    //   const newkm = await KeyManager.create_Id25519_fromEntropy(km.entropy, 1);
    //   assert.equal(newkm.id.toString("hex"), hiscp?.newId.toString("hex"));
    // });
    it("signcrypt and decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("encrypt and decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await __1.KeyManager.encrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("signcrypt and blind decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: signcrypt and decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: encrypt and decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await __1.VaultysId.encrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: signcrypt and blind decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("Decrypt a sample encrypted message", async () => {
        // const bob = await createRandomVaultysId();
        // console.log(await VaultysId.encrypt("test", [bob.id]));
        // console.log(bob.getSecret("base64"));
        const message = "BEGIN SALTPACK ENCRYPTED MESSAGE. keDIDMQWYvVR58B FTfTeD305hcoHcr Wi4X4pWBmPExHwE WaBDIrIPJ7pgJVE 2Yaxiu3jYK3Osf2 uhjKjQeNaUshMjT QrZdWGFObOEKXZS u5ZF9IyxzRQiBF8 vtIJhLH1kKcDJj4 IQGkhxNTmUljHeo ulEUOyGRt0K3CrR gVkJxxehI8H0GJy 0iJTgCMM7DEX4Jk qmUWofh3hNbfZcs G171PLnJVJ484sS ozpRNJIRMYpHD4g lEdwwVM3NfIoSW3 Cg6FKTrtiNoDgtN gvXoqM96taPvEal dAjNjMgXFcuPT2b U0CFssYXxGKzAnJ gevNrFwrZGLd78h. END SALTPACK ENCRYPTED MESSAGE.";
        const id = __1.VaultysId.fromSecret("AIShdgGhcMQg3KBa7NhKclRHgvQL/51gDBKkVt9ndZurKDM+wDY4uBSheMRgIEM+lQwxORCD8hOul7keOXea5fMYYghYYL2inBxdB1Uop0p+SGS0ju18I7OOTiMDGGKo7wzTR0xj5xxE9qpTHqHAbWi6fPFaYOXNTK1t6NwVTiNkJDrvqK1OvVrzHnOGoWXEIJRd5AQLlhofk5h7yIGMHzJt5kWUX/J+sTH4gQhGtW1S", "base64");
        const decrypted = await id.decrypt(message);
        assert_1.default.equal(decrypted, "test");
    });
    it("should perform Diffie-Hellman key exchange between two KeyManager instances", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Alice performs DH with Bob
        const aliceSharedSecret = await alice.performDiffieHellman(bob);
        // Bob performs DH with Alice
        const bobSharedSecret = await bob.performDiffieHellman(alice);
        // Verify that they derived the same shared secret
        assert_1.default.notEqual(aliceSharedSecret, null);
        assert_1.default.notEqual(bobSharedSecret, null);
        assert_1.default.equal(aliceSharedSecret?.toString("hex"), bobSharedSecret?.toString("hex"));
    });
    it("should perform Diffie-Hellman key exchange using static method", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Perform DH using static method
        const sharedSecret1 = await __1.KeyManager.diffieHellman(alice, bob);
        const sharedSecret2 = await __1.KeyManager.diffieHellman(bob, alice);
        // Verify that the static method derives the same shared secret regardless of order
        assert_1.default.notEqual(sharedSecret1, null);
        assert_1.default.notEqual(sharedSecret2, null);
        assert_1.default.equal(sharedSecret1?.toString("hex"), sharedSecret2?.toString("hex"));
    });
    it("should fail Diffie-Hellman key exchange with a public KeyManager", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bobPrivate = await __1.KeyManager.generate_Id25519();
        // Create a public-only version of Bob's KeyManager
        const bobPublic = __1.KeyManager.fromId(bobPrivate.id);
        // Alice attempts DH with Bob's public KeyManager (should fail)
        const aliceSharedSecret = await alice.performDiffieHellman(bobPublic);
        // Bob's public KeyManager attempts DH with Alice (should fail)
        const bobSharedSecret = await bobPublic.performDiffieHellman(alice);
        // Verify that the operations failed
        // assert.equal(aliceSharedSecret, null);
        assert_1.default.equal(bobSharedSecret, null);
    });
    it("should be able to use DH shared secret for encryption and decryption", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Perform DH to get shared secret
        const aliceSharedSecret = await alice.performDiffieHellman(bob);
        assert_1.default.notEqual(aliceSharedSecret, null);
        const nonce = tweetnacl_1.default.randomBytes(tweetnacl_1.default.box.nonceLength);
        // Use the shared secret for encryption (using a simple XOR for demonstration)
        const plaintext = buffer_1.Buffer.from("Secret message for testing", "utf-8");
        const encryptedMessage = tweetnacl_1.default.secretbox(plaintext, nonce, aliceSharedSecret);
        // Bob also derives the shared secret
        const bobSharedSecret = await bob.performDiffieHellman(alice);
        assert_1.default.notEqual(bobSharedSecret, null);
        // Bob decrypts the message
        const decryptedMessage = buffer_1.Buffer.from(tweetnacl_1.default.secretbox.open(encryptedMessage, nonce, bobSharedSecret));
        // Verify the decrypted message matches the original
        assert_1.default.equal(decryptedMessage.toString("utf-8"), plaintext.toString("utf-8"));
    });
    it("should generate different shared secrets with different key pairs", async () => {
        // Create three key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const charlie = await __1.KeyManager.generate_Id25519();
        // Alice-Bob shared secret
        const secretAB = await alice.performDiffieHellman(bob);
        // Alice-Charlie shared secret
        const secretAC = await alice.performDiffieHellman(charlie);
        // Bob-Charlie shared secret
        const secretBC = await bob.performDiffieHellman(charlie);
        // Verify all shared secrets are different
        assert_1.default.notEqual(secretAB?.toString("hex"), secretAC?.toString("hex"));
        assert_1.default.notEqual(secretAB?.toString("hex"), secretBC?.toString("hex"));
        assert_1.default.notEqual(secretAC?.toString("hex"), secretBC?.toString("hex"));
    });
});


/***/ }),

/***/ "./test/pqc.test.ts":
/*!**************************!*\
  !*** ./test/pqc.test.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const pqCrypto_1 = __webpack_require__(/*! ../src/pqCrypto */ "./src/pqCrypto.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
describe("Post-Quantum Cryptography", () => {
    let keyPair;
    const testMessage = crypto_1.Buffer.from("Hello, Post-Quantum World!");
    beforeEach(() => {
        keyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
    });
    describe("DILITHIUM Key Generation", () => {
        it("should generate different key pairs on each call", async () => {
            const keyPair1 = (0, pqCrypto_1.generateDilithiumKeyPair)();
            const keyPair2 = (0, pqCrypto_1.generateDilithiumKeyPair)();
            assert_1.default.notDeepEqual(keyPair1.publicKey, keyPair2.publicKey);
            assert_1.default.notDeepEqual(keyPair1.secretKey, keyPair2.secretKey);
        });
        it("should generate keys with correct sizes", async () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(keyPair.publicKey.length, keyInfo.publicKeySize);
            assert_1.default.equal(keyPair.secretKey.length, keyInfo.secretKeySize);
        });
    });
    describe("DILITHIUM Signing", () => {
        it("should sign a message successfully", async () => {
            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
            assert_1.default.equal(signature.length > 0, true);
        });
        it("should produce signatures of correct size", async () => {
            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(signature.length, keyInfo.signatureSize);
        });
        it("should produce different signatures for different messages", async () => {
            const message1 = crypto_1.Buffer.from("Message 1");
            const message2 = crypto_1.Buffer.from("Message 2");
            const signature1 = (0, pqCrypto_1.signDilithium)(message1, keyPair.secretKey);
            const signature2 = (0, pqCrypto_1.signDilithium)(message2, keyPair.secretKey);
            assert_1.default.notDeepEqual(signature1, signature2);
        });
    });
    describe("DILITHIUM Verification", () => {
        let signature;
        beforeEach(async () => {
            signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
        });
        it("should verify a valid signature", async () => {
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, keyPair.publicKey);
            assert_1.default.equal(isValid, true);
        });
        it("should reject an invalid signature", async () => {
            const invalidSignature = crypto_1.Buffer.alloc(signature.length, 0);
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, invalidSignature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should reject signature with wrong message", async () => {
            const wrongMessage = crypto_1.Buffer.from("Wrong message");
            const isValid = (0, pqCrypto_1.verifyDilithium)(wrongMessage, signature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should reject signature with wrong public key", async () => {
            const wrongKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, wrongKeyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should work with Uint8Array inputs", async () => {
            const messageArray = new Uint8Array(testMessage);
            const signatureArray = new Uint8Array(signature);
            const publicKeyArray = new Uint8Array(keyPair.publicKey);
            const isValid = (0, pqCrypto_1.verifyDilithium)(messageArray, signatureArray, publicKeyArray);
            assert_1.default.equal(isValid, true);
        });
        it("should handle corrupted signature gracefully", async () => {
            const corruptedSignature = crypto_1.Buffer.from(signature);
            corruptedSignature[0] = corruptedSignature[0] ^ 0xff; // Flip bits
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, corruptedSignature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
    });
    describe("COSE Key Creation", () => {
        it("should create a valid COSE key", () => {
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(keyPair.publicKey);
            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);
            assert_1.default.equal(coseKey.get(3), pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE), 2);
            assert_1.default.deepEqual(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), keyPair.publicKey);
        });
        it("should work with Uint8Array input", () => {
            const publicKeyArray = new Uint8Array(keyPair.publicKey);
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(publicKeyArray);
            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);
        });
    });
    describe("Key Info", () => {
        it("should return correct key size information", () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(keyInfo.publicKeySize, 1952);
            assert_1.default.equal(keyInfo.secretKeySize, 4032);
            assert_1.default.equal(keyInfo.signatureSize, 3309);
        });
        it("should match actual generated key sizes", async () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            assert_1.default.equal(testKeyPair.publicKey.length, keyInfo.publicKeySize);
            assert_1.default.equal(testKeyPair.secretKey.length, keyInfo.secretKeySize);
        });
    });
    describe("Constants", () => {
        it("should have correct COSE algorithm identifiers", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM2, -46);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM3, -47);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM5, -48);
        });
        it("should have correct COSE key type", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM, 4);
        });
        it("should have correct COSE key parameters", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, -100);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, -101);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_SK, -102);
        });
    });
    describe("End-to-End Workflow", () => {
        it("should complete full sign-verify cycle", async () => {
            // Generate keys
            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            // Sign message
            const message = crypto_1.Buffer.from("End-to-end test message");
            const signature = (0, pqCrypto_1.signDilithium)(message, testKeyPair.secretKey);
            // Verify signature
            const isValid = (0, pqCrypto_1.verifyDilithium)(message, signature, testKeyPair.publicKey);
            // Create COSE key
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(testKeyPair.publicKey);
            assert_1.default.equal(isValid, true);
            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), testKeyPair.publicKey);
        });
        it("should handle multiple signatures with same key pair", async () => {
            const messages = [crypto_1.Buffer.from("Message 1"), crypto_1.Buffer.from("Message 2"), crypto_1.Buffer.from("Message 3")];
            const signatures = [];
            // Sign all messages
            for (const message of messages) {
                const signature = (0, pqCrypto_1.signDilithium)(message, keyPair.secretKey);
                signatures.push(signature);
            }
            // Verify all signatures
            for (let i = 0; i < messages.length; i++) {
                const isValid = (0, pqCrypto_1.verifyDilithium)(messages[i], signatures[i], keyPair.publicKey);
                assert_1.default.equal(isValid, true);
            }
        });
    });
});


/***/ }),

/***/ "./test/pqcManager.web.test.ts":
/*!*************************************!*\
  !*** ./test/pqcManager.web.test.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
describe("PQC", () => {
    it("should run test", () => {
        assert_1.default.equal(0, 0);
    });
    it("serder a VaultytsID secret - software", async () => {
        assert_1.default.equal(0, 0);
    });
});


/***/ }),

/***/ "./test/saltpack.test.ts":
/*!*******************************!*\
  !*** ./test/saltpack.test.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
describe("Saltpack", () => {
    it("Saltpack working with ID", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id.toString("hex")];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
});


/***/ }),

/***/ "./test/shims.ts":
/*!***********************!*\
  !*** ./test/shims.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// nodejs polyfill
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
if (typeof window !== "undefined") {
    window.global = window;
    // @ts-ignore
    window.process = { env: {} };
}
else {
    if (__webpack_require__.g.navigator) {
        // node > 20
        // @ts-ignore
        __webpack_require__.g.navigator.credentials = SoftCredentials_1.default;
    }
    else {
        // node <= 20
        // @ts-ignore
        __webpack_require__.g.navigator = {
            // @ts-ignore
            credentials: SoftCredentials_1.default,
        };
    }
}
if (!__webpack_require__.g.atob)
    __webpack_require__.g.atob = (str) => Buffer.from(str, "base64").toString("latin1");
if (!__webpack_require__.g.btoa)
    __webpack_require__.g.btoa = (str) => Buffer.from(str, "latin1").toString("base64");
// @ts-ignore
__webpack_require__.g.CredentialUserInteractionRequest = () => __webpack_require__.g.CredentialUserInteractionRequested++;


/***/ }),

/***/ "./test/softCredentials.test.ts":
/*!**************************************!*\
  !*** ./test/softCredentials.test.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
// credentials request payload
const createRequest = (alg) => {
    const challenge = (0, crypto_1.randomBytes)(32);
    return {
        publicKey: {
            challenge,
            rp: {
                name: "Tests ID",
                id: "I am the new guy",
            },
            user: {
                id: Buffer.from("ertyu45678RUTYESEZTYSDYJTUE4576232453", "utf8"),
                name: "john.smith@mail.com",
                displayName: "John Smith",
            },
            pubKeyCredParams: [
                {
                    type: "public-key",
                    alg,
                },
            ],
        },
    };
};
let attestation;
describe("SoftCredentials", () => {
    it("create attestation (ECDSA)", async () => {
        attestation = await SoftCredentials_1.default.create(createRequest(-7));
        //console.log(attestation);
    });
    it("create attestation (EdDSA)", async () => {
        await SoftCredentials_1.default.create(createRequest(-8));
    });
    it("get assertion and verify with attestation using ECDSA", async () => {
        const payload = {
            publicKey: {
                challenge: (0, crypto_1.randomBytes)(32),
                allowCredentials: [
                    {
                        type: "public-key",
                        id: attestation.rawId,
                    },
                ],
            },
        };
        const assertion = await SoftCredentials_1.default.get(payload);
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(Buffer.from(assertion.response.clientDataJSON)), payload.publicKey.challenge.toString("base64"));
        const verified = SoftCredentials_1.default.verify(attestation, assertion);
        assert_1.default.ok(verified);
    });
    it("verify assertion with attestation using github webauthn json coming from yubikey credentials", async () => {
        const attestationSafe = {
            type: "public-key",
            id: "vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA",
            rawId: Buffer.from("vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiZkl3bFU5NHNNcUsyMVNrX1BYbFIzU2hLU0JVc0t6dFVpX0pqNE5YampSOCIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ", "base64"),
                attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjh3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolBBAAAAAQAAAAAAAAAAAAAAAAAAAAAAgLy4xOjmwXw2QmUiRKrdR4Q6JLjujuRc7cew0n0LbO0BGo9Am469Eq8vo1binQwNzicM5PI4coI5uvulrJIbFjMgQ3DDLYrTErcGO4rPBu6QirlIqw2d_gCmWAKppxegqiIiwcUsbw5ddYlTjHAYJBcDi3_Kxqr9OXN5Oq9l2dEgpAEBAycgBiFYIO6J63OnkjzyQ--iXSbgm1oLSl3wzlDCy4ohwkbN-l4I", "base64"),
                transports: ["nfc", "usb", "ble", "internal", "hybrid"],
            },
            clientExtensionResults: {},
        };
        const assertion = {
            type: "public-key",
            id: "vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA",
            rawId: Buffer.from("vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQU9tZmdkbnV4cl8ydWw4T1pMekFXUk1SYkd0NXkzbHIxMURxcnF3UUdMVSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wucWp6OXprL3lhYlBleCJ9", "base64"),
                authenticatorData: Buffer.from("3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolABAAAAIQ", "base64"),
                signature: Buffer.from("_eq8EwX_twQyWjyiCvCDu5JLKEWpMxW9Pz0Qwpt8A5UcHJyGoGQMrssaws-jwqIpKxkVU7MBlHzHUgFULFn5Cw", "base64"),
                userHandle: null,
            },
            clientExtensionResults: {},
        };
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), "fIwlU94sMqK21Sk/PXlR3ShKSBUsKztUi/Jj4NXjjR8=");
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), "AOmfgdnuxr/2ul8OZLzAWRMRbGt5y3lr11DqrqwQGLU=");
        // @ts-expect-error mockup
        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion);
        assert_1.default.ok(verified);
    });
    // it("attestation response from yubikey should be verified", async () => {
    //   const response = {
    //     clientDataJSON: Buffer.from("eyJjaGFsbGVuZ2UiOiJZTVdFVGYtUDc5aU1iLUJxZFRreVNOUmVPdmE3bksyaVZDOWZpQzhpR3ZZeXB1bkVPQ1pHWjYtWTVPVjFydk1pRGdBaldmRmk2VUMwV3lLR3NqQS1nQSIsIm9yaWdpbiI6Imh0dHBzOi8vd2ViYXV0aG4ub3JnIiwidHlwZSI6IndlYmF1dGhuLmNyZWF0ZSJ9", "base64"),
    //     attestationObject: Buffer.from("o2NmbXRmcGFja2VkZ2F0dFN0bXSjY2FsZyZjc2lnWEcwRQIhAIzOihC6Ba80o5JnoYOJJ_EtEVmWQcAvxVCnsCFnVRQZAiAfeIddLPsPl1FeSX8B5xZANcQKGNoO7pb0TZPnuJdebGN4NWOBWQKzMIICrzCCAZegAwIBAgIESFs9tjANBgkqhkiG9w0BAQsFADAhMR8wHQYDVQQDDBZZdWJpY28gRklETyBQcmV2aWV3IENBMB4XDTE4MDQxMjEwNTcxMFoXDTE4MTIzMTEwNTcxMFowbzELMAkGA1UEBhMCU0UxEjAQBgNVBAoMCVl1YmljbyBBQjEiMCAGA1UECwwZQXV0aGVudGljYXRvciBBdHRlc3RhdGlvbjEoMCYGA1UEAwwfWXViaWNvIFUyRiBFRSBTZXJpYWwgMTIxMzkzOTEyNjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABPss3TBDKMVySlDM5vYLrX0nqRtZ4eZvKXuJydQ9wrLHeIm08P-dAijLlG384BsZWJtngEqsl38oGJzNsyV0yiijbDBqMCIGCSsGAQQBgsQKAgQVMS4zLjYuMS40LjEuNDE0ODIuMS42MBMGCysGAQQBguUcAgEBBAQDAgQwMCEGCysGAQQBguUcAQEEBBIEEPigEfOMCk0VgAYXER-e3H0wDAYDVR0TAQH_BAIwADANBgkqhkiG9w0BAQsFAAOCAQEAMvPkvVjXQiuvSZmGCB8NqTvGqhxyEfkoU-vz63PaaTsG3jEzjl0C7PZ26VxCvqWPJdM3P3e7Kp18sj4RjEHUmkya2PPipOwBd3p0qMQSQ8MeziCPLQ9uvGGb4YShcvaprMv4c21b4piza-znHneNCmmq-ZS4Y23o-vYv085_BEwyLPcmPjSZ5qWysCq7rVvZ7OWwcU1zu5RhSZyUKl8dzK9lAzs5OdRH2fzEewsW2OkB_Ow_jBvAxqwLXXTHuwMFaRfpmBoZuQlcofSrnwJ8KA-K-e0dKTz2zC8EbZrWYrSpbrHKyqxeBT6DkUd8H4tgAd5lOr_yqrtVmIaRfq07NmhhdXRoRGF0YVjElWkIjx7O4yMpVANdvRDXyuORMFonUbVZu4_Xy7IpvdRBAAAAAPigEfOMCk0VgAYXER-e3H0AQMLC68jgMVzFOeLNnwklj81o1xzgSj6ZaDflB37Y-P66SLugWcTV6aZvNn-2Ool_RRDiinkufjdkwC3ssy5yXwClAQIDJiABIVggAYD1TSpf120DSVxen8ki56kF1bmT4EXO-P0JnSk5mMwiWCB3TlMZBRqPY6llzDcfHd-oW0EHdaFNgBdlGGFobpHKlw", "base64"),
    //   };
    //   // @ts-expect-error mockup
    //   const info = SoftCredentials.getCertificateInfo(response);
    //   assert.deepStrictEqual(info, {
    //     issuer: "CN=Yubico FIDO Preview CA",
    //     issuerName: "CN=Yubico FIDO Preview CA",
    //     subject: {
    //       C: "SE",
    //       O: "Yubico AB",
    //       OU: "Authenticator Attestation",
    //       CN: "Yubico U2F EE Serial 1213939126",
    //     },
    //     version: "v3 (2)",
    //     basicConstraintsCA: false,
    //   });
    //   // @ts-expect-error mockup
    //   assert.ok(await SoftCredentials.verifyPackedAttestation(response));
    // });
    // it("no attestation in response should be valid and not be verified", async () => {
    //   const response = {
    //     attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjFk2rw5H3LiaP/1p3XV4I1wW43p60EG8RCpFuQTrBOPiRFAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQGV0qcd/M/uuCBaLC0jX8PRZ9e5cEZTKp9Ngf6NCKWSdWinmpK7FYog14m5kfAepzh93Z4hrGD8M57ljxoBKXL0pQECAyYgASFYIIqukdwfB/WgIxfpOO3tGOKIp+xPsx1TCc2UPjC7G7BlIlggNJL1zJSlN2EAFhnKSxihoY6HZXopi1Wte83dgWlosoQ=", "base64"),
    //     clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiWXpTYkpBbGIya0N6Qm1xa1U3cG9Nem92LXNONU5HcHRuWUFrUElkRWt4VSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5c2lkMi5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ==", "base64"),
    //   };
    //   // @ts-expect-error mockup
    //   const info = SoftCredentials.getCertificateInfo(response);
    //   assert.equal(info, null);
    //   // @ts-expect-error mockup
    //   assert.ok(!(await SoftCredentials.verifyPackedAttestation(response)));
    // });
    it("verify assertion with attestation using github webauthn json coming from macosx credentials", async () => {
        const attestationSafe = {
            type: "public-key",
            id: "AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww",
            rawId: Buffer.from("AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYVJFMWVnWjZHMS1BRUVPSXpQbWxOckFnT1N5RWVWRG44OUtDREUxRGRPRSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wveWFiUGV4In0", "base64"),
                attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVkBP95PnSmphYcbW5aQmrH4XxNTCSWKcxK2I6tg6rwoRqJQRWH4It6tzgACNbzGCmSLCyXx8FUDALsB0ZOqKwDT-cWVs5CONEISWspV32MwLtg4zUubj0ChAUtd9UrxNBmi-E3xgRklpMdTscGJhgCcIfjAgMANx5bSdj9RKVz_4oszDIH81EvIuBtDfhJQtNJiMcXi09lY7vVaDBpcLGnhM-LovZKjQvfDoH_G_1Zu98IoMCnnomTjiT-VCw_jfVb-DmFjU-x3Wv9U4i668_5h-W7HBZLoLiafYEu-n8tt12Gf1VT9frDUfMcmI5lubUOWTRjDpQECAyYgASFYIM3N0z1jSTixc7fNwxy1BtBUrNUOiPOm2j7Zlwx6s8eXIlggKB-zZiuYTAaAdPVQuN5EUQeRNX0kjS2oikGCJsymvH8", "base64"),
                transports: ["internal"],
            },
            clientExtensionResults: {},
        };
        const assertion = {
            type: "public-key",
            id: "AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww",
            rawId: Buffer.from("AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoibUlySjNsVWxsNXRadjhfa25kMEJEeU12VlVFcnhBY19CWWNkX2hOQ2lZZyIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ", "base64"),
                authenticatorData: Buffer.from("3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolAFYgu7dQ", "base64"),
                signature: Buffer.from("MEQCIFyGZIbrLunau93lnx0vTkWQjr_CcTkjYhyZ1-szXRPeAiBXwyQRQhMn59eva_CRlZOTQ_TLAgxr3eCWbwa1dQBnTA", "base64"),
                userHandle: Buffer.from("ZGlkOnZhdWx0eXM6MzI2ZjUyY2VkNjRhYmE4YzQ4MWRkMDU3ZDFkODA0MGY0ZWE3MzZiMA", "base64"),
            },
            clientExtensionResults: {},
        };
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), "aRE1egZ6G1+AEEOIzPmlNrAgOSyEeVDn89KCDE1DdOE=");
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), "mIrJ3lUll5tZv8/knd0BDyMvVUErxAc/BYcd/hNCiYg=");
        // @ts-expect-error mockup
        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion, true);
        assert_1.default.ok(verified);
    });
});


/***/ }),

/***/ "./test/utils.ts":
/*!***********************!*\
  !*** ./test/utils.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRandomVaultysId = void 0;
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const pqCrypto_1 = __webpack_require__(/*! ../src/pqCrypto */ "./src/pqCrypto.ts");
const createRandomVaultysId = async () => {
    const types = [0, 1, 2];
    if (typeof window === "undefined") {
        types.push(3);
        types.push(4);
    }
    const pqc = Math.random() < 0.5;
    const type = types[Math.floor(Math.random() * types.length)];
    switch (type) {
        case 0:
            return __1.VaultysId.generateMachine(pqc);
        case 1:
            return __1.VaultysId.generatePerson(pqc);
        case 2:
            return __1.VaultysId.generateOrganization(pqc);
        case 3:
            const attestation1 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, false));
            // @ts-expect-error mockup
            return __1.VaultysId.fido2FromAttestation(attestation1);
        case 4:
            const attestation2 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, true));
            // @ts-expect-error mockup
            return __1.VaultysId.fido2FromAttestation(attestation2);
        default:
            return __1.VaultysId.generatePerson();
    }
};
exports.createRandomVaultysId = createRandomVaultysId;


/***/ }),

/***/ "./test/v0toV1.test.ts":
/*!*****************************!*\
  !*** ./test/v0toV1.test.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const generateWot = async (max = 4) => {
    const result = [];
    for (let i = 0; i < max; i++) {
        const vaultysId = await __1.VaultysId.generatePerson();
        const s = (0, __1.MemoryStorage)(() => "");
        const jeanjacques = new __1.IdManager(vaultysId, s);
        result.push(jeanjacques);
    }
    return result;
};
const testCertificate = (rogueCert) => {
    try {
        const result = __1.Challenger.deserializeCertificate(rogueCert);
        return result;
    }
    catch (error) {
        return {
            state: -2,
        };
    }
};
describe("VaultysId Migration", () => {
    it("create VaultysId  with version 1 by default", async () => {
        const bob = await (0, utils_1.createRandomVaultysId)();
        assert_1.default.equal(bob.version, 1);
    });
    it("Migrate VaultysId to Version 0", async () => {
        const bob = await (0, utils_1.createRandomVaultysId)();
        bob.toVersion(0);
        assert_1.default.equal(bob.version, 0);
    });
    it("Migrate IdManager to Version 0", async () => {
        const vaultysId = await (0, utils_1.createRandomVaultysId)();
        const s = (0, __1.MemoryStorage)(() => "");
        const bob = new __1.IdManager(vaultysId, s);
        const wot = await generateWot();
        for (let i = 0; i < wot.length; i++) {
            const jeanjacques = wot[i];
            const channel = __1.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            await Promise.all([jeanjacques.askContact(channel), bob.acceptContact(channel.otherend)]);
        }
        bob.migrate(0);
        wot.forEach((jeanjacques) => {
            jeanjacques.migrate(0);
            // console.log(jeanjacques);
            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);
        });
        assert_1.default.equal(bob.store.substore("wot").list().length, wot.length);
        assert_1.default.equal(bob.store.substore("contacts").list().length, wot.length);
        assert_1.default.equal(bob.vaultysId.version, 0);
        bob.migrate(1);
        wot.forEach((jeanjacques) => {
            jeanjacques.migrate(1);
            //console.log(jeanjacques);
            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);
        });
        assert_1.default.equal(bob.store.substore("wot").list().length, wot.length);
        assert_1.default.equal(bob.store.substore("contacts").list().length, wot.length);
        assert_1.default.equal(bob.vaultysId.version, 1);
    }).timeout(5000);
});
describe("Symetric Proof of Relationship - SRG - V0", () => {
    it("Perform Protocol with KeyManager", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 0);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Succeed for different vaultysId versions", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 0);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
});
describe("Symetric Proof of Relationship - SRG - V1", () => {
    it("Perform Protocol with KeyManager", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Succeed for different vaultysId versions", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1.toVersion(0));
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
    });
});


/***/ }),

/***/ "?78b1":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9bba":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b231":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?bfdd":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./test/shims.ts");
/******/ 	__webpack_require__("./test/pqc.test.ts");
/******/ 	__webpack_require__("./test/pqcManager.web.test.ts");
/******/ 	__webpack_require__("./test/challenger_v0.test.ts");
/******/ 	__webpack_require__("./test/challenger.test.ts");
/******/ 	__webpack_require__("./test/file.browser_test.ts");
/******/ 	__webpack_require__("./test/channel.test.ts");
/******/ 	__webpack_require__("./test/idManager.test.ts");
/******/ 	__webpack_require__("./test/saltpack.test.ts");
/******/ 	__webpack_require__("./test/softCredentials.test.ts");
/******/ 	__webpack_require__("./test/v0toV1.test.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./test/keymanager.test.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=test-bundle.js.map