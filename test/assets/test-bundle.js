/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/node/index.js":
/*!****************************!*\
  !*** ./dist/node/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CryptoChannel = exports.GameOfLifeIcon = exports.KeyManager = exports.IdManager = exports.LocalStorage = exports.convertWebWritableStreamToNodeWritable = exports.convertWebReadableStreamToNodeReadable = exports.StreamChannel = exports.MemoryStorage = exports.MemoryChannel = exports.Challenger = exports.VaultysId = exports.Buffer = exports.crypto = void 0;
const Challenger_1 = __importDefault(__webpack_require__(/*! ./src/Challenger */ "./dist/node/src/Challenger.js"));
exports.Challenger = Challenger_1.default;
const IdManager_1 = __importDefault(__webpack_require__(/*! ./src/IdManager */ "./dist/node/src/IdManager.js"));
exports.IdManager = IdManager_1.default;
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./src/KeyManager */ "./dist/node/src/KeyManager.js"));
exports.KeyManager = KeyManager_1.default;
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./src/VaultysId */ "./dist/node/src/VaultysId.js"));
exports.VaultysId = VaultysId_1.default;
const MemoryChannel_1 = __webpack_require__(/*! ./src/MemoryChannel */ "./dist/node/src/MemoryChannel.js");
Object.defineProperty(exports, "MemoryChannel", ({ enumerable: true, get: function () { return MemoryChannel_1.MemoryChannel; } }));
Object.defineProperty(exports, "StreamChannel", ({ enumerable: true, get: function () { return MemoryChannel_1.StreamChannel; } }));
Object.defineProperty(exports, "convertWebReadableStreamToNodeReadable", ({ enumerable: true, get: function () { return MemoryChannel_1.convertWebReadableStreamToNodeReadable; } }));
Object.defineProperty(exports, "convertWebWritableStreamToNodeWritable", ({ enumerable: true, get: function () { return MemoryChannel_1.convertWebWritableStreamToNodeWritable; } }));
const MemoryStorage_1 = __webpack_require__(/*! ./src/MemoryStorage */ "./dist/node/src/MemoryStorage.js");
Object.defineProperty(exports, "MemoryStorage", ({ enumerable: true, get: function () { return MemoryStorage_1.MemoryStorage; } }));
Object.defineProperty(exports, "LocalStorage", ({ enumerable: true, get: function () { return MemoryStorage_1.LocalStorage; } }));
const GameOfLifeIcon_1 = __importDefault(__webpack_require__(/*! ./src/GameOfLifeIcon */ "./dist/node/src/GameOfLifeIcon.js"));
exports.GameOfLifeIcon = GameOfLifeIcon_1.default;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./src/cryptoChannel */ "./dist/node/src/cryptoChannel.js"));
exports.CryptoChannel = cryptoChannel_1.default;
//utils
const crypto = __importStar(__webpack_require__(/*! ./src/crypto */ "./dist/node/src/crypto.js"));
exports.crypto = crypto;
const Buffer = crypto.Buffer;
exports.Buffer = Buffer;
if (typeof Symbol.dispose === "undefined") {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    Symbol.dispose = Symbol("Symbol.dispose");
}


/***/ }),

/***/ "./dist/node/src/Challenger.js":
/*!*************************************!*\
  !*** ./dist/node/src/Challenger.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./VaultysId */ "./dist/node/src/VaultysId.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const ERROR = -2;
const UNINITIALISED = -1;
const INIT = 0;
const STEP1 = 1;
const COMPLETE = 2;
const writeString = (name, value) => buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii"), buffer_1.Buffer.from([0xa0 + value.length]), buffer_1.Buffer.from(value, "ascii")]);
const writeBuffer = (name, value) => {
    const nameHeader = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii")]);
    let lengthHeader;
    if (value.length <= 65535) {
        // bin16: binary data whose length is upto (2^16)-1 bytes
        lengthHeader = buffer_1.Buffer.from([0xc5, (value.length >> 8) & 0xff, value.length & 0xff]);
    }
    else {
        // bin32: binary data whose length is upto (2^32)-1 bytes
        lengthHeader = buffer_1.Buffer.from([0xc6, (value.length >> 24) & 0xff, (value.length >> 16) & 0xff, (value.length >> 8) & 0xff, value.length & 0xff]);
    }
    return buffer_1.Buffer.concat([nameHeader, lengthHeader, value]);
};
const writeInt = (name, value) => {
    // console.log(value)
    const start = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, "ascii")]);
    let end;
    if (value >= 0 && value <= 0x7f) {
        end = buffer_1.Buffer.from([value]);
    }
    else if (value < 0 && value >= -0x20) {
        end = buffer_1.Buffer.from([value]);
    }
    else if (value > 0 && value <= 0xff) {
        // uint8
        end = buffer_1.Buffer.from([0xcc, value]);
    }
    else if (value >= -0x80 && value <= 0x7f) {
        // int8
        end = buffer_1.Buffer.from([0xd0, value]);
    }
    else if (value > 0 && value <= 0xffff) {
        // uint16
        end = buffer_1.Buffer.from([0xcd, value >>> 8, value]);
    }
    else if (value >= -0x8000 && value <= 0x7fff) {
        // int16
        end = buffer_1.Buffer.from([0xd1, value >>> 8, value]);
    }
    else if (value > 0 && value <= 0xffffffff) {
        // uint32
        end = buffer_1.Buffer.from([0xce, value >>> 24, value >>> 16, value >>> 8, value]);
    }
    else if (value >= -0x80000000 && value <= 0x7fffffff) {
        // int32
        end = buffer_1.Buffer.from([0xd2, value >>> 24, value >>> 16, value >>> 8, value]);
    }
    else if (value > 0 && value <= 0xffffffffffffffffn) {
        // uint64
        // Split 64 bit number into two 32 bit numbers because JavaScript only regards
        // 32 bits for bitwise operations.
        const hi = value / 2 ** 32;
        const lo = value % 2 ** 32;
        end = buffer_1.Buffer.from([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);
    }
    else {
        end = buffer_1.Buffer.from([0x00]);
    }
    return buffer_1.Buffer.concat([start, end]);
};
const encode_v0 = ({ version, protocol, service, timestamp, pk1, pk2, nonce, metadata }) => {
    const p = buffer_1.Buffer.concat([
        buffer_1.Buffer.from([0x87]),
        writeString("protocol", protocol),
        writeString("service", service),
        writeInt("timestamp", timestamp),
        writeBuffer("pk1", pk1),
        writeBuffer("pk2", pk2),
        writeBuffer("nonce", nonce),
        buffer_1.Buffer.from([0xa0 + "metadata".length]),
        buffer_1.Buffer.from("metadata", "ascii"),
        buffer_1.Buffer.from([0x80]), // empty metadata
    ]);
    // console.log(p.toString("base64"));
    return p;
};
const encode_v0_full = ({ version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata }) => {
    const p = buffer_1.Buffer.concat([
        buffer_1.Buffer.from([0x89]),
        writeString("protocol", protocol),
        writeString("service", service),
        writeInt("timestamp", timestamp),
        writeBuffer("pk1", pk1),
        writeBuffer("pk2", pk2),
        writeBuffer("nonce", nonce),
        writeBuffer("sign1", sign1),
        writeBuffer("sign2", sign2),
        buffer_1.Buffer.from([0xa0 + "metadata".length]),
        buffer_1.Buffer.from("metadata", "ascii"),
        buffer_1.Buffer.from([0x80]), // empty metadata
    ]);
    //console.log(p.toString("ascii"))
    return p;
};
const deserialize = (challenge) => {
    const unpacked = (0, msgpack_1.decode)(challenge);
    const state = {
        state: ERROR,
        error: "",
    };
    if (!unpacked.version) {
        unpacked.version = 0;
    }
    const result = {
        ...unpacked,
        ...state,
    };
    try {
        if (!result.timestamp || !result.protocol || !result.service) {
            result.state = ERROR;
            result.error = "[ERROR] Challenge is missing values";
        }
        else if (!result.pk2 && !!result.pk1 && !result.sign1 && !result.sign2 && result.nonce?.length === 16) {
            result.state = INIT;
        }
        else if (!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {
            result.state = STEP1;
            const id2 = VaultysId_1.default.fromId(result.pk2);
            const challenge = serializeUnsigned(result);
            if (!id2.verifyChallenge(challenge, result.sign2, true)) {
                result.state = ERROR;
                result.error = "[STEP1] failed the verification of pk2";
            }
        }
        else if (!!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {
            result.state = COMPLETE;
            //console.log(result);
            const id1 = VaultysId_1.default.fromId(result.pk1);
            const id2 = VaultysId_1.default.fromId(result.pk2);
            if (id1.version !== unpacked.version || id2.version !== unpacked.version) {
                //console.log(id1.version, id2.version, unpacked.version);
                result.state = ERROR;
                result.error = "[COMPLETE] pk1 and pk2 are using different serialization version";
            }
            const challenge = serializeUnsigned(result);
            if (!id2.verifyChallenge(challenge, result.sign2, true)) {
                result.state = ERROR;
                result.error = "[COMPLETE] failed the verification of pk2";
            }
            if (!id1.verifyChallenge(challenge, result.sign1, true)) {
                result.state = ERROR;
                result.error = "[COMPLETE] failed the verification of pk1";
            }
        }
    }
    catch (error) {
        result.error = "[" + result.state + " -> ERROR] " + error;
        result.state = ERROR;
    }
    return result;
};
const serialize = (data) => {
    if (data.state == INIT) {
        const { version, protocol, service, timestamp, pk1, nonce, metadata } = data;
        const picked = { version, protocol, service, timestamp, pk1, nonce, metadata };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    if (data.state == STEP1) {
        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign2, metadata } = data;
        const picked = {
            version,
            protocol,
            service,
            timestamp,
            pk1,
            pk2,
            nonce,
            sign2,
            metadata,
        };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    if (data.state == COMPLETE) {
        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata } = data;
        const picked = {
            version,
            protocol,
            service,
            timestamp,
            pk1,
            pk2,
            nonce,
            sign1,
            sign2,
            metadata,
        };
        const encoded = (0, msgpack_1.encode)(picked);
        return buffer_1.Buffer.from(encoded);
    }
    return null;
};
const serializeUnsigned = (challenge) => {
    const { version, protocol, service, timestamp, pk1, pk2, nonce, metadata } = challenge;
    const picked = { version, protocol, service, timestamp, pk1, pk2, nonce, metadata };
    return version === 0 ? encode_v0(picked) : buffer_1.Buffer.from((0, msgpack_1.encode)(picked));
};
const isLive = (challenge, liveliness, time = Date.now()) => {
    return challenge.timestamp > time - liveliness && challenge.timestamp < time + liveliness;
};
class Challenger {
    constructor(vaultysId, liveliness = 60 * 1000) {
        this.version = 0;
        this.state = UNINITIALISED;
        // create a copy of VaultysId
        this.vaultysId = VaultysId_1.default.fromSecret(vaultysId.getSecret());
        this.liveliness = liveliness;
    }
    static async verifyCertificate(certificate) {
        const deser = deserialize(certificate);
        return deser.state === COMPLETE;
    }
    static async fromCertificate(certificate, liveliness) {
        const deser = deserialize(certificate);
        if (!deser.version) {
            deser.version = 0;
        }
        if (deser.state === INIT) {
            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk1).toVersion(deser.version), liveliness);
            challenger.challenge = deser;
            challenger.mykey = deser.pk1;
            challenger.state = INIT;
        }
        else if (deser.state === STEP1) {
            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk2).toVersion(deser.version), liveliness);
            challenger.challenge = deser;
            challenger.mykey = deser.pk2;
            challenger.hisKey = deser.pk1;
            challenger.state = STEP1;
            return challenger;
        }
    }
    async setChallenge(challengeString) {
        if (this.state !== UNINITIALISED) {
            this.state = ERROR;
            throw new Error("Challenger already initialised, can't reset the state");
        }
        this.challenge = deserialize(challengeString);
        this.version = this.challenge.version;
        if (!isLive(this.challenge, this.liveliness)) {
            this.state = ERROR;
            this.challenge.error = "challenge timestamp failed the liveliness at first signature";
            throw new Error(this.challenge.error);
        }
        if (this.challenge.state === ERROR) {
            this.state = ERROR;
            throw new Error(this.challenge.error);
        }
        else if (this.challenge.state === INIT) {
            //this.vaultysId.toVersion(this.challenge.version);
            this.mykey = this.vaultysId.id;
            this.challenge.pk2 = this.mykey;
            this.hisKey = this.challenge.pk1;
            this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce || new Uint8Array(), (0, crypto_1.randomBytes)(16)]);
            const serialized = this.getUnsignedChallenge();
            if (!serialized)
                throw new Error("Error processing Challenge");
            this.challenge.sign2 = (await this.vaultysId.signChallenge(serialized)) || undefined;
            this.challenge.state = this.state = STEP1;
        }
        else if (this.challenge.state === COMPLETE) {
            //this.vaultysId.toVersion(this.challenge.version);
            this.mykey = this.vaultysId.id;
            if (!this.challenge.pk1?.equals(this.mykey) && !this.challenge.pk1?.equals(this.mykey)) {
                this.state = ERROR;
                throw new Error("Can't link the vaultys id to this challenge");
            }
            else {
                this.state = COMPLETE;
            }
        }
        else {
            throw new Error("Challenge is from a protocol already launched, this is completely unsafe");
        }
    }
    getContext() {
        return {
            protocol: this.challenge?.protocol,
            service: this.challenge?.service,
            metadata: this.challenge?.metadata,
        };
    }
    createChallenge(protocol, service, version = 0, metadata) {
        this.version = version;
        if (this.state == UNINITIALISED) {
            this.mykey = this.vaultysId.toVersion(version).id;
            // console.log(this)
            this.challenge = {
                version,
                protocol,
                service,
                metadata: metadata ? { pk1: metadata } : {},
                timestamp: Date.now(),
                pk1: this.mykey,
                nonce: (0, crypto_1.randomBytes)(16),
                state: INIT,
            };
            this.state = INIT;
        }
        else {
            this.state = ERROR;
            throw new Error("Challenger already initialised, can't reset the state");
        }
    }
    getCertificate() {
        if (!this.challenge)
            return buffer_1.Buffer.from([]);
        return serialize(this.challenge) || buffer_1.Buffer.from([]);
    }
    getUnsignedChallenge() {
        return serializeUnsigned(this.challenge);
    }
    getContactDid() {
        if (!this.hisKey)
            return null;
        return VaultysId_1.default.fromId(this.hisKey).did;
    }
    getContactId() {
        // to be sure this function is not misused, we get the id of the contact only once the protocol is complete
        if (this.isComplete()) {
            const contact = VaultysId_1.default.fromId(this.hisKey, this.getCertificate() || undefined);
            return contact;
        }
        else
            throw new Error("The challenge is not COMPLETE, it is unsafe to get the Contact ID before");
    }
    static fromString(vaultysId, challengeString) {
        const challenger = new Challenger(vaultysId);
        challenger.setChallenge(challengeString);
        return challenger;
    }
    hasFailed() {
        return this.state == ERROR;
    }
    isComplete() {
        return this.state == COMPLETE;
    }
    async init(challengeString) {
        if (this.state !== UNINITIALISED) {
            throw new Error("Can't init INITIALISED challenge");
        }
        const tempchallenge = deserialize(challengeString);
        this.version = tempchallenge.version = tempchallenge.version ? 1 : 0;
        this.vaultysId.toVersion(this.version);
        if (tempchallenge.state === INIT) {
            if (tempchallenge.pk2?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                this.state = ERROR;
                throw new Error("challenge is not corresponding to the right id");
            }
            this.challenge = tempchallenge;
            this.version = tempchallenge.version;
            this.mykey = this.challenge.pk2 = this.vaultysId.id;
            this.hisKey = this.challenge.pk1;
            this.challenge.state = this.state = INIT;
            return;
        }
        if (tempchallenge.state === STEP1) {
            if (tempchallenge.pk2?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                this.state = ERROR;
                throw new Error("challenge is not corresponding to the right id");
            }
            this.challenge = tempchallenge;
            this.version = tempchallenge.version;
            this.mykey = this.challenge.pk2;
            this.hisKey = this.challenge.pk1;
            this.state = this.challenge.state = STEP1;
            return;
        }
    }
    async update(challengeString, metadata) {
        if (this.state === ERROR) {
            throw new Error("Can't update errorneous challenge");
        }
        else if (this.state === COMPLETE) {
            throw new Error("Can't update COMPLETE challenge");
        }
        else {
            const tempchallenge = deserialize(challengeString);
            // console.log(this.state, tempchallenge.state);
            if (!tempchallenge) {
                this.state = ERROR;
                throw new Error("Can't read the new incoming challenge");
            }
            if (tempchallenge.state === ERROR) {
                //console.log(tempchallenge.pk1?.length, tempchallenge.pk2?.length);
                this.state = ERROR;
                throw new Error(tempchallenge.error);
            }
            if (!isLive(tempchallenge, this.liveliness)) {
                // console.log(this.liveliness);
                // const time = Date.now();
                // console.log(time - tempchallenge.timestamp, this.liveliness);
                // console.log(tempchallenge.timestamp > time - this.liveliness && tempchallenge.timestamp < time + this.liveliness);
                this.state = ERROR;
                throw new Error("challenge timestamp failed the liveliness");
            }
            this.version = tempchallenge.version;
            this.vaultysId.toVersion(this.version);
            if (this.state === UNINITIALISED && tempchallenge.state === INIT) {
                if (tempchallenge.metadata.pk2) {
                    this.state = ERROR;
                    throw new Error("Metadata is malformed: pk2 is already set");
                }
                this.challenge = tempchallenge;
                this.mykey = this.challenge.pk2 = this.vaultysId.id;
                this.hisKey = this.challenge.pk1;
                if (metadata)
                    this.challenge.metadata.pk2 = metadata;
                this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce, (0, crypto_1.randomBytes)(16)]);
                const serialized = this.getUnsignedChallenge();
                this.challenge.sign2 = await this.vaultysId.signChallenge(serialized);
                this.challenge.state = this.state = STEP1;
                return;
            }
            if (this.state === UNINITIALISED && tempchallenge.state === STEP1) {
                if (tempchallenge.pk1?.toString("base64") !== this.vaultysId.id.toString("base64")) {
                    // console.log(this.vaultysId.version, this);
                    this.state = ERROR;
                    throw new Error("challenge is not corresponding to the right id");
                }
                const serialized = serializeUnsigned(tempchallenge);
                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);
                this.challenge = tempchallenge;
                this.mykey = this.challenge.pk1;
                this.hisKey = this.challenge.pk2;
                this.state = this.challenge.state = COMPLETE;
                return;
            }
            if (this.state === UNINITIALISED && tempchallenge.state === COMPLETE) {
                console.log("COMPLETE case?!!");
                return;
            }
            if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {
                this.state = ERROR;
                throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);
            }
            if (this.state === INIT && tempchallenge.state === STEP1) {
                // @ts-ignore
                if (!tempchallenge.nonce?.subarray(0, 16).equals(this.challenge.nonce.subarray(0, 16))) {
                    this.state = ERROR;
                    throw new Error("Nonce has been tampered with");
                }
                if (tempchallenge.timestamp !== this.challenge?.timestamp) {
                    this.state = ERROR;
                    throw new Error("Timestamp has been tampered with");
                }
                if (!this.mykey?.equals(tempchallenge.pk1)) {
                    this.state = ERROR;
                    throw new Error(`The challenge has been tampered with. Received pk1 = '${tempchallenge.pk1}', expected pk1 = '${this.mykey}'`);
                }
                const serialized = serializeUnsigned(tempchallenge);
                if (!serialized) {
                    this.state = ERROR;
                    throw new Error("Error processing Challenge");
                }
                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);
                this.challenge = tempchallenge;
                this.hisKey = tempchallenge.pk2;
                this.state = this.challenge.state = COMPLETE;
            }
            else if (this.state === STEP1 && tempchallenge.state === COMPLETE) {
                if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {
                    this.state = ERROR;
                    throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);
                }
                // @ts-ignore
                if (!tempchallenge.nonce?.subarray(16, 32).equals(this.challenge.nonce.subarray(16, 32))) {
                    this.state = ERROR;
                    throw new Error("Nonce has been tampered with");
                }
                if (tempchallenge.timestamp !== this.challenge?.timestamp) {
                    this.state = ERROR;
                    throw new Error("Timestamp has been tampered with");
                }
                // INFO: no need for liveliness check since the whole certificate is complete
                // if (!isLive(tempchallenge, this.liveliness)) {
                //   this.state = ERROR;
                //   throw new Error("challenge timestamp failed the liveliness at 2nd signature");
                // }
                if (!this.mykey.equals(tempchallenge.pk2)) {
                    this.state = ERROR;
                    throw new Error(`The challenge pk2 has been tampered with`);
                }
                this.challenge = tempchallenge;
                this.state = COMPLETE;
            }
            else {
                //console.log(tempchallenge);
                const error = `The challenge is in an expected state. Received state = '${tempchallenge.state}', expected state = '${this.state + 1}'`;
                this.state = ERROR;
                throw new Error(error);
            }
        }
    }
}
Challenger.deserializeCertificate = deserialize;
Challenger.serializeCertificate_v0 = encode_v0_full;
Challenger.serializeCertificate = serializeUnsigned;
exports["default"] = Challenger;


/***/ }),

/***/ "./dist/node/src/Fido2Manager.js":
/*!***************************************!*\
  !*** ./dist/node/src/Fido2Manager.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./dist/node/src/platform/webauthn.js");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const encodeBinary = (data) => {
    if (data.length <= 65535) {
        // bin16: binary data whose length is upto (2^16)-1 bytes
        return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
    }
    else {
        // bin32: binary data whose length is upto (2^32)-1 bytes
        return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
    }
};
const serializeID_v0 = (km) => {
    const version = buffer_1.Buffer.from([0x83, 0xa1, 0x76, km.version]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    const ckey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x63]), encodeBinary(km.ckey)]);
    return buffer_1.Buffer.concat([version, ckey, cypher]);
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const type = cbor_1.default.decode(ckey).get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2Manager extends KeyManager_1.default {
    constructor() {
        super();
        this._transports = 0;
        this.level = 1; // ROOT, no Proof Management
        this.encType = "X25519KeyAgreementKey2019";
        this.webAuthn = (0, webauthn_1.getWebAuthnProvider)();
    }
    get transports() {
        return getTransports(this._transports);
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2Manager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        //encrypting
        const entropy = (0, crypto_1.randomBytes)(32);
        const seed = sha512(entropy);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed.slice(0, 32));
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        f2m.entropy = entropy;
        return f2m;
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                c: this.ckey,
                e: this.cypher.publicKey,
            }));
    }
    get id_v0() {
        return serializeID_v0(this);
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return f2m;
    }
    static instantiate(obj) {
        const f2m = new Fido2Manager();
        f2m.version = obj.version ?? 0;
        f2m.level = obj.level;
        f2m.fid = typeof obj.fid === "string" ? buffer_1.Buffer.from(obj.fid, "base64") : obj.fid;
        f2m._transports = obj.t ? obj.t : 15;
        f2m.ckey = obj.ckey.data ? buffer_1.Buffer.from(obj.ckey.data) : buffer_1.Buffer.from(obj.ckey);
        f2m.signer = getSignerFromCkey(f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return f2m;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "public";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m.ckey = data.c;
        f2m.signer = getSignerFromCkey(data.c);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: data.e,
        };
        return f2m;
    }
    async getSigner() {
        return {
            sign: async (data) => {
                if (!navigator.credentials)
                    return null;
                // ugly request userinteraction (needed for Safari and iOS)
                try {
                    await window?.CredentialUserInteractionRequest();
                }
                catch (error) { }
                const challenge = (0, crypto_1.hash)("sha256", data);
                const publicKey = {
                    challenge,
                    userVerification: "preferred",
                    allowCredentials: [
                        {
                            type: "public-key",
                            id: this.fid,
                            transports: getTransports(this._transports),
                        },
                    ],
                };
                const { response } = (await this.webAuthn.get(publicKey));
                const publicKeyResponse = response;
                const output = {
                    s: buffer_1.Buffer.from(publicKeyResponse.signature),
                    c: buffer_1.Buffer.from(publicKeyResponse.clientDataJSON),
                    a: buffer_1.Buffer.from(publicKeyResponse.authenticatorData),
                };
                return buffer_1.Buffer.from((0, msgpack_1.encode)(output));
            },
        };
    }
    verify(data, signature, userVerification = false) {
        const signatureBuffer = buffer_1.Buffer.from(signature);
        const decoded = (0, msgpack_1.decode)(signatureBuffer);
        const response = {
            signature: decoded.s,
            clientDataJSON: decoded.c,
            authenticatorData: decoded.a,
            userHandle: buffer_1.Buffer.from([]).buffer,
        };
        const challenge = (0, crypto_1.hash)("sha256", data).toString("base64");
        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);
        if (challenge !== extractedChallenge) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    verifyCredentials(credentials, userVerification = false) {
        if (credentials.id !== this.fid.toString("base64")) {
            return false;
        }
        const response = credentials.response;
        const rpIdHash = buffer_1.Buffer.from(response.authenticatorData.slice(0, 32)).toString("hex");
        const myIdHash = sha256(buffer_1.Buffer.from(credentials.id, "base64")).toString("hex");
        if (rpIdHash !== myIdHash) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    async createRevocationCertificate() {
        // TODO use an external id
        return null;
    }
}
exports["default"] = Fido2Manager;


/***/ }),

/***/ "./dist/node/src/Fido2PRFManager.js":
/*!******************************************!*\
  !*** ./dist/node/src/Fido2PRFManager.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const decoded = cbor_1.default.decode(ckey, { extendedResults: true });
    const type = decoded.value.get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey, { extendedResults: true }).value;
    //console.log("getSignerFromCkey", k);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2PRFManager extends Fido2Manager_1.default {
    constructor() {
        super();
        this.prfsalt = buffer_1.Buffer.from("VaultysID salt");
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2PRFManager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        //console.log(attestation, f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        await f2m.getCypher();
        delete f2m.cypher.secretKey;
        return f2m;
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.publicKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2PRFManager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        f2m.cypher = { publicKey: data.e };
        return f2m;
    }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
    }
    async getCypher() {
        if (!this.cypher?.secretKey) {
            const publicKey = {
                challenge: buffer_1.Buffer.from([]),
                userVerification: "preferred",
                allowCredentials: [
                    {
                        type: "public-key",
                        id: this.fid,
                        transports: getTransports(this._transports),
                    },
                ],
                extensions: {
                    prf: {
                        eval: {
                            // Input the contextual information
                            first: this.prfsalt,
                            // There is a "second" optional field too
                            // Though it is intended for key rotation.
                        },
                    },
                },
            };
            const result = await this.webAuthn.get(publicKey);
            const { prf } = result.getClientExtensionResults();
            const first = prf?.results?.first;
            if (!first)
                throw new Error("PRF failed");
            const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(first));
            this.cypher = {
                publicKey: buffer_1.Buffer.from(cypher.publicKey),
                secretKey: buffer_1.Buffer.from(cypher.secretKey),
            };
        }
        return super.getCypher();
    }
    async createRevocationCertificate() {
        // impossible
        return null;
    }
}
exports["default"] = Fido2PRFManager;


/***/ }),

/***/ "./dist/node/src/GameOfLifeIcon.js":
/*!*****************************************!*\
  !*** ./dist/node/src/GameOfLifeIcon.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const squareSize = 10;
const boardTopx = 0;
const boardTopy = 0;
const createFrom256 = (hex) => hex.match(/.{1,4}/g)?.map((line) => parseInt(line, 16).toString(2).padStart(16, "0")) || [];
const createFromFingerprint = (fp) => createFrom256((0, crypto_1.hash)("sha256", (0, crypto_1.fromHex)(fp.replaceAll(" ", ""))).toString("hex"));
const nextstep = (bin, memo) => {
    const output = [];
    for (let i = 0; i < 16; i++) {
        let line = "";
        for (let j = 0; j < 16; j++) {
            let count = 0;
            for (let k = i - 1; k < i + 2; k++) {
                for (let l = j - 1; l < j + 2; l++) {
                    if (k > -1 && k < 16 && l > -1 && l < 16) {
                        if ((k != i || l != j) && bin[k][l] == "1")
                            count++;
                    }
                }
            }
            let live = false;
            if (count == 3)
                live = true;
            else if (count == 2 && bin[i][j] == "1")
                live = true;
            line += live ? "1" : "O";
            if (memo && live) {
                memo[i][j]++;
            }
        }
        output.push(line);
    }
    return output;
};
const run = (hex, max) => {
    const result = createFrom256(hex)?.map((line) => line.split("").map((c) => parseInt(c)));
    let step = createFrom256(hex);
    for (let a = 0; a < max; a++) {
        step = nextstep(step, result);
    }
    return result;
};
const renderStep = (context, step) => {
    for (let i = 0; i < 16; i++) {
        for (let j = 0; j < 16; j++) {
            context.fillStyle = step[i][j] == 1 ? "black" : "white";
            let xOffset = boardTopx + j * squareSize;
            let yOffset = boardTopy + i * squareSize;
            context.fillRect(xOffset, yOffset, squareSize, squareSize);
            context.fillRect(150 - xOffset, yOffset, squareSize, squareSize);
            context.fillRect(xOffset, 150 - yOffset, squareSize, squareSize);
            context.fillRect(150 - xOffset, 150 - yOffset, squareSize, squareSize);
        }
    }
};
const heatMapColorforValue = (value, offset = 1) => {
    var h = (1.0 - value) * 240 + offset;
    //return `rgba(0,0,0,${value})`
    return "hsl(" + h + ", 100%, 50%)";
};
const renderMemo = (data, mapcolors = 2, context) => {
    let min = 1000;
    let max = 0;
    const memo = JSON.parse(JSON.stringify(data));
    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            memo[i][j] =
                memo[15 - i][j] =
                    memo[i][15 - j] =
                        memo[15 - i][15 - j] =
                            memo[i][j] + memo[15 - i][j] + memo[i][15 - j] + memo[15 - i][15 - j];
            const val = memo[i][j];
            if (val < min)
                min = val;
            if (val > max)
                max = val;
        }
    }
    for (let i = 0; i < 16; i++) {
        for (let j = 0; j < 16; j++) {
            context.fillStyle = heatMapColorforValue(Math.floor(((memo[i][j] - min) * mapcolors) / max) / mapcolors, max * max);
            let xOffset = boardTopx + j * squareSize;
            let yOffset = boardTopy + i * squareSize;
            context.fillRect(xOffset, yOffset, squareSize, squareSize);
        }
    }
};
exports["default"] = {
    renderFingerprint: (fp, canvas, steps = 32) => {
        let step = createFromFingerprint(fp.replaceAll(" ", ""));
        let memo = step?.map((line) => line.split("").map((c) => parseInt(c)));
        const context = canvas.getContext("2d");
        if (!context || !memo)
            return;
        for (let t = 0; t < steps; t++) {
            step = nextstep(step, memo);
        }
        renderMemo(memo, 3, context);
        return canvas;
    },
    animateFingerprint: async (fp, canvas, steps = 32, speed = 500) => {
        let step = createFromFingerprint(fp.replaceAll(" ", ""));
        let memo = step?.map((line) => line.split("").map((c) => parseInt(c)));
        const context = canvas.getContext("2d");
        if (!context || !memo)
            return;
        for (let t = 0; t < steps; t++) {
            step = nextstep(step, memo);
            renderMemo(memo, 3, context);
            await new Promise((resolve) => setTimeout(resolve, speed));
        }
        renderMemo(memo, 3, context);
        return canvas;
    },
};


/***/ }),

/***/ "./dist/node/src/IdManager.js":
/*!************************************!*\
  !*** ./dist/node/src/IdManager.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Challenger_1 = __importDefault(__webpack_require__(/*! ./Challenger */ "./dist/node/src/Challenger.js"));
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const MemoryChannel_1 = __webpack_require__(/*! ./MemoryChannel */ "./dist/node/src/MemoryChannel.js");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const VaultysId_1 = __importDefault(__webpack_require__(/*! ./VaultysId */ "./dist/node/src/VaultysId.js"));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const Fido2PRFManager_1 = __importDefault(__webpack_require__(/*! ./Fido2PRFManager */ "./dist/node/src/Fido2PRFManager.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
// "vaultys/encryption/" + version = 0x01
const ENCRYPTION_HEADER = buffer_1.Buffer.from("7661756c7479732f656e6372797074696f6e2f01", "hex");
const PRF_NONCE_LENGTH = 32;
const getSignatureType = (challenge) => {
    if (challenge.startsWith("vaultys://connect?")) {
        return "LOGIN";
    }
    else if (challenge.startsWith("vaultys://signfile?")) {
        return "DOCUMENT";
    }
    else {
        return "UNKNOWN";
    }
};
const instanciateContact = (c) => {
    let vaultysId;
    if (c.type === 3) {
        vaultysId = new VaultysId_1.default(Fido2Manager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    else if (c.type === 4) {
        vaultysId = new VaultysId_1.default(Fido2PRFManager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    else {
        vaultysId = new VaultysId_1.default(KeyManager_1.default.instantiate(c.keyManager), c.certificate, c.type);
    }
    return vaultysId;
};
const instanciateApp = (a) => {
    return VaultysId_1.default.fromId(buffer_1.Buffer.from(a.serverId, "base64"), a.certificate);
};
class IdManager {
    constructor(vaultysId, store) {
        this.protocol_version = 0;
        // alias since this is symetric key encryption
        this.acceptEncryptFile = this.acceptDecryptFile;
        this.vaultysId = vaultysId;
        this.store = store;
        if (!this.store.get("metadata")) {
            this.store.set("metadata", {});
        }
        if (this.vaultysId.keyManager.entropy)
            this.store.set("entropy", this.vaultysId.keyManager.entropy);
        else
            this.store.set("secret", this.vaultysId.getSecret());
        this.store.save();
    }
    setProtocolVersion(version) {
        this.protocol_version = version;
    }
    static async fromStore(store) {
        const entropy = store.get("entropy");
        const secret = store.get("secret");
        if (secret) {
            if (entropy) {
                const secretBuffer = buffer_1.Buffer.from(secret, "base64");
                const type = secretBuffer[0];
                const vaultysId = await VaultysId_1.default.fromEntropy(entropy, type);
                return new IdManager(vaultysId, store);
            }
            else {
                const vaultysId = VaultysId_1.default.fromSecret(secret);
                return new IdManager(vaultysId, store);
            }
        }
        else if (entropy) {
            const vaultysId = await VaultysId_1.default.machineFromEntropy(entropy);
            return new IdManager(vaultysId, store);
        }
        else {
            const vaultysId = await VaultysId_1.default.generateMachine();
            return new IdManager(vaultysId, store);
        }
    }
    merge(otherStore, master = true) {
        // TODO: check if same profile ?
        // TODO: revamp contact metadata and sync
        const master_store = master ? otherStore : this.store;
        const slave_store = master ? this.store : otherStore;
        this.store.set("metadata", { ...slave_store.get("metadata"), ...master_store.get("metadata") });
        ["signatures", "wot"].forEach((table) => {
            const other = otherStore.substore(table);
            const me = this.store.substore(table);
            other.list().forEach((k) => {
                if (!me.get(k)) {
                    me.set(k, other.get(k));
                }
            });
        });
        const other = otherStore.substore("contacts");
        const me = this.store.substore("contacts");
        const m = master ? other : me;
        const s = master ? me : other;
        other.list().forEach((did) => {
            if (!me.get(did)) {
                me.set(did, other.get(did));
            }
            else {
                const contact = me.get(did);
                contact.metadata = { ...s.get(did).metadata, ...m.get(did).metadata };
                me.set(did, contact);
            }
        });
        this.store.save();
    }
    isHardware() {
        return this.vaultysId.isHardware();
    }
    async signIn() {
        if (!this.vaultysId.isHardware())
            return true;
        await window.CredentialUserInteractionRequest();
        const challenge = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);
        const keyManager = this.vaultysId.keyManager;
        const creds = (await navigator.credentials.get({
            publicKey: {
                challenge,
                allowCredentials: [
                    {
                        type: "public-key",
                        id: keyManager.fid,
                        transports: keyManager.transports,
                    },
                ],
                userVerification: "discouraged",
            },
        }));
        if (creds == null)
            return false;
        const response = creds.response;
        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);
        if (challenge.toString("base64") !== extractedChallenge) {
            return false;
        }
        return keyManager.verifyCredentials(creds);
    }
    get contacts() {
        const s = this.store.substore("contacts");
        return s
            .list()
            .map((did) => s.get(did))
            .map(instanciateContact)
            .map((contact) => contact.toVersion(this.vaultysId.version));
    }
    get apps() {
        const s = this.store.substore("registrations");
        return s
            .list()
            .map((did) => s.get(did))
            .map(instanciateApp)
            .map((app) => app.toVersion(this.vaultysId.version));
    }
    getContact(did) {
        const c = this.store.substore("contacts").get(did);
        if (!c)
            return null;
        return instanciateContact(c).toVersion(this.vaultysId.version);
    }
    getApp(did) {
        const app = this.store.substore("registrations").get(did);
        if (!app)
            return null;
        return instanciateApp(app).toVersion(this.vaultysId.version);
    }
    setContactMetadata(did, name, value) {
        const c = this.store.substore("contacts").get(did);
        if (c) {
            if (!c.metadata) {
                c.metadata = {};
            }
            c.metadata[name] = value;
        }
    }
    getContactMetadata(did, name) {
        const c = this.store.substore("contacts").get(did);
        if (c && c.metadata) {
            return c.metadata[name];
        }
        return null;
    }
    getContactMetadatas(did) {
        const c = this.store.substore("contacts").get(did);
        if (c && c.metadata) {
            return c.metadata;
        }
        return null;
    }
    async verifyRelationshipCertificate(did) {
        const c = this.store.substore("contacts").get(did) || this.store.substore("registrations").get(did);
        return Challenger_1.default.verifyCertificate(c.certificate);
    }
    set name(n) {
        this.store.get("metadata").name = n;
    }
    get name() {
        return this.store.get("metadata").name;
    }
    get displayName() {
        const metadata = this.store.get("metadata");
        const result = metadata.firstname ? metadata.firstname + " " + (metadata.name ?? "") : metadata.name;
        return result?.length > 0 ? result : "Anonymous " + this.vaultysId.fingerprint?.slice(-4);
    }
    set phone(n) {
        this.store.get("metadata").phone = n;
    }
    get phone() {
        return this.store.get("metadata").phone;
    }
    set email(n) {
        this.store.get("metadata").email = n;
    }
    get email() {
        return this.store.get("metadata").email;
    }
    // set avatar(n) {
    //   this.store.get("metadata").avatar = {
    //     data: Buffer.from(n.data).toString("base64"),
    //     type: n.type,
    //   };
    // }
    // get avatar() {
    //   const temp = this.store.get("metadata").avatar;
    //   if (!temp) return null;
    //   return {
    //     data: Buffer.from(temp.data, "base64"),
    //     type: temp.type,
    //   };
    // }
    async signChallenge(challenge) {
        const signature = await this.vaultysId.signChallenge(challenge);
        this.store.substore("signatures").set("" + Date.now(), {
            signature,
            challenge,
        });
        this.store.save();
        return signature;
    }
    async signFile(file) {
        const h = (0, crypto_1.hash)("sha256", file.arrayBuffer).toString("hex");
        const challenge = buffer_1.Buffer.from(`vaultys://signfile?hash=${h}&timestamp=${Date.now()}`, "utf-8");
        const payload = {
            challenge,
            signature: await this.vaultysId.signChallenge(challenge),
        };
        this.store.substore("signatures").set(Date.now() + "", payload);
        this.store.save();
        return payload;
    }
    verifyFile(file, fileSignature, contactId, userVerifiation = true) {
        const data = fileSignature.challenge.toString("utf8");
        if (!data.startsWith("vaultys://signfile?")) {
            return false;
        }
        const h = (0, crypto_1.hash)("sha256", file.arrayBuffer).toString("hex");
        const url = new URL(data);
        const fileHash = url.searchParams.get("hash");
        if (h !== fileHash) {
            return false;
        }
        if (url.search.match(/[a-z\d]+=[a-z\d]+/gi)?.length === 2 && url.searchParams.get("timestamp")) {
            return contactId.verifyChallenge(fileSignature.challenge, fileSignature.signature, userVerifiation);
        }
        return false;
    }
    async decryptFile(toDecrypt, channel) {
        // Extract nonce and ciphertext from arrayBuffer
        const data = new Uint8Array(toDecrypt.arrayBuffer);
        const header = data.slice(0, ENCRYPTION_HEADER.length);
        if (buffer_1.Buffer.from(header).toString("hex") !== ENCRYPTION_HEADER.toString("hex")) {
            throw new Error("Invalid header for encrypted file");
        }
        const prfNonceBytes = data.slice(ENCRYPTION_HEADER.length, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);
        const nonceBytes = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);
        const ciphertext = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);
        const prf = channel ? await this.requestPRF(channel, "encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption") : await this.vaultysId.hmac("prf|encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption|prf");
        if (prf?.length !== PRF_NONCE_LENGTH) {
            throw new Error("Invalid PRF generated");
        }
        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)
        const secretKey = (0, crypto_1.hash)("sha256", prf);
        (0, crypto_1.secureErase)(prf);
        // Decrypt using nacl.secretbox.open
        const decrypted = tweetnacl_1.default.secretbox.open(ciphertext, nonceBytes, secretKey);
        (0, crypto_1.secureErase)(secretKey);
        if (!decrypted) {
            throw new Error("Decryption failed");
        }
        return {
            name: toDecrypt.name,
            type: toDecrypt.type,
            arrayBuffer: buffer_1.Buffer.from(decrypted),
        };
    }
    async encryptFile(toEncrypt, channel) {
        // Generate a secure random nonce for both the PRF and the secretbox
        const prfNonceBytes = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);
        const prf = channel ? await this.requestPRF(channel, "encryption/" + buffer_1.Buffer.from(prfNonceBytes).toString("hex") + "/encryption") : await this.vaultysId.hmac("prf|encryption/" + prfNonceBytes.toString("hex") + "/encryption|prf");
        if (prf?.length !== PRF_NONCE_LENGTH) {
            return null;
        }
        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)
        const secretKey = (0, crypto_1.hash)("sha256", prf);
        (0, crypto_1.secureErase)(prf);
        // Generate a random nonce for secretbox encryption
        const nonceBytes = tweetnacl_1.default.randomBytes(tweetnacl_1.default.secretbox.nonceLength);
        // Encrypt using nacl.secretbox
        const ciphertext = tweetnacl_1.default.secretbox(new Uint8Array(toEncrypt.arrayBuffer), nonceBytes, secretKey);
        (0, crypto_1.secureErase)(secretKey);
        // Combine encryption nonce and ciphertext into a single buffer
        const result = new Uint8Array(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length + ciphertext.length);
        result.set(ENCRYPTION_HEADER);
        result.set(prfNonceBytes, ENCRYPTION_HEADER.length);
        result.set(nonceBytes, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);
        result.set(ciphertext, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length);
        return {
            name: toEncrypt.name,
            type: toEncrypt.type,
            arrayBuffer: buffer_1.Buffer.from(result), // Buffer contains secretbox nonce + ciphertext
        };
    }
    getSignatures() {
        const store = this.store.substore("signatures");
        return store
            .list()
            .sort()
            .map((date) => {
            const payload = store.get(date);
            const challenge = buffer_1.Buffer.from(payload.challenge).toString("utf-8");
            return {
                date,
                payload,
                challenge,
                type: getSignatureType(challenge),
            };
        });
    }
    migrate(version) {
        this.vaultysId.toVersion(version);
        const s = this.store.substore("contacts");
        for (const did of s.list()) {
            const data = s.get(did);
            const contact = instanciateContact(data);
            const newContact = contact.toVersion(version);
            if (newContact.did !== did) {
                s.set(newContact.did, { ...contact, ...newContact, metadata: data.metadata, oldDid: did });
                s.delete(did);
                //console.log(did, "->", newContact.did);
            }
        }
        const apps = this.store.substore("registrations");
        for (const did of apps.list()) {
            const data = apps.get(did);
            const site = instanciateApp(data);
            if (site) {
                const newSite = site.toVersion(version);
                if (newSite.did !== did) {
                    const name = data.site === did ? newSite.did : data.site;
                    apps.set(newSite.did, { site: name, oldDid: did, serverId: newSite.id.toString("base64"), certificate: data.certificate, timestamp: data.timestamp });
                    apps.delete(did);
                    // console.log(did, "->", newSite.did);
                }
            }
        }
        this.store.save();
    }
    async verifyChallenge(challenge, signature) {
        return this.vaultysId.verifyChallenge(challenge, signature, true);
    }
    async upload(channel, stream) {
        const challenger = await this.startSRP(channel, "p2p", "transfer");
        if (challenger.isComplete()) {
            const { upload } = (0, MemoryChannel_1.StreamChannel)(channel);
            await upload(stream);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async download(channel, stream) {
        const challenger = await this.acceptSRP(channel, "p2p", "transfer");
        if (challenger.isComplete()) {
            const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
            await download(stream);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestDecrypt(channel, toDecrypt) {
        const challenger = await this.acceptSRP(channel, "p2p", "decrypt");
        if (challenger.isComplete()) {
            channel.send(toDecrypt);
            const new_encrypted = await channel.receive();
            const decrypted = await this.vaultysId.dhiesDecrypt(new_encrypted, challenger.getContactId().id);
            return decrypted;
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptDecrypt(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "decrypt", {}, accept);
        if (challenger.isComplete()) {
            const toDecrypt = await channel.receive();
            const decrypted = await this.vaultysId.decrypt(toDecrypt.toString("utf-8"));
            if (decrypted) {
                const encrypted = await this.vaultysId.dhiesEncrypt(decrypted, challenger.getContactId().id);
                channel.send(encrypted ?? buffer_1.Buffer.from([0]));
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestDecryptFile(channel, toDecrypt) {
        return this.decryptFile(toDecrypt, channel);
    }
    async requestEncryptFile(channel, toEncrypt) {
        return this.encryptFile(toEncrypt, channel);
    }
    async acceptDecryptFile(channel, accept) {
        let result_contact = null;
        await this.acceptPRF(channel, (contact, appid) => {
            if (appid.length > 63 && appid.startsWith("encryption/") && appid.endsWith("/encryption")) {
                result_contact = contact;
                //TODO: maybe by default should be in web of trust?
                return accept?.(contact) || Promise.resolve(true);
            }
            else
                return Promise.resolve(false);
        });
        return result_contact;
    }
    async requestSignFile(channel, file) {
        const challenger = await this.acceptSRP(channel, "p2p", "signfile");
        if (challenger.isComplete()) {
            channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(file)));
            const result = await channel.receive();
            const fileSignature = (0, msgpack_1.decode)(result);
            if (this.verifyFile(file, fileSignature, challenger.getContactId().toVersion(1))) {
                return fileSignature;
            }
            else
                return undefined;
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptSignFile(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "signfile");
        if (challenger.isComplete()) {
            const result = await channel.receive();
            const file = (0, msgpack_1.decode)(result);
            if (!accept || (await accept(challenger.getContactId(), file))) {
                const result = await this.signFile(file);
                channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(result)));
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async requestPRF(channel, appid) {
        if (appid.length < 3) {
            throw new Error("appid is too short, less than 3 characters");
        }
        if (appid.split("|").length > 1) {
            throw new Error("appid contains illegal character |");
        }
        const challenger = await this.acceptSRP(channel, "p2p", "prf");
        if (challenger.isComplete()) {
            channel.send(buffer_1.Buffer.from(appid, "utf-8"));
            const prf = await channel.receive();
            return buffer_1.Buffer.from(prf);
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    async acceptPRF(channel, accept) {
        const challenger = await this.startSRP(channel, "p2p", "prf");
        if (challenger.isComplete()) {
            const result = await channel.receive();
            const appid = result.toString("utf-8");
            if (appid.length < 3 || appid.split("|").length > 1) {
                // error if appid is too short or contains illegal character
                channel.send(buffer_1.Buffer.from([0]));
            }
            else if (!accept || (await accept(challenger.getContactId(), appid))) {
                const hmac = (await this.vaultysId.hmac("prf|" + appid + "|prf")) ?? buffer_1.Buffer.from([0]);
                channel.send(hmac);
                (0, crypto_1.secureErase)(hmac);
            }
            else
                channel.send(buffer_1.Buffer.from([0]));
        }
        else
            channel.send(buffer_1.Buffer.from([0]));
    }
    /***************************/
    /*   SIGNING PARTY HERE!   */
    /***************************/
    listCertificates() {
        const wot = this.store.substore("wot");
        return wot.list().map((timestamp) => {
            const c = wot.get(timestamp);
            if (c.timestamp) {
                return c;
            }
            else {
                const result = {
                    ...Challenger_1.default.deserializeCertificate(wot.get(timestamp)),
                    raw: c,
                };
                wot.set(timestamp, result);
                return result;
            }
        });
    }
    async startSRP(channel, protocol, service, metadata = {}, accept) {
        const challenger = new Challenger_1.default(this.vaultysId);
        challenger.createChallenge(protocol, service, this.protocol_version, metadata);
        //console.log(challenger);
        const cert = challenger.getCertificate();
        if (!cert) {
            channel.close();
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error("Error processing challenge");
        }
        channel.send(cert);
        try {
            const message = await channel.receive();
            // console.log("startSRP", message)
            const contact = Challenger_1.default.deserializeCertificate(message).pk2;
            if (!contact) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact pk2 is not sent");
            }
            if (accept && !(await accept(VaultysId_1.default.fromId(contact)))) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact refused");
            }
            await challenger.update(message);
        }
        catch (error) {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error(error);
        }
        if (challenger.isComplete()) {
            const certificate = challenger.getCertificate();
            if (!certificate) {
                channel.close();
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Error processing challenge");
            }
            // there is a caveat here, we are not sure that the last bit of information has been received
            channel.send(certificate);
            this.store.substore("wot").set(Date.now() + "", certificate);
            // TODO create/update merkle tree + sign it
            return challenger;
        }
        else {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error("Can't add a new contact if the protocol is not complete");
        }
    }
    async acceptSRP(channel, protocol, service, metadata = {}, accept) {
        const challenger = new Challenger_1.default(this.vaultysId);
        try {
            const message = await channel.receive();
            const chal = Challenger_1.default.deserializeCertificate(message);
            if (!chal.pk1) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact pk1 is not sent");
            }
            if (chal.protocol !== protocol) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("protocol is not the one expected: " + chal.protocol + " !=" + protocol);
            }
            if (chal.service !== service) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("service is not the one expected: " + chal.service + " !=" + service);
            }
            if (accept && !(await accept(VaultysId_1.default.fromId(chal.pk1)))) {
                channel.send(buffer_1.Buffer.from([0]));
                throw new Error("Contact refused");
            }
            await challenger.update(message, metadata);
        }
        catch (error) {
            channel.send(buffer_1.Buffer.from([0]));
            throw new Error(error);
        }
        const cert = challenger.getCertificate();
        if (!cert) {
            channel.send(buffer_1.Buffer.from([0]));
            await channel.close();
            throw new Error("Error processing challenge");
        }
        // console.log("acceptSRP sending 1")
        channel.send(cert);
        // console.log("acceptSRP sending 2")
        try {
            const message = await channel.receive();
            // console.log("acceptSRP 2", message)
            await challenger.update(message);
        }
        catch (error) {
            await channel.close();
            //console.log(challenger);
            throw new Error(error);
        }
        if (challenger.isComplete()) {
            const certificate = challenger.getCertificate();
            this.store.substore("wot").set(Date.now() + "", certificate);
            // TODO create/update merkle tree + sign it
            return challenger;
        }
        else {
            await channel.close();
            throw new Error("Can't add a new contact if the protocol is not complete");
        }
    }
    saveApp(app, name) {
        app.toVersion(this.vaultysId.version);
        if (!app.isMachine()) {
            this.saveContact(app);
        }
        else {
            const appstore = this.store.substore("registrations");
            if (!appstore.get(app.did)) {
                appstore.set(app.did, {
                    site: name ?? app.did,
                    serverId: app.id.toString("base64"),
                    certificate: app.certificate,
                });
            }
        }
    }
    saveContact(contact) {
        contact.toVersion(this.vaultysId.version);
        if (contact.isMachine()) {
            this.saveApp(contact);
        }
        else {
            const contactstore = this.store.substore("contacts");
            if (!contactstore.get(contact.did)) {
                contactstore.set(contact.did, contact);
                this.store.save();
            }
        }
    }
    async askContact(channel, metadata = {}, accept) {
        const challenger = await this.startSRP(channel, "p2p", "auth", metadata, accept);
        const contact = challenger.getContactId();
        this.saveContact(contact);
        return contact;
    }
    async acceptContact(channel, metadata = {}, accept) {
        const challenger = await this.acceptSRP(channel, "p2p", "auth", metadata, accept);
        const contact = challenger.getContactId();
        this.saveContact(contact);
        return contact;
    }
}
exports["default"] = IdManager;


/***/ }),

/***/ "./dist/node/src/KeyManager.js":
/*!*************************************!*\
  !*** ./dist/node/src/KeyManager.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DHIES = void 0;
const saltpack_1 = __webpack_require__(/*! @vaultys/saltpack */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_2 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
ed25519_1.ed25519.CURVE = { ...ed25519_1.ed25519.CURVE };
// @ts-ignore hack to get compatibility with former @stricahq/bip32ed25519 lib
ed25519_1.ed25519.CURVE.adjustScalarBytes = (bytes) => {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 63; // 0b0001_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
};
////@ts-expect-error fix for wrong way of exporting bip32ed25519
//const bip32 = bip32fix.default ?? bip32fix;
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const serializeID_v0 = (km) => {
    const encodeBinary = (data) => {
        if (data.length <= 65535) {
            // bin16: binary data whose length is upto (2^16)-1 bytes
            return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
        }
        else {
            // bin32: binary data whose length is upto (2^32)-1 bytes
            return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
        }
    };
    const version = buffer_1.Buffer.from([0x84, 0xa1, 0x76, 0]);
    const proof = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x70]), encodeBinary(km.proof)]);
    const sign = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x78]), encodeBinary(km.signer.publicKey)]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    return buffer_1.Buffer.concat([version, proof, sign, cypher]);
};
/**
 * DHIES (Diffie-Hellman Integrated Encryption Scheme) for KeyManager
 * Provides authenticated encryption using Diffie-Hellman key exchange
 */
class DHIES {
    constructor(keyManager) {
        this.keyManager = keyManager;
    }
    /**
     * Encrypts a message for a recipient using DHIES
     *
     * @param message The plaintext message to encrypt
     * @param recipientPublicKey The recipient's public key
     * @returns Encrypted message with ephemeral public key and authentication tag, or null if encryption fails
     */
    async encrypt(message, recipientPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot encrypt with DHIES using a public KeyManager");
            return null;
        }
        const cypher = await this.keyManager.getCypher();
        // Convert message to Buffer if it's a string
        const messageBuffer = typeof message === "string" ? buffer_1.Buffer.from(message, "utf8") : message;
        try {
            const ephemeralKey = (0, crypto_1.randomBytes)(32); // Generate a random 32-byte key for ephemeral key
            // Derive shared secret using recipient's public key and sender secret key
            const dh = await cypher.diffieHellman(recipientPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys from shared secret
            const kdfOutput = this.kdf(sharedSecret, this.keyManager.cypher.publicKey, recipientPublicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Encrypt the message using XChaCha20-Poly1305
            const nonce = (0, crypto_1.randomBytes)(24); // 24 bytes nonce for XChaCha20-Poly1305
            const ciphertext = buffer_1.Buffer.from(tweetnacl_1.default.secretbox(messageBuffer, nonce, encryptionKey));
            // Compute MAC (Message Authentication Code)
            const dataToAuthenticate = buffer_1.Buffer.concat([this.keyManager.cypher.publicKey, nonce, ciphertext]);
            const mac = this.computeMAC(macKey, dataToAuthenticate);
            // Construct the final encrypted message: nonce + ephemeralKey + ciphertext + MAC
            const encryptedMessage = buffer_1.Buffer.concat([nonce, ephemeralKey, ciphertext, mac]);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(dh);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return encryptedMessage;
        }
        catch (error) {
            console.error("DHIES encryption failed:", error);
            return null;
        }
    }
    /**
     * Decrypts a message encrypted with DHIES
     *
     * @param encryptedMessage The complete encrypted message from the encrypt method
     * @returns Decrypted message as a Buffer, or null if decryption fails
     */
    async decrypt(encryptedMessage, senderPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot decrypt with DHIES using a public KeyManager");
            return null;
        }
        try {
            // Extract components from the encrypted message
            // Format: nonce (24 bytes) + ephemeralKey (32 bytes) + ciphertext + MAC (32 bytes)
            const nonce = encryptedMessage.slice(0, 24);
            const ephemeralKey = encryptedMessage.slice(24, 56);
            const mac = encryptedMessage.slice(encryptedMessage.length - 32);
            const ciphertext = encryptedMessage.slice(56, encryptedMessage.length - 32);
            const cypher = await this.keyManager.getCypher();
            // Derive shared secret using sender public key and recipient secret key
            const dh = await cypher.diffieHellman(senderPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys
            const kdfOutput = this.kdf(sharedSecret, senderPublicKey, this.keyManager.cypher.publicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Verify MAC
            const dataToAuthenticate = buffer_1.Buffer.concat([senderPublicKey, nonce, ciphertext]);
            const computedMac = this.computeMAC(macKey, dataToAuthenticate);
            if (!this.constantTimeEqual(mac, computedMac)) {
                //console.log(mac, computedMac);
                console.error("DHIES: MAC verification failed");
                return null;
            }
            // Decrypt the ciphertext
            const plaintext = tweetnacl_1.default.secretbox.open(ciphertext, nonce, encryptionKey);
            if (!plaintext) {
                console.error("DHIES: Decryption failed");
                return null;
            }
            const result = buffer_1.Buffer.from(plaintext);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return result;
        }
        catch (error) {
            console.error("DHIES decryption failed:", error);
            return null;
        }
    }
    /**
     * Key Derivation Function: Derives encryption and MAC keys from the shared secret
     */
    kdf(sharedSecret, ephemeralPublicKey, staticPublicKey) {
        // Create a context for the KDF to ensure different keys for different uses
        const context = buffer_1.Buffer.concat([buffer_1.Buffer.from("DHIES-KDF"), ephemeralPublicKey, staticPublicKey]);
        // Derive encryption key: HKDF-like construction
        const encryptionKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x01]), // Domain separation byte
        ]));
        // Derive MAC key (using a different domain separation byte)
        const macKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x02]), // Domain separation byte
        ]));
        // Use first 32 bytes of each as the actual keys (for NaCl's secretbox)
        return {
            encryptionKey: encryptionKeyMaterial.slice(0, 32),
            macKey: macKeyMaterial.slice(0, 32),
        };
    }
    /**
     * Computes MAC for authenticated encryption
     */
    computeMAC(macKey, data) {
        return (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([macKey, data]));
    }
    /**
     * Constant-time comparison of two buffers to prevent timing attacks
     */
    constantTimeEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        let result = 0;
        for (let i = 0; i < a.length; i++) {
            result |= a[i] ^ b[i];
        }
        return result === 0;
    }
}
exports.DHIES = DHIES;
class KeyManager {
    constructor() {
        this.level = 1;
        this.version = 1;
        this.capability = "private";
        this.authType = "Ed25519VerificationKey2020";
        this.encType = "X25519KeyAgreementKey2019";
    }
    static async create_Id25519_fromEntropy(entropy, swapIndex = 0) {
        const km = new KeyManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        const seed = sha512(entropy);
        // const derivedKey = privateDerivePath(await bip32.Bip32PrivateKey.fromEntropy(seed.slice(0, 32)), `m/1'/0'/${swapIndex}'`);
        km.proofKey = {
            publicKey: buffer_1.Buffer.from([]), //deprecated
            //secretKey: derivedKey.toBytes(),
        };
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", km.proofKey.publicKey);
        // const privateKey = privateDerivePath(derivedKey, "/0'");
        km.signer = {
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(seed.slice(0, 32))),
            secretKey: seed.slice(0, 32),
        };
        const swapIndexBuffer = buffer_1.Buffer.alloc(8);
        swapIndexBuffer.writeBigInt64LE(BigInt(swapIndex), 0);
        const seed2 = sha256(buffer_1.Buffer.concat([seed.slice(32, 64), swapIndexBuffer]));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_Id25519() {
        return KeyManager.create_Id25519_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                p: this.proof,
                x: this.signer.publicKey,
                e: this.cypher.publicKey,
            }));
    }
    async getCypher() {
        // todo fetch secretKey here
        const cypher = this.cypher;
        return {
            hmac: (message) => cypher.secretKey
                ? buffer_1.Buffer.from((0, crypto_2.createHmac)("sha256", buffer_1.Buffer.from(cypher.secretKey).toString("hex"))
                    .update("VaultysID/" + message + "/end")
                    .digest())
                : undefined,
            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),
            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),
            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),
        };
    }
    getSigner() {
        // todo fetch secretKey here
        const secretKey = this.signer.secretKey;
        const sign = (data) => Promise.resolve(buffer_1.Buffer.from(ed25519_1.ed25519.sign(data, secretKey)));
        //console.log(secretKey.toString("hex"), new bip32.PrivateKey(secretKey).toPublicKey().toBytes().toString("hex"), Buffer.from(ed25519.getPublicKey(secretKey)).toString("hex"));
        return Promise.resolve({ sign });
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            x: this.signer.secretKey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.signer = {
            secretKey: data.x.slice(0, 32),
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(data.x.slice(0, 32))),
        };
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new KeyManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        const signer = await this.getSigner();
        return signer.sign(data);
    }
    verify(data, signature, userVerificationIgnored) {
        return ed25519_1.ed25519.verify(signature, data, this.signer.publicKey);
    }
    // async createRevocationCertificate(newId) {
    //   if (this.level == LEVEL_ROOT) {
    //     const seed = sha512(this.entropy);
    //     let node = derivePath(
    //       await Bip32PrivateKey.fromEntropy(seed.slice(0, 32)),
    //       "m/1'/0'/1'",
    //     );
    //     const proof = hash("sha256", node.toBip32PublicKey().toBytes());
    //     if (this.proof.toString("hex") == proof.toString("hex")) {
    //       const revocationCertificate = {
    //         xpub: node.toBytes(),
    //         id: this.id,
    //         newId,
    //       };
    //       revocationCertificate.signature = node.toPrivateKey().sign(revocationCertificate);
    //       return revocationCertificate;
    //     } else return null;
    //   } else return null;
    // }
    // async createSwapingCertificate() {
    //   if (this.level === LEVEL_ROOT && this.entropy) {
    //     const newKey = await KeyManager.create_Id25519_fromEntropy(this.entropy, this.swapIndex + 1);
    //     const hiscp: HISCP = {
    //       newId: newKey.id,
    //       proofKey: this.proofKey.publicKey,
    //       timestamp: Date.now(),
    //       signature: Buffer.from([]),
    //     };
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     hiscp.signature = new bip32.Bip32PrivateKey(this.proofKey.secretKey!).toPrivateKey().sign(hiscpBuffer);
    //     return hiscp;
    //   }
    //   return null;
    // }
    // async verifySwapingCertificate(hiscp: HISCP) {
    //   const proof = hash("sha256", hiscp.proofKey).toString("hex");
    //   if (proof === this.proof.toString("hex")) {
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const newKey = KeyManager.fromId(hiscp.newId);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     const proofVerifier = bip32.Bip32PublicKey.fromBytes(hiscp.proofKey);
    //     return proofVerifier.toPublicKey().verify(hiscpBuffer, hiscp.signature);
    //   } else {
    //     return false;
    //   }
    // }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
        if (this.signer?.secretKey) {
            (0, crypto_1.secureErase)(this.signer.secretKey);
            delete this.signer.secretKey;
        }
        if (this.entropy) {
            (0, crypto_1.secureErase)(this.entropy);
            delete this.entropy;
        }
    }
    /**
     * Performs a Diffie-Hellman key exchange with another KeyManager instance
     * @param otherKeyManager The other party's KeyManager instance
     * @returns A shared secret that can be used for symmetric encryption
     */
    async performDiffieHellman(otherKeyManager) {
        if (this.capability === "public") {
            console.error("Cannot perform DH key exchange with a public key capability");
            return null;
        }
        const cypher = await this.getCypher();
        const otherKey = otherKeyManager.cypher.publicKey;
        // Perform the X25519 scalar multiplication to derive the shared secret
        const sharedSecret = await cypher.diffieHellman(otherKey);
        // Hash the shared secret for better security (to derive a symmetric key)
        const derivedKey = sha256(sharedSecret);
        // Securely erase the shared secret from memory
        (0, crypto_1.secureErase)(sharedSecret);
        return derivedKey;
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two KeyManager instances
     * @param keyManager1 First KeyManager instance
     * @param keyManager2 Second KeyManager instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(keyManager1, keyManager2) {
        return keyManager1.performDiffieHellman(keyManager2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's KeyManager ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        const recipientKM = KeyManager.fromId(recipientId);
        //console.log(recipientKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.encrypt(message, recipientKM.cypher.publicKey);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        const senderKM = KeyManager.fromId(senderId);
        //console.log(senderKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.decrypt(encryptedMessage, senderKM.cypher.publicKey);
    }
    static async encrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        return await (0, saltpack_1.encryptAndArmor)(plaintext, null, publicKeys);
    }
    async signcrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        const cypher = await this.getCypher();
        return await cypher.signcrypt(plaintext, publicKeys);
    }
    async decrypt(encryptedMessage, senderId = null) {
        const cypher = await this.getCypher();
        const senderKey = senderId ? KeyManager.fromId(senderId).cypher.publicKey : null;
        const message = await cypher.decrypt(encryptedMessage, senderKey);
        return message.toString();
    }
    // use better hash to prevent attack
    getSecretHash(data) {
        const toHash = buffer_1.Buffer.concat([data, buffer_1.Buffer.from("secrethash"), this.cypher.secretKey]);
        return (0, crypto_1.hash)("sha256", toHash);
    }
}
exports["default"] = KeyManager;


/***/ }),

/***/ "./dist/node/src/MemoryChannel.js":
/*!****************************************!*\
  !*** ./dist/node/src/MemoryChannel.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryChannel = void 0;
exports.pipeChannels = pipeChannels;
exports.unpipeChannels = unpipeChannels;
exports.StreamChannel = StreamChannel;
exports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;
exports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./cryptoChannel */ "./dist/node/src/cryptoChannel.js"));
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Pipes two channels together, creating a bidirectional flow where
 * messages sent to one channel are automatically forwarded to the other.
 * @param channel1 The first channel to connect
 * @param channel2 The second channel to connect
 * @returns A Promise that resolves when both channels close
 */
function pipeChannels(channel1, channel2) {
    let running = true;
    // Start both piping directions
    const pipe1to2 = async () => {
        try {
            await channel1.start();
            await channel2.start();
            console.log("pipe1to2");
            while (running) {
                try {
                    const data = await channel1.receive();
                    console.log("pipe1to2", data);
                    if (!running || data.length === 0)
                        break;
                    channel2.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe1to2:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe1to2:", error);
        }
    };
    const pipe2to1 = async () => {
        try {
            while (running) {
                console.log("pipe2to1");
                try {
                    const data = await channel2.receive();
                    console.log("pipe2to1", data);
                    if (!running || data.length === 0)
                        break;
                    channel1.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe2to1:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe2to1:", error);
        }
    };
    // Start the pipes
    pipe1to2();
    pipe2to1();
    // Return function to stop piping
    return async () => {
        running = false;
        await Promise.all([channel1.close(), channel2.close()]);
    };
}
/**
 * Utility function that stops an active channel pipe
 * @param channel1 The first channel in the pipe
 * @param channel2 The second channel in the pipe
 */
async function unpipeChannels(channel1, channel2) {
    await Promise.all([channel1.close(), channel2.close()]);
}
function StreamChannel(channel) {
    const onData = async (callback) => {
        let message = await channel.receive();
        while (message) {
            callback(message);
            if (message.toString("utf-8") === "EOF") {
                return;
            }
            message = await channel.receive();
        }
    };
    const getWriteStream = () => {
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                channel.send(chunk);
                done();
            },
        });
        return stream;
    };
    const upload = async (stream) => {
        return new Promise((resolve) => {
            const writeStream = getWriteStream();
            stream.pipe(writeStream).once("finish", () => {
                channel.send(buffer_1.Buffer.from("EOF", "utf-8"));
                writeStream.end();
                resolve();
            });
        });
    };
    const uploadData = async (data) => {
        const stream = stream_1.Readable.from(data);
        await upload(stream);
    };
    const download = async (stream) => {
        const readStream = getReadStream();
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve();
        }));
        readStream.pipe(stream);
        await result;
    };
    const downloadData = async () => {
        const readStream = getReadStream();
        const chunks = [];
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve(buffer_1.Buffer.concat(chunks));
        }));
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                chunks.push(chunk);
                done();
            },
        });
        readStream.pipe(stream);
        return result;
    };
    const getReadStream = () => {
        let push;
        let temp;
        const stream = new stream_1.Stream.Readable({
            read() {
                push = (data) => this.push(data);
            },
        });
        onData((buf) => {
            if (buf.length === 3 && buf.toString("utf-8") === "EOF" && push) {
                temp && push(temp);
                push(null);
                stream.destroy();
            }
            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;
            if (push) {
                !push(temp) && (push = null);
                temp = null;
            }
        });
        return stream;
    };
    return {
        getReadStream,
        getWriteStream,
        upload,
        uploadData,
        download,
        downloadData,
    };
}
function convertWebWritableStreamToNodeWritable(webWritableStream) {
    const writer = webWritableStream.getWriter();
    return new stream_1.Writable({
        async write(chunk, encoding, callback) {
            try {
                // Get a writer from the Web WritableStream
                await writer.write(chunk);
                writer.releaseLock(); // Release the lock on the writer after writing
                callback(); // Signal that the chunk has been processed
            }
            catch (error) {
                callback(); // Signal an error if it occurred
            }
        },
        async final(callback) {
            try {
                // Close the Web WritableStream
                const writer = webWritableStream.getWriter();
                await writer.close();
                writer.releaseLock(); // Release the lock on the writer after closing
                callback(); // Signal that the stream is finished
            }
            catch (error) {
                callback(); // Signal an error if it occurred during close
            }
        },
        async destroy(error, callback) {
            try {
                // Abort the Web WritableStream in case of an error
                const writer = webWritableStream.getWriter();
                await writer.abort(error);
                writer.releaseLock(); // Release the lock on the writer after aborting
                callback(error); // Signal that the stream is destroyed
            }
            catch (abortError) {
                callback(null); // Signal an error if it occurred during abort
            }
        },
    });
}
function convertWebReadableStreamToNodeReadable(webReadableStream) {
    const reader = webReadableStream.getReader();
    return new stream_1.Readable({
        async read() {
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    //console.log(value);
                    if (done) {
                        this.push(null); // Signal the end of the stream
                        break;
                    }
                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer
                }
            }
            catch (error) {
                this.destroy();
            }
        },
    });
}
class MemoryChannel {
    constructor() {
        this.messageQueue = [];
        this.waitingResolvers = [];
        this.connected = false;
        this.connectedCallbacks = [];
        this.closed = false;
    }
    setChannel(chan, name) {
        this.name = name;
        this.otherend = chan;
    }
    static createBidirectionnal() {
        const input = new MemoryChannel();
        const output = new MemoryChannel();
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    onConnected(callback) {
        if (this.connected) {
            callback();
        }
        else {
            this.connectedCallbacks.push(callback);
        }
    }
    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {
        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    getConnectionString() {
        return "vaultys://memory";
    }
    fromConnectionString(string) {
        return string === "vaultys://memory" ? new MemoryChannel() : null;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setInjector(injector) {
        this.injector = injector;
    }
    async start() {
        this.connected = true;
        this.connectedCallbacks.forEach((callback) => callback());
        this.connectedCallbacks = []; // Clear callbacks after calling them
    }
    async send(data) {
        if (this.closed) {
            throw new Error("Cannot send on closed channel");
        }
        if (!this.otherend) {
            throw new Error("No other end connected to this channel");
        }
        // Log the data if a logger is set
        if (this.logger) {
            this.logger(data);
        }
        // Process data through injector if present
        let processedData = data;
        if (this.injector) {
            processedData = await this.injector(data);
        }
        // // Signal that this end is connected
        if (!this.connected) {
            await this.start();
        }
        // Deliver the message to the other end
        this.otherend.deliverMessage(processedData);
    }
    deliverMessage(data) {
        // If there are waiting receivers, deliver directly to the first one
        if (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            resolver(data);
        }
        else {
            // Otherwise queue the message
            this.messageQueue.push(data);
        }
    }
    async receive() {
        if (this.closed) {
            throw new Error("Cannot receive on closed channel");
        }
        //console.log(this);
        // If there are queued messages, return the first one
        if (this.messageQueue.length > 0) {
            return this.messageQueue.shift();
        }
        // Otherwise, wait for a message to arrive
        return new Promise((resolve) => {
            this.waitingResolvers.push(resolve);
        });
    }
    async close() {
        this.closed = true;
        // Clear any waiting receivers with an error
        while (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            // Resolve with empty buffer to indicate channel closed
            resolver(buffer_1.Buffer.alloc(0));
        }
        // Clear the message queue
        this.messageQueue = [];
    }
}
exports.MemoryChannel = MemoryChannel;


/***/ }),

/***/ "./dist/node/src/MemoryStorage.js":
/*!****************************************!*\
  !*** ./dist/node/src/MemoryStorage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const replacer = (key, value) => {
    //if(key=="1686045792046") console.log(value);
    if (!value)
        return value;
    if (key === "certificate")
        return "__C__" + buffer_1.Buffer.from(value).toString("base64");
    if (value.type === "Buffer") {
        return "_bx_" + buffer_1.Buffer.from(value.data).toString("base64");
    }
    if (value.constructor.name === "Array") {
        return "_bx_" + buffer_1.Buffer.from(value).toString("base64");
    }
    return value;
};
const reviver = (key, value) => {
    if (value && key === "certificate") {
        if (typeof value === "string" && value.startsWith("__C__")) {
            return buffer_1.Buffer.from(value.slice(5), "base64");
        }
        else
            return buffer_1.Buffer.from(value);
    }
    if (typeof value === "string" && value.startsWith("_bx_")) {
        return buffer_1.Buffer.from(value.slice(4), "base64");
    }
    return value;
};
const serialize = (data) => JSON.stringify(data, replacer);
exports.serialize = serialize;
const deserialize = (string) => JSON.parse(string, reviver);
exports.deserialize = deserialize;
const MemoryStorage = (save) => {
    let data = {};
    if (!save)
        save = () => (0, exports.serialize)(data);
    return storagify(data, save, () => "");
};
exports.MemoryStorage = MemoryStorage;
const LocalStorage = (key = "vaultysStorage") => {
    let data = {};
    const _id = Math.random();
    //console.log(key);
    if (!localStorage[key])
        localStorage[key] = "{}";
    else
        data = (0, exports.deserialize)(localStorage[key]);
    return storagify(data, () => {
        //console.log("save !!!!!", key, _id);
        localStorage.setItem(key, (0, exports.serialize)(data));
    }, () => localStorage.removeItem(key));
};
exports.LocalStorage = LocalStorage;
const storagify = (object, save, destroy) => {
    return {
        destroy,
        save,
        toString: () => (0, exports.serialize)(object),
        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),
        _raw: object,
        set: (key, value) => (object[key] = value),
        delete: (key) => delete object[key],
        get: (key) => object[key],
        list: () => Object.keys(object).filter((k) => !k.startsWith("!")),
        listSubstores: () => Object.keys(object)
            .filter((k) => k.startsWith("!"))
            .map((k) => k.slice(1)),
        deleteSubstore: (key) => delete object["!" + key],
        renameSubstore: (oldname, newname) => {
            if (oldname === newname || !!object["!" + newname])
                return;
            object["!" + newname] = object["!" + oldname];
            delete object["!" + oldname];
        },
        substore: (key) => {
            if (!object["!" + key])
                object["!" + key] = {};
            return storagify(object["!" + key], save, destroy);
        },
    };
};


/***/ }),

/***/ "./dist/node/src/PQManager.js":
/*!************************************!*\
  !*** ./dist/node/src/PQManager.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const saltpack_1 = __webpack_require__(/*! @vaultys/saltpack */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_2 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
class PQManager extends KeyManager_1.default {
    constructor() {
        super();
        this.authType = "DilithiumVerificationKey2025";
    }
    static async create_PQ_fromEntropy(entropy, swapIndex = 0) {
        const km = new PQManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        km.seed = sha512(entropy);
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from([]));
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_PQ() {
        return PQManager.create_PQ_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    async getCypher() {
        // todo fetch secretKey here
        const cypher = this.cypher;
        return {
            hmac: (message) => cypher.secretKey
                ? buffer_1.Buffer.from((0, crypto_2.createHmac)("sha256", buffer_1.Buffer.from(cypher.secretKey).toString("hex"))
                    .update("VaultysID/" + message + "/end")
                    .digest())
                : undefined,
            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),
            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),
            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),
        };
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            s: this.seed,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.seed = buffer_1.Buffer.from(data.s);
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new PQManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        return (0, pqCrypto_1.signDilithium)(data, this.signer.secretKey);
    }
    verify(data, signature, userVerificationIgnored) {
        return (0, pqCrypto_1.verifyDilithium)(data, signature, this.signer.publicKey);
    }
}
exports["default"] = PQManager;


/***/ }),

/***/ "./dist/node/src/VaultysId.js":
/*!************************************!*\
  !*** ./dist/node/src/VaultysId.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./dist/node/src/Fido2Manager.js"));
const Fido2PRFManager_1 = __importDefault(__webpack_require__(/*! ./Fido2PRFManager */ "./dist/node/src/Fido2PRFManager.js"));
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./dist/node/src/KeyManager.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./dist/node/src/platform/webauthn.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const PQManager_1 = __importDefault(__webpack_require__(/*! ./PQManager */ "./dist/node/src/PQManager.js"));
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./dist/node/src/pqCrypto.js");
const TYPE_MACHINE = 0;
const TYPE_PERSON = 1;
const TYPE_ORGANIZATION = 2;
const TYPE_FIDO2 = 3;
const TYPE_FIDO2PRF = 4;
class VaultysId {
    constructor(keyManager, certificate, type = TYPE_MACHINE) {
        this.encrypt = VaultysId.encrypt;
        this.type = type;
        this.keyManager = keyManager;
        this.certificate = certificate;
    }
    // // Set the index of the proof in case of previous key for this protocol/service have been compromised
    // setProofIndex(protocol, service, index) {
    //   this.proofIndices[`${protocol}-${service}`] = index;
    // }
    // createSwapingCertificate(protocol, service) {
    //   let proofIndex = this.proofIndices[`${protocol}-${service}`]
    //     ? this.proofIndices[`${protocol}-${service}`]
    //     : 0;
    //   const pk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex,
    //   });
    //   const newPk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex: proofIndex + 1,
    //   });
    //   const xPub = this.device.getProofXPub({
    //     protocol,
    //     service,
    //     index,
    //   });
    //   const derivation = PDM.getProofDerivation(protocol, service, index);
    //   const revocationCertificate = `vaultys://p2p/revocation?pk=${pk}&npk=${newPk}&xpub=${xpub}&index=${derivation}`;
    // }
    static fromId(id, certificate, encoding = "hex") {
        let cleanId = id;
        if (id.data) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id.data);
        }
        if (id instanceof Uint8Array) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id);
        }
        if (typeof id === "string") {
            cleanId = buffer_1.Buffer.from(id, encoding);
        }
        const type = cleanId[0];
        if (type === TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else if (type === TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else {
            if (cleanId.length > 1952) {
                const pqm = PQManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(pqm, certificate, type);
            }
            else {
                const km = KeyManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(km, certificate, type);
            }
        }
    }
    static async fromEntropy(entropy, type, pqc = false) {
        const cleanedEntropy = entropy;
        if (pqc) {
            const km = await PQManager_1.default.create_PQ_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
        else {
            const km = await KeyManager_1.default.create_Id25519_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
    }
    static async createWebauthn(passkey = true, onPRFEnabled) {
        const options = VaultysId.createPublicKeyCredentialCreationOptions(passkey);
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation, onPRFEnabled);
    }
    static async createPQC() {
        const options = VaultysId.createPublicKeyCredentialOptionsPQC();
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        //console.log(attestation);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation);
    }
    static async fido2FromAttestation(attestation, onPRFEnabled) {
        // should be somehow valid.
        SoftCredentials_1.default.verifyPackedAttestation(attestation.response, true);
        //console.log(SoftCredentials.verifyPackedAttestation(attestation.response as AuthenticatorAttestationResponse, true));
        if (attestation.getClientExtensionResults().prf?.enabled && (!onPRFEnabled || (await onPRFEnabled()))) {
            const f2m = await Fido2PRFManager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2PRF);
        }
        else {
            const f2m = await Fido2Manager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2);
        }
    }
    static async machineFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_MACHINE);
    }
    static async organizationFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_ORGANIZATION);
    }
    static async personFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_PERSON);
    }
    static fromSecret(secret, encoding = "hex") {
        const secretBuffer = buffer_1.Buffer.from(secret, encoding);
        const type = secretBuffer[0];
        if (type == TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else if (type == TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else {
            //console.log(secretBuffer.length);
            if (secretBuffer.length === 109) {
                const pqm = PQManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(pqm, undefined, type);
            }
            else {
                const km = KeyManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(km, undefined, type);
            }
        }
    }
    static async generatePerson(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
    }
    static async generateOrganization(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
    }
    static async generateMachine(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
    }
    get relationshipCertificate() {
        return this.certificate;
    }
    getSecret(encoding = "hex") {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.getSecret()]).toString(encoding);
    }
    get fingerprint() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return fp
            .slice(0, 40)
            .toUpperCase()
            .match(/.{1,4}/g)
            .join(" ");
    }
    get did() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return `did:vaultys:${fp.slice(0, 40)}`;
    }
    get didDocument() {
        return {
            "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2020/v1"],
            id: this.did,
            authentication: [
                {
                    id: `${this.did}#keys-1`,
                    type: this.keyManager.authType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.signer.publicKey).toString("base64"),
                },
            ],
            keyAgreement: [
                {
                    id: `${this.did}#keys-2`,
                    type: this.keyManager.encType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.cypher.publicKey).toString("base64"),
                },
            ],
        };
    }
    get id() {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.id]);
    }
    toVersion(v) {
        this.keyManager.version = v;
        return this;
    }
    get version() {
        return this.keyManager.version;
    }
    isHardware() {
        return this.type === TYPE_FIDO2 || this.type === TYPE_FIDO2PRF;
    }
    isMachine() {
        return this.type === TYPE_MACHINE;
    }
    isPerson() {
        return this.type === TYPE_PERSON;
    }
    getOTPHmac(timelock = 1 * 3600000) {
        const otp = Math.floor(new Date().getTime() / timelock);
        return this.keyManager.getSecretHash(buffer_1.Buffer.from(`OTP-${otp}`)).toString("hex");
    }
    // Need to think about insecure use of this function
    getOTP(prefix = "password", timelock = 24 * 3600000) {
        if (this.certificate) {
            const otp = Math.floor(new Date().getTime() / timelock);
            const toHash = buffer_1.Buffer.concat([buffer_1.Buffer.from(prefix, "utf-8"), buffer_1.Buffer.from(this.certificate), buffer_1.Buffer.from([otp])]);
            return (0, crypto_1.hash)("SHA256", toHash).toString("hex");
        }
        throw new Error("no certificate, cannot derive OTP");
    }
    async performDiffieHellman(otherVaultysId) {
        return this.keyManager.performDiffieHellman(otherVaultysId.keyManager);
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two VaultysId instances
     * @param vaultysId1 First VaultysId instance
     * @param vaultysId2 Second VaultysId instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(vaultysId1, vaultysId2) {
        return vaultysId1.performDiffieHellman(vaultysId2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's VaultysId ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        let cleanId;
        if (typeof recipientId === "string") {
            cleanId = buffer_1.Buffer.from(recipientId.slice(2), "hex");
        }
        else {
            cleanId = recipientId.slice(1);
        }
        return this.keyManager.dhiesEncrypt(message, cleanId);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message as Buffer or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        let cleanId;
        if (typeof senderId === "string") {
            cleanId = buffer_1.Buffer.from(senderId.slice(2), "hex");
        }
        else {
            cleanId = senderId.slice(1);
        }
        return this.keyManager.dhiesDecrypt(encryptedMessage, cleanId);
    }
    async signChallenge(challenge) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        const signature = await this.keyManager.sign(result);
        if (!signature)
            throw new Error("Could not sign challenge");
        else
            return signature;
    }
    verifyChallenge(challenge, signature, userVerification) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        if (typeof signature == "string") {
            signature = buffer_1.Buffer.from(signature, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        return this.keyManager.verify(result, signature, userVerification);
    }
    async signcrypt(plaintext, recipientIds) {
        return this.keyManager.signcrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    static async encrypt(plaintext, recipientIds) {
        return KeyManager_1.default.encrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    async decrypt(encryptedMessage, senderId) {
        let cleanId;
        if (senderId) {
            if (typeof senderId === "string")
                cleanId = buffer_1.Buffer.from(senderId.slice(2));
            // @ts-ignore
            else
                cleanId = senderId.subarray(1);
        }
        return this.keyManager.decrypt(encryptedMessage, cleanId);
    }
    async hmac(message) {
        const cypher = await this.keyManager.getCypher();
        return cypher.hmac(message);
    }
}
VaultysId.createPublicKeyCredentialOptionsPQC = () => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: "cross-platform",
            residentKey: "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [{ type: "public-key", alg: pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 }],
    };
    return options;
};
VaultysId.createPublicKeyCredentialCreationOptions = (passkey) => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = passkey ? "client-device" : "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: passkey ? "platform" : "cross-platform",
            residentKey: passkey ? "required" : "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7, // SECP256/ECDSA, Ed25519/EdDSA (-8) not supported natively on mobile or yubikey (crying)
            },
            {
                type: "public-key",
                alg: -8, // Ed25519/EdDSA prefered
            },
            {
                type: "public-key",
                alg: -257, // RS256
            },
            // {
            //   "type": "public-key",
            //   "alg": -36
            // },
            // {
            //   "type": "public-key",
            //   "alg": -37
            // },
            // {
            //   "type": "public-key",
            //   "alg": -38
            // },
            // {
            //   "type": "public-key",
            //   "alg": -39
            // },
            // {
            //   "type": "public-key",
            //   "alg": -258
            // },
            // {
            //   "type": "public-key",
            //   "alg": -259
            // }
        ],
    };
    return options;
};
exports["default"] = VaultysId;


/***/ }),

/***/ "./dist/node/src/crypto.js":
/*!*********************************!*\
  !*** ./dist/node/src/crypto.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hash = exports.Buffer = void 0;
const crypto_1 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
Object.defineProperty(exports, "Buffer", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js");
const sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js");
const getAlgorithm = (alg) => {
    const cleanAlg = alg.replaceAll("-", "").toLowerCase();
    if (cleanAlg === "sha256")
        return sha256_1.sha256.create();
    if (cleanAlg === "sha512")
        return sha512_1.sha512.create();
    if (cleanAlg === "sha224")
        return sha256_1.sha224.create();
    return sha256_1.sha256.create();
};
const _randomBytes = (size) => buffer_1.Buffer.from(crypto_1.randomBytes ? (0, crypto_1.randomBytes)(size) : crypto.getRandomValues(new Uint8Array(size)));
exports.randomBytes = _randomBytes;
const hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).update(buffer).digest());
exports.hash = hash;
const secretbox = tweetnacl_1.default.secretbox;
exports.secretbox = secretbox;
const toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("base64");
exports.toBase64 = toBase64;
const toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("hex");
exports.toHex = toHex;
const toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("utf-8");
exports.toUTF8 = toUTF8;
const fromBase64 = (string) => buffer_1.Buffer.from(string, "base64");
exports.fromBase64 = fromBase64;
const fromHex = (string) => buffer_1.Buffer.from(string, "hex");
exports.fromHex = fromHex;
const fromUTF8 = (string) => buffer_1.Buffer.from(string, "utf-8");
exports.fromUTF8 = fromUTF8;
const secureErase = (buffer) => {
    for (let i = 0; i < buffer.length; i++) {
        buffer[i] = 0;
    }
};
exports.secureErase = secureErase;


/***/ }),

/***/ "./dist/node/src/cryptoChannel.js":
/*!****************************************!*\
  !*** ./dist/node/src/cryptoChannel.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);
const encrypt = (buffer, key) => {
    //console.log("encrypting: ", buffer, key)
    const keyUint8Array = key;
    const nonce = newNonce();
    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return buffer_1.Buffer.from(fullMessage);
};
exports.encrypt = encrypt;
const decrypt = (messageWithNonce, key) => {
    //console.log("decrypting: ", messageWithNonce, key)
    const keyUint8Array = key;
    const messageWithNonceAsUint8Array = messageWithNonce;
    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);
    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);
    if (!decrypted) {
        throw new Error("Could not decrypt message");
    }
    return buffer_1.Buffer.from(decrypted);
};
exports.decrypt = decrypt;
// upgrading a channel api with an encrypting layer. The API shoud be
// - send(Buffer):null
// - async receive():Buffer
const encryptChannel = (channel, key) => {
    const sendHandler = {
        apply(target, that, args) {
            return target.call(that, (0, exports.encrypt)(args[0], key));
        },
    };
    const receiveHandler = {
        async apply(target, that, args) {
            const result = await target.call(that);
            return (0, exports.decrypt)(result, key);
        },
    };
    channel.send = new Proxy(channel.send, sendHandler);
    channel.receive = new Proxy(channel.receive, receiveHandler);
    return channel;
};
const generateKey = () => (0, crypto_1.randomBytes)(32);
exports["default"] = {
    decrypt: exports.decrypt,
    encrypt: exports.encrypt,
    encryptChannel,
    generateKey,
};


/***/ }),

/***/ "./dist/node/src/platform/SoftCredentials.js":
/*!***************************************************!*\
  !*** ./dist/node/src/platform/SoftCredentials.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: to revamp and optimize
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_2 = __webpack_require__(/*! ../crypto */ "./dist/node/src/crypto.js");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
const p256_1 = __webpack_require__(/*! @noble/curves/p256 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js");
const p384_1 = __webpack_require__(/*! @noble/curves/p384 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js");
const p521_1 = __webpack_require__(/*! @noble/curves/p521 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js");
const x509_1 = __webpack_require__(/*! @peculiar/x509 */ "./node_modules/.pnpm/@peculiar+x509@1.12.4/node_modules/@peculiar/x509/build/x509.es.js");
const pqCrypto_1 = __webpack_require__(/*! ../pqCrypto */ "./dist/node/src/pqCrypto.js");
const credentials = {};
//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;
const COSEKEYS = {
    kty: 1,
    alg: 3,
    crv: -1,
    x: -2,
    y: -3,
    n: -1,
    e: -2,
};
const COSEKTY = {
    OKP: 1,
    EC2: 2,
    RSA: 3,
    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,
};
const COSERSASCHEME = {
    "-3": "pss-sha256",
    "-39": "pss-sha512",
    "-38": "pss-sha384",
    "-65535": "pkcs1-sha1",
    "-257": "pkcs1-sha256",
    "-258": "pkcs1-sha384",
    "-259": "pkcs1-sha512",
};
const COSECRV = {
    1: p256_1.p256,
    2: p384_1.p384,
    3: p521_1.p521,
};
const COSEALGHASH = {
    "-257": "SHA-256",
    "-258": "SHA-384",
    "-259": "SHA-512",
    "-65535": "SHA-1",
    "-39": "SHA-512",
    "-38": "SHA-384",
    "-37": "SHA-256",
    "-260": "SHA-256",
    "-261": "SHA-512",
    "-7": "SHA-256",
    "-36": "SHA-512",
    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: "SHA-256", // DILITHIUM2 uses SHA-256 for hashing
};
const hash = (alg, message) => (0, crypto_2.hash)(alg.replace("-", ""), message);
const base64ToPem = (b64cert) => {
    let pemcert = "";
    for (let i = 0; i < b64cert.length; i += 64)
        pemcert += b64cert.slice(i, i + 64) + "\n";
    return "-----BEGIN CERTIFICATE-----\n" + pemcert + "-----END CERTIFICATE-----";
};
const getCertificateInfo = (certificate) => {
    const x509 = new x509_1.X509Certificate(certificate);
    const subjectString = x509.subject;
    const issuer = x509.issuer;
    const issuerName = x509.issuerName.toString();
    const subjectParts = subjectString.split(",");
    const subject = {};
    for (const field of subjectParts) {
        const kv = field.split("=");
        subject[kv[0].trim()] = kv[1];
    }
    // console.log(subject);
    const { Version } = x509.toTextObject().Data;
    const bc = x509.getExtension(x509_1.BasicConstraintsExtension);
    const basicConstraintsCA = bc ? bc.ca : false;
    return {
        issuer,
        issuerName,
        subject,
        version: Version,
        basicConstraintsCA,
    };
};
const parseAuthData = (buffer) => {
    const rpIdHash = buffer.slice(0, 32);
    buffer = buffer.slice(32);
    const flagsBuf = buffer.slice(0, 1);
    buffer = buffer.slice(1);
    const flagsInt = flagsBuf[0];
    const flags = {
        up: !!(flagsInt & 0x01),
        uv: !!(flagsInt & 0x04),
        at: !!(flagsInt & 0x40),
        ed: !!(flagsInt & 0x80),
        flagsInt,
    };
    const counterBuf = buffer.slice(0, 4);
    buffer = buffer.slice(4);
    const counter = counterBuf.readUInt32BE(0);
    let aaguid = undefined;
    let credID = undefined;
    let COSEPublicKey = undefined;
    if (flags.at) {
        aaguid = buffer.slice(0, 16);
        buffer = buffer.slice(16);
        const credIDLenBuf = buffer.slice(0, 2);
        buffer = buffer.slice(2);
        const credIDLen = credIDLenBuf.readUInt16BE(0);
        credID = buffer.slice(0, credIDLen);
        buffer = buffer.slice(credIDLen);
        COSEPublicKey = buffer;
    }
    //console.log(aaguid);
    return {
        rpIdHash,
        flagsBuf,
        flags,
        counter,
        counterBuf,
        aaguid,
        credID,
        COSEPublicKey,
    };
};
const verifyPackedAttestation = (response, userVerification = false) => {
    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
    if (attestationStruct.fmt == "none")
        return false;
    const authDataStruct = parseAuthData(attestationStruct.authData);
    // check if user has actually touched the device
    if (!authDataStruct.flags.up)
        return false;
    // check if did enter PIN code
    if (userVerification && !authDataStruct.flags.uv)
        return false;
    const clientDataHashBuf = hash("sha256", buffer_1.Buffer.from(response.clientDataJSON));
    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);
    const signature = attestationStruct.attStmt.sig;
    let signatureIsValid = false;
    /* ----- Verify FULL attestation ----- */
    if (attestationStruct.attStmt.x5c) {
        const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString("base64"));
        const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);
        const subject = certInfo.subject;
        // console.log(certInfo);
        if (subject.OU !== "Authenticator Attestation")
            throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');
        if (!subject.CN)
            throw new Error("Batch certificate CN MUST no be empty!");
        if (!subject.O)
            throw new Error("Batch certificate O MUST no be empty!");
        if (!subject.C || subject.C.length !== 2)
            throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");
        if (certInfo.basicConstraintsCA)
            throw new Error("Batch certificate basic constraints CA MUST be false!");
        if (certInfo.version !== "v3 (2)")
            throw new Error("Batch certificate version MUST be 3(ASN1 2)!");
        signatureIsValid = crypto_1.default.createVerify("sha256").update(dataBuffer).verify(leafCert, signature);
        /* ----- Verify FULL attestation ENDS ----- */
    }
    else if (attestationStruct.attStmt.ecdaaKeyId) {
        throw new Error("ECDAA IS NOT SUPPORTED!");
    }
    else {
        /* ----- Verify SURROGATE attestation ----- */
        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];
        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];
        const data = hash(hashAlg, dataBuffer);
        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {
            // ECDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            const y = pubKeyCose.get(COSEKEYS.y);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);
            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];
            const sig = ec.Signature.fromDER(signature);
            signatureIsValid = ec.verify(sig, data, pubKey);
        }
        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {
            // EdDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);
        }
        else {
            return false;
        }
        /* ----- Verify SURROGATE attestation ENDS ----- */
    }
    if (!signatureIsValid)
        throw new Error("Failed to verify the signature!");
    return true;
};
class MyPublicKeyCredential {
    constructor(creds) {
        this.type = "public-key";
        this.clientExtensionResults = {};
        const keys = ["id", "rawId", "response"];
        this.id = creds.id;
        this.rawId = buffer_1.Buffer.from(creds.rawId);
        this.response = creds.response;
    }
    getClientExtensionResults() {
        return {};
    }
}
const verifyECDSA = (data, publicKey, signature) => {
    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);
};
const verifyEdDSA = (data, publicKey, signature) => {
    return ed25519_1.ed25519.verify(signature, data, publicKey);
};
// Webauthn Partial Implementation for testing
class SoftCredentials {
    constructor() {
        this.signCount = 0;
        this.rawId = (0, crypto_2.randomBytes)(32);
        this.aaguid = buffer_1.Buffer.alloc(16);
    }
    // credentials request payload
    static createRequest(alg, prf = false) {
        const challenge = buffer_1.Buffer.from((0, crypto_2.randomBytes)(32).toString("base64"));
        const result = {
            publicKey: {
                challenge,
                rp: {
                    name: "Vaultys ID",
                    id: "Vaultys ID",
                },
                user: {
                    id: buffer_1.Buffer.from("Vaultys Wallet ID", "utf8"),
                    name: "Vaultys Wallet ID",
                    displayName: "Vaultys Wallet ID",
                },
                pubKeyCredParams: [
                    {
                        type: "public-key",
                        alg,
                    },
                ],
            },
        };
        if (prf) {
            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_2.randomBytes)(32) } } };
        }
        return result;
    }
    static getCertificateInfo(response) {
        const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
        const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
        if (attestationStruct.attStmt.x5c) {
            return getCertificateInfo(attestationStruct.attStmt.x5c[0]);
        }
        else {
            return null;
        }
    }
    static async create(options, origin = "test") {
        const credential = new SoftCredentials();
        const publicKey = options.publicKey;
        credential.options = publicKey;
        credential.rpId = publicKey.rp.id || publicKey.rp.name;
        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), "base64");
        credentials[credential.rawId.toString("base64")] = credential; // erase previous instance
        // Get the algorithm from pubKeyCredParams
        const pubKeyCredParams = publicKey.pubKeyCredParams;
        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)
        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
        // Set algorithm, prioritizing DILITHIUM if it's supported
        if (supportsDilithium) {
            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;
        }
        else {
            credential.alg = publicKey.pubKeyCredParams[0].alg;
        }
        if (credential.alg === -8) {
            const random = ed25519_1.ed25519.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: ed25519_1.ed25519.getPublicKey(random),
                algorithm: "EdDSA",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 1);
            credential.coseKey.set(3, -8);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(0, 32);
            credential.coseKey.set(-2, x);
        }
        else if (credential.alg === -7) {
            const random = p256_1.p256.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: p256_1.p256.getPublicKey(random, false),
                algorithm: "ES256",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 2);
            credential.coseKey.set(3, -7);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(1, 33);
            const y = credential.keyPair.publicKey.slice(33);
            credential.coseKey.set(-2, x);
            credential.coseKey.set(-3, y);
            // console.log(extpk,x,y)
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // Generate DILITHIUM key pair
            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();
            //console.log("PQC", dilithiumPk, dilithiumSk);
            credential.keyPair = {
                privateKey: dilithiumSk,
                publicKey: dilithiumPk,
                algorithm: "DILITHIUM2",
                isDILITHIUM: true,
            };
            // Create COSE key representation
            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);
            //console.log("PQC", credential);
        }
        const clientData = {
            type: "webauthn.create",
            challenge: publicKey.challenge,
            origin,
        };
        const rpIdHash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "ascii"));
        const flags = buffer_1.Buffer.from("41", "hex"); // attested_data + user_present
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);
        rawIdLength.writeUInt16BE(credential.rawId.length, 0);
        const coseKey = cbor_1.default.encode(credential.coseKey);
        const attestationObject = {
            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),
            fmt: "none",
            attStmt: {},
        };
        const pkCredentials = {
            id: credential.rawId.toString("base64"),
            rawId: credential.rawId,
            authenticatorAttachment: null,
            type: "public-key",
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    return { prf: { enabled: true } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                attestationObject: cbor_1.default.encode(attestationObject),
                getTransports: () => ["usb", "hybrid"],
                getAuthenticatorData: () => attestationObject.authData,
                getPublicKey: () => coseKey,
                getPublicKeyAlgorithm: () => -7,
            },
        };
        return pkCredentials;
    }
    static simpleVerify(COSEPublicKey, response, userVerification = false) {
        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;
        const rpIdHash = response.authenticatorData.slice(0, 32);
        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];
        const counter = response.authenticatorData.slice(33, 37);
        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);
        if (!goodflags)
            return false;
        const hash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(response.clientDataJSON));
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);
        if (ckey.get(3) == -7) {
            data = (0, crypto_2.hash)("sha256", data);
        }
        if (ckey.get(1) == 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) == 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(response.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);
        }
        return false;
    }
    static getCOSEPublicKey(attestation) {
        const response = attestation.response;
        const ato = cbor_1.default.decode(response.attestationObject);
        //console.log("getCOSEPublicKey", ato, parseAuthData(ato.authData));
        return parseAuthData(ato.authData).COSEPublicKey;
    }
    static verifyPackedAttestation(attestation, userVerification = false) {
        return verifyPackedAttestation(attestation, userVerification);
    }
    static async verify(attestation, assertion, userVerifiation = false) {
        //if (assertion.id !== attestation.id) return false;
        const hash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(assertion.response.clientDataJSON));
        const ass = assertion.response;
        const att = attestation.response;
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);
        const ato = cbor_1.default.decode(att.attestationObject);
        const authData = parseAuthData(ato.authData);
        // check if user has actually touched the device
        if (!authData.flags.up)
            return false;
        // check if the user has entered his PIN code or used biometric sensor
        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)
            return false;
        const ckey = cbor_1.default.decode(authData.COSEPublicKey);
        // Hash data for ES256
        if (ckey.get(3) == -7) {
            data = (0, crypto_2.hash)("sha256", data);
        }
        // Get key type
        const keyType = ckey.get(1);
        if (keyType === 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(ass.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);
        }
        return false;
    }
    static extractChallenge(clientDataJSON) {
        const clientData = JSON.parse(clientDataJSON.toString());
        const m = clientData.challenge.length % 4;
        return clientData.challenge
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), "=");
    }
    static async get({ publicKey }, origin = "test") {
        if (!publicKey.allowCredentials)
            throw new Error();
        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString("base64");
        const credential = credentials[id];
        credential.signCount += 1;
        // prepare signature
        const clientData = {
            type: "webauthn.get",
            challenge: buffer_1.Buffer.from(publicKey.challenge).toString("base64"),
            origin,
        };
        const clientDataHash = (0, crypto_2.hash)("sha256", (0, crypto_2.fromUTF8)(JSON.stringify(clientData)));
        const rpIdHash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "utf-8"));
        const flags = buffer_1.Buffer.from("05", "hex"); // user verification
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);
        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);
        let signature = new Uint8Array();
        if (credential.alg === -7) {
            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();
        }
        else if (credential.alg === -8) {
            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // DILITHIUM signing - this returns a Promise so we need to await it
            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);
        }
        const pkCredentials = {
            id,
            rawId: buffer_1.Buffer.from(id, "base64").buffer,
            type: "public-key",
            authenticatorAttachment: null,
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    // unsafe and not following w3c recommendation. for testing purpose only
                    return { prf: { results: { first: hash("sha256", publicKey.extensions?.prf?.eval?.first) } } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                authenticatorData,
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                signature: signature,
                userHandle: credential.userHandle,
            },
        };
        return pkCredentials;
    }
}
exports["default"] = SoftCredentials;


/***/ }),

/***/ "./dist/node/src/platform/webauthn.js":
/*!********************************************!*\
  !*** ./dist/node/src/platform/webauthn.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeWebAuthn = exports.BrowserWebAuthn = void 0;
exports.getWebAuthnProvider = getWebAuthnProvider;
exports.createCredentialRequest = createCredentialRequest;
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./SoftCredentials */ "./dist/node/src/platform/SoftCredentials.js"));
// Browser implementation
class BrowserWebAuthn {
    isAvailable() {
        return typeof window !== "undefined" && typeof window.PublicKeyCredential !== "undefined";
    }
    async create(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.create({ publicKey: options }));
    }
    async get(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.get({ publicKey: options }));
    }
}
exports.BrowserWebAuthn = BrowserWebAuthn;
// Node.js implementation using SoftCredentials
class NodeWebAuthn {
    constructor(origin = "test") {
        this.origin = origin;
    }
    isAvailable() {
        return true; // Always available in mock mode
    }
    async create(options) {
        return await SoftCredentials_1.default.create({
            publicKey: options,
        }, this.origin);
    }
    async get(options) {
        return await SoftCredentials_1.default.get({
            publicKey: options,
        }, this.origin);
    }
}
exports.NodeWebAuthn = NodeWebAuthn;
// Factory function
function getWebAuthnProvider(options) {
    if (typeof window !== "undefined") {
        return new BrowserWebAuthn();
    }
    return new NodeWebAuthn(options?.origin);
}
// Helper to create credential request
function createCredentialRequest(alg, prf = false) {
    return SoftCredentials_1.default.createRequest(alg, prf);
}


/***/ }),

/***/ "./dist/node/src/pqCrypto.js":
/*!***********************************!*\
  !*** ./dist/node/src/pqCrypto.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Post-Quantum Cryptography Operations
 *
 * This file contains implementations for post-quantum cryptographic algorithms
 * starting with DILITHIUM for digital signatures.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;
exports.generateDilithiumKeyPair = generateDilithiumKeyPair;
exports.signDilithium = signDilithium;
exports.verifyDilithium = verifyDilithium;
exports.createDilithiumCoseKey = createDilithiumCoseKey;
exports.getDilithiumKeyInfo = getDilithiumKeyInfo;
const ml_dsa_js_1 = __webpack_require__(/*! @noble/post-quantum/ml-dsa.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./dist/node/src/crypto.js");
/**
 * COSE algorithm identifiers for post-quantum algorithms
 * Note: These values are provisional and may need to be updated as standards evolve
 */
exports.PQ_COSE_ALG = {
    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)
    DILITHIUM2: -46, // Level 2 (128-bit security)
    DILITHIUM3: -47, // Level 3 (192-bit security)
    DILITHIUM5: -48, // Level 5 (256-bit security)
};
/**
 * COSE key type for DILITHIUM
 */
exports.PQ_COSE_KEY_TYPE = {
    DILITHIUM: 4, // Custom key type for DILITHIUM
};
/**
 * COSE key parameter identifiers for DILITHIUM
 */
exports.PQ_COSE_KEY_PARAMS = {
    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)
    DILITHIUM_PK: -101, // Public key
    DILITHIUM_SK: -102, // Secret key
};
/**
 * Generate a DILITHIUM Level 2 key pair
 * @returns Promise resolving to an object containing the key pair
 */
function generateDilithiumKeyPair(seed) {
    if (!seed)
        seed = (0, crypto_1.randomBytes)(32);
    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);
    return {
        publicKey: buffer_1.Buffer.from(keyPair.publicKey),
        secretKey: buffer_1.Buffer.from(keyPair.secretKey),
    };
}
/**
 * Sign a message using DILITHIUM Level 2
 * @param message - The message to sign
 * @param privateKey - The DILITHIUM private key
 * @returns Promise resolving to signature as Uint8Array
 */
function signDilithium(message, secretKey) {
    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));
}
/**
 * Verify a DILITHIUM Level 2 signature
 * @param message - The original message
 * @param signature - The signature to verify
 * @param publicKey - The DILITHIUM public key
 * @returns Promise resolving to boolean indicating if signature is valid
 */
function verifyDilithium(message, signature, publicKey) {
    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);
}
/**
 * Create a COSE key representation for a DILITHIUM public key
 * @param publicKey - The DILITHIUM public key
 * @returns Map representing the COSE key
 */
function createDilithiumCoseKey(publicKey) {
    const coseKey = new Map();
    // Standard COSE key parameters
    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type
    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm
    // DILITHIUM-specific parameters
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);
    return coseKey;
}
/**
 * Get key size information for DILITHIUM
 * @returns Object with key size information
 */
function getDilithiumKeyInfo() {
    return {
        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key
        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key
        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)
/* harmony export */ });
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");

const DEFAULT_MAX_KEY_LENGTH = 16;
const DEFAULT_MAX_LENGTH_PER_KEY = 16;
class CachedKeyDecoder {
    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.hit = 0;
        this.miss = 0;
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        // avoid `new Array(N)`, which makes a sparse array,
        // because a sparse array is typically slower than a non-sparse array.
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
            this.caches.push([]);
        }
    }
    canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
    }
    find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK: for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
                if (recordBytes[j] !== bytes[inputOffset + j]) {
                    continue FIND_CHUNK;
                }
            }
            return record.str;
        }
        return null;
    }
    store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
            // `records` are full!
            // Set `record` to an arbitrary position.
            records[(Math.random() * records.length) | 0] = record;
        }
        else {
            records.push(record);
        }
    }
    decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
            this.hit++;
            return cachedValue;
        }
        this.miss++;
        const str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);
        // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
    }
}
//# sourceMappingURL=CachedKeyDecoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodeError: () => (/* binding */ DecodeError)
/* harmony export */ });
class DecodeError extends Error {
    constructor(message) {
        super(message);
        // fix the prototype chain in a cross-platform way
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError.name,
        });
    }
}
//# sourceMappingURL=DecodeError.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Decoder: () => (/* binding */ Decoder)
/* harmony export */ });
/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");
/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs");
/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs");
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");







const STATE_ARRAY = "array";
const STATE_MAP_KEY = "map_key";
const STATE_MAP_VALUE = "map_value";
const mapKeyConverter = (key) => {
    if (typeof key === "string" || typeof key === "number") {
        return key;
    }
    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError("The type of key must be string or number but " + typeof key);
};
class StackPool {
    constructor() {
        this.stack = [];
        this.stackHeadPosition = -1;
    }
    get length() {
        return this.stackHeadPosition + 1;
    }
    top() {
        return this.stack[this.stackHeadPosition];
    }
    pushArrayState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_ARRAY;
        state.position = 0;
        state.size = size;
        state.array = new Array(size);
    }
    pushMapState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_MAP_KEY;
        state.readCount = 0;
        state.size = size;
        state.map = {};
    }
    getUninitializedStateFromPool() {
        this.stackHeadPosition++;
        if (this.stackHeadPosition === this.stack.length) {
            const partialState = {
                type: undefined,
                size: 0,
                array: undefined,
                position: 0,
                readCount: 0,
                map: undefined,
                key: null,
            };
            this.stack.push(partialState);
        }
        return this.stack[this.stackHeadPosition];
    }
    release(state) {
        const topStackState = this.stack[this.stackHeadPosition];
        if (topStackState !== state) {
            throw new Error("Invalid stack state. Released state is not on top of the stack.");
        }
        if (state.type === STATE_ARRAY) {
            const partialState = state;
            partialState.size = 0;
            partialState.array = undefined;
            partialState.position = 0;
            partialState.type = undefined;
        }
        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
            const partialState = state;
            partialState.size = 0;
            partialState.map = undefined;
            partialState.readCount = 0;
            partialState.type = undefined;
        }
        this.stackHeadPosition--;
    }
    reset() {
        this.stack.length = 0;
        this.stackHeadPosition = -1;
    }
}
const HEAD_BYTE_REQUIRED = -1;
const EMPTY_VIEW = new DataView(new ArrayBuffer(0));
const EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
    // IE11: The spec says it should throw RangeError,
    // IE11: but in IE11 it throws TypeError.
    EMPTY_VIEW.getInt8(0);
}
catch (e) {
    if (!(e instanceof RangeError)) {
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
    }
}
const MORE_DATA = new RangeError("Insufficient data");
const sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__.CachedKeyDecoder();
class Decoder {
    constructor(options) {
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = new StackPool();
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionCodec.defaultCodec;
        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.rawStrings = options?.rawStrings ?? false;
        this.maxStrLength = options?.maxStrLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxBinLength = options?.maxBinLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxArrayLength = options?.maxArrayLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxMapLength = options?.maxMapLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.maxExtLength = options?.maxExtLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;
        this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;
        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;
    }
    clone() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new Decoder({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder,
        });
    }
    reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.reset();
        // view, bytes, and pos will be re-initialized in setBuffer()
    }
    setBuffer(buffer) {
        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);
        this.bytes = bytes;
        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        this.pos = 0;
    }
    appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
            this.setBuffer(buffer);
        }
        else {
            const remainingData = this.bytes.subarray(this.pos);
            const newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);
            // concat remainingData + newData
            const newBuffer = new Uint8Array(remainingData.length + newData.length);
            newBuffer.set(remainingData);
            newBuffer.set(newData, remainingData.length);
            this.setBuffer(newBuffer);
        }
    }
    hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
    }
    createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
    }
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */
    decode(buffer) {
        if (this.entered) {
            const instance = this.clone();
            return instance.decode(buffer);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.setBuffer(buffer);
            const object = this.doDecodeSync();
            if (this.hasRemaining(1)) {
                throw this.createExtraByteError(this.pos);
            }
            return object;
        }
        finally {
            this.entered = false;
        }
    }
    *decodeMulti(buffer) {
        if (this.entered) {
            const instance = this.clone();
            yield* instance.decodeMulti(buffer);
            return;
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.setBuffer(buffer);
            while (this.hasRemaining(1)) {
                yield this.doDecodeSync();
            }
        }
        finally {
            this.entered = false;
        }
    }
    async decodeAsync(stream) {
        if (this.entered) {
            const instance = this.clone();
            return instance.decodeAsync(stream);
        }
        try {
            this.entered = true;
            let decoded = false;
            let object;
            for await (const buffer of stream) {
                if (decoded) {
                    this.entered = false;
                    throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                try {
                    object = this.doDecodeSync();
                    decoded = true;
                }
                catch (e) {
                    if (!(e instanceof RangeError)) {
                        throw e; // rethrow
                    }
                    // fallthrough
                }
                this.totalPos += this.pos;
            }
            if (decoded) {
                if (this.hasRemaining(1)) {
                    throw this.createExtraByteError(this.totalPos);
                }
                return object;
            }
            const { headByte, pos, totalPos } = this;
            throw new RangeError(`Insufficient data in parsing ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
        }
        finally {
            this.entered = false;
        }
    }
    decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
    }
    decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
    }
    async *decodeMultiAsync(stream, isArray) {
        if (this.entered) {
            const instance = this.clone();
            yield* instance.decodeMultiAsync(stream, isArray);
            return;
        }
        try {
            this.entered = true;
            let isArrayHeaderRequired = isArray;
            let arrayItemsLeft = -1;
            for await (const buffer of stream) {
                if (isArray && arrayItemsLeft === 0) {
                    throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                if (isArrayHeaderRequired) {
                    arrayItemsLeft = this.readArraySize();
                    isArrayHeaderRequired = false;
                    this.complete();
                }
                try {
                    while (true) {
                        yield this.doDecodeSync();
                        if (--arrayItemsLeft === 0) {
                            break;
                        }
                    }
                }
                catch (e) {
                    if (!(e instanceof RangeError)) {
                        throw e; // rethrow
                    }
                    // fallthrough
                }
                this.totalPos += this.pos;
            }
        }
        finally {
            this.entered = false;
        }
    }
    doDecodeSync() {
        DECODE: while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 0xe0) {
                // negative fixint (111x xxxx) 0xe0 - 0xff
                object = headByte - 0x100;
            }
            else if (headByte < 0xc0) {
                if (headByte < 0x80) {
                    // positive fixint (0xxx xxxx) 0x00 - 0x7f
                    object = headByte;
                }
                else if (headByte < 0x90) {
                    // fixmap (1000 xxxx) 0x80 - 0x8f
                    const size = headByte - 0x80;
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = {};
                    }
                }
                else if (headByte < 0xa0) {
                    // fixarray (1001 xxxx) 0x90 - 0x9f
                    const size = headByte - 0x90;
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = [];
                    }
                }
                else {
                    // fixstr (101x xxxx) 0xa0 - 0xbf
                    const byteLength = headByte - 0xa0;
                    object = this.decodeString(byteLength, 0);
                }
            }
            else if (headByte === 0xc0) {
                // nil
                object = null;
            }
            else if (headByte === 0xc2) {
                // false
                object = false;
            }
            else if (headByte === 0xc3) {
                // true
                object = true;
            }
            else if (headByte === 0xca) {
                // float 32
                object = this.readF32();
            }
            else if (headByte === 0xcb) {
                // float 64
                object = this.readF64();
            }
            else if (headByte === 0xcc) {
                // uint 8
                object = this.readU8();
            }
            else if (headByte === 0xcd) {
                // uint 16
                object = this.readU16();
            }
            else if (headByte === 0xce) {
                // uint 32
                object = this.readU32();
            }
            else if (headByte === 0xcf) {
                // uint 64
                if (this.useBigInt64) {
                    object = this.readU64AsBigInt();
                }
                else {
                    object = this.readU64();
                }
            }
            else if (headByte === 0xd0) {
                // int 8
                object = this.readI8();
            }
            else if (headByte === 0xd1) {
                // int 16
                object = this.readI16();
            }
            else if (headByte === 0xd2) {
                // int 32
                object = this.readI32();
            }
            else if (headByte === 0xd3) {
                // int 64
                if (this.useBigInt64) {
                    object = this.readI64AsBigInt();
                }
                else {
                    object = this.readI64();
                }
            }
            else if (headByte === 0xd9) {
                // str 8
                const byteLength = this.lookU8();
                object = this.decodeString(byteLength, 1);
            }
            else if (headByte === 0xda) {
                // str 16
                const byteLength = this.lookU16();
                object = this.decodeString(byteLength, 2);
            }
            else if (headByte === 0xdb) {
                // str 32
                const byteLength = this.lookU32();
                object = this.decodeString(byteLength, 4);
            }
            else if (headByte === 0xdc) {
                // array 16
                const size = this.readU16();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xdd) {
                // array 32
                const size = this.readU32();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xde) {
                // map 16
                const size = this.readU16();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xdf) {
                // map 32
                const size = this.readU32();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xc4) {
                // bin 8
                const size = this.lookU8();
                object = this.decodeBinary(size, 1);
            }
            else if (headByte === 0xc5) {
                // bin 16
                const size = this.lookU16();
                object = this.decodeBinary(size, 2);
            }
            else if (headByte === 0xc6) {
                // bin 32
                const size = this.lookU32();
                object = this.decodeBinary(size, 4);
            }
            else if (headByte === 0xd4) {
                // fixext 1
                object = this.decodeExtension(1, 0);
            }
            else if (headByte === 0xd5) {
                // fixext 2
                object = this.decodeExtension(2, 0);
            }
            else if (headByte === 0xd6) {
                // fixext 4
                object = this.decodeExtension(4, 0);
            }
            else if (headByte === 0xd7) {
                // fixext 8
                object = this.decodeExtension(8, 0);
            }
            else if (headByte === 0xd8) {
                // fixext 16
                object = this.decodeExtension(16, 0);
            }
            else if (headByte === 0xc7) {
                // ext 8
                const size = this.lookU8();
                object = this.decodeExtension(size, 1);
            }
            else if (headByte === 0xc8) {
                // ext 16
                const size = this.lookU16();
                object = this.decodeExtension(size, 2);
            }
            else if (headByte === 0xc9) {
                // ext 32
                const size = this.lookU32();
                object = this.decodeExtension(size, 4);
            }
            else {
                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
                // arrays and maps
                const state = stack.top();
                if (state.type === STATE_ARRAY) {
                    state.array[state.position] = object;
                    state.position++;
                    if (state.position === state.size) {
                        object = state.array;
                        stack.release(state);
                    }
                    else {
                        continue DECODE;
                    }
                }
                else if (state.type === STATE_MAP_KEY) {
                    if (object === "__proto__") {
                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError("The key __proto__ is not allowed");
                    }
                    state.key = this.mapKeyConverter(object);
                    state.type = STATE_MAP_VALUE;
                    continue DECODE;
                }
                else {
                    // it must be `state.type === State.MAP_VALUE` here
                    state.map[state.key] = object;
                    state.readCount++;
                    if (state.readCount === state.size) {
                        object = state.map;
                        stack.release(state);
                    }
                    else {
                        state.key = null;
                        state.type = STATE_MAP_KEY;
                        continue DECODE;
                    }
                }
            }
            return object;
        }
    }
    readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = this.readU8();
            // console.log("headByte", prettyByte(this.headByte));
        }
        return this.headByte;
    }
    complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
    }
    readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
            case 0xdc:
                return this.readU16();
            case 0xdd:
                return this.readU32();
            default: {
                if (headByte < 0xa0) {
                    return headByte - 0x90;
                }
                else {
                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized array type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);
                }
            }
        }
    }
    pushMapState(size) {
        if (size > this.maxMapLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.pushMapState(size);
    }
    pushArrayState(size) {
        if (size > this.maxArrayLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.pushArrayState(size);
    }
    decodeString(byteLength, headerOffset) {
        if (!this.rawStrings || this.stateIsMapKey()) {
            return this.decodeUtf8String(byteLength, headerOffset);
        }
        return this.decodeBinary(byteLength, headerOffset);
    }
    /**
     * @throws {@link RangeError}
     */
    decodeUtf8String(byteLength, headerOffset) {
        if (byteLength > this.maxStrLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
            throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {
            object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        }
        else {
            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
    }
    stateIsMapKey() {
        if (this.stack.length > 0) {
            const state = this.stack.top();
            return state.type === STATE_MAP_KEY;
        }
        return false;
    }
    /**
     * @throws {@link RangeError}
     */
    decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
            throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
    }
    decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(size, headOffset + 1 /* extType */);
        return this.extensionCodec.decode(data, extType, this.context);
    }
    lookU8() {
        return this.view.getUint8(this.pos);
    }
    lookU16() {
        return this.view.getUint16(this.pos);
    }
    lookU32() {
        return this.view.getUint32(this.pos);
    }
    readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
    }
    readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
    }
    readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
    }
    readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
    }
    readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
    }
    readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
    }
    readU64() {
        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
    }
    readI64() {
        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
    }
    readU64AsBigInt() {
        const value = this.view.getBigUint64(this.pos);
        this.pos += 8;
        return value;
    }
    readI64AsBigInt() {
        const value = this.view.getBigInt64(this.pos);
        this.pos += 8;
        return value;
    }
    readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
    }
    readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
    }
}
//# sourceMappingURL=Decoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),
/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),
/* harmony export */   Encoder: () => (/* binding */ Encoder)
/* harmony export */ });
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs");




const DEFAULT_MAX_DEPTH = 100;
const DEFAULT_INITIAL_BUFFER_SIZE = 2048;
class Encoder {
    constructor(options) {
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;
        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;
        this.sortKeys = options?.sortKeys ?? false;
        this.forceFloat32 = options?.forceFloat32 ?? false;
        this.ignoreUndefined = options?.ignoreUndefined ?? false;
        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
    }
    clone() {
        // Because of slightly special argument `context`,
        // type assertion is needed.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new Encoder({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat,
        });
    }
    reinitializeState() {
        this.pos = 0;
    }
    /**
     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
     *
     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
     */
    encodeSharedRef(object) {
        if (this.entered) {
            const instance = this.clone();
            return instance.encodeSharedRef(object);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.doEncode(object, 1);
            return this.bytes.subarray(0, this.pos);
        }
        finally {
            this.entered = false;
        }
    }
    /**
     * @returns Encodes the object and returns a copy of the encoder's internal buffer.
     */
    encode(object) {
        if (this.entered) {
            const instance = this.clone();
            return instance.encode(object);
        }
        try {
            this.entered = true;
            this.reinitializeState();
            this.doEncode(object, 1);
            return this.bytes.slice(0, this.pos);
        }
        finally {
            this.entered = false;
        }
    }
    doEncode(object, depth) {
        if (depth > this.maxDepth) {
            throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
            this.encodeNil();
        }
        else if (typeof object === "boolean") {
            this.encodeBoolean(object);
        }
        else if (typeof object === "number") {
            if (!this.forceIntegerToFloat) {
                this.encodeNumber(object);
            }
            else {
                this.encodeNumberAsFloat(object);
            }
        }
        else if (typeof object === "string") {
            this.encodeString(object);
        }
        else if (this.useBigInt64 && typeof object === "bigint") {
            this.encodeBigInt64(object);
        }
        else {
            this.encodeObject(object, depth);
        }
    }
    ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
        }
    }
    resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
    }
    encodeNil() {
        this.writeU8(0xc0);
    }
    encodeBoolean(object) {
        if (object === false) {
            this.writeU8(0xc2);
        }
        else {
            this.writeU8(0xc3);
        }
    }
    encodeNumber(object) {
        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
            if (object >= 0) {
                if (object < 0x80) {
                    // positive fixint
                    this.writeU8(object);
                }
                else if (object < 0x100) {
                    // uint 8
                    this.writeU8(0xcc);
                    this.writeU8(object);
                }
                else if (object < 0x10000) {
                    // uint 16
                    this.writeU8(0xcd);
                    this.writeU16(object);
                }
                else if (object < 0x100000000) {
                    // uint 32
                    this.writeU8(0xce);
                    this.writeU32(object);
                }
                else if (!this.useBigInt64) {
                    // uint 64
                    this.writeU8(0xcf);
                    this.writeU64(object);
                }
                else {
                    this.encodeNumberAsFloat(object);
                }
            }
            else {
                if (object >= -0x20) {
                    // negative fixint
                    this.writeU8(0xe0 | (object + 0x20));
                }
                else if (object >= -0x80) {
                    // int 8
                    this.writeU8(0xd0);
                    this.writeI8(object);
                }
                else if (object >= -0x8000) {
                    // int 16
                    this.writeU8(0xd1);
                    this.writeI16(object);
                }
                else if (object >= -0x80000000) {
                    // int 32
                    this.writeU8(0xd2);
                    this.writeI32(object);
                }
                else if (!this.useBigInt64) {
                    // int 64
                    this.writeU8(0xd3);
                    this.writeI64(object);
                }
                else {
                    this.encodeNumberAsFloat(object);
                }
            }
        }
        else {
            this.encodeNumberAsFloat(object);
        }
    }
    encodeNumberAsFloat(object) {
        if (this.forceFloat32) {
            // float 32
            this.writeU8(0xca);
            this.writeF32(object);
        }
        else {
            // float 64
            this.writeU8(0xcb);
            this.writeF64(object);
        }
    }
    encodeBigInt64(object) {
        if (object >= BigInt(0)) {
            // uint 64
            this.writeU8(0xcf);
            this.writeBigUint64(object);
        }
        else {
            // int 64
            this.writeU8(0xd3);
            this.writeBigInt64(object);
        }
    }
    writeStringHeader(byteLength) {
        if (byteLength < 32) {
            // fixstr
            this.writeU8(0xa0 + byteLength);
        }
        else if (byteLength < 0x100) {
            // str 8
            this.writeU8(0xd9);
            this.writeU8(byteLength);
        }
        else if (byteLength < 0x10000) {
            // str 16
            this.writeU8(0xda);
            this.writeU16(byteLength);
        }
        else if (byteLength < 0x100000000) {
            // str 32
            this.writeU8(0xdb);
            this.writeU32(byteLength);
        }
        else {
            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
    }
    encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);
        this.pos += byteLength;
    }
    encodeObject(object, depth) {
        // try to encode objects with custom codec first of non-primitives
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
            this.encodeExtension(ext);
        }
        else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
        }
        else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
        }
        else if (typeof object === "object") {
            this.encodeMap(object, depth);
        }
        else {
            // symbol, function and other special object come here unless extensionCodec handles them.
            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
    }
    encodeBinary(object) {
        const size = object.byteLength;
        if (size < 0x100) {
            // bin 8
            this.writeU8(0xc4);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // bin 16
            this.writeU8(0xc5);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // bin 32
            this.writeU8(0xc6);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);
        this.writeU8a(bytes);
    }
    encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
            // fixarray
            this.writeU8(0x90 + size);
        }
        else if (size < 0x10000) {
            // array 16
            this.writeU8(0xdc);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // array 32
            this.writeU8(0xdd);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
            this.doEncode(item, depth + 1);
        }
    }
    countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
            if (object[key] !== undefined) {
                count++;
            }
        }
        return count;
    }
    encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
            keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
            // fixmap
            this.writeU8(0x80 + size);
        }
        else if (size < 0x10000) {
            // map 16
            this.writeU8(0xde);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // map 32
            this.writeU8(0xdf);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
            const value = object[key];
            if (!(this.ignoreUndefined && value === undefined)) {
                this.encodeString(key);
                this.doEncode(value, depth + 1);
            }
        }
    }
    encodeExtension(ext) {
        if (typeof ext.data === "function") {
            const data = ext.data(this.pos + 6);
            const size = data.length;
            if (size >= 0x100000000) {
                throw new Error(`Too large extension object: ${size}`);
            }
            this.writeU8(0xc9);
            this.writeU32(size);
            this.writeI8(ext.type);
            this.writeU8a(data);
            return;
        }
        const size = ext.data.length;
        if (size === 1) {
            // fixext 1
            this.writeU8(0xd4);
        }
        else if (size === 2) {
            // fixext 2
            this.writeU8(0xd5);
        }
        else if (size === 4) {
            // fixext 4
            this.writeU8(0xd6);
        }
        else if (size === 8) {
            // fixext 8
            this.writeU8(0xd7);
        }
        else if (size === 16) {
            // fixext 16
            this.writeU8(0xd8);
        }
        else if (size < 0x100) {
            // ext 8
            this.writeU8(0xc7);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // ext 16
            this.writeU8(0xc8);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // ext 32
            this.writeU8(0xc9);
            this.writeU32(size);
        }
        else {
            throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
    }
    writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
    }
    writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
    }
    writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
    }
    writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
    }
    writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
    }
    writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
    }
    writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
    }
    writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
    }
    writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
    }
    writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);
        this.pos += 8;
    }
    writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);
        this.pos += 8;
    }
    writeBigUint64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigUint64(this.pos, value);
        this.pos += 8;
    }
    writeBigInt64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
    }
}
//# sourceMappingURL=Encoder.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtData: () => (/* binding */ ExtData)
/* harmony export */ });
/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */
class ExtData {
    constructor(type, data) {
        this.type = type;
        this.data = data;
    }
}
//# sourceMappingURL=ExtData.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)
/* harmony export */ });
/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs");
/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs");
// ExtensionCodec to handle MessagePack extensions


class ExtensionCodec {
    constructor() {
        // built-in extensions
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        // custom extensions
        this.encoders = [];
        this.decoders = [];
        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);
    }
    register({ type, encode, decode, }) {
        if (type >= 0) {
            // custom extensions
            this.encoders[type] = encode;
            this.decoders[type] = decode;
        }
        else {
            // built-in extensions
            const index = -1 - type;
            this.builtInEncoders[index] = encode;
            this.builtInDecoders[index] = decode;
        }
    }
    tryToEncode(object, context) {
        // built-in extensions
        for (let i = 0; i < this.builtInEncoders.length; i++) {
            const encodeExt = this.builtInEncoders[i];
            if (encodeExt != null) {
                const data = encodeExt(object, context);
                if (data != null) {
                    const type = -1 - i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        // custom extensions
        for (let i = 0; i < this.encoders.length; i++) {
            const encodeExt = this.encoders[i];
            if (encodeExt != null) {
                const data = encodeExt(object, context);
                if (data != null) {
                    const type = i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {
            // to keep ExtData as is
            return object;
        }
        return null;
    }
    decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
            return decodeExt(data, type, context);
        }
        else {
            // decode() does not fail, returns ExtData instead.
            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
        }
    }
}
ExtensionCodec.defaultCodec = new ExtensionCodec();
//# sourceMappingURL=ExtensionCodec.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeMulti: () => (/* binding */ decodeMulti)
/* harmony export */ });
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");

/**
 * It decodes a single MessagePack object in a buffer.
 *
 * This is a synchronous decoding function.
 * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.
 *
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decode(buffer, options) {
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);
    return decoder.decode(buffer);
}
/**
 * It decodes multiple MessagePack objects in a buffer.
 * This is corresponding to {@link decodeMultiStream}.
 *
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeMulti(buffer, options) {
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);
    return decoder.decodeMulti(buffer);
}
//# sourceMappingURL=decode.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeArrayStream: () => (/* binding */ decodeArrayStream),
/* harmony export */   decodeAsync: () => (/* binding */ decodeAsync),
/* harmony export */   decodeMultiStream: () => (/* binding */ decodeMultiStream)
/* harmony export */ });
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");
/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/stream.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs");


/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
async function decodeAsync(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeAsync(stream);
}
/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeArrayStream(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeArrayStream(stream);
}
/**
 * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.
 * @throws {@link DecodeError} if the buffer contains invalid data.
 */
function decodeMultiStream(streamLike, options) {
    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAsyncIterable)(streamLike);
    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_1__.Decoder(options);
    return decoder.decodeStream(stream);
}
//# sourceMappingURL=decodeAsync.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs");

/**
 * It encodes `value` in the MessagePack format and
 * returns a byte buffer.
 *
 * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.
 */
function encode(value, options) {
    const encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);
    return encoder.encodeSharedRef(value);
}
//# sourceMappingURL=encode.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodeError: () => (/* reexport safe */ _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__.DecodeError),
/* harmony export */   Decoder: () => (/* reexport safe */ _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__.Decoder),
/* harmony export */   EXT_TIMESTAMP: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.EXT_TIMESTAMP),
/* harmony export */   Encoder: () => (/* reexport safe */ _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__.Encoder),
/* harmony export */   ExtData: () => (/* reexport safe */ _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtData),
/* harmony export */   ExtensionCodec: () => (/* reexport safe */ _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionCodec),
/* harmony export */   decode: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decode),
/* harmony export */   decodeArrayStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeArrayStream),
/* harmony export */   decodeAsync: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeAsync),
/* harmony export */   decodeMulti: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeMulti),
/* harmony export */   decodeMultiStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeMultiStream),
/* harmony export */   decodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampExtension),
/* harmony export */   decodeTimestampToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampToTimeSpec),
/* harmony export */   encode: () => (/* reexport safe */ _encode_mjs__WEBPACK_IMPORTED_MODULE_0__.encode),
/* harmony export */   encodeDateToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeDateToTimeSpec),
/* harmony export */   encodeTimeSpecToTimestamp: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimeSpecToTimestamp),
/* harmony export */   encodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimestampExtension)
/* harmony export */ });
/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs");
/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs");
/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decodeAsync.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs");
/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Decoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs");
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");
/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Encoder.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs");
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs");
/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ExtData.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs");
/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./timestamp.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs");
// Main Functions:












// Utilities for Extension Types:






//# sourceMappingURL=index.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),
/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),
/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),
/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),
/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),
/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),
/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)
/* harmony export */ });
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs");
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs");
// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type


const EXT_TIMESTAMP = -1;
const TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int
const TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int
function encodeTimeSpecToTimestamp({ sec, nsec }) {
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        // Here sec >= 0 && nsec >= 0
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
            // timestamp 32 = { sec32 (unsigned) }
            const rv = new Uint8Array(4);
            const view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
        }
        else {
            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
            const secHigh = sec / 0x100000000;
            const secLow = sec & 0xffffffff;
            const rv = new Uint8Array(8);
            const view = new DataView(rv.buffer);
            // nsec30 | secHigh2
            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));
            // secLow32
            view.setUint32(4, secLow);
            return rv;
        }
    }
    else {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);
        return rv;
    }
}
function encodeDateToTimeSpec(date) {
    const msec = date.getTime();
    const sec = Math.floor(msec / 1e3);
    const nsec = (msec - sec * 1e3) * 1e6;
    // Normalizes { sec, nsec } to ensure nsec is unsigned.
    const nsecInSec = Math.floor(nsec / 1e9);
    return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9,
    };
}
function encodeTimestampExtension(object) {
    if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
    }
    else {
        return null;
    }
}
function decodeTimestampToTimeSpec(data) {
    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // data may be 32, 64, or 96 bits
    switch (data.byteLength) {
        case 4: {
            // timestamp 32 = { sec32 }
            const sec = view.getUint32(0);
            const nsec = 0;
            return { sec, nsec };
        }
        case 8: {
            // timestamp 64 = { nsec30, sec34 }
            const nsec30AndSecHigh2 = view.getUint32(0);
            const secLow32 = view.getUint32(4);
            const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
            const nsec = nsec30AndSecHigh2 >>> 2;
            return { sec, nsec };
        }
        case 12: {
            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
            const sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);
            const nsec = view.getUint32(0);
            return { sec, nsec };
        }
        default:
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
    }
}
function decodeTimestampExtension(data) {
    const timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
const timestampExtension = {
    type: EXT_TIMESTAMP,
    encode: encodeTimestampExtension,
    decode: decodeTimestampExtension,
};
//# sourceMappingURL=timestamp.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),
/* harmony export */   getInt64: () => (/* binding */ getInt64),
/* harmony export */   getUint64: () => (/* binding */ getUint64),
/* harmony export */   setInt64: () => (/* binding */ setInt64),
/* harmony export */   setUint64: () => (/* binding */ setUint64)
/* harmony export */ });
// Integer Utility
const UINT32_MAX = 4294967295;
// DataView extension to handle int64 / uint64,
// where the actual range is 53-bits integer (a.k.a. safe integer)
function setUint64(view, offset, value) {
    const high = value / 4294967296;
    const low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
    const high = Math.floor(value / 4294967296);
    const low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
    const high = view.getInt32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
function getUint64(view, offset) {
    const high = view.getUint32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
//# sourceMappingURL=int.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prettyByte: () => (/* binding */ prettyByte)
/* harmony export */ });
function prettyByte(byte) {
    return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}
//# sourceMappingURL=prettyByte.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncIterableFromStream: () => (/* binding */ asyncIterableFromStream),
/* harmony export */   ensureAsyncIterable: () => (/* binding */ ensureAsyncIterable),
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)
/* harmony export */ });
// utility for whatwg streams
function isAsyncIterable(object) {
    return object[Symbol.asyncIterator] != null;
}
async function* asyncIterableFromStream(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                return;
            }
            yield value;
        }
    }
    finally {
        reader.releaseLock();
    }
}
function ensureAsyncIterable(streamLike) {
    if (isAsyncIterable(streamLike)) {
        return streamLike;
    }
    else {
        return asyncIterableFromStream(streamLike);
    }
}
//# sourceMappingURL=stream.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)
/* harmony export */ });
function isArrayBufferLike(buffer) {
    return (buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer));
}
function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
        return buffer;
    }
    else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    else if (isArrayBufferLike(buffer)) {
        return new Uint8Array(buffer);
    }
    else {
        // ArrayLike<number>
        return Uint8Array.from(buffer);
    }
}
//# sourceMappingURL=typedArrays.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   utf8Count: () => (/* binding */ utf8Count),
/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),
/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),
/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),
/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),
/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),
/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)
/* harmony export */ });
function utf8Count(str) {
    const strLength = str.length;
    let byteLength = 0;
    let pos = 0;
    while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            byteLength++;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            byteLength += 2;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    const extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                byteLength += 3;
            }
            else {
                // 4-byte
                byteLength += 4;
            }
        }
    }
    return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
    const strLength = str.length;
    let offset = outputOffset;
    let pos = 0;
    while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            output[offset++] = value;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    const extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
            else {
                // 4-byte
                output[offset++] = ((value >> 18) & 0x07) | 0xf0;
                output[offset++] = ((value >> 12) & 0x3f) | 0x80;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
        }
        output[offset++] = (value & 0x3f) | 0x80;
    }
}
// TextEncoder and TextDecoder are standardized in whatwg encoding:
// https://encoding.spec.whatwg.org/
// and available in all the modern browsers:
// https://caniuse.com/textencoder
// They are available in Node.js since v12 LTS as well:
// https://nodejs.org/api/globals.html#textencoder
const sharedTextEncoder = new TextEncoder();
// This threshold should be determined by benchmarking, which might vary in engines and input data.
// Run `npx ts-node benchmark/encode-string.ts` for details.
const TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
    if (str.length > TEXT_ENCODER_THRESHOLD) {
        utf8EncodeTE(str, output, outputOffset);
    }
    else {
        utf8EncodeJs(str, output, outputOffset);
    }
}
const CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
    let offset = inputOffset;
    const end = offset + byteLength;
    const units = [];
    let result = "";
    while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 0x80) === 0) {
            // 1 byte
            units.push(byte1);
        }
        else if ((byte1 & 0xe0) === 0xc0) {
            // 2 bytes
            const byte2 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 6) | byte2);
        }
        else if ((byte1 & 0xf0) === 0xe0) {
            // 3 bytes
            const byte2 = bytes[offset++] & 0x3f;
            const byte3 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
        }
        else if ((byte1 & 0xf8) === 0xf0) {
            // 4 bytes
            const byte2 = bytes[offset++] & 0x3f;
            const byte3 = bytes[offset++] & 0x3f;
            const byte4 = bytes[offset++] & 0x3f;
            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(((unit >>> 10) & 0x3ff) | 0xd800);
                unit = 0xdc00 | (unit & 0x3ff);
            }
            units.push(unit);
        }
        else {
            units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
            result += String.fromCharCode(...units);
            units.length = 0;
        }
    }
    if (units.length > 0) {
        result += String.fromCharCode(...units);
    }
    return result;
}
const sharedTextDecoder = new TextDecoder();
// This threshold should be determined by benchmarking, which might vary in engines and input data.
// Run `npx ts-node benchmark/decode-string.ts` for details.
const TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
    if (byteLength > TEXT_DECODER_THRESHOLD) {
        return utf8DecodeTD(bytes, inputOffset, byteLength);
    }
    else {
        return utf8DecodeJs(bytes, inputOffset, byteLength);
    }
}
//# sourceMappingURL=utf8.mjs.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js");
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.wNAF = wNAF;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, property, points) {
    const getz = property === 'pz' ? (p) => p.pz : (p) => p.ez;
    const toInv = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(getz));
    // @ts-ignore
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
function wNAF(c, bits) {
    return {
        constTimeNegate: negateCt,
        hasPrecomputes(elm) {
            return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder(elm, n, p = c.ZERO) {
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = calcWOpts(W, bits);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // i=1, bc we skip 0
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // Smaller version:
            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
            // TODO: check the scalar is less than group order?
            // wNAF behavior is undefined otherwise. But have to carefully remove
            // other checks before wNAF. ORDER == bits here.
            // Accumulators
            let p = c.ZERO;
            let f = c.BASE;
            // This code was first written with assumption that 'f' and 'p' will never be infinity point:
            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
            // there is negate now: it is possible that negated element from low value
            // would be the same as high element, which will create carry into next window.
            // It's not obvious how this can fail, but still worth investigating later.
            const wo = calcWOpts(W, bits);
            for (let window = 0; window < wo.windows; window++) {
                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) {
                    // bits are 0: add garbage to fake point
                    // Important part for const-time getPublicKey: add random "noise" point to f.
                    f = f.add(negateCt(isNegF, precomputes[offsetF]));
                }
                else {
                    // bits are 1: add to result point
                    p = p.add(negateCt(isNeg, precomputes[offset]));
                }
            }
            assert0(n);
            // Return both real and fake points: JIT won't eliminate f.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
            const wo = calcWOpts(W, bits);
            for (let window = 0; window < wo.windows; window++) {
                if (n === _0n)
                    break; // Early-exit, skip 0 value
                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) {
                    // Window bits are 0: skip processing.
                    // Move to next window.
                    continue;
                }
                else {
                    const item = precomputes[offset];
                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
                }
            }
            assert0(n);
            return acc;
        },
        getPrecomputes(W, P, transform) {
            // Calculate precomputes on a first run, reuse them after
            let comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    // Doing transform outside of if brings 15% perf hit
                    if (typeof transform === 'function')
                        comp = transform(comp);
                    pointPrecomputes.set(P, comp);
                }
            }
            return comp;
        },
        wNAFCached(P, n, transform) {
            const W = getW(P);
            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe(P, n, transform, prev) {
            const W = getW(P);
            if (W === 1)
                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster
            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
            validateW(W, bits);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        },
    };
}
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar  256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255  32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16  255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order);
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    return { Fp, Fn };
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.edwards = edwards;
exports.eddsa = eddsa;
exports.twistedEdwards = twistedEdwards;
/**
 * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.
 * For design rationale of types / exports, see weierstrass module documentation.
 * Untwisted Edwards curves exist, but they aren't used in real-world protocols.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
const VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('edwards', CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, { uvRatio: 'function' });
    // Important:
    // There are some places where Fp.BYTES is used instead of nByteLength.
    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.
    // TODO: test and find curves which behave otherwise.
    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);
    const modP = (n) => Fp.create(n); // Function overrides
    // sqrt(u/v)
    const uvRatio = curveOpts.uvRatio ||
        ((u, v) => {
            try {
                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
            }
            catch (e) {
                return { isValid: false, value: _0n };
            }
        });
    // Validate whether the passed curve params are valid.
    // equation ax + y = 1 + dxy should work for generator point.
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    /**
     * Asserts coordinate is valid: 0 <= n < MASK.
     * Coordinates >= Fp.ORDER are allowed for zip215.
     */
    function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);
        return n;
    }
    function aextpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null)
            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
            return { x: _0n, y: _1n };
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax + y = 1 + dxy
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X); // X
        const Y2 = modP(Y * Y); // Y
        const Z2 = modP(Z * Z); // Z
        const Z4 = modP(Z2 * Z2); // Z
        const aX2 = modP(X2 * a); // aX
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY
        if (left !== right)
            throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
            throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(ex, ey, ez, et) {
            this.ex = acoord('x', ex);
            this.ey = acoord('y', ey);
            this.ez = acoord('z', ez, true);
            this.et = acoord('t', et);
            Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point)
                throw new Error('extended point not allowed');
            const { x, y } = p || {};
            acoord('x', x);
            acoord('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, 'ez', points);
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        precompute(windowSize = 8, isLazy = true) {
            wnaf.setWindowSize(this, windowSize);
            if (!isLazy)
                this.multiply(_2n); // random number
            return this;
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            aextpoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
            const n = scalar;
            (0, utils_ts_1.aInRange)('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L
            const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);
            return Point.normalizeZ([p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
            const n = scalar;
            (0, utils_ts_1.aInRange)('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L
            if (n === _0n)
                return Point.ZERO;
            if (this.is0() || n === _1n)
                return this;
            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
            if (cofactor === _1n)
                return this;
            return this.multiplyUnsafe(cofactor);
        }
        static fromBytes(bytes, zip215 = false) {
            (0, utils_ts_1.abytes)(bytes);
            return this.fromHex(bytes, zip215);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_ts_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array
            (0, utils_ts_1.abool)('zip215', zip215);
            const normed = hex.slice(); // copy again, we'll manipulate it
            const lastByte = hex[len - 1]; // select last byte
            normed[len - 1] = lastByte & ~0x80; // clear last bit
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)('pointHex.y', y, _0n, max);
            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:
            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y - 1
            const v = modP(d * y2 - a); // v = d y + 1.
            let { isValid, value: x } = uvRatio(u, v); // (u/v)
            if (!isValid)
                throw new Error('Point.fromHex: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd)
                // if x=0 and x_0 = 1, fail
                throw new Error('Point.fromHex: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd)
                x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({ x, y });
        }
        static fromPrivateScalar(scalar) {
            return Point.BASE.multiply(scalar);
        }
        toBytes() {
            const { x, y } = this.toAffine();
            const bytes = (0, utils_ts_1.numberToBytesLE)(y, Fp.BYTES); // each y has 2 x values (x, -y)
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
            return bytes; // and use the last byte to encode sign of x
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
            return this.toBytes();
        }
        toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    // fields
    Point.Fp = Fp;
    Point.Fn = Fn;
    const wnaf = (0, curve_ts_1.wNAF)(Point, Fn.BYTES * 8); // Fn.BITS?
    return Point;
}
/**
 * Initializes EdDSA signatures over given Edwards curve.
 */
function eddsa(Point, eddsaOpts) {
    (0, utils_ts_1._validateObject)(eddsaOpts, {
        hash: 'function',
    }, {
        adjustScalarBytes: 'function',
        randomBytes: 'function',
        domain: 'function',
        prehash: 'function',
        mapToCurve: 'function',
    });
    const { prehash, hash: cHash } = eddsaOpts;
    const { BASE: G, Fp, Fn } = Point;
    const CURVE_ORDER = Fn.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes); // NOOP
    const domain = eddsaOpts.domain ||
        ((data, ctx, phflag) => {
            (0, utils_ts_1.abool)('phflag', phflag);
            if (ctx.length || phflag)
                throw new Error('Contexts/pre-hash are not supported');
            return data;
        }); // NOOP
    function modN(a) {
        return Fn.create(a);
    }
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        // Not using Fn.fromBytes: hash can be 2*Fn.BYTES
        return modN((0, utils_ts_1.bytesToNumberLE)(hash));
    }
    // Get the hashed private scalar per RFC8032 5.1.5
    function getPrivateScalar(key) {
        const len = Fp.BYTES;
        key = (0, utils_ts_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        return { head, prefix, scalar };
    }
    // Convenience method that creates public key from scalar. RFC8032 5.1.5
    function getExtendedPublicKey(key) {
        const { head, prefix, scalar } = getPrivateScalar(key);
        const point = G.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
    }
    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
    function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */
    function sign(msg, privKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        if (prehash)
            msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = G.multiply(r).toBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = modN(r + k * scalar); // S = (r + k * s) mod L
        (0, utils_ts_1.aInRange)('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l
        const L = Fp.BYTES;
        const res = (0, utils_ts_1.concatBytes)(R, (0, utils_ts_1.numberToBytesLE)(s, L));
        return (0, utils_ts_1.ensureBytes)('result', res, L * 2); // 64-byte signature
    }
    const verifyOpts = VERIFY_DEFAULT;
    /**
     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
     * An extended group equation is checked.
     */
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
        sig = (0, utils_ts_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, len);
        if (zip215 !== undefined)
            (0, utils_ts_1.abool)('zip215', zip215);
        if (prehash)
            msg = prehash(msg); // for ed25519ph, etc
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.slice(len, 2 * len));
        let A, R, SB;
        try {
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
        }
        catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder())
            return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // Extended group equation
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().is0();
    }
    G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    const utils = {
        getExtendedPublicKey,
        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
        randomPrivateKey: () => randomBytes_(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return { getPublicKey, sign, verify, utils, Point };
}
function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
    const eddsaOpts = {
        hash: c.hash,
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve,
    };
    return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa) {
    const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });
    return legacy;
}
// TODO: remove. Use eddsa
function twistedEdwards(c) {
    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
}
//# sourceMappingURL=edwards.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    if (!(0, utils_ts_1.isBytes)(_DST) && typeof _DST !== 'string')
        throw new Error('DST must be string or uint8array');
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const dst = defaults.DST ? defaults.DST : {};
            const opts = Object.assign({}, defaults, dst, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const dst = defaults.encodeDST ? defaults.encodeDST : {};
            const opts = Object.assign({}, defaults, dst, options);
            const u = hash_to_field(msg, 1, opts);
            return clear(map(u[0]));
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);
const _8n = /* @__PURE__ */ BigInt(8);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    // Throw if root^2 != n
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
    return root;
}
// TODO: Commented-out for now. Provide test vectors.
// Tonelli is too slow for extension fields Fp2.
// That means we can't use sqrt (c1, c2...) even for initialization constants.
// if (P % _16n === _9n) return sqrt9mod16;
// // prettier-ignore
// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {
//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;
//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic
//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4
//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1
//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1
//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1
//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x
//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x
//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x
//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2
// }
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < BigInt(3))
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P  3 (mod 4)
 * 2. P  5 (mod 8)
 * 3. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P  3 (mod 4) => n = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P  9 (mod 16) not implemented, see above
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p)  1    if a is a square (mod p), quadratic residue
 * * (a | p)  -1   if a is not a square (mod p), quadratic non residue
 * * (a | p)  0    if a  0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.montgomery = montgomery;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function validateOpts(curve) {
    (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: 'function',
        powPminus2: 'function',
    });
    return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === 'x25519';
    if (!is25519 && type !== 'x448')
        throw new Error('invalid type');
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    // RFC 7748 #5:
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and
    // (156326 - 2) / 4 = 39081 for curve448/X448
    // const a = is25519 ? 156326n : 486662n;
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    // RFC: x25519 "the resulting integer is of the form 2^254 plus
    // eight times a value between 0 and 2^251 - 1 (inclusive)"
    // x448: "2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)"
    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
    const maxAdded = is25519
        ? BigInt(8) * _2n ** BigInt(251) - _1n
        : BigInt(4) * _2n ** BigInt(445) - _1n;
    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)
    const modP = (n) => (0, modular_ts_1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);
        // RFC: When receiving such an array, implementations of X25519
        // (but not X448) MUST mask the most significant bit in the final byte.
        if (is25519)
            _u[31] &= 127; // 0b0111_1111
        // RFC: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.  The non-canonical
        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
        // - 1 through 2^448 - 1 for X448.
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        // Some public keys are useless, of low-order. Curve author doesn't think
        // it needs to be validated, but we do it nonetheless.
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('invalid private or public key received');
        return encodeU(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    // cswap from RFC7748 "example code"
    function cswap(swap, x_2, x_3) {
        // dummy = mask(swap) AND (x_2 XOR x_3)
        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2
        // and x_3, computed, e.g., as mask(swap) = 0 - swap.
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy
        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy
        return { x_2, x_3 };
    }
    /**
     * Montgomery x-only multiplication ladder.
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)('u', u, _0n, P);
        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent
        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))
    }
    return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey) => scalarMultBase(privateKey),
        utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
        GuBytes: GuBytes.slice(),
    };
}
//# sourceMappingURL=montgomery.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = exports.DERErr = void 0;
exports._legacyHelperEquat = _legacyHelperEquat;
exports._legacyHelperNormPriv = _legacyHelperNormPriv;
exports.weierstrassN = weierstrassN;
exports.weierstrassPoints = weierstrassPoints;
exports.ecdsa = ecdsa;
exports.weierstrass = weierstrass;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
/**
 * Short Weierstrass curve methods. The formula is: y = x + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = __webpack_require__(/*! @noble/hashes/hmac.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js");
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
function validateSigVerOpts(opts) {
    if (opts.lowS !== undefined)
        (0, utils_ts_1.abool)('lowS', opts.lowS);
    if (opts.prehash !== undefined)
        (0, utils_ts_1.abool)('prehash', opts.prehash);
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
// TODO: remove
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.
     * @returns y
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b
    }
    return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    // Validates if priv key is valid and converts it to bigint.
    function normPrivateKeyToScalar(key) {
        let num;
        if (typeof key === 'bigint') {
            num = key;
        }
        else {
            let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
            if (allowedPrivateKeyLengths) {
                if (!allowedPrivateKeyLengths.includes(bytes.length * 2))
                    throw new Error('invalid private key');
                const padded = new Uint8Array(expected);
                padded.set(bytes, padded.length - bytes.length);
                bytes = padded;
            }
            try {
                num = Fn.fromBytes(bytes);
            }
            catch (error) {
                throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
            }
        }
        if (wrapPrivateKey)
            num = Fn.create(num); // disabled by default, enabled for BLS
        if (!Fn.isValidNot0(num))
            throw new Error('invalid private key: out of range [1..N-1]');
        return num;
    }
    return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('weierstrass', CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = curveOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        }
    }
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1.abool)('isCompressed', isCompressed);
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1.abytes)(bytes);
        const L = Fp.BYTES;
        const LC = L + 1; // length compressed, e.g. 33 for 32-byte field
        const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === LC && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y = x + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === LU && head === 0x04) {
            // TODO: more checks
            const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));
            const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
        }
    }
    const toBytes = curveOpts.toBytes || pointToBytes;
    const fromBytes = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y == x + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y = x + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z)  (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        // Fast-path for normalized points
        if (Fp.eql(z, Fp.ONE))
            return { x, y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (curveOpts.allowInfinityPoint && !Fp.is0(p.py))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(px, py, pz) {
            this.px = acoord('x', px);
            this.py = acoord('y', py, true);
            this.pz = acoord('z', pz);
            Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, 'pz', points);
        }
        static fromBytes(bytes) {
            (0, utils_ts_1.abytes)(bytes);
            return Point.fromHex(bytes);
        }
        /** Converts hash string or Uint8Array to Point. */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        /** Multiplies generator point by privateKey. */
        static fromPrivateKey(privateKey) {
            const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        /** Multiscalar Multiplication */
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.setWindowSize(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        /** "Private method", don't use it directly */
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = curveOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.wNAFCached(this, n, Point.normalizeZ);
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = curveOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasPrecomputes(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
                // `wNAFCachedUnsafe` is 30% slower
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.wNAFCachedUnsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = curveOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = curveOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1.abool)('isCompressed', isCompressed);
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        /** @deprecated use `toBytes` */
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // fields
    Point.Fp = Fp;
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = (0, curve_ts_1.wNAF)(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point;
}
// _legacyWeierstrass
/** @deprecated use `weierstrassN` */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
function ecdsa(Point, ecdsaOpts, curveOpts = {}) {
    (0, utils_ts_1._validateObject)(ecdsaOpts, { hash: 'function' }, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac_ = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            aValidRS('r', r); // r in [1..N-1]
            aValidRS('s', s); // s in [1..N-1]
            this.r = r;
            this.s = s;
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const L = Fn.BYTES;
            const b = (0, utils_ts_1.ensureBytes)('compactSignature', hex, L * 2);
            return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        /**
         * @todo remove
         * @deprecated
         */
        assertValidity() { }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        // ProjPointType<bigint>
        recoverPublicKey(msgHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromHex((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toBytes(format) {
            if (format === 'compact')
                return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            throw new Error('invalid format');
        }
        // DER-encoded
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const n = CURVE_ORDER;
            return (0, modular_ts_1.mapHashToField)(randomBytes_((0, modular_ts_1.getMinHashLength)(n)), n);
        },
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const arr = (0, utils_ts_1.ensureBytes)('key', item);
        const length = arr.length;
        const L = Fp.BYTES;
        const LC = L + 1; // e.g. 33 for 32
        const LU = 2 * L + 1; // e.g. 65 for 32
        if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
            return undefined;
        }
        else {
            return length === LC || length === LU;
        }
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicB) === false)
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function (bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function (bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,
    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash } = ecdsaOpts;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        validateSigVerOpts(opts);
        if (prehash)
            msgHash = (0, utils_ts_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE.precompute(8);
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        // Verify opts
        validateSigVerOpts(opts);
        const { lowS, prehash, format } = opts;
        // TODO: remove
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        if (format !== undefined && !['compact', 'der', 'js'].includes(format))
            throw new Error('format must be "compact", "der" or "js"');
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            !format &&
            typeof sg === 'object' &&
            sg !== null &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        let _sig = undefined;
        let P;
        // deduce signature format
        try {
            // if (format === 'js') {
            //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);
            // } else if (format === 'compact') {
            //   _sig = Signature.fromCompact(sg);
            // } else if (format === 'der') {
            //   _sig = Signature.fromDER(sg);
            // } else {
            //   throw new Error('invalid format');
            // }
            if (isObj) {
                if (format === undefined || format === 'js') {
                    _sig = new Signature(sg.r, sg.s);
                }
                else {
                    throw new Error('invalid format');
                }
            }
            if (isHex) {
                // TODO: remove this malleable check
                // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).
                // Since DER can also be 2*Fn.BYTES bytes, we check for it first.
                try {
                    if (format !== 'compact')
                        _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                }
                if (!_sig && format !== 'der')
                    _sig = Signature.fromCompact(sg);
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            return false;
        }
        if (!_sig)
            return false;
        if (lowS && _sig.hasHighS())
            return false;
        // todo: optional.hash => hash
        if (prehash)
            msgHash = ecdsaOpts.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = Fn.inv(s); // s^-1
        const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
        const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
            return false;
        const v = Fn.create(R.x); // v = r.x mod n
        return v === r;
    }
    // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?
    // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);
    return Object.freeze({
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        utils,
        Point,
        Signature,
    });
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength);
    const curveOpts = {
        Fp,
        Fn,
        allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        wrapPrivateKey: c.wrapPrivateKey,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hash: c.hash,
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, ecdsaOpts };
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    // TODO: remove
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, ecdsa) {
    return Object.assign({}, ecdsa, {
        ProjectivePoint: ecdsa.Point,
        CURVE: c,
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./abstract/curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js");
const edwards_ts_1 = __webpack_require__(/*! ./abstract/edwards.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const montgomery_ts_1 = __webpack_require__(/*! ./abstract/montgomery.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
// 2n**255n - 19n
// Removing Fp.create() will still work, and is 10% faster on sign
//     a: Fp.create(BigInt(-1)),
// d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
// Finite field 2n**255n - 19n
// Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
const ed25519_CURVE = {
    p: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'),
    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),
    h: _8n,
    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),
    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),
    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),
    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),
};
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE.p;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
    const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P; // x^31
    const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;
    const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;
    const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;
    const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;
    const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;
    const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;
    const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// (-1) aka (a) aka 2^((p-1)/4)
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ed25519_CURVE.p;
    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v
    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx
    const root1 = x; // First root candidate
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}
/** Weird / bogus points, useful for debugging. */
exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
];
const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, undefined, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/v
    uvRatio,
}))();
/**
 * ed25519 curve with EdDSA signatures.
 * @example
 * import { ed25519 } from '@noble/curves/ed25519';
 * const priv = ed25519.utils.randomPrivateKey();
 * const pub = ed25519.getPublicKey(priv);
 * const msg = new TextEncoder().encode('hello');
 * const sig = ed25519.sign(msg, priv);
 * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
 * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
 */
exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
        throw new Error('Context is too big');
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
}))();
exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512,
})))();
/**
 * ECDH using curve25519 aka x25519.
 * @example
 * import { x25519 } from '@noble/curves/ed25519';
 * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';
 * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';
 * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases
 * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
 * x25519.getPublicKey(x25519.utils.randomPrivateKey());
 */
exports.x25519 = (() => {
    const P = ed25519_CURVE.p;
    return (0, montgomery_ts_1.montgomery)({
        P,
        type: 'x25519',
        powPminus2: (x) => {
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
    });
})();
/**
 * Converts ed25519 public key to x25519 public key. Uses formula:
 * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
 * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
 * @example
 *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
 *   const aPriv = x25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
 */
function edwardsToMontgomeryPub(edwardsPub) {
    const bpub = (0, utils_ts_1.ensureBytes)('pub', edwardsPub);
    const { y } = exports.ed25519.Point.fromHex(bpub);
    const _1n = BigInt(1);
    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
}
exports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
/**
 * Converts ed25519 secret key to x25519 secret key.
 * @example
 *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
 *   const aPriv = ed25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
 */
function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true); // batch division
    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)
}
exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha512,
}))();
exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
function aristp(other) {
    if (!(other instanceof RistPoint))
        throw new Error('RistrettoPoint expected');
}
// (-1) aka (a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// (ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / (a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/(number)
const invertSqrt = (number) => uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
/**
 * Computes Elligator map for Ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
 * the [website](https://ristretto.group/formulas/elligator.html).
 */
function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod = exports.ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
    if (!Ns_D_is_sq)
        s = s_; // 7
    if (!Ns_D_is_sq)
        c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
/**
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
class RistPoint {
    // Private property to discourage combining ExtendedPoint + RistrettoPoint
    // Always use Ristretto encoding/decoding instead.
    constructor(ep) {
        this.ep = ep;
    }
    static fromAffine(ap) {
        return new RistPoint(exports.ed25519.Point.fromAffine(ap));
    }
    /**
     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
     * The hash-to-group operation applies Elligator twice and adds the results.
     * **Note:** this is one-way map, there is no conversion from point to hash.
     * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
     * the [website](https://ristretto.group/formulas/elligator.html).
     * @param hex 64-byte output of a hash function
     */
    static hashToCurve(hex) {
        hex = (0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new RistPoint(R1.add(R2));
    }
    static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return this.fromHex(bytes);
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
        hex = (0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
        return new RistPoint(new exports.ed25519.Point(x, y, _1n, t));
    }
    static msm(points, scalars) {
        const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
        return (0, curve_ts_1.pippenger)(RistPoint, Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y)); // 1
        const u2 = mod(x * y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * t); // 6
        let D; // 7
        if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2; // 8
        }
        if ((0, modular_ts_1.isNegativeLE)(x * zInv, P))
            y = mod(-y); // 9
        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
        return (0, utils_ts_1.numberToBytesLE)(s, 32); // 11
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
        return this.toBytes();
    }
    toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
        return this.toHex();
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
        aristp(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = Fp.create;
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    add(other) {
        aristp(other);
        return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        aristp(other);
        return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return new RistPoint(this.ep.double());
    }
    negate() {
        return new RistPoint(this.ep.negate());
    }
}
/**
 * Wrapper over Edwards Point for ristretto255 from
 * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE)
        RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
    if (!RistPoint.ZERO)
        RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
    return RistPoint;
})();
/**
 * hash-to-curve for ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).
 */
const hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === 'string' ? (0, utils_js_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
};
exports.hashToRistretto255 = hashToRistretto255;
/** @deprecated */
exports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy
//# sourceMappingURL=ed25519.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p521_hasher = exports.secp521r1 = exports.p521 = exports.p384_hasher = exports.secp384r1 = exports.p384 = exports.p256_hasher = exports.secp256r1 = exports.p256 = void 0;
/**
 * Internal module for NIST P256, P384, P521 curves.
 * Do not use for now.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js");
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js");
// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n
// a = Fp256.create(BigInt('-3'));
const p256_CURVE = {
    p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
    h: BigInt(1),
    a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
    b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n
const p384_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'),
    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),
    h: BigInt(1),
    a: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'),
    b: BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'),
    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),
    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),
};
// p = 2n**521n - 1n
const p521_CURVE = {
    p: BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),
    h: BigInt(1),
    a: BigInt('0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'),
    b: BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'),
    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),
    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),
};
const Fp256 = (0, modular_ts_1.Field)(p256_CURVE.p);
const Fp384 = (0, modular_ts_1.Field)(p384_CURVE.p);
const Fp521 = (0, modular_ts_1.Field)(p521_CURVE.p);
function createSWU(field, opts) {
    const map = (0, weierstrass_ts_1.mapToCurveSimpleSWU)(field, opts);
    return (scalars) => map(scalars[0]);
}
/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */
exports.p256 = (0, _shortw_utils_ts_1.createCurve)({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha2_js_1.sha256);
/** Alias to p256. */
exports.secp256r1 = exports.p256;
/** Hashing / encoding to p256 points / field. RFC 9380 methods. */
exports.p256_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p256.Point, createSWU(Fp256, {
        A: p256_CURVE.a,
        B: p256_CURVE.b,
        Z: Fp256.create(BigInt('-10')),
    }), {
        DST: 'P256_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',
        p: p256_CURVE.p,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha2_js_1.sha256,
    });
})();
/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */
exports.p384 = (0, _shortw_utils_ts_1.createCurve)({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha2_js_1.sha384);
/** Alias to p384. */
exports.secp384r1 = exports.p384;
/** Hashing / encoding to p384 points / field. RFC 9380 methods. */
exports.p384_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p384.Point, createSWU(Fp384, {
        A: p384_CURVE.a,
        B: p384_CURVE.b,
        Z: Fp384.create(BigInt('-12')),
    }), {
        DST: 'P384_XMD:SHA-384_SSWU_RO_',
        encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',
        p: p384_CURVE.p,
        m: 1,
        k: 192,
        expand: 'xmd',
        hash: sha2_js_1.sha384,
    });
})();
/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */
exports.p521 = (0, _shortw_utils_ts_1.createCurve)({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha2_js_1.sha512);
/** Alias to p521. */
exports.secp521r1 = exports.p521;
/** Hashing / encoding to p521 points / field. RFC 9380 methods. */
exports.p521_hasher = (() => {
    return (0, hash_to_curve_ts_1.createHasher)(exports.p521.Point, createSWU(Fp521, {
        A: p521_CURVE.a,
        B: p521_CURVE.b,
        Z: Fp521.create(BigInt('-4')),
    }), {
        DST: 'P521_XMD:SHA-512_SSWU_RO_',
        encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',
        p: p521_CURVE.p,
        m: 1,
        k: 256,
        expand: 'xmd',
        hash: sha2_js_1.sha512,
    });
})();
//# sourceMappingURL=nist.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256r1 = exports.p256 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p256 = nist_ts_1.p256;
exports.secp256r1 = nist_ts_1.p256;
exports.hashToCurve = (() => nist_ts_1.p256_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p256_hasher.encodeToCurve)();
//# sourceMappingURL=p256.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp384r1 = exports.p384 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p384 = nist_ts_1.p384;
exports.secp384r1 = nist_ts_1.p384;
exports.hashToCurve = (() => nist_ts_1.p384_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p384_hasher.encodeToCurve)();
/** @deprecated Use `import { p384_hasher } from "@noble/curves/nist"` module. */
//# sourceMappingURL=p384.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp521r1 = exports.p521 = void 0;
const nist_ts_1 = __webpack_require__(/*! ./nist.js */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js");
exports.p521 = nist_ts_1.p521;
exports.secp521r1 = nist_ts_1.p521;
exports.hashToCurve = (() => nist_ts_1.p521_hasher.hashToCurve)();
exports.encodeToCurve = (() => nist_ts_1.p521_hasher.encodeToCurve)();
//# sourceMappingURL=p521.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
var utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js");
const u64 = __webpack_require__(/*! ./_u64.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */
const sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha224 = sha2_ts_1.sha224;
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */
const _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js");
// prettier-ignore
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
exports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */
exports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */
exports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */
exports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */
exports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */
exports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */
exports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */
exports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
exports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */
exports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();
//# sourceMappingURL=sha3.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
/**
 * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.
 *
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).
 * @module
 * @deprecated
 */
const sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512 = sha2_ts_1.SHA512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512 = sha2_ts_1.sha512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA384 = sha2_ts_1.SHA384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha384 = sha2_ts_1.sha384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_224 = sha2_ts_1.SHA512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_224 = sha2_ts_1.sha512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_256 = sha2_ts_1.SHA512_256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_256 = sha2_ts_1.sha512_256;
//# sourceMappingURL=sha512.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XOF256 = exports.XOF128 = exports.genCrystals = void 0;
/**
 * Internal methods for lattice-based ML-KEM and ML-DSA.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js");
// TODO: benchmark
function bitReversal(n, bits = 8) {
    const padded = n.toString(2).padStart(8, '0');
    const sliced = padded.slice(-bits).padStart(7, '0');
    const revrsd = sliced.split('').reverse().join('');
    return Number.parseInt(revrsd, 2);
}
const genCrystals = (opts) => {
    // isKyber: true means Kyber, false means Dilithium
    const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits, isKyber } = opts;
    const mod = (a, modulo = Q) => {
        const result = a % modulo | 0;
        return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;
    };
    // -(Q-1)/2 < a <= (Q-1)/2
    const smod = (a, modulo = Q) => {
        const r = mod(a, modulo) | 0;
        return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;
    };
    // Generate zettas
    function getZettas() {
        const out = newPoly(N);
        for (let i = 0; i < N; i++) {
            const b = bitReversal(i, brvBits);
            const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);
            out[i] = Number(p) | 0;
        }
        return out;
    }
    const nttZetas = getZettas();
    // Number-Theoretic Transform
    // Explained: https://electricdusk.com/ntt.html
    // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,
    // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.
    // TODO: there should be less ugly way to define this.
    const LEN1 = isKyber ? 128 : N;
    const LEN2 = isKyber ? 1 : 0;
    const NTT = {
        encode: (r) => {
            for (let k = 1, len = 128; len > LEN2; len >>= 1) {
                for (let start = 0; start < N; start += 2 * len) {
                    const zeta = nttZetas[k++];
                    for (let j = start; j < start + len; j++) {
                        const t = mod(zeta * r[j + len]);
                        r[j + len] = mod(r[j] - t) | 0;
                        r[j] = mod(r[j] + t) | 0;
                    }
                }
            }
            return r;
        },
        decode: (r) => {
            for (let k = LEN1 - 1, len = 1 + LEN2; len < LEN1 + LEN2; len <<= 1) {
                for (let start = 0; start < N; start += 2 * len) {
                    const zeta = nttZetas[k--];
                    for (let j = start; j < start + len; j++) {
                        const t = r[j];
                        r[j] = mod(t + r[j + len]);
                        r[j + len] = mod(zeta * (r[j + len] - t));
                    }
                }
            }
            for (let i = 0; i < r.length; i++)
                r[i] = mod(F * r[i]);
            return r;
        },
    };
    // Encode polynominal as bits
    const bitsCoder = (d, c) => {
        const mask = (0, utils_ts_1.getMask)(d);
        const bytesLen = d * (N / 8);
        return {
            bytesLen,
            encode: (poly) => {
                const r = new Uint8Array(bytesLen);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {
                    buf |= (c.encode(poly[i]) & mask) << bufLen;
                    bufLen += d;
                    for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
                        r[pos++] = buf & (0, utils_ts_1.getMask)(bufLen);
                }
                return r;
            },
            decode: (bytes) => {
                const r = newPoly(N);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {
                    buf |= bytes[i] << bufLen;
                    bufLen += 8;
                    for (; bufLen >= d; bufLen -= d, buf >>= d)
                        r[pos++] = c.decode(buf & mask);
                }
                return r;
            },
        };
    };
    return { mod, smod, nttZetas, NTT, bitsCoder };
};
exports.genCrystals = genCrystals;
const createXofShake = (shake) => (seed, blockLen) => {
    if (!blockLen)
        blockLen = shake.blockLen;
    // Optimizations that won't mater:
    // - cached seed update (two .update(), on start and on the end)
    // - another cache which cloned into working copy
    // Faster than multiple updates, since seed less than blockLen
    const _seed = new Uint8Array(seed.length + 2);
    _seed.set(seed);
    const seedLen = seed.length;
    const buf = new Uint8Array(blockLen); // == shake128.blockLen
    let h = shake.create({});
    let calls = 0;
    let xofs = 0;
    return {
        stats: () => ({ calls, xofs }),
        get: (x, y) => {
            _seed[seedLen + 0] = x;
            _seed[seedLen + 1] = y;
            h.destroy();
            h = shake.create({}).update(_seed);
            calls++;
            return () => {
                xofs++;
                return h.xofInto(buf);
            };
        },
        clean: () => {
            h.destroy();
            buf.fill(0);
            _seed.fill(0);
        },
    };
};
exports.XOF128 = createXofShake(sha3_1.shake128);
exports.XOF256 = createXofShake(sha3_1.shake256);
//# sourceMappingURL=_crystals.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ml_dsa87 = exports.ml_dsa65 = exports.ml_dsa44 = exports.PARAMS = void 0;
/**
 * ML-DSA: Module Lattice-based Digital Signature Algorithm from
 * [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd). A.k.a. CRYSTALS-Dilithium.
 *
 * Has similar internals to ML-KEM, but their keys and params are different.
 * Check out [official site](https://www.pq-crystals.org/dilithium/index.shtml),
 * [repo](https://github.com/pq-crystals/dilithium).
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const _crystals_ts_1 = __webpack_require__(/*! ./_crystals.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js");
// Constants
const N = 256;
// 2**23  2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints
const Q = 8380417;
const ROOT_OF_UNITY = 1753;
// f = 256**1 mod q, pow(256, -1, q) = 8347681 (python3)
const F = 8347681;
const D = 13;
// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.
const GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;
const GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;
/** Internal params for different versions of ML-DSA  */
// prettier-ignore
exports.PARAMS = {
    2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },
    3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },
    5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },
};
const newPoly = (n) => new Int32Array(n);
const { mod, smod, NTT, bitsCoder } = (0, _crystals_ts_1.genCrystals)({
    N,
    Q,
    F,
    ROOT_OF_UNITY,
    newPoly,
    isKyber: false,
    brvBits: 8,
});
const id = (n) => n;
const polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {
    encode: (i) => compress(verify(i)),
    decode: (i) => verify(compress(i)),
});
const polyAdd = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] + b[i]);
    return a;
};
const polySub = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] - b[i]);
    return a;
};
const polyShiftl = (p) => {
    for (let i = 0; i < N; i++)
        p[i] <<= D;
    return p;
};
const polyChknorm = (p, B) => {
    // Not very sure about this, but FIPS204 doesn't provide any function for that :(
    for (let i = 0; i < N; i++)
        if (Math.abs(smod(p[i])) >= B)
            return true;
    return false;
};
const MultiplyNTTs = (a, b) => {
    // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,
    // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,
    // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).
    // Barrett reduction is slower than mod :(
    const c = newPoly(N);
    for (let i = 0; i < a.length; i++)
        c[i] = mod(a[i] * b[i]);
    return c;
};
// Return poly in NTT representation
function RejNTTPoly(xof) {
    // Samples a polynomial  Tq.
    const r = newPoly(N);
    // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(
    for (let j = 0; j < N;) {
        const b = xof();
        if (b.length % 3)
            throw new Error('RejNTTPoly: unaligned block');
        for (let i = 0; j < N && i <= b.length - 3; i += 3) {
            const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes
            if (t < Q)
                r[j++] = t;
        }
    }
    return r;
}
function getDilithium(opts) {
    const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;
    const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256 } = opts;
    if (![2, 4].includes(ETA))
        throw new Error('Wrong ETA');
    if (![1 << 17, 1 << 19].includes(GAMMA1))
        throw new Error('Wrong GAMMA1');
    if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))
        throw new Error('Wrong GAMMA2');
    const BETA = TAU * ETA;
    const decompose = (r) => {
        // Decomposes r into (r1, r0) such that r  r1(22) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 * GAMMA2) | 0;
        if (rPlus - r0 === Q - 1)
            return { r1: 0 | 0, r0: (r0 - 1) | 0 };
        const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;
        return { r1, r0 }; // r1 = HighBits, r0 = LowBits
    };
    const HighBits = (r) => decompose(r).r1;
    const LowBits = (r) => decompose(r).r0;
    const MakeHint = (z, r) => {
        // Compute hint bit indicating whether adding z to r alters the high bits of r.
        // From dilithium code
        const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;
        // from FIPS204:
        // // const r1 = HighBits(r);
        // // const v1 = HighBits(r + z);
        // // const res1 = +(r1 !== v1);
        // But they return different results! However, decompose is same.
        // So, either there is a bug in Dilithium ref implementation or in FIPS204.
        // For now, lets use dilithium one, so test vectors can be passed.
        // See
        // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints
        return res0;
    };
    const UseHint = (h, r) => {
        // Returns the high bits of r adjusted according to hint h
        const m = Math.floor((Q - 1) / (2 * GAMMA2));
        const { r1, r0 } = decompose(r);
        // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m
        // 4: if h = 1 and r0  0 return (r1  1) mod m
        if (h === 1)
            return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;
        return r1 | 0;
    };
    const Power2Round = (r) => {
        // Decomposes r into (r1, r0) such that r  r1*(2**d) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 ** D) | 0;
        return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };
    };
    const hintCoder = {
        bytesLen: OMEGA + K,
        encode: (h) => {
            if (h === false)
                throw new Error('hint.encode: hint is false'); // should never happen
            const res = new Uint8Array(OMEGA + K);
            for (let i = 0, k = 0; i < K; i++) {
                for (let j = 0; j < N; j++)
                    if (h[i][j] !== 0)
                        res[k++] = j;
                res[OMEGA + i] = k;
            }
            return res;
        },
        decode: (buf) => {
            const h = [];
            let k = 0;
            for (let i = 0; i < K; i++) {
                const hi = newPoly(N);
                if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA)
                    return false;
                for (let j = k; j < buf[OMEGA + i]; j++) {
                    if (j > k && buf[j] <= buf[j - 1])
                        return false;
                    hi[buf[j]] = 1;
                }
                k = buf[OMEGA + i];
                h.push(hi);
            }
            for (let j = k; j < OMEGA; j++)
                if (buf[j] !== 0)
                    return false;
            return h;
        },
    };
    const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i) => ETA - i, (i) => {
        if (!(-ETA <= i && i <= ETA))
            throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);
        return i;
    });
    const T0Coder = polyCoder(13, (i) => (1 << (D - 1)) - i);
    const T1Coder = polyCoder(10);
    // Requires smod. Need to fix!
    const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i) => smod(GAMMA1 - i));
    const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);
    const W1Vec = (0, utils_ts_1.vecCoder)(W1Coder, K);
    // Main structures
    const publicCoder = (0, utils_ts_1.splitCoder)(32, (0, utils_ts_1.vecCoder)(T1Coder, K));
    const secretCoder = (0, utils_ts_1.splitCoder)(32, 32, TR_BYTES, (0, utils_ts_1.vecCoder)(ETACoder, L), (0, utils_ts_1.vecCoder)(ETACoder, K), (0, utils_ts_1.vecCoder)(T0Coder, K));
    const sigCoder = (0, utils_ts_1.splitCoder)(C_TILDE_BYTES, (0, utils_ts_1.vecCoder)(ZCoder, L), hintCoder);
    const CoefFromHalfByte = ETA === 2
        ? (n) => (n < 15 ? 2 - (n % 5) : false)
        : (n) => (n < 9 ? 4 - n : false);
    // Return poly in NTT representation
    function RejBoundedPoly(xof) {
        // Samples an element a  Rq with coeffcients in [, ] computed via rejection sampling from .
        const r = newPoly(N);
        for (let j = 0; j < N;) {
            const b = xof();
            for (let i = 0; j < N && i < b.length; i += 1) {
                // half byte. Should be superfast with vector instructions. But very slow with js :(
                const d1 = CoefFromHalfByte(b[i] & 0x0f);
                const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);
                if (d1 !== false)
                    r[j++] = d1;
                if (j < N && d2 !== false)
                    r[j++] = d2;
            }
        }
        return r;
    }
    const SampleInBall = (seed) => {
        // Samples a polynomial c  Rq with coeffcients from {1, 0, 1} and Hamming weight 
        const pre = newPoly(N);
        const s = sha3_1.shake256.create({}).update(seed);
        const buf = new Uint8Array(sha3_1.shake256.blockLen);
        s.xofInto(buf);
        const masks = buf.slice(0, 8);
        for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {
            let b = i + 1;
            for (; b > i;) {
                b = buf[pos++];
                if (pos < sha3_1.shake256.blockLen)
                    continue;
                s.xofInto(buf);
                pos = 0;
            }
            pre[i] = pre[b];
            pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);
            if (maskBit >= 8) {
                maskPos++;
                maskBit = 0;
            }
        }
        return pre;
    };
    const polyPowerRound = (p) => {
        const res0 = newPoly(N);
        const res1 = newPoly(N);
        for (let i = 0; i < p.length; i++) {
            const { r0, r1 } = Power2Round(p[i]);
            res0[i] = r0;
            res1[i] = r1;
        }
        return { r0: res0, r1: res1 };
    };
    const polyUseHint = (u, h) => {
        for (let i = 0; i < N; i++)
            u[i] = UseHint(h[i], u[i]);
        return u;
    };
    const polyMakeHint = (a, b) => {
        const v = newPoly(N);
        let cnt = 0;
        for (let i = 0; i < N; i++) {
            const h = MakeHint(a[i], b[i]);
            v[i] = h;
            cnt += h;
        }
        return { v, cnt };
    };
    const signRandBytes = 32;
    const seedCoder = (0, utils_ts_1.splitCoder)(32, 64, 32);
    // API & argument positions are exactly as in FIPS204.
    const internal = {
        signRandBytes,
        keygen: (seed) => {
            // H(||IntegerToBytes(, 1)||IntegerToBytes(, 1), 128) 2:  expand seed
            const seedDst = new Uint8Array(32 + 2);
            const randSeed = seed === undefined;
            if (randSeed)
                seed = (0, utils_ts_1.randomBytes)(32);
            (0, utils_ts_1.ensureBytes)(seed, 32);
            seedDst.set(seed);
            if (randSeed)
                seed.fill(0);
            seedDst[32] = K;
            seedDst[33] = L;
            const [rho, rhoPrime, K_] = seedCoder.decode((0, sha3_1.shake256)(seedDst, { dkLen: seedCoder.bytesLen }));
            const xofPrime = XOF256(rhoPrime);
            const s1 = [];
            for (let i = 0; i < L; i++)
                s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s2 = [];
            for (let i = L; i < L + K; i++)
                s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s1Hat = s1.map((i) => NTT.encode(i.slice()));
            const t0 = [];
            const t1 = [];
            const xof = XOF128(rho);
            const t = newPoly(N);
            for (let i = 0; i < K; i++) {
                // t  NTT1(A*NTT(s1)) + s2
                t.fill(0); // don't-reallocate
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // super slow!
                    polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));
                }
                NTT.decode(t);
                const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0)  Power2Round(t, d)
                t0.push(r0);
                t1.push(r1);
            }
            const publicKey = publicCoder.encode([rho, t1]); // pk  pkEncode(, t1)
            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // tr  H(BytesToBits(pk), 512)
            const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk  skEncode(, K,tr, s1, s2, t0)
            xof.clean();
            xofPrime.clean();
            // STATS
            // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }
            // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }
            (0, utils_ts_1.cleanBytes)(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);
            return { publicKey, secretKey };
        },
        // NOTE: random is optional.
        sign: (secretKey, msg, random, externalMu = false) => {
            // This part can be pre-cached per secretKey, but there is only minor performance improvement,
            // since we re-use a lot of variables to computation.
            const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (, K,tr, s1, s2, t0)  skDecode(sk)
            // Cache matrix to avoid re-compute later
            const A = []; // A  ExpandA()
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const pv = [];
                for (let j = 0; j < L; j++)
                    pv.push(RejNTTPoly(xof.get(j, i)));
                A.push(pv);
            }
            xof.clean();
            for (let i = 0; i < L; i++)
                NTT.encode(s1[i]); // s1  NTT(s1)
            for (let i = 0; i < K; i++) {
                NTT.encode(s2[i]); // s2  NTT(s2)
                NTT.encode(t0[i]); // t0  NTT(t0)
            }
            // This part is per msg
            const mu = externalMu
                ? msg
                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6:   H(tr||M, 512)  Compute message representative 
            // Compute private random seed
            const rnd = random ? random : new Uint8Array(32);
            (0, utils_ts_1.ensureBytes)(rnd);
            const rhoprime = sha3_1.shake256
                .create({ dkLen: CRH_BYTES })
                .update(_K)
                .update(rnd)
                .update(mu)
                .digest(); //  H(K||rnd||, 512)
            (0, utils_ts_1.ensureBytes)(rhoprime, CRH_BYTES);
            const x256 = XOF256(rhoprime, ZCoder.bytesLen);
            //  Rejection sampling loop
            main_loop: for (let kappa = 0;;) {
                const y = [];
                // y  ExpandMask( , )
                for (let i = 0; i < L; i++, kappa++)
                    y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));
                const z = y.map((i) => NTT.encode(i.slice()));
                const w = [];
                for (let i = 0; i < K; i++) {
                    // w  NTT1(A  NTT(y))
                    const wi = newPoly(N);
                    for (let j = 0; j < L; j++)
                        polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));
                    NTT.decode(wi);
                    w.push(wi);
                }
                const w1 = w.map((j) => j.map(HighBits)); // w1  HighBits(w)
                // Commitment hash: c {0, 1 2 }  H(||w1Encode(w1), 2)
                const cTilde = sha3_1.shake256
                    .create({ dkLen: C_TILDE_BYTES })
                    .update(mu)
                    .update(W1Vec.encode(w1))
                    .digest();
                // Verifers challenge
                const cHat = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1); c  NTT(c)
                // cs1  NTT1(c s1)
                const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));
                for (let i = 0; i < L; i++) {
                    polyAdd(NTT.decode(cs1[i]), y[i]); // z  y + cs1
                    if (polyChknorm(cs1[i], GAMMA1 - BETA))
                        continue main_loop; // ||z||  1  
                }
                // cs1 is now z ( Signers response)
                let cnt = 0;
                const h = [];
                for (let i = 0; i < K; i++) {
                    const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // cs2  NTT1(c s2)
                    const r0 = polySub(w[i], cs2).map(LowBits); // r0  LowBits(w  cs2)
                    if (polyChknorm(r0, GAMMA2 - BETA))
                        continue main_loop; // ||r0||  2  
                    const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // ct0  NTT1(c t0)
                    if (polyChknorm(ct0, GAMMA2))
                        continue main_loop;
                    polyAdd(r0, ct0);
                    //  Signers hint
                    const hint = polyMakeHint(r0, w1[i]); // h  MakeHint(ct0, w cs2 + ct0)
                    h.push(hint.v);
                    cnt += hint.cnt;
                }
                if (cnt > OMEGA)
                    continue; // the number of 1s in h is greater than 
                x256.clean();
                const res = sigCoder.encode([cTilde, cs1, h]); //   sigEncode(c, z modq, h)
                // rho, _K, tr is subarray of secretKey, cannot clean.
                (0, utils_ts_1.cleanBytes)(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);
                return res;
            }
            // @ts-ignore
            throw new Error('Unreachable code path reached, report this error');
        },
        verify: (publicKey, msg, sig, externalMu = false) => {
            // ML-DSA.Verify(pk, M, ): Verifes a signature  for a message M.
            const [rho, t1] = publicCoder.decode(publicKey); // (, t1)  pkDecode(pk)
            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // 6: tr  H(BytesToBits(pk), 512)
            if (sig.length !== sigCoder.bytesLen)
                return false; // return false instead of exception
            const [cTilde, z, h] = sigCoder.decode(sig); // (c, z, h)  sigDecode(),  Signers commitment hash c , response z and hint
            if (h === false)
                return false; // if h =  then return false
            for (let i = 0; i < L; i++)
                if (polyChknorm(z[i], GAMMA1 - BETA))
                    return false;
            const mu = externalMu
                ? msg
                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7:   H(tr||M, 512)
            // Compute verifers challenge from c
            const c = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1)
            const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)
            for (let i = 0; i < L; i++)
                NTT.encode(zNtt[i]);
            const wTick1 = [];
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)
                const Az = newPoly(N); // // A * z
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace
                    polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));
                }
                // wApprox = A*z - c*t1 * (2**d)
                const wApprox = NTT.decode(polySub(Az, ct12d));
                // Reconstruction of signers commitment
                wTick1.push(polyUseHint(wApprox, h[i])); // w   UseHint(h, w'approx )
            }
            xof.clean();
            // c H (||w1Encode(w1), 2),  Hash it; this should match c
            const c2 = sha3_1.shake256
                .create({ dkLen: C_TILDE_BYTES })
                .update(mu)
                .update(W1Vec.encode(wTick1))
                .digest();
            // Additional checks in FIPS-204:
            // [[ ||z|| < 1   ]] and [[c  = c]] and [[number of 1s in h is  ]]
            for (const t of h) {
                const sum = t.reduce((acc, i) => acc + i, 0);
                if (!(sum <= OMEGA))
                    return false;
            }
            for (const t of z)
                if (polyChknorm(t, GAMMA1 - BETA))
                    return false;
            return (0, utils_ts_1.equalBytes)(cTilde, c2);
        },
    };
    return {
        internal,
        keygen: internal.keygen,
        signRandBytes: internal.signRandBytes,
        sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {
            const M = (0, utils_ts_1.getMessage)(msg, ctx);
            const res = internal.sign(secretKey, M, random);
            M.fill(0);
            return res;
        },
        verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {
            return internal.verify(publicKey, (0, utils_ts_1.getMessage)(msg, ctx), sig);
        },
        prehash: (hashName) => ({
            sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {
                const M = (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx);
                const res = internal.sign(secretKey, M, random);
                M.fill(0);
                return res;
            },
            verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {
                return internal.verify(publicKey, (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx), sig);
            },
        }),
    };
}
/** ML-DSA-44 for 128-bit security level. Not recommended after 2030, as per ASD. */
exports.ml_dsa44 = getDilithium({
    ...exports.PARAMS[2],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 32,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
/** ML-DSA-65 for 192-bit security level. Not recommended after 2030, as per ASD. */
exports.ml_dsa65 = getDilithium({
    ...exports.PARAMS[3],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 48,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
/** ML-DSA-87 for 256-bit security level. OK after 2030, as per ASD. */
exports.ml_dsa87 = getDilithium({
    ...exports.PARAMS[5],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 64,
    XOF128: _crystals_ts_1.XOF128,
    XOF256: _crystals_ts_1.XOF256,
});
//# sourceMappingURL=ml-dsa.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EMPTY = exports.utf8ToBytes = exports.concatBytes = exports.randomBytes = exports.ensureBytes = void 0;
exports.equalBytes = equalBytes;
exports.splitCoder = splitCoder;
exports.vecCoder = vecCoder;
exports.cleanBytes = cleanBytes;
exports.getMask = getMask;
exports.getMessage = getMessage;
exports.getMessagePrehash = getMessagePrehash;
/**
 * Utilities for hex, bytearray and number handling.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js");
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_1.concatBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_1.utf8ToBytes; } }));
exports.ensureBytes = utils_1.abytes;
exports.randomBytes = utils_1.randomBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
function splitCoder(...lengths) {
    const getLength = (c) => (typeof c === 'number' ? c : c.bytesLen);
    const bytesLen = lengths.reduce((sum, a) => sum + getLength(a), 0);
    return {
        bytesLen,
        encode: (bufs) => {
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < lengths.length; i++) {
                const c = lengths[i];
                const l = getLength(c);
                const b = typeof c === 'number' ? bufs[i] : c.encode(bufs[i]);
                (0, exports.ensureBytes)(b, l);
                res.set(b, pos);
                if (typeof c !== 'number')
                    b.fill(0); // clean
                pos += l;
            }
            return res;
        },
        decode: (buf) => {
            (0, exports.ensureBytes)(buf, bytesLen);
            const res = [];
            for (const c of lengths) {
                const l = getLength(c);
                const b = buf.subarray(0, l);
                res.push(typeof c === 'number' ? b : c.decode(b));
                buf = buf.subarray(l);
            }
            return res;
        },
    };
}
// nano-packed.array (fixed size)
function vecCoder(c, vecLen) {
    const bytesLen = vecLen * c.bytesLen;
    return {
        bytesLen,
        encode: (u) => {
            if (u.length !== vecLen)
                throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < u.length; i++) {
                const b = c.encode(u[i]);
                res.set(b, pos);
                b.fill(0); // clean
                pos += b.length;
            }
            return res;
        },
        decode: (a) => {
            (0, exports.ensureBytes)(a, bytesLen);
            const r = [];
            for (let i = 0; i < a.length; i += c.bytesLen)
                r.push(c.decode(a.subarray(i, i + c.bytesLen)));
            return r;
        },
    };
}
// cleanBytes(new Uint8Array(), [new Uint16Array(), new Uint32Array()])
function cleanBytes(...list) {
    for (const t of list) {
        if (Array.isArray(t))
            for (const b of t)
                b.fill(0);
        else
            t.fill(0);
    }
}
function getMask(bits) {
    return (1 << bits) - 1; // 4 -> 0b1111
}
exports.EMPTY = new Uint8Array(0);
function getMessage(msg, ctx = exports.EMPTY) {
    (0, exports.ensureBytes)(msg);
    (0, exports.ensureBytes)(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    return (0, utils_1.concatBytes)(new Uint8Array([0, ctx.length]), ctx, msg);
}
// OIDS from https://csrc.nist.gov/projects/computer-security-objects-register/algorithm-registration
// TODO: maybe add 'OID' property to hashes themselves to improve tree-shaking?
const HASHES = {
    'SHA2-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040201'), hash: sha2_1.sha256 },
    'SHA2-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040202'), hash: sha2_1.sha384 },
    'SHA2-512': { oid: (0, utils_1.hexToBytes)('0609608648016503040203'), hash: sha2_1.sha512 },
    'SHA2-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040204'), hash: sha2_1.sha224 },
    'SHA2-512/224': { oid: (0, utils_1.hexToBytes)('0609608648016503040205'), hash: sha2_1.sha512_224 },
    'SHA2-512/256': { oid: (0, utils_1.hexToBytes)('0609608648016503040206'), hash: sha2_1.sha512_256 },
    'SHA3-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040207'), hash: sha3_1.sha3_224 },
    'SHA3-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040208'), hash: sha3_1.sha3_256 },
    'SHA3-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040209'), hash: sha3_1.sha3_384 },
    'SHA3-512': { oid: (0, utils_1.hexToBytes)('060960864801650304020A'), hash: sha3_1.sha3_512 },
    'SHAKE-128': {
        oid: (0, utils_1.hexToBytes)('060960864801650304020B'),
        hash: (msg) => (0, sha3_1.shake128)(msg, { dkLen: 32 }),
    },
    'SHAKE-256': {
        oid: (0, utils_1.hexToBytes)('060960864801650304020C'),
        hash: (msg) => (0, sha3_1.shake256)(msg, { dkLen: 64 }),
    },
};
function getMessagePrehash(hashName, msg, ctx = exports.EMPTY) {
    (0, exports.ensureBytes)(msg);
    (0, exports.ensureBytes)(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    if (!HASHES[hashName])
        throw new Error('unknown hash: ' + hashName);
    const { oid, hash } = HASHES[hashName];
    const hashed = hash(msg);
    return (0, utils_1.concatBytes)(new Uint8Array([1, ctx.length]), ctx, oid, hashed);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attribute.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attribute.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class Attribute {
    constructor(params = {}) {
        this.attrType = "";
        this.attrValues = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], Attribute.prototype, "attrType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, repeated: "set" })
], Attribute.prototype, "attrValues", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attributes.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attributes.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CounterSignature: () => (/* binding */ CounterSignature),
/* harmony export */   SigningTime: () => (/* binding */ SigningTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _signer_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signer_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js");




let SigningTime = class SigningTime extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Time {
};
SigningTime = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], SigningTime);

let CounterSignature = class CounterSignature extends _signer_info__WEBPACK_IMPORTED_MODULE_2__.SignerInfo {
};
CounterSignature = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], CounterSignature);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificateChoices: () => (/* binding */ CertificateChoices),
/* harmony export */   CertificateSet: () => (/* binding */ CertificateSet),
/* harmony export */   OtherCertificateFormat: () => (/* binding */ OtherCertificateFormat)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509_attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-x509-attr */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/index.js");
var CertificateSet_1;




class OtherCertificateFormat {
    constructor(params = {}) {
        this.otherCertFormat = "";
        this.otherCert = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], OtherCertificateFormat.prototype, "otherCertFormat", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], OtherCertificateFormat.prototype, "otherCert", void 0);
let CertificateChoices = class CertificateChoices {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Certificate })
], CertificateChoices.prototype, "certificate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509_attr__WEBPACK_IMPORTED_MODULE_2__.AttributeCertificate, context: 2, implicit: true })
], CertificateChoices.prototype, "v2AttrCert", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OtherCertificateFormat, context: 3, implicit: true })
], CertificateChoices.prototype, "other", void 0);
CertificateChoices = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], CertificateChoices);

let CertificateSet = CertificateSet_1 = class CertificateSet extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificateSet_1.prototype);
    }
};
CertificateSet = CertificateSet_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: CertificateChoices })
], CertificateSet);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/content_info.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/content_info.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentInfo: () => (/* binding */ ContentInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class ContentInfo {
    constructor(params = {}) {
        this.contentType = "";
        this.content = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], ContentInfo.prototype, "contentType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], ContentInfo.prototype, "content", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncapsulatedContent: () => (/* binding */ EncapsulatedContent),
/* harmony export */   EncapsulatedContentInfo: () => (/* binding */ EncapsulatedContentInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


let EncapsulatedContent = class EncapsulatedContent {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], EncapsulatedContent.prototype, "single", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], EncapsulatedContent.prototype, "any", void 0);
EncapsulatedContent = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], EncapsulatedContent);

class EncapsulatedContentInfo {
    constructor(params = {}) {
        this.eContentType = "";
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], EncapsulatedContentInfo.prototype, "eContentType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: EncapsulatedContent, context: 0, optional: true })
], EncapsulatedContentInfo.prototype, "eContent", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncryptedContent: () => (/* binding */ EncryptedContent),
/* harmony export */   EncryptedContentInfo: () => (/* binding */ EncryptedContentInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");



let EncryptedContent = class EncryptedContent {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString, context: 0, implicit: true, optional: true })
], EncryptedContent.prototype, "value", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString,
        converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConstructedOctetStringConverter,
        context: 0,
        implicit: true,
        optional: true,
        repeated: "sequence",
    })
], EncryptedContent.prototype, "constructedValue", void 0);
EncryptedContent = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], EncryptedContent);

class EncryptedContentInfo {
    constructor(params = {}) {
        this.contentType = "";
        this.contentEncryptionAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_1__.ContentEncryptionAlgorithmIdentifier();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], EncryptedContentInfo.prototype, "contentType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_1__.ContentEncryptionAlgorithmIdentifier })
], EncryptedContentInfo.prototype, "contentEncryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: EncryptedContent, optional: true })
], EncryptedContentInfo.prototype, "encryptedContent", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvelopedData: () => (/* binding */ EnvelopedData),
/* harmony export */   UnprotectedAttributes: () => (/* binding */ UnprotectedAttributes)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attribute.js");
/* harmony import */ var _recipient_infos__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recipient_infos */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js");
/* harmony import */ var _originator_info__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./originator_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js");
/* harmony import */ var _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./encrypted_content_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js");
var UnprotectedAttributes_1;







let UnprotectedAttributes = UnprotectedAttributes_1 = class UnprotectedAttributes extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, UnprotectedAttributes_1.prototype);
    }
};
UnprotectedAttributes = UnprotectedAttributes_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: _attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute })
], UnprotectedAttributes);

class EnvelopedData {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_1__.CMSVersion.v0;
        this.recipientInfos = new _recipient_infos__WEBPACK_IMPORTED_MODULE_3__.RecipientInfos();
        this.encryptedContentInfo = new _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__.EncryptedContentInfo();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], EnvelopedData.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _originator_info__WEBPACK_IMPORTED_MODULE_4__.OriginatorInfo, context: 0, implicit: true, optional: true })
], EnvelopedData.prototype, "originatorInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _recipient_infos__WEBPACK_IMPORTED_MODULE_3__.RecipientInfos })
], EnvelopedData.prototype, "recipientInfos", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__.EncryptedContentInfo })
], EnvelopedData.prototype, "encryptedContentInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: UnprotectedAttributes, context: 1, implicit: true, optional: true })
], EnvelopedData.prototype, "unprotectedAttrs", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* reexport safe */ _attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute),
/* harmony export */   CMSVersion: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.CMSVersion),
/* harmony export */   CertificateChoices: () => (/* reexport safe */ _certificate_choices__WEBPACK_IMPORTED_MODULE_2__.CertificateChoices),
/* harmony export */   CertificateSet: () => (/* reexport safe */ _certificate_choices__WEBPACK_IMPORTED_MODULE_2__.CertificateSet),
/* harmony export */   ContentEncryptionAlgorithmIdentifier: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.ContentEncryptionAlgorithmIdentifier),
/* harmony export */   ContentInfo: () => (/* reexport safe */ _content_info__WEBPACK_IMPORTED_MODULE_3__.ContentInfo),
/* harmony export */   CounterSignature: () => (/* reexport safe */ _attributes__WEBPACK_IMPORTED_MODULE_0__.CounterSignature),
/* harmony export */   DigestAlgorithmIdentifier: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.DigestAlgorithmIdentifier),
/* harmony export */   DigestAlgorithmIdentifiers: () => (/* reexport safe */ _signed_data__WEBPACK_IMPORTED_MODULE_17__.DigestAlgorithmIdentifiers),
/* harmony export */   EncapsulatedContent: () => (/* reexport safe */ _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_4__.EncapsulatedContent),
/* harmony export */   EncapsulatedContentInfo: () => (/* reexport safe */ _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_4__.EncapsulatedContentInfo),
/* harmony export */   EncryptedContent: () => (/* reexport safe */ _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__.EncryptedContent),
/* harmony export */   EncryptedContentInfo: () => (/* reexport safe */ _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__.EncryptedContentInfo),
/* harmony export */   EnvelopedData: () => (/* reexport safe */ _enveloped_data__WEBPACK_IMPORTED_MODULE_6__.EnvelopedData),
/* harmony export */   IssuerAndSerialNumber: () => (/* reexport safe */ _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_7__.IssuerAndSerialNumber),
/* harmony export */   KEKIdentifier: () => (/* reexport safe */ _kek_recipient_info__WEBPACK_IMPORTED_MODULE_8__.KEKIdentifier),
/* harmony export */   KEKRecipientInfo: () => (/* reexport safe */ _kek_recipient_info__WEBPACK_IMPORTED_MODULE_8__.KEKRecipientInfo),
/* harmony export */   KeyAgreeRecipientIdentifier: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.KeyAgreeRecipientIdentifier),
/* harmony export */   KeyAgreeRecipientInfo: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.KeyAgreeRecipientInfo),
/* harmony export */   KeyDerivationAlgorithmIdentifier: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.KeyDerivationAlgorithmIdentifier),
/* harmony export */   KeyEncryptionAlgorithmIdentifier: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.KeyEncryptionAlgorithmIdentifier),
/* harmony export */   KeyTransRecipientInfo: () => (/* reexport safe */ _key_trans_recipient_info__WEBPACK_IMPORTED_MODULE_10__.KeyTransRecipientInfo),
/* harmony export */   MessageAuthenticationCodeAlgorithm: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.MessageAuthenticationCodeAlgorithm),
/* harmony export */   OriginatorIdentifierOrKey: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.OriginatorIdentifierOrKey),
/* harmony export */   OriginatorInfo: () => (/* reexport safe */ _originator_info__WEBPACK_IMPORTED_MODULE_12__.OriginatorInfo),
/* harmony export */   OriginatorPublicKey: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.OriginatorPublicKey),
/* harmony export */   OtherCertificateFormat: () => (/* reexport safe */ _certificate_choices__WEBPACK_IMPORTED_MODULE_2__.OtherCertificateFormat),
/* harmony export */   OtherRecipientInfo: () => (/* reexport safe */ _recipient_info__WEBPACK_IMPORTED_MODULE_14__.OtherRecipientInfo),
/* harmony export */   OtherRevocationInfoFormat: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.OtherRevocationInfoFormat),
/* harmony export */   PasswordRecipientInfo: () => (/* reexport safe */ _password_recipient_info__WEBPACK_IMPORTED_MODULE_13__.PasswordRecipientInfo),
/* harmony export */   RecipientEncryptedKey: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.RecipientEncryptedKey),
/* harmony export */   RecipientEncryptedKeys: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.RecipientEncryptedKeys),
/* harmony export */   RecipientIdentifier: () => (/* reexport safe */ _key_trans_recipient_info__WEBPACK_IMPORTED_MODULE_10__.RecipientIdentifier),
/* harmony export */   RecipientInfo: () => (/* reexport safe */ _recipient_info__WEBPACK_IMPORTED_MODULE_14__.RecipientInfo),
/* harmony export */   RecipientInfos: () => (/* reexport safe */ _recipient_infos__WEBPACK_IMPORTED_MODULE_15__.RecipientInfos),
/* harmony export */   RecipientKeyIdentifier: () => (/* reexport safe */ _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__.RecipientKeyIdentifier),
/* harmony export */   RevocationInfoChoice: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.RevocationInfoChoice),
/* harmony export */   RevocationInfoChoices: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.RevocationInfoChoices),
/* harmony export */   SignatureAlgorithmIdentifier: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_20__.SignatureAlgorithmIdentifier),
/* harmony export */   SignedData: () => (/* reexport safe */ _signed_data__WEBPACK_IMPORTED_MODULE_17__.SignedData),
/* harmony export */   SignerIdentifier: () => (/* reexport safe */ _signer_identifier__WEBPACK_IMPORTED_MODULE_18__.SignerIdentifier),
/* harmony export */   SignerInfo: () => (/* reexport safe */ _signer_info__WEBPACK_IMPORTED_MODULE_19__.SignerInfo),
/* harmony export */   SignerInfos: () => (/* reexport safe */ _signer_info__WEBPACK_IMPORTED_MODULE_19__.SignerInfos),
/* harmony export */   SigningTime: () => (/* reexport safe */ _attributes__WEBPACK_IMPORTED_MODULE_0__.SigningTime),
/* harmony export */   UnprotectedAttributes: () => (/* reexport safe */ _enveloped_data__WEBPACK_IMPORTED_MODULE_6__.UnprotectedAttributes),
/* harmony export */   id_authData: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_authData),
/* harmony export */   id_ct_contentInfo: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_ct_contentInfo),
/* harmony export */   id_data: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_data),
/* harmony export */   id_digestedData: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_digestedData),
/* harmony export */   id_encryptedData: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_encryptedData),
/* harmony export */   id_envelopedData: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_envelopedData),
/* harmony export */   id_ri: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.id_ri),
/* harmony export */   id_ri_ocsp_response: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.id_ri_ocsp_response),
/* harmony export */   id_ri_scvp: () => (/* reexport safe */ _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__.id_ri_scvp),
/* harmony export */   id_signedData: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_11__.id_signedData)
/* harmony export */ });
/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributes */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attributes.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attribute.js");
/* harmony import */ var _certificate_choices__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./certificate_choices */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js");
/* harmony import */ var _content_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./content_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/content_info.js");
/* harmony import */ var _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./encapsulated_content_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js");
/* harmony import */ var _encrypted_content_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./encrypted_content_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js");
/* harmony import */ var _enveloped_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enveloped_data */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js");
/* harmony import */ var _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./issuer_and_serial_number */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js");
/* harmony import */ var _kek_recipient_info__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./kek_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js");
/* harmony import */ var _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./key_agree_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js");
/* harmony import */ var _key_trans_recipient_info__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./key_trans_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js");
/* harmony import */ var _originator_info__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./originator_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js");
/* harmony import */ var _password_recipient_info__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./password_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js");
/* harmony import */ var _recipient_info__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js");
/* harmony import */ var _recipient_infos__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./recipient_infos */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js");
/* harmony import */ var _revocation_info_choice__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./revocation_info_choice */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js");
/* harmony import */ var _signed_data__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./signed_data */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js");
/* harmony import */ var _signer_identifier__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./signer_identifier */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js");
/* harmony import */ var _signer_info__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./signer_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");























/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IssuerAndSerialNumber: () => (/* binding */ IssuerAndSerialNumber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class IssuerAndSerialNumber {
    constructor(params = {}) {
        this.issuer = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Name();
        this.serialNumber = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Name })
], IssuerAndSerialNumber.prototype, "issuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], IssuerAndSerialNumber.prototype, "serialNumber", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KEKIdentifier: () => (/* binding */ KEKIdentifier),
/* harmony export */   KEKRecipientInfo: () => (/* binding */ KEKRecipientInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _other_key_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./other_key_attribute */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");




class KEKIdentifier {
    constructor(params = {}) {
        this.keyIdentifier = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], KEKIdentifier.prototype, "keyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime, optional: true })
], KEKIdentifier.prototype, "date", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _other_key_attribute__WEBPACK_IMPORTED_MODULE_1__.OtherKeyAttribute, optional: true })
], KEKIdentifier.prototype, "other", void 0);
class KEKRecipientInfo {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_2__.CMSVersion.v4;
        this.kekid = new KEKIdentifier();
        this.keyEncryptionAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_2__.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], KEKRecipientInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: KEKIdentifier })
], KEKRecipientInfo.prototype, "kekid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_2__.KeyEncryptionAlgorithmIdentifier })
], KEKRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], KEKRecipientInfo.prototype, "encryptedKey", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyAgreeRecipientIdentifier: () => (/* binding */ KeyAgreeRecipientIdentifier),
/* harmony export */   KeyAgreeRecipientInfo: () => (/* binding */ KeyAgreeRecipientInfo),
/* harmony export */   OriginatorIdentifierOrKey: () => (/* binding */ OriginatorIdentifierOrKey),
/* harmony export */   OriginatorPublicKey: () => (/* binding */ OriginatorPublicKey),
/* harmony export */   RecipientEncryptedKey: () => (/* binding */ RecipientEncryptedKey),
/* harmony export */   RecipientEncryptedKeys: () => (/* binding */ RecipientEncryptedKeys),
/* harmony export */   RecipientKeyIdentifier: () => (/* binding */ RecipientKeyIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");
/* harmony import */ var _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./issuer_and_serial_number */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _other_key_attribute__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./other_key_attribute */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js");
var RecipientEncryptedKeys_1;






class RecipientKeyIdentifier {
    constructor(params = {}) {
        this.subjectKeyIdentifier = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.SubjectKeyIdentifier();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.SubjectKeyIdentifier })
], RecipientKeyIdentifier.prototype, "subjectKeyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime, optional: true })
], RecipientKeyIdentifier.prototype, "date", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _other_key_attribute__WEBPACK_IMPORTED_MODULE_4__.OtherKeyAttribute, optional: true })
], RecipientKeyIdentifier.prototype, "other", void 0);
let KeyAgreeRecipientIdentifier = class KeyAgreeRecipientIdentifier {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: RecipientKeyIdentifier, context: 0, implicit: true, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "rKeyId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_2__.IssuerAndSerialNumber, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
KeyAgreeRecipientIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], KeyAgreeRecipientIdentifier);

class RecipientEncryptedKey {
    constructor(params = {}) {
        this.rid = new KeyAgreeRecipientIdentifier();
        this.encryptedKey = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: KeyAgreeRecipientIdentifier })
], RecipientEncryptedKey.prototype, "rid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], RecipientEncryptedKey.prototype, "encryptedKey", void 0);
let RecipientEncryptedKeys = RecipientEncryptedKeys_1 = class RecipientEncryptedKeys extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RecipientEncryptedKeys_1.prototype);
    }
};
RecipientEncryptedKeys = RecipientEncryptedKeys_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: RecipientEncryptedKey })
], RecipientEncryptedKeys);

class OriginatorPublicKey {
    constructor(params = {}) {
        this.algorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.AlgorithmIdentifier })
], OriginatorPublicKey.prototype, "algorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], OriginatorPublicKey.prototype, "publicKey", void 0);
let OriginatorIdentifierOrKey = class OriginatorIdentifierOrKey {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.SubjectKeyIdentifier, context: 0, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "subjectKeyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OriginatorPublicKey, context: 1, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "originatorKey", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_2__.IssuerAndSerialNumber, optional: true })
], OriginatorIdentifierOrKey.prototype, "issuerAndSerialNumber", void 0);
OriginatorIdentifierOrKey = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], OriginatorIdentifierOrKey);

class KeyAgreeRecipientInfo {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_1__.CMSVersion.v3;
        this.originator = new OriginatorIdentifierOrKey();
        this.keyEncryptionAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier();
        this.recipientEncryptedKeys = new RecipientEncryptedKeys();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], KeyAgreeRecipientInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OriginatorIdentifierOrKey, context: 0 })
], KeyAgreeRecipientInfo.prototype, "originator", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString, context: 1, optional: true })
], KeyAgreeRecipientInfo.prototype, "ukm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier })
], KeyAgreeRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: RecipientEncryptedKeys })
], KeyAgreeRecipientInfo.prototype, "recipientEncryptedKeys", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyTransRecipientInfo: () => (/* binding */ KeyTransRecipientInfo),
/* harmony export */   RecipientIdentifier: () => (/* binding */ RecipientIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");
/* harmony import */ var _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./issuer_and_serial_number */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");





let RecipientIdentifier = class RecipientIdentifier {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_3__.SubjectKeyIdentifier, context: 0, implicit: true })
], RecipientIdentifier.prototype, "subjectKeyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_2__.IssuerAndSerialNumber })
], RecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
RecipientIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], RecipientIdentifier);

class KeyTransRecipientInfo {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_1__.CMSVersion.v0;
        this.rid = new RecipientIdentifier();
        this.keyEncryptionAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], KeyTransRecipientInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: RecipientIdentifier })
], KeyTransRecipientInfo.prototype, "rid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier })
], KeyTransRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], KeyTransRecipientInfo.prototype, "encryptedKey", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_authData: () => (/* binding */ id_authData),
/* harmony export */   id_ct_contentInfo: () => (/* binding */ id_ct_contentInfo),
/* harmony export */   id_data: () => (/* binding */ id_data),
/* harmony export */   id_digestedData: () => (/* binding */ id_digestedData),
/* harmony export */   id_encryptedData: () => (/* binding */ id_encryptedData),
/* harmony export */   id_envelopedData: () => (/* binding */ id_envelopedData),
/* harmony export */   id_signedData: () => (/* binding */ id_signedData)
/* harmony export */ });
const id_ct_contentInfo = "1.2.840.113549.1.9.16.1.6";
const id_data = "1.2.840.113549.1.7.1";
const id_signedData = "1.2.840.113549.1.7.2";
const id_envelopedData = "1.2.840.113549.1.7.3";
const id_digestedData = "1.2.840.113549.1.7.5";
const id_encryptedData = "1.2.840.113549.1.7.6";
const id_authData = "1.2.840.113549.1.9.16.1.2";


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OriginatorInfo: () => (/* binding */ OriginatorInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _certificate_choices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./certificate_choices */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js");
/* harmony import */ var _revocation_info_choice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./revocation_info_choice */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js");




class OriginatorInfo {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _certificate_choices__WEBPACK_IMPORTED_MODULE_1__.CertificateSet, context: 0, implicit: true, optional: true })
], OriginatorInfo.prototype, "certs", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _revocation_info_choice__WEBPACK_IMPORTED_MODULE_2__.RevocationInfoChoices, context: 1, implicit: true, optional: true })
], OriginatorInfo.prototype, "crls", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OtherKeyAttribute: () => (/* binding */ OtherKeyAttribute)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class OtherKeyAttribute {
    constructor(params = {}) {
        this.keyAttrId = "";
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], OtherKeyAttribute.prototype, "keyAttrId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, optional: true })
], OtherKeyAttribute.prototype, "keyAttr", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PasswordRecipientInfo: () => (/* binding */ PasswordRecipientInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");



class PasswordRecipientInfo {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_1__.CMSVersion.v0;
        this.keyEncryptionAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], PasswordRecipientInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_1__.KeyDerivationAlgorithmIdentifier, context: 0, optional: true })
], PasswordRecipientInfo.prototype, "keyDerivationAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_1__.KeyEncryptionAlgorithmIdentifier })
], PasswordRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], PasswordRecipientInfo.prototype, "encryptedKey", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OtherRecipientInfo: () => (/* binding */ OtherRecipientInfo),
/* harmony export */   RecipientInfo: () => (/* binding */ RecipientInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./key_agree_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js");
/* harmony import */ var _key_trans_recipient_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./key_trans_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js");
/* harmony import */ var _kek_recipient_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./kek_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js");
/* harmony import */ var _password_recipient_info__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./password_recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js");






class OtherRecipientInfo {
    constructor(params = {}) {
        this.oriType = "";
        this.oriValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], OtherRecipientInfo.prototype, "oriType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], OtherRecipientInfo.prototype, "oriValue", void 0);
let RecipientInfo = class RecipientInfo {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _key_trans_recipient_info__WEBPACK_IMPORTED_MODULE_2__.KeyTransRecipientInfo, optional: true })
], RecipientInfo.prototype, "ktri", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _key_agree_recipient_info__WEBPACK_IMPORTED_MODULE_1__.KeyAgreeRecipientInfo, context: 1, implicit: true, optional: true })
], RecipientInfo.prototype, "kari", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _kek_recipient_info__WEBPACK_IMPORTED_MODULE_3__.KEKRecipientInfo, context: 2, implicit: true, optional: true })
], RecipientInfo.prototype, "kekri", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _password_recipient_info__WEBPACK_IMPORTED_MODULE_4__.PasswordRecipientInfo, context: 3, implicit: true, optional: true })
], RecipientInfo.prototype, "pwri", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OtherRecipientInfo, context: 4, implicit: true, optional: true })
], RecipientInfo.prototype, "ori", void 0);
RecipientInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], RecipientInfo);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RecipientInfos: () => (/* binding */ RecipientInfos)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _recipient_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./recipient_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js");
var RecipientInfos_1;



let RecipientInfos = RecipientInfos_1 = class RecipientInfos extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RecipientInfos_1.prototype);
    }
};
RecipientInfos = RecipientInfos_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: _recipient_info__WEBPACK_IMPORTED_MODULE_1__.RecipientInfo })
], RecipientInfos);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OtherRevocationInfoFormat: () => (/* binding */ OtherRevocationInfoFormat),
/* harmony export */   RevocationInfoChoice: () => (/* binding */ RevocationInfoChoice),
/* harmony export */   RevocationInfoChoices: () => (/* binding */ RevocationInfoChoices),
/* harmony export */   id_ri: () => (/* binding */ id_ri),
/* harmony export */   id_ri_ocsp_response: () => (/* binding */ id_ri_ocsp_response),
/* harmony export */   id_ri_scvp: () => (/* binding */ id_ri_scvp)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
var RevocationInfoChoices_1;



const id_ri = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.id_pkix}.16`;
const id_ri_ocsp_response = `${id_ri}.2`;
const id_ri_scvp = `${id_ri}.4`;
class OtherRevocationInfoFormat {
    constructor(params = {}) {
        this.otherRevInfoFormat = "";
        this.otherRevInfo = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], OtherRevocationInfoFormat.prototype, "otherRevInfoFormat", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], OtherRevocationInfoFormat.prototype, "otherRevInfo", void 0);
let RevocationInfoChoice = class RevocationInfoChoice {
    constructor(params = {}) {
        this.other = new OtherRevocationInfoFormat();
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OtherRevocationInfoFormat, context: 1, implicit: true })
], RevocationInfoChoice.prototype, "other", void 0);
RevocationInfoChoice = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], RevocationInfoChoice);

let RevocationInfoChoices = RevocationInfoChoices_1 = class RevocationInfoChoices extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RevocationInfoChoices_1.prototype);
    }
};
RevocationInfoChoices = RevocationInfoChoices_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: RevocationInfoChoice })
], RevocationInfoChoices);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DigestAlgorithmIdentifiers: () => (/* binding */ DigestAlgorithmIdentifiers),
/* harmony export */   SignedData: () => (/* binding */ SignedData)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _certificate_choices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./certificate_choices */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");
/* harmony import */ var _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./encapsulated_content_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js");
/* harmony import */ var _revocation_info_choice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./revocation_info_choice */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js");
/* harmony import */ var _signer_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./signer_info */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js");
var DigestAlgorithmIdentifiers_1;







let DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = class DigestAlgorithmIdentifiers extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, DigestAlgorithmIdentifiers_1.prototype);
    }
};
DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: _types__WEBPACK_IMPORTED_MODULE_2__.DigestAlgorithmIdentifier })
], DigestAlgorithmIdentifiers);

class SignedData {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_2__.CMSVersion.v0;
        this.digestAlgorithms = new DigestAlgorithmIdentifiers();
        this.encapContentInfo = new _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_3__.EncapsulatedContentInfo();
        this.signerInfos = new _signer_info__WEBPACK_IMPORTED_MODULE_5__.SignerInfos();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], SignedData.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: DigestAlgorithmIdentifiers })
], SignedData.prototype, "digestAlgorithms", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _encapsulated_content_info__WEBPACK_IMPORTED_MODULE_3__.EncapsulatedContentInfo })
], SignedData.prototype, "encapContentInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _certificate_choices__WEBPACK_IMPORTED_MODULE_1__.CertificateSet, context: 0, implicit: true, optional: true })
], SignedData.prototype, "certificates", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _revocation_info_choice__WEBPACK_IMPORTED_MODULE_4__.RevocationInfoChoices, context: 1, implicit: true, optional: true })
], SignedData.prototype, "crls", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _signer_info__WEBPACK_IMPORTED_MODULE_5__.SignerInfos })
], SignedData.prototype, "signerInfos", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SignerIdentifier: () => (/* binding */ SignerIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./issuer_and_serial_number */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");




let SignerIdentifier = class SignerIdentifier {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectKeyIdentifier, context: 0, implicit: true })
], SignerIdentifier.prototype, "subjectKeyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_and_serial_number__WEBPACK_IMPORTED_MODULE_1__.IssuerAndSerialNumber })
], SignerIdentifier.prototype, "issuerAndSerialNumber", void 0);
SignerIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], SignerIdentifier);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SignerInfo: () => (/* binding */ SignerInfo),
/* harmony export */   SignerInfos: () => (/* binding */ SignerInfos)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _signer_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signer_identifier */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/attribute.js");
var SignerInfos_1;





class SignerInfo {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_2__.CMSVersion.v0;
        this.sid = new _signer_identifier__WEBPACK_IMPORTED_MODULE_1__.SignerIdentifier();
        this.digestAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_2__.DigestAlgorithmIdentifier();
        this.signatureAlgorithm = new _types__WEBPACK_IMPORTED_MODULE_2__.SignatureAlgorithmIdentifier();
        this.signature = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], SignerInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _signer_identifier__WEBPACK_IMPORTED_MODULE_1__.SignerIdentifier })
], SignerInfo.prototype, "sid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_2__.DigestAlgorithmIdentifier })
], SignerInfo.prototype, "digestAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attribute__WEBPACK_IMPORTED_MODULE_3__.Attribute, repeated: "set", context: 0, implicit: true, optional: true })
], SignerInfo.prototype, "signedAttrs", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _types__WEBPACK_IMPORTED_MODULE_2__.SignatureAlgorithmIdentifier })
], SignerInfo.prototype, "signatureAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], SignerInfo.prototype, "signature", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attribute__WEBPACK_IMPORTED_MODULE_3__.Attribute, repeated: "set", context: 1, implicit: true, optional: true })
], SignerInfo.prototype, "unsignedAttrs", void 0);
let SignerInfos = SignerInfos_1 = class SignerInfos extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SignerInfos_1.prototype);
    }
};
SignerInfos = SignerInfos_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: SignerInfo })
], SignerInfos);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/types.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CMSVersion: () => (/* binding */ CMSVersion),
/* harmony export */   ContentEncryptionAlgorithmIdentifier: () => (/* binding */ ContentEncryptionAlgorithmIdentifier),
/* harmony export */   DigestAlgorithmIdentifier: () => (/* binding */ DigestAlgorithmIdentifier),
/* harmony export */   KeyDerivationAlgorithmIdentifier: () => (/* binding */ KeyDerivationAlgorithmIdentifier),
/* harmony export */   KeyEncryptionAlgorithmIdentifier: () => (/* binding */ KeyEncryptionAlgorithmIdentifier),
/* harmony export */   MessageAuthenticationCodeAlgorithm: () => (/* binding */ MessageAuthenticationCodeAlgorithm),
/* harmony export */   SignatureAlgorithmIdentifier: () => (/* binding */ SignatureAlgorithmIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");



var CMSVersion;
(function (CMSVersion) {
    CMSVersion[CMSVersion["v0"] = 0] = "v0";
    CMSVersion[CMSVersion["v1"] = 1] = "v1";
    CMSVersion[CMSVersion["v2"] = 2] = "v2";
    CMSVersion[CMSVersion["v3"] = 3] = "v3";
    CMSVersion[CMSVersion["v4"] = 4] = "v4";
    CMSVersion[CMSVersion["v5"] = 5] = "v5";
})(CMSVersion || (CMSVersion = {}));
let DigestAlgorithmIdentifier = class DigestAlgorithmIdentifier extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
DigestAlgorithmIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], DigestAlgorithmIdentifier);

let SignatureAlgorithmIdentifier = class SignatureAlgorithmIdentifier extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
SignatureAlgorithmIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], SignatureAlgorithmIdentifier);

let KeyEncryptionAlgorithmIdentifier = class KeyEncryptionAlgorithmIdentifier extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
KeyEncryptionAlgorithmIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], KeyEncryptionAlgorithmIdentifier);

let ContentEncryptionAlgorithmIdentifier = class ContentEncryptionAlgorithmIdentifier extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
ContentEncryptionAlgorithmIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], ContentEncryptionAlgorithmIdentifier);

let MessageAuthenticationCodeAlgorithm = class MessageAuthenticationCodeAlgorithm extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
MessageAuthenticationCodeAlgorithm = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], MessageAuthenticationCodeAlgorithm);

let KeyDerivationAlgorithmIdentifier = class KeyDerivationAlgorithmIdentifier extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier {
};
KeyDerivationAlgorithmIdentifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], KeyDerivationAlgorithmIdentifier);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/attributes.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/attributes.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attributes: () => (/* binding */ Attributes)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
var Attributes_1;



let Attributes = Attributes_1 = class Attributes extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Attributes_1.prototype);
    }
};
Attributes = Attributes_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Attribute })
], Attributes);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificationRequest: () => (/* binding */ CertificationRequest)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _certification_request_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./certification_request_info */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");




class CertificationRequest {
    constructor(params = {}) {
        this.certificationRequestInfo = new _certification_request_info__WEBPACK_IMPORTED_MODULE_1__.CertificationRequestInfo();
        this.signatureAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier();
        this.signature = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _certification_request_info__WEBPACK_IMPORTED_MODULE_1__.CertificationRequestInfo })
], CertificationRequest.prototype, "certificationRequestInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier })
], CertificationRequest.prototype, "signatureAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], CertificationRequest.prototype, "signature", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificationRequestInfo: () => (/* binding */ CertificationRequestInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attributes */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/attributes.js");




class CertificationRequestInfo {
    constructor(params = {}) {
        this.version = 0;
        this.subject = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Name();
        this.subjectPKInfo = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.SubjectPublicKeyInfo();
        this.attributes = new _attributes__WEBPACK_IMPORTED_MODULE_2__.Attributes();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], CertificationRequestInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Name })
], CertificationRequestInfo.prototype, "subject", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.SubjectPublicKeyInfo })
], CertificationRequestInfo.prototype, "subjectPKInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attributes__WEBPACK_IMPORTED_MODULE_2__.Attributes, implicit: true, context: 0 })
], CertificationRequestInfo.prototype, "attributes", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attributes: () => (/* reexport safe */ _attributes__WEBPACK_IMPORTED_MODULE_0__.Attributes),
/* harmony export */   CertificationRequest: () => (/* reexport safe */ _certification_request__WEBPACK_IMPORTED_MODULE_1__.CertificationRequest),
/* harmony export */   CertificationRequestInfo: () => (/* reexport safe */ _certification_request_info__WEBPACK_IMPORTED_MODULE_2__.CertificationRequestInfo)
/* harmony export */ });
/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributes */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/attributes.js");
/* harmony import */ var _certification_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./certification_request */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js");
/* harmony import */ var _certification_request_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./certification_request_info */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js");





/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ecdsaWithSHA1: () => (/* binding */ ecdsaWithSHA1),
/* harmony export */   ecdsaWithSHA224: () => (/* binding */ ecdsaWithSHA224),
/* harmony export */   ecdsaWithSHA256: () => (/* binding */ ecdsaWithSHA256),
/* harmony export */   ecdsaWithSHA384: () => (/* binding */ ecdsaWithSHA384),
/* harmony export */   ecdsaWithSHA512: () => (/* binding */ ecdsaWithSHA512)
/* harmony export */ });
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js");


function create(algorithm) {
    return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier({ algorithm });
}
const ecdsaWithSHA1 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ecdsaWithSHA1);
const ecdsaWithSHA224 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ecdsaWithSHA224);
const ecdsaWithSHA256 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ecdsaWithSHA256);
const ecdsaWithSHA384 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ecdsaWithSHA384);
const ecdsaWithSHA512 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ecdsaWithSHA512);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ECParameters: () => (/* binding */ ECParameters)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _rfc3279__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rfc3279 */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js");



let ECParameters = class ECParameters {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], ECParameters.prototype, "namedCurve", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Null })
], ECParameters.prototype, "implicitCurve", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _rfc3279__WEBPACK_IMPORTED_MODULE_1__.SpecifiedECDomain })
], ECParameters.prototype, "specifiedCurve", void 0);
ECParameters = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], ECParameters);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ECPrivateKey: () => (/* binding */ ECPrivateKey)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _ec_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ec_parameters */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js");



class ECPrivateKey {
    constructor(params = {}) {
        this.version = 1;
        this.privateKey = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], ECPrivateKey.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], ECPrivateKey.prototype, "privateKey", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _ec_parameters__WEBPACK_IMPORTED_MODULE_1__.ECParameters, context: 0, optional: true })
], ECPrivateKey.prototype, "parameters", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString, context: 1, optional: true })
], ECPrivateKey.prototype, "publicKey", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ECDSASigValue: () => (/* binding */ ECDSASigValue)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class ECDSASigValue {
    constructor(params = {}) {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "r", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "s", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Curve: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.Curve),
/* harmony export */   ECDSASigValue: () => (/* reexport safe */ _ec_signature_value__WEBPACK_IMPORTED_MODULE_3__.ECDSASigValue),
/* harmony export */   ECPVer: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.ECPVer),
/* harmony export */   ECParameters: () => (/* reexport safe */ _ec_parameters__WEBPACK_IMPORTED_MODULE_1__.ECParameters),
/* harmony export */   ECPoint: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.ECPoint),
/* harmony export */   ECPrivateKey: () => (/* reexport safe */ _ec_private_key__WEBPACK_IMPORTED_MODULE_2__.ECPrivateKey),
/* harmony export */   FieldElement: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.FieldElement),
/* harmony export */   FieldID: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.FieldID),
/* harmony export */   SpecifiedECDomain: () => (/* reexport safe */ _rfc3279__WEBPACK_IMPORTED_MODULE_5__.SpecifiedECDomain),
/* harmony export */   ecdsaWithSHA1: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_0__.ecdsaWithSHA1),
/* harmony export */   ecdsaWithSHA224: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_0__.ecdsaWithSHA224),
/* harmony export */   ecdsaWithSHA256: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_0__.ecdsaWithSHA256),
/* harmony export */   ecdsaWithSHA384: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_0__.ecdsaWithSHA384),
/* harmony export */   ecdsaWithSHA512: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_0__.ecdsaWithSHA512),
/* harmony export */   id_ecDH: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecDH),
/* harmony export */   id_ecMQV: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecMQV),
/* harmony export */   id_ecPublicKey: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecPublicKey),
/* harmony export */   id_ecdsaWithSHA1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecdsaWithSHA1),
/* harmony export */   id_ecdsaWithSHA224: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecdsaWithSHA224),
/* harmony export */   id_ecdsaWithSHA256: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecdsaWithSHA256),
/* harmony export */   id_ecdsaWithSHA384: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecdsaWithSHA384),
/* harmony export */   id_ecdsaWithSHA512: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_ecdsaWithSHA512),
/* harmony export */   id_secp192r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_secp192r1),
/* harmony export */   id_secp224r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_secp224r1),
/* harmony export */   id_secp256r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_secp256r1),
/* harmony export */   id_secp384r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_secp384r1),
/* harmony export */   id_secp521r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_secp521r1),
/* harmony export */   id_sect163k1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect163k1),
/* harmony export */   id_sect163r2: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect163r2),
/* harmony export */   id_sect233k1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect233k1),
/* harmony export */   id_sect233r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect233r1),
/* harmony export */   id_sect283k1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect283k1),
/* harmony export */   id_sect283r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect283r1),
/* harmony export */   id_sect409k1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect409k1),
/* harmony export */   id_sect409r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect409r1),
/* harmony export */   id_sect571k1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect571k1),
/* harmony export */   id_sect571r1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_sect571r1)
/* harmony export */ });
/* harmony import */ var _algorithms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js");
/* harmony import */ var _ec_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ec_parameters */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js");
/* harmony import */ var _ec_private_key__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ec_private_key */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js");
/* harmony import */ var _ec_signature_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ec_signature_value */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js");
/* harmony import */ var _rfc3279__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rfc3279 */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js");








/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_ecDH: () => (/* binding */ id_ecDH),
/* harmony export */   id_ecMQV: () => (/* binding */ id_ecMQV),
/* harmony export */   id_ecPublicKey: () => (/* binding */ id_ecPublicKey),
/* harmony export */   id_ecdsaWithSHA1: () => (/* binding */ id_ecdsaWithSHA1),
/* harmony export */   id_ecdsaWithSHA224: () => (/* binding */ id_ecdsaWithSHA224),
/* harmony export */   id_ecdsaWithSHA256: () => (/* binding */ id_ecdsaWithSHA256),
/* harmony export */   id_ecdsaWithSHA384: () => (/* binding */ id_ecdsaWithSHA384),
/* harmony export */   id_ecdsaWithSHA512: () => (/* binding */ id_ecdsaWithSHA512),
/* harmony export */   id_secp192r1: () => (/* binding */ id_secp192r1),
/* harmony export */   id_secp224r1: () => (/* binding */ id_secp224r1),
/* harmony export */   id_secp256r1: () => (/* binding */ id_secp256r1),
/* harmony export */   id_secp384r1: () => (/* binding */ id_secp384r1),
/* harmony export */   id_secp521r1: () => (/* binding */ id_secp521r1),
/* harmony export */   id_sect163k1: () => (/* binding */ id_sect163k1),
/* harmony export */   id_sect163r2: () => (/* binding */ id_sect163r2),
/* harmony export */   id_sect233k1: () => (/* binding */ id_sect233k1),
/* harmony export */   id_sect233r1: () => (/* binding */ id_sect233r1),
/* harmony export */   id_sect283k1: () => (/* binding */ id_sect283k1),
/* harmony export */   id_sect283r1: () => (/* binding */ id_sect283r1),
/* harmony export */   id_sect409k1: () => (/* binding */ id_sect409k1),
/* harmony export */   id_sect409r1: () => (/* binding */ id_sect409r1),
/* harmony export */   id_sect571k1: () => (/* binding */ id_sect571k1),
/* harmony export */   id_sect571r1: () => (/* binding */ id_sect571r1)
/* harmony export */ });
const id_ecPublicKey = "1.2.840.10045.2.1";
const id_ecDH = "1.3.132.1.12";
const id_ecMQV = "1.3.132.1.13";
const id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
const id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
const id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
const id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
const id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
const id_secp192r1 = "1.2.840.10045.3.1.1";
const id_sect163k1 = "1.3.132.0.1";
const id_sect163r2 = "1.3.132.0.15";
const id_secp224r1 = "1.3.132.0.33";
const id_sect233k1 = "1.3.132.0.26";
const id_sect233r1 = "1.3.132.0.27";
const id_secp256r1 = "1.2.840.10045.3.1.7";
const id_sect283k1 = "1.3.132.0.16";
const id_sect283r1 = "1.3.132.0.17";
const id_secp384r1 = "1.3.132.0.34";
const id_sect409k1 = "1.3.132.0.36";
const id_sect409r1 = "1.3.132.0.37";
const id_secp521r1 = "1.3.132.0.35";
const id_sect571k1 = "1.3.132.0.38";
const id_sect571r1 = "1.3.132.0.39";


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Curve: () => (/* binding */ Curve),
/* harmony export */   ECPVer: () => (/* binding */ ECPVer),
/* harmony export */   ECPoint: () => (/* binding */ ECPoint),
/* harmony export */   FieldElement: () => (/* binding */ FieldElement),
/* harmony export */   FieldID: () => (/* binding */ FieldID),
/* harmony export */   SpecifiedECDomain: () => (/* binding */ SpecifiedECDomain)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


let FieldID = class FieldID {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], FieldID.prototype, "fieldType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], FieldID.prototype, "parameters", void 0);
FieldID = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], FieldID);

class ECPoint extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
class FieldElement extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
let Curve = class Curve {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.OctetString })
], Curve.prototype, "a", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.OctetString })
], Curve.prototype, "b", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString, optional: true })
], Curve.prototype, "seed", void 0);
Curve = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], Curve);

var ECPVer;
(function (ECPVer) {
    ECPVer[ECPVer["ecpVer1"] = 1] = "ecpVer1";
})(ECPVer || (ECPVer = {}));
let SpecifiedECDomain = class SpecifiedECDomain {
    constructor(params = {}) {
        this.version = ECPVer.ecpVer1;
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], SpecifiedECDomain.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: FieldID })
], SpecifiedECDomain.prototype, "fieldID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: Curve })
], SpecifiedECDomain.prototype, "curve", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: ECPoint })
], SpecifiedECDomain.prototype, "base", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], SpecifiedECDomain.prototype, "order", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, optional: true })
], SpecifiedECDomain.prototype, "cofactor", void 0);
SpecifiedECDomain = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], SpecifiedECDomain);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PKCS12AttrSet: () => (/* binding */ PKCS12AttrSet),
/* harmony export */   PKCS12Attribute: () => (/* binding */ PKCS12Attribute)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
var PKCS12AttrSet_1;


class PKCS12Attribute {
    constructor(params = {}) {
        this.attrId = "";
        this.attrValues = [];
        Object.assign(params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], PKCS12Attribute.prototype, "attrId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, repeated: "set" })
], PKCS12Attribute.prototype, "attrValues", void 0);
let PKCS12AttrSet = PKCS12AttrSet_1 = class PKCS12AttrSet extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, PKCS12AttrSet_1.prototype);
    }
};
PKCS12AttrSet = PKCS12AttrSet_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: PKCS12Attribute })
], PKCS12AttrSet);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthenticatedSafe: () => (/* binding */ AuthenticatedSafe)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-cms */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js");
var AuthenticatedSafe_1;



let AuthenticatedSafe = AuthenticatedSafe_1 = class AuthenticatedSafe extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AuthenticatedSafe_1.prototype);
    }
};
AuthenticatedSafe = AuthenticatedSafe_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.ContentInfo })
], AuthenticatedSafe);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertBag: () => (/* binding */ CertBag),
/* harmony export */   id_certTypes: () => (/* binding */ id_certTypes),
/* harmony export */   id_sdsiCertificate: () => (/* binding */ id_sdsiCertificate),
/* harmony export */   id_x509Certificate: () => (/* binding */ id_x509Certificate)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js");



class CertBag {
    constructor(params = {}) {
        this.certId = "";
        this.certValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], CertBag.prototype, "certId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], CertBag.prototype, "certValue", void 0);
const id_certTypes = `${_types__WEBPACK_IMPORTED_MODULE_1__.id_pkcs_9}.22`;
const id_x509Certificate = `${id_certTypes}.1`;
const id_sdsiCertificate = `${id_certTypes}.2`;


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRLBag: () => (/* binding */ CRLBag),
/* harmony export */   id_crlTypes: () => (/* binding */ id_crlTypes),
/* harmony export */   id_x509CRL: () => (/* binding */ id_x509CRL)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js");



class CRLBag {
    constructor(params = {}) {
        this.crlId = "";
        this.crltValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], CRLBag.prototype, "crlId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], CRLBag.prototype, "crltValue", void 0);
const id_crlTypes = `${_types__WEBPACK_IMPORTED_MODULE_1__.id_pkcs_9}.23`;
const id_x509CRL = `${id_crlTypes}.1`;


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRLBag: () => (/* reexport safe */ _crl_bag__WEBPACK_IMPORTED_MODULE_1__.CRLBag),
/* harmony export */   CertBag: () => (/* reexport safe */ _cert_bag__WEBPACK_IMPORTED_MODULE_0__.CertBag),
/* harmony export */   KeyBag: () => (/* reexport safe */ _key_bag__WEBPACK_IMPORTED_MODULE_2__.KeyBag),
/* harmony export */   PKCS8ShroudedKeyBag: () => (/* reexport safe */ _pkcs8_shrouded_key_bag__WEBPACK_IMPORTED_MODULE_3__.PKCS8ShroudedKeyBag),
/* harmony export */   SecretBag: () => (/* reexport safe */ _secret_bag__WEBPACK_IMPORTED_MODULE_4__.SecretBag),
/* harmony export */   id_CRLBag: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_CRLBag),
/* harmony export */   id_SafeContents: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_SafeContents),
/* harmony export */   id_SecretBag: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_SecretBag),
/* harmony export */   id_certBag: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_certBag),
/* harmony export */   id_certTypes: () => (/* reexport safe */ _cert_bag__WEBPACK_IMPORTED_MODULE_0__.id_certTypes),
/* harmony export */   id_crlTypes: () => (/* reexport safe */ _crl_bag__WEBPACK_IMPORTED_MODULE_1__.id_crlTypes),
/* harmony export */   id_keyBag: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_keyBag),
/* harmony export */   id_pkcs8ShroudedKeyBag: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_pkcs8ShroudedKeyBag),
/* harmony export */   id_pkcs_9: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.id_pkcs_9),
/* harmony export */   id_sdsiCertificate: () => (/* reexport safe */ _cert_bag__WEBPACK_IMPORTED_MODULE_0__.id_sdsiCertificate),
/* harmony export */   id_x509CRL: () => (/* reexport safe */ _crl_bag__WEBPACK_IMPORTED_MODULE_1__.id_x509CRL),
/* harmony export */   id_x509Certificate: () => (/* reexport safe */ _cert_bag__WEBPACK_IMPORTED_MODULE_0__.id_x509Certificate)
/* harmony export */ });
/* harmony import */ var _cert_bag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cert_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js");
/* harmony import */ var _crl_bag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crl_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js");
/* harmony import */ var _key_bag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./key_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js");
/* harmony import */ var _pkcs8_shrouded_key_bag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pkcs8_shrouded_key_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js");
/* harmony import */ var _secret_bag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./secret_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js");








/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyBag: () => (/* binding */ KeyBag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-pkcs8 */ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");



let KeyBag = class KeyBag extends _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyInfo {
};
KeyBag = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], KeyBag);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PKCS8ShroudedKeyBag: () => (/* binding */ PKCS8ShroudedKeyBag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-pkcs8 */ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");



let PKCS8ShroudedKeyBag = class PKCS8ShroudedKeyBag extends _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_0__.EncryptedPrivateKeyInfo {
};
PKCS8ShroudedKeyBag = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence })
], PKCS8ShroudedKeyBag);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretBag: () => (/* binding */ SecretBag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class SecretBag {
    constructor(params = {}) {
        this.secretTypeId = "";
        this.secretValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], SecretBag.prototype, "secretTypeId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], SecretBag.prototype, "secretValue", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_CRLBag: () => (/* binding */ id_CRLBag),
/* harmony export */   id_SafeContents: () => (/* binding */ id_SafeContents),
/* harmony export */   id_SecretBag: () => (/* binding */ id_SecretBag),
/* harmony export */   id_certBag: () => (/* binding */ id_certBag),
/* harmony export */   id_keyBag: () => (/* binding */ id_keyBag),
/* harmony export */   id_pkcs8ShroudedKeyBag: () => (/* binding */ id_pkcs8ShroudedKeyBag),
/* harmony export */   id_pkcs_9: () => (/* binding */ id_pkcs_9)
/* harmony export */ });
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js");

const id_keyBag = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.1`;
const id_pkcs8ShroudedKeyBag = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.2`;
const id_certBag = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.3`;
const id_CRLBag = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.4`;
const id_SecretBag = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.5`;
const id_SafeContents = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_bagtypes}.6`;
const id_pkcs_9 = "1.2.840.113549.1.9";


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthenticatedSafe: () => (/* reexport safe */ _authenticated_safe__WEBPACK_IMPORTED_MODULE_1__.AuthenticatedSafe),
/* harmony export */   CRLBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.CRLBag),
/* harmony export */   CertBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.CertBag),
/* harmony export */   KeyBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.KeyBag),
/* harmony export */   MacData: () => (/* reexport safe */ _mac_data__WEBPACK_IMPORTED_MODULE_3__.MacData),
/* harmony export */   PFX: () => (/* reexport safe */ _pfx__WEBPACK_IMPORTED_MODULE_5__.PFX),
/* harmony export */   PKCS12AttrSet: () => (/* reexport safe */ _attribute__WEBPACK_IMPORTED_MODULE_0__.PKCS12AttrSet),
/* harmony export */   PKCS12Attribute: () => (/* reexport safe */ _attribute__WEBPACK_IMPORTED_MODULE_0__.PKCS12Attribute),
/* harmony export */   PKCS8ShroudedKeyBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.PKCS8ShroudedKeyBag),
/* harmony export */   SafeBag: () => (/* reexport safe */ _safe_bag__WEBPACK_IMPORTED_MODULE_6__.SafeBag),
/* harmony export */   SafeContents: () => (/* reexport safe */ _safe_bag__WEBPACK_IMPORTED_MODULE_6__.SafeContents),
/* harmony export */   SecretBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.SecretBag),
/* harmony export */   id_CRLBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_CRLBag),
/* harmony export */   id_SafeContents: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_SafeContents),
/* harmony export */   id_SecretBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_SecretBag),
/* harmony export */   id_bagtypes: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_bagtypes),
/* harmony export */   id_certBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_certBag),
/* harmony export */   id_certTypes: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_certTypes),
/* harmony export */   id_crlTypes: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_crlTypes),
/* harmony export */   id_keyBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_keyBag),
/* harmony export */   id_pbeWithSHAAnd128BitRC2_CBC: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbeWithSHAAnd128BitRC2_CBC),
/* harmony export */   id_pbeWithSHAAnd128BitRC4: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbeWithSHAAnd128BitRC4),
/* harmony export */   id_pbeWithSHAAnd2_KeyTripleDES_CBC: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbeWithSHAAnd2_KeyTripleDES_CBC),
/* harmony export */   id_pbeWithSHAAnd3_KeyTripleDES_CBC: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbeWithSHAAnd3_KeyTripleDES_CBC),
/* harmony export */   id_pbeWithSHAAnd40BitRC4: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbeWithSHAAnd40BitRC4),
/* harmony export */   id_pbewithSHAAnd40BitRC2_CBC: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pbewithSHAAnd40BitRC2_CBC),
/* harmony export */   id_pkcs: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pkcs),
/* harmony export */   id_pkcs8ShroudedKeyBag: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_pkcs8ShroudedKeyBag),
/* harmony export */   id_pkcs_12: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pkcs_12),
/* harmony export */   id_pkcs_12PbeIds: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_pkcs_12PbeIds),
/* harmony export */   id_pkcs_9: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_pkcs_9),
/* harmony export */   id_rsadsi: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_4__.id_rsadsi),
/* harmony export */   id_sdsiCertificate: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_sdsiCertificate),
/* harmony export */   id_x509CRL: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_x509CRL),
/* harmony export */   id_x509Certificate: () => (/* reexport safe */ _bags__WEBPACK_IMPORTED_MODULE_2__.id_x509Certificate)
/* harmony export */ });
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js");
/* harmony import */ var _authenticated_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authenticated_safe */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js");
/* harmony import */ var _bags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bags */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/bags/index.js");
/* harmony import */ var _mac_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mac_data */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js");
/* harmony import */ var _pfx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pfx */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js");
/* harmony import */ var _safe_bag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./safe_bag */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js");









/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MacData: () => (/* binding */ MacData)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-rsa */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");



class MacData {
    constructor(params = {}) {
        this.mac = new _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_0__.DigestInfo();
        this.macSalt = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString();
        this.iterations = 1;
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnProp)({ type: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_0__.DigestInfo })
], MacData.prototype, "mac", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString })
], MacData.prototype, "macSalt", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Integer, defaultValue: 1 })
], MacData.prototype, "iterations", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_bagtypes: () => (/* binding */ id_bagtypes),
/* harmony export */   id_pbeWithSHAAnd128BitRC2_CBC: () => (/* binding */ id_pbeWithSHAAnd128BitRC2_CBC),
/* harmony export */   id_pbeWithSHAAnd128BitRC4: () => (/* binding */ id_pbeWithSHAAnd128BitRC4),
/* harmony export */   id_pbeWithSHAAnd2_KeyTripleDES_CBC: () => (/* binding */ id_pbeWithSHAAnd2_KeyTripleDES_CBC),
/* harmony export */   id_pbeWithSHAAnd3_KeyTripleDES_CBC: () => (/* binding */ id_pbeWithSHAAnd3_KeyTripleDES_CBC),
/* harmony export */   id_pbeWithSHAAnd40BitRC4: () => (/* binding */ id_pbeWithSHAAnd40BitRC4),
/* harmony export */   id_pbewithSHAAnd40BitRC2_CBC: () => (/* binding */ id_pbewithSHAAnd40BitRC2_CBC),
/* harmony export */   id_pkcs: () => (/* binding */ id_pkcs),
/* harmony export */   id_pkcs_12: () => (/* binding */ id_pkcs_12),
/* harmony export */   id_pkcs_12PbeIds: () => (/* binding */ id_pkcs_12PbeIds),
/* harmony export */   id_rsadsi: () => (/* binding */ id_rsadsi)
/* harmony export */ });
const id_rsadsi = "1.2.840.113549";
const id_pkcs = `${id_rsadsi}.1`;
const id_pkcs_12 = `${id_pkcs}.12`;
const id_pkcs_12PbeIds = `${id_pkcs_12}.1`;
const id_pbeWithSHAAnd128BitRC4 = `${id_pkcs_12PbeIds}.1`;
const id_pbeWithSHAAnd40BitRC4 = `${id_pkcs_12PbeIds}.2`;
const id_pbeWithSHAAnd3_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.3`;
const id_pbeWithSHAAnd2_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.4`;
const id_pbeWithSHAAnd128BitRC2_CBC = `${id_pkcs_12PbeIds}.5`;
const id_pbewithSHAAnd40BitRC2_CBC = `${id_pkcs_12PbeIds}.6`;
const id_bagtypes = `${id_pkcs_12}.10.1`;


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PFX: () => (/* binding */ PFX)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-cms */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js");
/* harmony import */ var _mac_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mac_data */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js");




class PFX {
    constructor(params = {}) {
        this.version = 3;
        this.authSafe = new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.ContentInfo();
        this.macData = new _mac_data__WEBPACK_IMPORTED_MODULE_2__.MacData();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], PFX.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.ContentInfo })
], PFX.prototype, "authSafe", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _mac_data__WEBPACK_IMPORTED_MODULE_2__.MacData, optional: true })
], PFX.prototype, "macData", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SafeBag: () => (/* binding */ SafeBag),
/* harmony export */   SafeContents: () => (/* binding */ SafeContents)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js");
var SafeContents_1;



class SafeBag {
    constructor(params = {}) {
        this.bagId = "";
        this.bagValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], SafeBag.prototype, "bagId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], SafeBag.prototype, "bagValue", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attribute__WEBPACK_IMPORTED_MODULE_1__.PKCS12Attribute, repeated: "set", optional: true })
], SafeBag.prototype, "bagAttributes", void 0);
let SafeContents = SafeContents_1 = class SafeContents extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SafeContents_1.prototype);
    }
};
SafeContents = SafeContents_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: SafeBag })
], SafeContents);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncryptedData: () => (/* binding */ EncryptedData),
/* harmony export */   EncryptedPrivateKeyInfo: () => (/* binding */ EncryptedPrivateKeyInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class EncryptedData extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
class EncryptedPrivateKeyInfo {
    constructor(params = {}) {
        this.encryptionAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.encryptedData = new EncryptedData();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], EncryptedPrivateKeyInfo.prototype, "encryptionAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: EncryptedData })
], EncryptedPrivateKeyInfo.prototype, "encryptedData", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attributes: () => (/* reexport safe */ _private_key_info__WEBPACK_IMPORTED_MODULE_1__.Attributes),
/* harmony export */   EncryptedData: () => (/* reexport safe */ _encrypted_private_key_info__WEBPACK_IMPORTED_MODULE_0__.EncryptedData),
/* harmony export */   EncryptedPrivateKeyInfo: () => (/* reexport safe */ _encrypted_private_key_info__WEBPACK_IMPORTED_MODULE_0__.EncryptedPrivateKeyInfo),
/* harmony export */   PrivateKey: () => (/* reexport safe */ _private_key_info__WEBPACK_IMPORTED_MODULE_1__.PrivateKey),
/* harmony export */   PrivateKeyInfo: () => (/* reexport safe */ _private_key_info__WEBPACK_IMPORTED_MODULE_1__.PrivateKeyInfo),
/* harmony export */   Version: () => (/* reexport safe */ _private_key_info__WEBPACK_IMPORTED_MODULE_1__.Version)
/* harmony export */ });
/* harmony import */ var _encrypted_private_key_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encrypted_private_key_info */ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js");
/* harmony import */ var _private_key_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./private_key_info */ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js");




/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attributes: () => (/* binding */ Attributes),
/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),
/* harmony export */   PrivateKeyInfo: () => (/* binding */ PrivateKeyInfo),
/* harmony export */   Version: () => (/* binding */ Version)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
var Attributes_1;



var Version;
(function (Version) {
    Version[Version["v1"] = 0] = "v1";
})(Version || (Version = {}));
class PrivateKey extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
let Attributes = Attributes_1 = class Attributes extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Attributes_1.prototype);
    }
};
Attributes = Attributes_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Attribute })
], Attributes);

class PrivateKeyInfo {
    constructor(params = {}) {
        this.version = Version.v1;
        this.privateKeyAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.privateKey = new PrivateKey();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], PrivateKeyInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: PrivateKey })
], PrivateKeyInfo.prototype, "privateKey", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: Attributes, implicit: true, context: 0, optional: true })
], PrivateKeyInfo.prototype, "attributes", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-pkcs9@2.3.15/node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-pkcs9@2.3.15/node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChallengePassword: () => (/* binding */ ChallengePassword),
/* harmony export */   ContentType: () => (/* binding */ ContentType),
/* harmony export */   CounterSignature: () => (/* binding */ CounterSignature),
/* harmony export */   CountryOfCitizenship: () => (/* binding */ CountryOfCitizenship),
/* harmony export */   CountryOfResidence: () => (/* binding */ CountryOfResidence),
/* harmony export */   DateOfBirth: () => (/* binding */ DateOfBirth),
/* harmony export */   EmailAddress: () => (/* binding */ EmailAddress),
/* harmony export */   EncryptedPrivateKeyInfo: () => (/* binding */ EncryptedPrivateKeyInfo),
/* harmony export */   ExtendedCertificateAttributes: () => (/* binding */ ExtendedCertificateAttributes),
/* harmony export */   ExtensionRequest: () => (/* binding */ ExtensionRequest),
/* harmony export */   FriendlyName: () => (/* binding */ FriendlyName),
/* harmony export */   Gender: () => (/* binding */ Gender),
/* harmony export */   LocalKeyId: () => (/* binding */ LocalKeyId),
/* harmony export */   MessageDigest: () => (/* binding */ MessageDigest),
/* harmony export */   PKCS9String: () => (/* binding */ PKCS9String),
/* harmony export */   Pkcs7PDU: () => (/* binding */ Pkcs7PDU),
/* harmony export */   PlaceOfBirth: () => (/* binding */ PlaceOfBirth),
/* harmony export */   Pseudonym: () => (/* binding */ Pseudonym),
/* harmony export */   RandomNonce: () => (/* binding */ RandomNonce),
/* harmony export */   SMIMECapabilities: () => (/* binding */ SMIMECapabilities),
/* harmony export */   SMIMECapability: () => (/* binding */ SMIMECapability),
/* harmony export */   SequenceNumber: () => (/* binding */ SequenceNumber),
/* harmony export */   SigningDescription: () => (/* binding */ SigningDescription),
/* harmony export */   SigningTime: () => (/* binding */ SigningTime),
/* harmony export */   UnstructuredAddress: () => (/* binding */ UnstructuredAddress),
/* harmony export */   UnstructuredName: () => (/* binding */ UnstructuredName),
/* harmony export */   UserPKCS12: () => (/* binding */ UserPKCS12),
/* harmony export */   crlTypes: () => (/* binding */ crlTypes),
/* harmony export */   id_at_pseudonym: () => (/* binding */ id_at_pseudonym),
/* harmony export */   id_certTypes: () => (/* binding */ id_certTypes),
/* harmony export */   id_ietf_at: () => (/* binding */ id_ietf_at),
/* harmony export */   id_pkcs9: () => (/* binding */ id_pkcs9),
/* harmony export */   id_pkcs9_at: () => (/* binding */ id_pkcs9_at),
/* harmony export */   id_pkcs9_at_challengePassword: () => (/* binding */ id_pkcs9_at_challengePassword),
/* harmony export */   id_pkcs9_at_contentType: () => (/* binding */ id_pkcs9_at_contentType),
/* harmony export */   id_pkcs9_at_counterSignature: () => (/* binding */ id_pkcs9_at_counterSignature),
/* harmony export */   id_pkcs9_at_countryOfCitizenship: () => (/* binding */ id_pkcs9_at_countryOfCitizenship),
/* harmony export */   id_pkcs9_at_countryOfResidence: () => (/* binding */ id_pkcs9_at_countryOfResidence),
/* harmony export */   id_pkcs9_at_dateOfBirth: () => (/* binding */ id_pkcs9_at_dateOfBirth),
/* harmony export */   id_pkcs9_at_emailAddress: () => (/* binding */ id_pkcs9_at_emailAddress),
/* harmony export */   id_pkcs9_at_encryptedPrivateKeyInfo: () => (/* binding */ id_pkcs9_at_encryptedPrivateKeyInfo),
/* harmony export */   id_pkcs9_at_extendedCertificateAttributes: () => (/* binding */ id_pkcs9_at_extendedCertificateAttributes),
/* harmony export */   id_pkcs9_at_extensionRequest: () => (/* binding */ id_pkcs9_at_extensionRequest),
/* harmony export */   id_pkcs9_at_friendlyName: () => (/* binding */ id_pkcs9_at_friendlyName),
/* harmony export */   id_pkcs9_at_gender: () => (/* binding */ id_pkcs9_at_gender),
/* harmony export */   id_pkcs9_at_localKeyId: () => (/* binding */ id_pkcs9_at_localKeyId),
/* harmony export */   id_pkcs9_at_messageDigest: () => (/* binding */ id_pkcs9_at_messageDigest),
/* harmony export */   id_pkcs9_at_pkcs15Token: () => (/* binding */ id_pkcs9_at_pkcs15Token),
/* harmony export */   id_pkcs9_at_pkcs7PDU: () => (/* binding */ id_pkcs9_at_pkcs7PDU),
/* harmony export */   id_pkcs9_at_placeOfBirth: () => (/* binding */ id_pkcs9_at_placeOfBirth),
/* harmony export */   id_pkcs9_at_randomNonce: () => (/* binding */ id_pkcs9_at_randomNonce),
/* harmony export */   id_pkcs9_at_sequenceNumber: () => (/* binding */ id_pkcs9_at_sequenceNumber),
/* harmony export */   id_pkcs9_at_signingDescription: () => (/* binding */ id_pkcs9_at_signingDescription),
/* harmony export */   id_pkcs9_at_signingTime: () => (/* binding */ id_pkcs9_at_signingTime),
/* harmony export */   id_pkcs9_at_smimeCapabilities: () => (/* binding */ id_pkcs9_at_smimeCapabilities),
/* harmony export */   id_pkcs9_at_unstructuredAddress: () => (/* binding */ id_pkcs9_at_unstructuredAddress),
/* harmony export */   id_pkcs9_at_unstructuredName: () => (/* binding */ id_pkcs9_at_unstructuredName),
/* harmony export */   id_pkcs9_at_userPKCS12: () => (/* binding */ id_pkcs9_at_userPKCS12),
/* harmony export */   id_pkcs9_mo: () => (/* binding */ id_pkcs9_mo),
/* harmony export */   id_pkcs9_mr: () => (/* binding */ id_pkcs9_mr),
/* harmony export */   id_pkcs9_mr_caseIgnoreMatch: () => (/* binding */ id_pkcs9_mr_caseIgnoreMatch),
/* harmony export */   id_pkcs9_mr_signingTimeMatch: () => (/* binding */ id_pkcs9_mr_signingTimeMatch),
/* harmony export */   id_pkcs9_oc: () => (/* binding */ id_pkcs9_oc),
/* harmony export */   id_pkcs9_oc_naturalPerson: () => (/* binding */ id_pkcs9_oc_naturalPerson),
/* harmony export */   id_pkcs9_oc_pkcsEntity: () => (/* binding */ id_pkcs9_oc_pkcsEntity),
/* harmony export */   id_pkcs9_sx: () => (/* binding */ id_pkcs9_sx),
/* harmony export */   id_pkcs9_sx_pkcs9String: () => (/* binding */ id_pkcs9_sx_pkcs9String),
/* harmony export */   id_pkcs9_sx_signingTime: () => (/* binding */ id_pkcs9_sx_signingTime),
/* harmony export */   id_smime: () => (/* binding */ id_smime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-cms */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_pfx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-pfx */ "./node_modules/.pnpm/@peculiar+asn1-pfx@2.3.15/node_modules/@peculiar/asn1-pfx/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @peculiar/asn1-pkcs8 */ "./node_modules/.pnpm/@peculiar+asn1-pkcs8@2.3.15/node_modules/@peculiar/asn1-pkcs8/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509_attr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @peculiar/asn1-x509-attr */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/index.js");
var ExtensionRequest_1, ExtendedCertificateAttributes_1, SMIMECapabilities_1;







const id_pkcs9 = "1.2.840.113549.1.9";
const id_pkcs9_mo = `${id_pkcs9}.0`;
const id_pkcs9_oc = `${id_pkcs9}.24`;
const id_pkcs9_at = `${id_pkcs9}.25`;
const id_pkcs9_sx = `${id_pkcs9}.26`;
const id_pkcs9_mr = `${id_pkcs9}.27`;
const id_pkcs9_oc_pkcsEntity = `${id_pkcs9_oc}.1`;
const id_pkcs9_oc_naturalPerson = `${id_pkcs9_oc}.2`;
const id_pkcs9_at_emailAddress = `${id_pkcs9}.1`;
const id_pkcs9_at_unstructuredName = `${id_pkcs9}.2`;
const id_pkcs9_at_contentType = `${id_pkcs9}.3`;
const id_pkcs9_at_messageDigest = `${id_pkcs9}.4`;
const id_pkcs9_at_signingTime = `${id_pkcs9}.5`;
const id_pkcs9_at_counterSignature = `${id_pkcs9}.6`;
const id_pkcs9_at_challengePassword = `${id_pkcs9}.7`;
const id_pkcs9_at_unstructuredAddress = `${id_pkcs9}.8`;
const id_pkcs9_at_extendedCertificateAttributes = `${id_pkcs9}.9`;
const id_pkcs9_at_signingDescription = `${id_pkcs9}.13`;
const id_pkcs9_at_extensionRequest = `${id_pkcs9}.14`;
const id_pkcs9_at_smimeCapabilities = `${id_pkcs9}.15`;
const id_pkcs9_at_friendlyName = `${id_pkcs9}.20`;
const id_pkcs9_at_localKeyId = `${id_pkcs9}.21`;
const id_pkcs9_at_userPKCS12 = `2.16.840.1.113730.3.1.216`;
const id_pkcs9_at_pkcs15Token = `${id_pkcs9_at}.1`;
const id_pkcs9_at_encryptedPrivateKeyInfo = `${id_pkcs9_at}.2`;
const id_pkcs9_at_randomNonce = `${id_pkcs9_at}.3`;
const id_pkcs9_at_sequenceNumber = `${id_pkcs9_at}.4`;
const id_pkcs9_at_pkcs7PDU = `${id_pkcs9_at}.5`;
const id_ietf_at = `1.3.6.1.5.5.7.9`;
const id_pkcs9_at_dateOfBirth = `${id_ietf_at}.1`;
const id_pkcs9_at_placeOfBirth = `${id_ietf_at}.2`;
const id_pkcs9_at_gender = `${id_ietf_at}.3`;
const id_pkcs9_at_countryOfCitizenship = `${id_ietf_at}.4`;
const id_pkcs9_at_countryOfResidence = `${id_ietf_at}.5`;
const id_pkcs9_sx_pkcs9String = `${id_pkcs9_sx}.1`;
const id_pkcs9_sx_signingTime = `${id_pkcs9_sx}.2`;
const id_pkcs9_mr_caseIgnoreMatch = `${id_pkcs9_mr}.1`;
const id_pkcs9_mr_signingTimeMatch = `${id_pkcs9_mr}.2`;
const id_smime = `${id_pkcs9}.16`;
const id_certTypes = `${id_pkcs9}.22`;
const crlTypes = `${id_pkcs9}.23`;
const id_at_pseudonym = `${_peculiar_asn1_x509_attr__WEBPACK_IMPORTED_MODULE_5__.id_at}.65`;
let PKCS9String = class PKCS9String extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
    constructor(params = {}) {
        super(params);
    }
    toString() {
        const o = {};
        o.toString();
        return this.ia5String || super.toString();
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String })
], PKCS9String.prototype, "ia5String", void 0);
PKCS9String = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], PKCS9String);

let Pkcs7PDU = class Pkcs7PDU extends _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.ContentInfo {
};
Pkcs7PDU = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], Pkcs7PDU);

let UserPKCS12 = class UserPKCS12 extends _peculiar_asn1_pfx__WEBPACK_IMPORTED_MODULE_2__.PFX {
};
UserPKCS12 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], UserPKCS12);

let EncryptedPrivateKeyInfo = class EncryptedPrivateKeyInfo extends _peculiar_asn1_pkcs8__WEBPACK_IMPORTED_MODULE_3__.EncryptedPrivateKeyInfo {
};
EncryptedPrivateKeyInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], EncryptedPrivateKeyInfo);

let EmailAddress = class EmailAddress {
    constructor(value = "") {
        this.value = value;
    }
    toString() {
        return this.value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String })
], EmailAddress.prototype, "value", void 0);
EmailAddress = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], EmailAddress);

let UnstructuredName = class UnstructuredName extends PKCS9String {
};
UnstructuredName = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], UnstructuredName);

let UnstructuredAddress = class UnstructuredAddress extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
};
UnstructuredAddress = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], UnstructuredAddress);

let DateOfBirth = class DateOfBirth {
    constructor(value = new Date()) {
        this.value = value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime })
], DateOfBirth.prototype, "value", void 0);
DateOfBirth = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], DateOfBirth);

let PlaceOfBirth = class PlaceOfBirth extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
};
PlaceOfBirth = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], PlaceOfBirth);

let Gender = class Gender {
    constructor(value = "M") {
        this.value = value;
    }
    toString() {
        return this.value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.PrintableString })
], Gender.prototype, "value", void 0);
Gender = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], Gender);

let CountryOfCitizenship = class CountryOfCitizenship {
    constructor(value = "") {
        this.value = value;
    }
    toString() {
        return this.value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.PrintableString })
], CountryOfCitizenship.prototype, "value", void 0);
CountryOfCitizenship = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], CountryOfCitizenship);

let CountryOfResidence = class CountryOfResidence extends CountryOfCitizenship {
};
CountryOfResidence = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], CountryOfResidence);

let Pseudonym = class Pseudonym extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
};
Pseudonym = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], Pseudonym);

let ContentType = class ContentType {
    constructor(value = "") {
        this.value = value;
    }
    toString() {
        return this.value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], ContentType.prototype, "value", void 0);
ContentType = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], ContentType);

class MessageDigest extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
let SigningTime = class SigningTime extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.Time {
};
SigningTime = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], SigningTime);

class RandomNonce extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
let SequenceNumber = class SequenceNumber {
    constructor(value = 0) {
        this.value = value;
    }
    toString() {
        return this.value.toString();
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], SequenceNumber.prototype, "value", void 0);
SequenceNumber = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], SequenceNumber);

let CounterSignature = class CounterSignature extends _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.SignerInfo {
};
CounterSignature = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], CounterSignature);

let ChallengePassword = class ChallengePassword extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
};
ChallengePassword = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], ChallengePassword);

let ExtensionRequest = ExtensionRequest_1 = class ExtensionRequest extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.Extensions {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtensionRequest_1.prototype);
    }
};
ExtensionRequest = ExtensionRequest_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], ExtensionRequest);

let ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = class ExtendedCertificateAttributes extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtendedCertificateAttributes_1.prototype);
    }
};
ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_1__.Attribute })
], ExtendedCertificateAttributes);

let FriendlyName = class FriendlyName {
    constructor(value = "") {
        this.value = value;
    }
    toString() {
        return this.value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BmpString })
], FriendlyName.prototype, "value", void 0);
FriendlyName = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], FriendlyName);

class LocalKeyId extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
class SigningDescription extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.DirectoryString {
}
let SMIMECapability = class SMIMECapability extends _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_4__.AlgorithmIdentifier {
};
SMIMECapability = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], SMIMECapability);

let SMIMECapabilities = SMIMECapabilities_1 = class SMIMECapabilities extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SMIMECapabilities_1.prototype);
    }
};
SMIMECapabilities = SMIMECapabilities_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: SMIMECapability })
], SMIMECapabilities);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   md2: () => (/* binding */ md2),
/* harmony export */   md2WithRSAEncryption: () => (/* binding */ md2WithRSAEncryption),
/* harmony export */   md4: () => (/* binding */ md4),
/* harmony export */   md5WithRSAEncryption: () => (/* binding */ md5WithRSAEncryption),
/* harmony export */   mgf1SHA1: () => (/* binding */ mgf1SHA1),
/* harmony export */   pSpecifiedEmpty: () => (/* binding */ pSpecifiedEmpty),
/* harmony export */   rsaEncryption: () => (/* binding */ rsaEncryption),
/* harmony export */   sha1: () => (/* binding */ sha1),
/* harmony export */   sha1WithRSAEncryption: () => (/* binding */ sha1WithRSAEncryption),
/* harmony export */   sha224: () => (/* binding */ sha224),
/* harmony export */   sha224WithRSAEncryption: () => (/* binding */ sha224WithRSAEncryption),
/* harmony export */   sha256: () => (/* binding */ sha256),
/* harmony export */   sha256WithRSAEncryption: () => (/* binding */ sha256WithRSAEncryption),
/* harmony export */   sha384: () => (/* binding */ sha384),
/* harmony export */   sha384WithRSAEncryption: () => (/* binding */ sha384WithRSAEncryption),
/* harmony export */   sha512: () => (/* binding */ sha512),
/* harmony export */   sha512WithRSAEncryption: () => (/* binding */ sha512WithRSAEncryption),
/* harmony export */   sha512_224: () => (/* binding */ sha512_224),
/* harmony export */   sha512_224WithRSAEncryption: () => (/* binding */ sha512_224WithRSAEncryption),
/* harmony export */   sha512_256: () => (/* binding */ sha512_256),
/* harmony export */   sha512_256WithRSAEncryption: () => (/* binding */ sha512_256WithRSAEncryption)
/* harmony export */ });
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js");



function create(algorithm) {
    return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({ algorithm, parameters: null });
}
const md2 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md2);
const md4 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md5);
const sha1 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha1);
const sha224 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha224);
const sha256 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha256);
const sha384 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha384);
const sha512 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512);
const sha512_224 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_224);
const sha512_256 = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_256);
const mgf1SHA1 = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
    algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_mgf1,
    parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(sha1),
});
const pSpecifiedEmpty = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
    algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_pSpecified,
    parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnOctetStringConverter.toASN(new Uint8Array([
        0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18,
        0x90, 0xaf, 0xd8, 0x07, 0x09,
    ]).buffer)),
});
const rsaEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_rsaEncryption);
const md2WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md2WithRSAEncryption);
const md5WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md5WithRSAEncryption);
const sha1WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha1WithRSAEncryption);
const sha224WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_224WithRSAEncryption);
const sha256WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_256WithRSAEncryption);
const sha384WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha384WithRSAEncryption);
const sha512WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512WithRSAEncryption);
const sha512_224WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_224WithRSAEncryption);
const sha512_256WithRSAEncryption = create(_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_256WithRSAEncryption);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DigestInfo: () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_0__.DigestInfo),
/* harmony export */   OtherPrimeInfo: () => (/* reexport safe */ _other_prime_info__WEBPACK_IMPORTED_MODULE_3__.OtherPrimeInfo),
/* harmony export */   OtherPrimeInfos: () => (/* reexport safe */ _other_prime_info__WEBPACK_IMPORTED_MODULE_3__.OtherPrimeInfos),
/* harmony export */   RSAES_OAEP: () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_0__.RSAES_OAEP),
/* harmony export */   RSAPrivateKey: () => (/* reexport safe */ _rsa_private_key__WEBPACK_IMPORTED_MODULE_4__.RSAPrivateKey),
/* harmony export */   RSAPublicKey: () => (/* reexport safe */ _rsa_public_key__WEBPACK_IMPORTED_MODULE_5__.RSAPublicKey),
/* harmony export */   RSASSA_PSS: () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_0__.RSASSA_PSS),
/* harmony export */   RsaEsOaepParams: () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_0__.RsaEsOaepParams),
/* harmony export */   RsaSaPssParams: () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_0__.RsaSaPssParams),
/* harmony export */   id_RSAES_OAEP: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_RSAES_OAEP),
/* harmony export */   id_RSASSA_PSS: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_RSASSA_PSS),
/* harmony export */   id_md2: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md2),
/* harmony export */   id_md2WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md2WithRSAEncryption),
/* harmony export */   id_md5: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md5),
/* harmony export */   id_md5WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_md5WithRSAEncryption),
/* harmony export */   id_mgf1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_mgf1),
/* harmony export */   id_pSpecified: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_pSpecified),
/* harmony export */   id_pkcs_1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_pkcs_1),
/* harmony export */   id_rsaEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_rsaEncryption),
/* harmony export */   id_sha1: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha1),
/* harmony export */   id_sha1WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha1WithRSAEncryption),
/* harmony export */   id_sha224: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha224),
/* harmony export */   id_sha224WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha224WithRSAEncryption),
/* harmony export */   id_sha256: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha256),
/* harmony export */   id_sha256WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha256WithRSAEncryption),
/* harmony export */   id_sha384: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha384),
/* harmony export */   id_sha384WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha384WithRSAEncryption),
/* harmony export */   id_sha512: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512),
/* harmony export */   id_sha512WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512WithRSAEncryption),
/* harmony export */   id_sha512_224: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_224),
/* harmony export */   id_sha512_224WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_224WithRSAEncryption),
/* harmony export */   id_sha512_256: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_256),
/* harmony export */   id_sha512_256WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_sha512_256WithRSAEncryption),
/* harmony export */   id_ssha224WithRSAEncryption: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ssha224WithRSAEncryption),
/* harmony export */   md2: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.md2),
/* harmony export */   md2WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.md2WithRSAEncryption),
/* harmony export */   md4: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.md4),
/* harmony export */   md5WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.md5WithRSAEncryption),
/* harmony export */   mgf1SHA1: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.mgf1SHA1),
/* harmony export */   pSpecifiedEmpty: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.pSpecifiedEmpty),
/* harmony export */   rsaEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.rsaEncryption),
/* harmony export */   sha1: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha1),
/* harmony export */   sha1WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha1WithRSAEncryption),
/* harmony export */   sha224: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha224),
/* harmony export */   sha224WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha224WithRSAEncryption),
/* harmony export */   sha256: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha256),
/* harmony export */   sha256WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha256WithRSAEncryption),
/* harmony export */   sha384: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha384),
/* harmony export */   sha384WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha384WithRSAEncryption),
/* harmony export */   sha512: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512),
/* harmony export */   sha512WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512WithRSAEncryption),
/* harmony export */   sha512_224: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512_224),
/* harmony export */   sha512_224WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512_224WithRSAEncryption),
/* harmony export */   sha512_256: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512_256),
/* harmony export */   sha512_256WithRSAEncryption: () => (/* reexport safe */ _algorithms__WEBPACK_IMPORTED_MODULE_1__.sha512_256WithRSAEncryption)
/* harmony export */ });
/* harmony import */ var _parameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parameters */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/index.js");
/* harmony import */ var _algorithms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js");
/* harmony import */ var _other_prime_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./other_prime_info */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js");
/* harmony import */ var _rsa_private_key__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rsa_private_key */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js");
/* harmony import */ var _rsa_public_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rsa_public_key */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js");








/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_RSAES_OAEP: () => (/* binding */ id_RSAES_OAEP),
/* harmony export */   id_RSASSA_PSS: () => (/* binding */ id_RSASSA_PSS),
/* harmony export */   id_md2: () => (/* binding */ id_md2),
/* harmony export */   id_md2WithRSAEncryption: () => (/* binding */ id_md2WithRSAEncryption),
/* harmony export */   id_md5: () => (/* binding */ id_md5),
/* harmony export */   id_md5WithRSAEncryption: () => (/* binding */ id_md5WithRSAEncryption),
/* harmony export */   id_mgf1: () => (/* binding */ id_mgf1),
/* harmony export */   id_pSpecified: () => (/* binding */ id_pSpecified),
/* harmony export */   id_pkcs_1: () => (/* binding */ id_pkcs_1),
/* harmony export */   id_rsaEncryption: () => (/* binding */ id_rsaEncryption),
/* harmony export */   id_sha1: () => (/* binding */ id_sha1),
/* harmony export */   id_sha1WithRSAEncryption: () => (/* binding */ id_sha1WithRSAEncryption),
/* harmony export */   id_sha224: () => (/* binding */ id_sha224),
/* harmony export */   id_sha224WithRSAEncryption: () => (/* binding */ id_sha224WithRSAEncryption),
/* harmony export */   id_sha256: () => (/* binding */ id_sha256),
/* harmony export */   id_sha256WithRSAEncryption: () => (/* binding */ id_sha256WithRSAEncryption),
/* harmony export */   id_sha384: () => (/* binding */ id_sha384),
/* harmony export */   id_sha384WithRSAEncryption: () => (/* binding */ id_sha384WithRSAEncryption),
/* harmony export */   id_sha512: () => (/* binding */ id_sha512),
/* harmony export */   id_sha512WithRSAEncryption: () => (/* binding */ id_sha512WithRSAEncryption),
/* harmony export */   id_sha512_224: () => (/* binding */ id_sha512_224),
/* harmony export */   id_sha512_224WithRSAEncryption: () => (/* binding */ id_sha512_224WithRSAEncryption),
/* harmony export */   id_sha512_256: () => (/* binding */ id_sha512_256),
/* harmony export */   id_sha512_256WithRSAEncryption: () => (/* binding */ id_sha512_256WithRSAEncryption),
/* harmony export */   id_ssha224WithRSAEncryption: () => (/* binding */ id_ssha224WithRSAEncryption)
/* harmony export */ });
const id_pkcs_1 = "1.2.840.113549.1.1";
const id_rsaEncryption = `${id_pkcs_1}.1`;
const id_RSAES_OAEP = `${id_pkcs_1}.7`;
const id_pSpecified = `${id_pkcs_1}.9`;
const id_RSASSA_PSS = `${id_pkcs_1}.10`;
const id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
const id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
const id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
const id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
const id_ssha224WithRSAEncryption = id_sha224WithRSAEncryption;
const id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
const id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
const id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
const id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
const id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
const id_sha1 = "1.3.14.3.2.26";
const id_sha224 = "2.16.840.1.101.3.4.2.4";
const id_sha256 = "2.16.840.1.101.3.4.2.1";
const id_sha384 = "2.16.840.1.101.3.4.2.2";
const id_sha512 = "2.16.840.1.101.3.4.2.3";
const id_sha512_224 = "2.16.840.1.101.3.4.2.5";
const id_sha512_256 = "2.16.840.1.101.3.4.2.6";
const id_md2 = "1.2.840.113549.2.2";
const id_md5 = "1.2.840.113549.2.5";
const id_mgf1 = `${id_pkcs_1}.8`;


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OtherPrimeInfo: () => (/* binding */ OtherPrimeInfo),
/* harmony export */   OtherPrimeInfos: () => (/* binding */ OtherPrimeInfos)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
var OtherPrimeInfos_1;


class OtherPrimeInfo {
    constructor(params = {}) {
        this.prime = new ArrayBuffer(0);
        this.exponent = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "prime", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "exponent", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "coefficient", void 0);
let OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
    }
};
OtherPrimeInfos = OtherPrimeInfos_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
], OtherPrimeInfos);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/index.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DigestInfo: () => (/* reexport safe */ _rsassa_pkcs1_v1_5__WEBPACK_IMPORTED_MODULE_2__.DigestInfo),
/* harmony export */   RSAES_OAEP: () => (/* reexport safe */ _rsaes_oaep__WEBPACK_IMPORTED_MODULE_0__.RSAES_OAEP),
/* harmony export */   RSASSA_PSS: () => (/* reexport safe */ _rsassa_pss__WEBPACK_IMPORTED_MODULE_1__.RSASSA_PSS),
/* harmony export */   RsaEsOaepParams: () => (/* reexport safe */ _rsaes_oaep__WEBPACK_IMPORTED_MODULE_0__.RsaEsOaepParams),
/* harmony export */   RsaSaPssParams: () => (/* reexport safe */ _rsassa_pss__WEBPACK_IMPORTED_MODULE_1__.RsaSaPssParams)
/* harmony export */ });
/* harmony import */ var _rsaes_oaep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rsaes_oaep */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js");
/* harmony import */ var _rsassa_pss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rsassa_pss */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js");
/* harmony import */ var _rsassa_pkcs1_v1_5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rsassa_pkcs1_v1_5 */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js");





/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RSAES_OAEP: () => (/* binding */ RSAES_OAEP),
/* harmony export */   RsaEsOaepParams: () => (/* binding */ RsaEsOaepParams)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js");
/* harmony import */ var _algorithms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js");





class RsaEsOaepParams {
    constructor(params = {}) {
        this.hashAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier(_algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1);
        this.maskGenAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
            algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_mgf1,
            parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(_algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1),
        });
        this.pSourceAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier(_algorithms__WEBPACK_IMPORTED_MODULE_3__.pSpecifiedEmpty);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier, context: 0, defaultValue: _algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1 })
], RsaEsOaepParams.prototype, "hashAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier, context: 1, defaultValue: _algorithms__WEBPACK_IMPORTED_MODULE_3__.mgf1SHA1 })
], RsaEsOaepParams.prototype, "maskGenAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier, context: 2, defaultValue: _algorithms__WEBPACK_IMPORTED_MODULE_3__.pSpecifiedEmpty })
], RsaEsOaepParams.prototype, "pSourceAlgorithm", void 0);
const RSAES_OAEP = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
    algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_RSAES_OAEP,
    parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(new RsaEsOaepParams()),
});


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DigestInfo: () => (/* binding */ DigestInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");



class DigestInfo {
    constructor(params = {}) {
        this.digestAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier();
        this.digest = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.AlgorithmIdentifier })
], DigestInfo.prototype, "digestAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString })
], DigestInfo.prototype, "digest", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RSASSA_PSS: () => (/* binding */ RSASSA_PSS),
/* harmony export */   RsaSaPssParams: () => (/* binding */ RsaSaPssParams)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js");
/* harmony import */ var _algorithms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js");





class RsaSaPssParams {
    constructor(params = {}) {
        this.hashAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier(_algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1);
        this.maskGenAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
            algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_mgf1,
            parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(_algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1),
        });
        this.saltLength = 20;
        this.trailerField = 1;
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier, context: 0, defaultValue: _algorithms__WEBPACK_IMPORTED_MODULE_3__.sha1 })
], RsaSaPssParams.prototype, "hashAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier, context: 1, defaultValue: _algorithms__WEBPACK_IMPORTED_MODULE_3__.mgf1SHA1 })
], RsaSaPssParams.prototype, "maskGenAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams.prototype, "saltLength", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams.prototype, "trailerField", void 0);
const RSASSA_PSS = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier({
    algorithm: _object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_RSASSA_PSS,
    parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnConvert.serialize(new RsaSaPssParams()),
});


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RSAPrivateKey: () => (/* binding */ RSAPrivateKey)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _other_prime_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./other_prime_info */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js");



class RSAPrivateKey {
    constructor(params = {}) {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], RSAPrivateKey.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "modulus", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "publicExponent", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "privateExponent", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime1", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime2", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent1", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent2", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "coefficient", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _other_prime_info__WEBPACK_IMPORTED_MODULE_1__.OtherPrimeInfos, optional: true })
], RSAPrivateKey.prototype, "otherPrimeInfos", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RSAPublicKey: () => (/* binding */ RSAPublicKey)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class RSAPublicKey {
    constructor(params = {}) {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "modulus", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "publicExponent", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/convert.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/convert.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnConvert: () => (/* binding */ AsnConvert)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/parser.js");
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serializer */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js");




class AsnConvert {
    static serialize(obj) {
        return _serializer__WEBPACK_IMPORTED_MODULE_3__.AsnSerializer.serialize(obj);
    }
    static parse(data, target) {
        return _parser__WEBPACK_IMPORTED_MODULE_2__.AsnParser.parse(data, target);
    }
    static toString(data) {
        const buf = pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.isBufferSource(data)
            ? pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.toArrayBuffer(data)
            : AsnConvert.serialize(data);
        const asn = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(buf);
        if (asn.offset === -1) {
            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnAnyConverter: () => (/* binding */ AsnAnyConverter),
/* harmony export */   AsnBitStringConverter: () => (/* binding */ AsnBitStringConverter),
/* harmony export */   AsnBmpStringConverter: () => (/* binding */ AsnBmpStringConverter),
/* harmony export */   AsnBooleanConverter: () => (/* binding */ AsnBooleanConverter),
/* harmony export */   AsnCharacterStringConverter: () => (/* binding */ AsnCharacterStringConverter),
/* harmony export */   AsnConstructedOctetStringConverter: () => (/* binding */ AsnConstructedOctetStringConverter),
/* harmony export */   AsnEnumeratedConverter: () => (/* binding */ AsnEnumeratedConverter),
/* harmony export */   AsnGeneralStringConverter: () => (/* binding */ AsnGeneralStringConverter),
/* harmony export */   AsnGeneralizedTimeConverter: () => (/* binding */ AsnGeneralizedTimeConverter),
/* harmony export */   AsnGraphicStringConverter: () => (/* binding */ AsnGraphicStringConverter),
/* harmony export */   AsnIA5StringConverter: () => (/* binding */ AsnIA5StringConverter),
/* harmony export */   AsnIntegerArrayBufferConverter: () => (/* binding */ AsnIntegerArrayBufferConverter),
/* harmony export */   AsnIntegerBigIntConverter: () => (/* binding */ AsnIntegerBigIntConverter),
/* harmony export */   AsnIntegerConverter: () => (/* binding */ AsnIntegerConverter),
/* harmony export */   AsnNullConverter: () => (/* binding */ AsnNullConverter),
/* harmony export */   AsnNumericStringConverter: () => (/* binding */ AsnNumericStringConverter),
/* harmony export */   AsnObjectIdentifierConverter: () => (/* binding */ AsnObjectIdentifierConverter),
/* harmony export */   AsnOctetStringConverter: () => (/* binding */ AsnOctetStringConverter),
/* harmony export */   AsnPrintableStringConverter: () => (/* binding */ AsnPrintableStringConverter),
/* harmony export */   AsnTeletexStringConverter: () => (/* binding */ AsnTeletexStringConverter),
/* harmony export */   AsnUTCTimeConverter: () => (/* binding */ AsnUTCTimeConverter),
/* harmony export */   AsnUniversalStringConverter: () => (/* binding */ AsnUniversalStringConverter),
/* harmony export */   AsnUtf8StringConverter: () => (/* binding */ AsnUtf8StringConverter),
/* harmony export */   AsnVideotexStringConverter: () => (/* binding */ AsnVideotexStringConverter),
/* harmony export */   AsnVisibleStringConverter: () => (/* binding */ AsnVisibleStringConverter),
/* harmony export */   defaultConverter: () => (/* binding */ defaultConverter)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/index */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/index.js");



const AsnAnyConverter = {
    fromASN: (value) => value instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__.Null ? null : value.valueBeforeDecodeView,
    toASN: (value) => {
        if (value === null) {
            return new asn1js__WEBPACK_IMPORTED_MODULE_0__.Null();
        }
        const schema = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(value);
        if (schema.result.error) {
            throw new Error(schema.result.error);
        }
        return schema.result;
    },
};
const AsnIntegerConverter = {
    fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4
        ? value.valueBlock.toString()
        : value.valueBlock.valueDec,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ value: +value }),
};
const AsnEnumeratedConverter = {
    fromASN: (value) => value.valueBlock.valueDec,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.Enumerated({ value }),
};
const AsnIntegerArrayBufferConverter = {
    fromASN: (value) => value.valueBlock.valueHexView,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ valueHex: value }),
};
const AsnIntegerBigIntConverter = {
    fromASN: (value) => value.toBigInt(),
    toASN: (value) => asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(value),
};
const AsnBitStringConverter = {
    fromASN: (value) => value.valueBlock.valueHexView,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.BitString({ valueHex: value }),
};
const AsnObjectIdentifierConverter = {
    fromASN: (value) => value.valueBlock.toString(),
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({ value }),
};
const AsnBooleanConverter = {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.Boolean({ value }),
};
const AsnOctetStringConverter = {
    fromASN: (value) => value.valueBlock.valueHexView,
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({ valueHex: value }),
};
const AsnConstructedOctetStringConverter = {
    fromASN: (value) => new _types_index__WEBPACK_IMPORTED_MODULE_2__.OctetString(value.getValue()),
    toASN: (value) => value.toASN(),
};
function createStringConverter(Asn1Type) {
    return {
        fromASN: (value) => value.valueBlock.value,
        toASN: (value) => new Asn1Type({ value }),
    };
}
const AsnUtf8StringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.Utf8String);
const AsnBmpStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.BmpString);
const AsnUniversalStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.UniversalString);
const AsnNumericStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.NumericString);
const AsnPrintableStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.PrintableString);
const AsnTeletexStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.TeletexString);
const AsnVideotexStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.VideotexString);
const AsnIA5StringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.IA5String);
const AsnGraphicStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.GraphicString);
const AsnVisibleStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.VisibleString);
const AsnGeneralStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.GeneralString);
const AsnCharacterStringConverter = createStringConverter(asn1js__WEBPACK_IMPORTED_MODULE_0__.CharacterString);
const AsnUTCTimeConverter = {
    fromASN: (value) => value.toDate(),
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.UTCTime({ valueDate: value }),
};
const AsnGeneralizedTimeConverter = {
    fromASN: (value) => value.toDate(),
    toASN: (value) => new asn1js__WEBPACK_IMPORTED_MODULE_0__.GeneralizedTime({ valueDate: value }),
};
const AsnNullConverter = {
    fromASN: () => null,
    toASN: () => {
        return new asn1js__WEBPACK_IMPORTED_MODULE_0__.Null();
    },
};
function defaultConverter(type) {
    switch (type) {
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Any:
            return AsnAnyConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.BitString:
            return AsnBitStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.BmpString:
            return AsnBmpStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Boolean:
            return AsnBooleanConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.CharacterString:
            return AsnCharacterStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Enumerated:
            return AsnEnumeratedConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.GeneralString:
            return AsnGeneralStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.GeneralizedTime:
            return AsnGeneralizedTimeConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.GraphicString:
            return AsnGraphicStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.IA5String:
            return AsnIA5StringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Integer:
            return AsnIntegerConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Null:
            return AsnNullConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.NumericString:
            return AsnNumericStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.ObjectIdentifier:
            return AsnObjectIdentifierConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.OctetString:
            return AsnOctetStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.PrintableString:
            return AsnPrintableStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.TeletexString:
            return AsnTeletexStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.UTCTime:
            return AsnUTCTimeConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.UniversalString:
            return AsnUniversalStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.Utf8String:
            return AsnUtf8StringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.VideotexString:
            return AsnVideotexStringConverter;
        case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes.VisibleString:
            return AsnVisibleStringConverter;
        default:
            return null;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnChoiceType: () => (/* binding */ AsnChoiceType),
/* harmony export */   AsnProp: () => (/* binding */ AsnProp),
/* harmony export */   AsnSequenceType: () => (/* binding */ AsnSequenceType),
/* harmony export */   AsnSetType: () => (/* binding */ AsnSetType),
/* harmony export */   AsnType: () => (/* binding */ AsnType)
/* harmony export */ });
/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./converters */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/storage.js");



const AsnType = (options) => (target) => {
    let schema;
    if (!_storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.has(target)) {
        schema = _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.createDefault(target);
        _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.set(target, schema);
    }
    else {
        schema = _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.get(target);
    }
    Object.assign(schema, options);
};
const AsnChoiceType = () => AsnType({ type: _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Choice });
const AsnSetType = (options) => AsnType({ type: _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Set, ...options });
const AsnSequenceType = (options) => AsnType({ type: _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence, ...options });
const AsnProp = (options) => (target, propertyKey) => {
    let schema;
    if (!_storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.has(target.constructor)) {
        schema = _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.createDefault(target.constructor);
        _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.set(target.constructor, schema);
    }
    else {
        schema = _storage__WEBPACK_IMPORTED_MODULE_2__.schemaStorage.get(target.constructor);
    }
    const copyOptions = Object.assign({}, options);
    if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const defaultConverter = _converters__WEBPACK_IMPORTED_MODULE_0__.defaultConverter(options.type);
        if (!defaultConverter) {
            throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
        }
        copyOptions.converter = defaultConverter;
    }
    schema.items[propertyKey] = copyOptions;
};


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnPropTypes: () => (/* binding */ AsnPropTypes),
/* harmony export */   AsnTypeTypes: () => (/* binding */ AsnTypeTypes)
/* harmony export */ });
var AsnTypeTypes;
(function (AsnTypeTypes) {
    AsnTypeTypes[AsnTypeTypes["Sequence"] = 0] = "Sequence";
    AsnTypeTypes[AsnTypeTypes["Set"] = 1] = "Set";
    AsnTypeTypes[AsnTypeTypes["Choice"] = 2] = "Choice";
})(AsnTypeTypes || (AsnTypeTypes = {}));
var AsnPropTypes;
(function (AsnPropTypes) {
    AsnPropTypes[AsnPropTypes["Any"] = 1] = "Any";
    AsnPropTypes[AsnPropTypes["Boolean"] = 2] = "Boolean";
    AsnPropTypes[AsnPropTypes["OctetString"] = 3] = "OctetString";
    AsnPropTypes[AsnPropTypes["BitString"] = 4] = "BitString";
    AsnPropTypes[AsnPropTypes["Integer"] = 5] = "Integer";
    AsnPropTypes[AsnPropTypes["Enumerated"] = 6] = "Enumerated";
    AsnPropTypes[AsnPropTypes["ObjectIdentifier"] = 7] = "ObjectIdentifier";
    AsnPropTypes[AsnPropTypes["Utf8String"] = 8] = "Utf8String";
    AsnPropTypes[AsnPropTypes["BmpString"] = 9] = "BmpString";
    AsnPropTypes[AsnPropTypes["UniversalString"] = 10] = "UniversalString";
    AsnPropTypes[AsnPropTypes["NumericString"] = 11] = "NumericString";
    AsnPropTypes[AsnPropTypes["PrintableString"] = 12] = "PrintableString";
    AsnPropTypes[AsnPropTypes["TeletexString"] = 13] = "TeletexString";
    AsnPropTypes[AsnPropTypes["VideotexString"] = 14] = "VideotexString";
    AsnPropTypes[AsnPropTypes["IA5String"] = 15] = "IA5String";
    AsnPropTypes[AsnPropTypes["GraphicString"] = 16] = "GraphicString";
    AsnPropTypes[AsnPropTypes["VisibleString"] = 17] = "VisibleString";
    AsnPropTypes[AsnPropTypes["GeneralString"] = 18] = "GeneralString";
    AsnPropTypes[AsnPropTypes["CharacterString"] = 19] = "CharacterString";
    AsnPropTypes[AsnPropTypes["UTCTime"] = 20] = "UTCTime";
    AsnPropTypes[AsnPropTypes["GeneralizedTime"] = 21] = "GeneralizedTime";
    AsnPropTypes[AsnPropTypes["DATE"] = 22] = "DATE";
    AsnPropTypes[AsnPropTypes["TimeOfDay"] = 23] = "TimeOfDay";
    AsnPropTypes[AsnPropTypes["DateTime"] = 24] = "DateTime";
    AsnPropTypes[AsnPropTypes["Duration"] = 25] = "Duration";
    AsnPropTypes[AsnPropTypes["TIME"] = 26] = "TIME";
    AsnPropTypes[AsnPropTypes["Null"] = 27] = "Null";
})(AsnPropTypes || (AsnPropTypes = {}));


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnSchemaValidationError: () => (/* reexport safe */ _schema_validation__WEBPACK_IMPORTED_MODULE_0__.AsnSchemaValidationError)
/* harmony export */ });
/* harmony import */ var _schema_validation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema_validation */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js");



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnSchemaValidationError: () => (/* binding */ AsnSchemaValidationError)
/* harmony export */ });
class AsnSchemaValidationError extends Error {
    constructor() {
        super(...arguments);
        this.schemas = [];
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/helper.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/helper.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArrayEqual: () => (/* binding */ isArrayEqual),
/* harmony export */   isConvertible: () => (/* binding */ isConvertible),
/* harmony export */   isTypeOfArray: () => (/* binding */ isTypeOfArray)
/* harmony export */ });
function isConvertible(target) {
    if (typeof target === "function" && target.prototype) {
        if (target.prototype.toASN && target.prototype.fromASN) {
            return true;
        }
        else {
            return isConvertible(target.prototype);
        }
    }
    else {
        return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
    }
}
function isTypeOfArray(target) {
    var _a;
    if (target) {
        const proto = Object.getPrototypeOf(target);
        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {
            return true;
        }
        return isTypeOfArray(proto);
    }
    return false;
}
function isArrayEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
        return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnAnyConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnAnyConverter),
/* harmony export */   AsnArray: () => (/* reexport safe */ _objects__WEBPACK_IMPORTED_MODULE_7__.AsnArray),
/* harmony export */   AsnBitStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnBitStringConverter),
/* harmony export */   AsnBmpStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnBmpStringConverter),
/* harmony export */   AsnBooleanConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnBooleanConverter),
/* harmony export */   AsnCharacterStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnCharacterStringConverter),
/* harmony export */   AsnChoiceType: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_2__.AsnChoiceType),
/* harmony export */   AsnConstructedOctetStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnConstructedOctetStringConverter),
/* harmony export */   AsnConvert: () => (/* reexport safe */ _convert__WEBPACK_IMPORTED_MODULE_8__.AsnConvert),
/* harmony export */   AsnEnumeratedConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnEnumeratedConverter),
/* harmony export */   AsnGeneralStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnGeneralStringConverter),
/* harmony export */   AsnGeneralizedTimeConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnGeneralizedTimeConverter),
/* harmony export */   AsnGraphicStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnGraphicStringConverter),
/* harmony export */   AsnIA5StringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnIA5StringConverter),
/* harmony export */   AsnIntegerArrayBufferConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter),
/* harmony export */   AsnIntegerBigIntConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerBigIntConverter),
/* harmony export */   AsnIntegerConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerConverter),
/* harmony export */   AsnNullConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnNullConverter),
/* harmony export */   AsnNumericStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnNumericStringConverter),
/* harmony export */   AsnObjectIdentifierConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnObjectIdentifierConverter),
/* harmony export */   AsnOctetStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnOctetStringConverter),
/* harmony export */   AsnParser: () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_4__.AsnParser),
/* harmony export */   AsnPrintableStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnPrintableStringConverter),
/* harmony export */   AsnProp: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_2__.AsnProp),
/* harmony export */   AsnPropTypes: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_3__.AsnPropTypes),
/* harmony export */   AsnSchemaValidationError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_6__.AsnSchemaValidationError),
/* harmony export */   AsnSequenceType: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_2__.AsnSequenceType),
/* harmony export */   AsnSerializer: () => (/* reexport safe */ _serializer__WEBPACK_IMPORTED_MODULE_5__.AsnSerializer),
/* harmony export */   AsnSetType: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_2__.AsnSetType),
/* harmony export */   AsnTeletexStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnTeletexStringConverter),
/* harmony export */   AsnType: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_2__.AsnType),
/* harmony export */   AsnTypeTypes: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_3__.AsnTypeTypes),
/* harmony export */   AsnUTCTimeConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnUTCTimeConverter),
/* harmony export */   AsnUniversalStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnUniversalStringConverter),
/* harmony export */   AsnUtf8StringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnUtf8StringConverter),
/* harmony export */   AsnVideotexStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnVideotexStringConverter),
/* harmony export */   AsnVisibleStringConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.AsnVisibleStringConverter),
/* harmony export */   BitString: () => (/* reexport safe */ _types_index__WEBPACK_IMPORTED_MODULE_1__.BitString),
/* harmony export */   OctetString: () => (/* reexport safe */ _types_index__WEBPACK_IMPORTED_MODULE_1__.OctetString),
/* harmony export */   defaultConverter: () => (/* reexport safe */ _converters__WEBPACK_IMPORTED_MODULE_0__.defaultConverter)
/* harmony export */ });
/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./converters */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js");
/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/index */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/index.js");
/* harmony import */ var _decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorators */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/parser.js");
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serializer */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js");
/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/objects.js");
/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./convert */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/convert.js");











/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/objects.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/objects.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnArray: () => (/* binding */ AsnArray)
/* harmony export */ });
class AsnArray extends Array {
    constructor(items = []) {
        if (typeof items === "number") {
            super(items);
        }
        else {
            super();
            for (const item of items) {
                this.push(item);
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/parser.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/parser.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnParser: () => (/* binding */ AsnParser)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./converters */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/helper.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/storage.js");






class AsnParser {
    static parse(data, target) {
        const asn1Parsed = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(data);
        if (asn1Parsed.result.error) {
            throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
    }
    static fromASN(asn1Schema, target) {
        var _a;
        try {
            if ((0,_helper__WEBPACK_IMPORTED_MODULE_4__.isConvertible)(target)) {
                const value = new target();
                return value.fromASN(asn1Schema);
            }
            const schema = _storage__WEBPACK_IMPORTED_MODULE_5__.schemaStorage.get(target);
            _storage__WEBPACK_IMPORTED_MODULE_5__.schemaStorage.cache(target);
            let targetSchema = schema.schema;
            if (asn1Schema.constructor === asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed && schema.type !== _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Choice) {
                targetSchema = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: asn1Schema.idBlock.tagNumber,
                    },
                    value: schema.schema.valueBlock.value,
                });
                for (const key in schema.items) {
                    delete asn1Schema[key];
                }
            }
            const asn1ComparedSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__.compareSchema({}, asn1Schema, targetSchema);
            if (!asn1ComparedSchema.verified) {
                throw new _errors__WEBPACK_IMPORTED_MODULE_3__.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
            }
            const res = new target();
            if ((0,_helper__WEBPACK_IMPORTED_MODULE_4__.isTypeOfArray)(target)) {
                if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
                }
                const itemType = schema.itemType;
                if (typeof itemType === "number") {
                    const converter = _converters__WEBPACK_IMPORTED_MODULE_2__.defaultConverter(itemType);
                    if (!converter) {
                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
                    }
                    return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
                }
                else {
                    return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
                }
            }
            for (const key in schema.items) {
                const asn1SchemaValue = asn1ComparedSchema.result[key];
                if (!asn1SchemaValue) {
                    continue;
                }
                const schemaItem = schema.items[key];
                const schemaItemType = schemaItem.type;
                if (typeof schemaItemType === "number" || (0,_helper__WEBPACK_IMPORTED_MODULE_4__.isConvertible)(schemaItemType)) {
                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : ((0,_helper__WEBPACK_IMPORTED_MODULE_4__.isConvertible)(schemaItemType)
                        ? new schemaItemType()
                        : null);
                    if (!converter) {
                        throw new Error("Converter is empty");
                    }
                    if (schemaItem.repeated) {
                        if (schemaItem.implicit) {
                            const Container = schemaItem.repeated === "sequence" ? asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence : asn1js__WEBPACK_IMPORTED_MODULE_0__.Set;
                            const newItem = new Container();
                            newItem.valueBlock = asn1SchemaValue.valueBlock;
                            const newItemAsn = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(newItem.toBER(false));
                            if (newItemAsn.offset === -1) {
                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
                            }
                            if (!("value" in newItemAsn.result.valueBlock &&
                                Array.isArray(newItemAsn.result.valueBlock.value))) {
                                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
                            }
                            const value = newItemAsn.result.valueBlock.value;
                            res[key] = Array.from(value, (element) => converter.fromASN(element));
                        }
                        else {
                            res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
                        }
                    }
                    else {
                        let value = asn1SchemaValue;
                        if (schemaItem.implicit) {
                            let newItem;
                            if ((0,_helper__WEBPACK_IMPORTED_MODULE_4__.isConvertible)(schemaItemType)) {
                                newItem = new schemaItemType().toSchema("");
                            }
                            else {
                                const Asn1TypeName = _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes[schemaItemType];
                                const Asn1Type = asn1js__WEBPACK_IMPORTED_MODULE_0__[Asn1TypeName];
                                if (!Asn1Type) {
                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                                }
                                newItem = new Asn1Type();
                            }
                            newItem.valueBlock = value.valueBlock;
                            value = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(newItem.toBER(false)).result;
                        }
                        res[key] = converter.fromASN(value);
                    }
                }
                else {
                    if (schemaItem.repeated) {
                        if (!Array.isArray(asn1SchemaValue)) {
                            throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
                        }
                        res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
                    }
                    else {
                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
                    }
                }
            }
            return res;
        }
        catch (error) {
            if (error instanceof _errors__WEBPACK_IMPORTED_MODULE_3__.AsnSchemaValidationError) {
                error.schemas.push(target.name);
            }
            throw error;
        }
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/schema.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/schema.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnSchemaStorage: () => (/* binding */ AsnSchemaStorage)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/helper.js");



class AsnSchemaStorage {
    constructor() {
        this.items = new WeakMap();
    }
    has(target) {
        return this.items.has(target);
    }
    get(target, checkSchema = false) {
        const schema = this.items.get(target);
        if (!schema) {
            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
        }
        if (checkSchema && !schema.schema) {
            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
        }
        return schema;
    }
    cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
            schema.schema = this.create(target, true);
        }
    }
    createDefault(target) {
        const schema = {
            type: _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence,
            items: {},
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
            Object.assign(schema, parentSchema);
            schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
    }
    create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for (const key in schema.items) {
            const item = schema.items[key];
            const name = useNames ? key : "";
            let asn1Item;
            if (typeof item.type === "number") {
                const Asn1TypeName = _enums__WEBPACK_IMPORTED_MODULE_1__.AsnPropTypes[item.type];
                const Asn1Type = asn1js__WEBPACK_IMPORTED_MODULE_0__[Asn1TypeName];
                if (!Asn1Type) {
                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
                }
                asn1Item = new Asn1Type({ name });
            }
            else if ((0,_helper__WEBPACK_IMPORTED_MODULE_2__.isConvertible)(item.type)) {
                const instance = new item.type();
                asn1Item = instance.toSchema(name);
            }
            else if (item.optional) {
                const itemSchema = this.get(item.type);
                if (itemSchema.type === _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Choice) {
                    asn1Item = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Any({ name });
                }
                else {
                    asn1Item = this.create(item.type, false);
                    asn1Item.name = name;
                }
            }
            else {
                asn1Item = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Any({ name });
            }
            const optional = !!item.optional || item.defaultValue !== undefined;
            if (item.repeated) {
                asn1Item.name = "";
                const Container = item.repeated === "set" ? asn1js__WEBPACK_IMPORTED_MODULE_0__.Set : asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence;
                asn1Item = new Container({
                    name: "",
                    value: [
                        new asn1js__WEBPACK_IMPORTED_MODULE_0__.Repeated({
                            name,
                            value: asn1Item,
                        }),
                    ],
                });
            }
            if (item.context !== null && item.context !== undefined) {
                if (item.implicit) {
                    if (typeof item.type === "number" || (0,_helper__WEBPACK_IMPORTED_MODULE_2__.isConvertible)(item.type)) {
                        const Container = item.repeated ? asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed : asn1js__WEBPACK_IMPORTED_MODULE_0__.Primitive;
                        asn1Value.push(new Container({
                            name,
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            },
                        }));
                    }
                    else {
                        this.cache(item.type);
                        const isRepeated = !!item.repeated;
                        let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
                        value =
                            "valueBlock" in value
                                ? value.valueBlock.value
                                : value.value;
                        asn1Value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed({
                            name: !isRepeated ? name : "",
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            },
                            value: value,
                        }));
                    }
                }
                else {
                    asn1Value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed({
                        optional,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: item.context,
                        },
                        value: [asn1Item],
                    }));
                }
            }
            else {
                asn1Item.optional = optional;
                asn1Value.push(asn1Item);
            }
        }
        switch (schema.type) {
            case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Sequence:
                return new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({ value: asn1Value, name: "" });
            case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Set:
                return new asn1js__WEBPACK_IMPORTED_MODULE_0__.Set({ value: asn1Value, name: "" });
            case _enums__WEBPACK_IMPORTED_MODULE_1__.AsnTypeTypes.Choice:
                return new asn1js__WEBPACK_IMPORTED_MODULE_0__.Choice({ value: asn1Value, name: "" });
            default:
                throw new Error(`Unsupported ASN1 type in use`);
        }
    }
    set(target, schema) {
        this.items.set(target, schema);
        return this;
    }
    findParentSchema(target) {
        const parent = Object.getPrototypeOf(target);
        if (parent) {
            const schema = this.items.get(parent);
            return schema || this.findParentSchema(parent);
        }
        return null;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnSerializer: () => (/* binding */ AsnSerializer)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./converters */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/converters.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/enums.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/helper.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/storage.js");





class AsnSerializer {
    static serialize(obj) {
        if (obj instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__.BaseBlock) {
            return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
    }
    static toASN(obj) {
        if (obj && typeof obj === "object" && (0,_helper__WEBPACK_IMPORTED_MODULE_3__.isConvertible)(obj)) {
            return obj.toASN();
        }
        if (!(obj && typeof obj === "object")) {
            throw new TypeError("Parameter 1 should be type of Object.");
        }
        const target = obj.constructor;
        const schema = _storage__WEBPACK_IMPORTED_MODULE_4__.schemaStorage.get(target);
        _storage__WEBPACK_IMPORTED_MODULE_4__.schemaStorage.cache(target);
        let asn1Value = [];
        if (schema.itemType) {
            if (!Array.isArray(obj)) {
                throw new TypeError("Parameter 1 should be type of Array.");
            }
            if (typeof schema.itemType === "number") {
                const converter = _converters__WEBPACK_IMPORTED_MODULE_1__.defaultConverter(schema.itemType);
                if (!converter) {
                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
                }
                asn1Value = obj.map((o) => converter.toASN(o));
            }
            else {
                asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
            }
        }
        else {
            for (const key in schema.items) {
                const schemaItem = schema.items[key];
                const objProp = obj[key];
                if (objProp === undefined ||
                    schemaItem.defaultValue === objProp ||
                    (typeof schemaItem.defaultValue === "object" &&
                        typeof objProp === "object" &&
                        (0,_helper__WEBPACK_IMPORTED_MODULE_3__.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp)))) {
                    continue;
                }
                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
                if (typeof schemaItem.context === "number") {
                    if (schemaItem.implicit) {
                        if (!schemaItem.repeated &&
                            (typeof schemaItem.type === "number" || (0,_helper__WEBPACK_IMPORTED_MODULE_3__.isConvertible)(schemaItem.type))) {
                            const value = {};
                            value.valueHex =
                                asn1Item instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__.Null
                                    ? asn1Item.valueBeforeDecodeView
                                    : asn1Item.valueBlock.toBER();
                            asn1Value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__.Primitive({
                                optional: schemaItem.optional,
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: schemaItem.context,
                                },
                                ...value,
                            }));
                        }
                        else {
                            asn1Value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed({
                                optional: schemaItem.optional,
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: schemaItem.context,
                                },
                                value: asn1Item.valueBlock.value,
                            }));
                        }
                    }
                    else {
                        asn1Value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__.Constructed({
                            optional: schemaItem.optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: schemaItem.context,
                            },
                            value: [asn1Item],
                        }));
                    }
                }
                else if (schemaItem.repeated) {
                    asn1Value = asn1Value.concat(asn1Item);
                }
                else {
                    asn1Value.push(asn1Item);
                }
            }
        }
        let asnSchema;
        switch (schema.type) {
            case _enums__WEBPACK_IMPORTED_MODULE_2__.AsnTypeTypes.Sequence:
                asnSchema = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({ value: asn1Value });
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_2__.AsnTypeTypes.Set:
                asnSchema = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Set({ value: asn1Value });
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_2__.AsnTypeTypes.Choice:
                if (!asn1Value[0]) {
                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
                }
                asnSchema = asn1Value[0];
                break;
        }
        return asnSchema;
    }
    static toAsnItem(schemaItem, key, target, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
            const converter = schemaItem.converter;
            if (!converter) {
                throw new Error(`Property '${key}' doesn't have converter for type ${_enums__WEBPACK_IMPORTED_MODULE_2__.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
            }
            if (schemaItem.repeated) {
                if (!Array.isArray(objProp)) {
                    throw new TypeError("Parameter 'objProp' should be type of Array.");
                }
                const items = Array.from(objProp, (element) => converter.toASN(element));
                const Container = schemaItem.repeated === "sequence" ? asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence : asn1js__WEBPACK_IMPORTED_MODULE_0__.Set;
                asn1Item = new Container({
                    value: items,
                });
            }
            else {
                asn1Item = converter.toASN(objProp);
            }
        }
        else {
            if (schemaItem.repeated) {
                if (!Array.isArray(objProp)) {
                    throw new TypeError("Parameter 'objProp' should be type of Array.");
                }
                const items = Array.from(objProp, (element) => this.toASN(element));
                const Container = schemaItem.repeated === "sequence" ? asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence : asn1js__WEBPACK_IMPORTED_MODULE_0__.Set;
                asn1Item = new Container({
                    value: items,
                });
            }
            else {
                asn1Item = this.toASN(objProp);
            }
        }
        return asn1Item;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/storage.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/storage.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   schemaStorage: () => (/* binding */ schemaStorage)
/* harmony export */ });
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/schema.js");

const schemaStorage = new _schema__WEBPACK_IMPORTED_MODULE_0__.AsnSchemaStorage();


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitString: () => (/* binding */ BitString)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");


class BitString {
    constructor(params, unusedBits = 0) {
        this.unusedBits = 0;
        this.value = new ArrayBuffer(0);
        if (params) {
            if (typeof params === "number") {
                this.fromNumber(params);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.isBufferSource(params)) {
                this.unusedBits = unusedBits;
                this.value = pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.toArrayBuffer(params);
            }
            else {
                throw TypeError("Unsupported type of 'params' argument for BitString");
            }
        }
    }
    fromASN(asn) {
        if (!(asn instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__.BitString)) {
            throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
        }
        this.unusedBits = asn.valueBlock.unusedBits;
        this.value = asn.valueBlock.valueHex;
        return this;
    }
    toASN() {
        return new asn1js__WEBPACK_IMPORTED_MODULE_0__.BitString({ unusedBits: this.unusedBits, valueHex: this.value });
    }
    toSchema(name) {
        return new asn1js__WEBPACK_IMPORTED_MODULE_0__.BitString({ name });
    }
    toNumber() {
        let res = "";
        const uintArray = new Uint8Array(this.value);
        for (const octet of uintArray) {
            res += octet.toString(2).padStart(8, "0");
        }
        res = res.split("").reverse().join("");
        if (this.unusedBits) {
            res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
        }
        return parseInt(res, 2);
    }
    fromNumber(value) {
        let bits = value.toString(2);
        const octetSize = (bits.length + 7) >> 3;
        this.unusedBits = (octetSize << 3) - bits.length;
        const octets = new Uint8Array(octetSize);
        bits = bits
            .padStart(octetSize << 3, "0")
            .split("")
            .reverse()
            .join("");
        let index = 0;
        while (index < octetSize) {
            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
            index++;
        }
        this.value = octets.buffer;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/index.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/index.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitString: () => (/* reexport safe */ _bit_string__WEBPACK_IMPORTED_MODULE_0__.BitString),
/* harmony export */   OctetString: () => (/* reexport safe */ _octet_string__WEBPACK_IMPORTED_MODULE_1__.OctetString)
/* harmony export */ });
/* harmony import */ var _bit_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bit_string */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js");
/* harmony import */ var _octet_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./octet_string */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js");




/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OctetString: () => (/* binding */ OctetString)
/* harmony export */ });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");


class OctetString {
    get byteLength() {
        return this.buffer.byteLength;
    }
    get byteOffset() {
        return 0;
    }
    constructor(param) {
        if (typeof param === "number") {
            this.buffer = new ArrayBuffer(param);
        }
        else {
            if (pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.isBufferSource(param)) {
                this.buffer = pvtsutils__WEBPACK_IMPORTED_MODULE_1__.BufferSourceConverter.toArrayBuffer(param);
            }
            else if (Array.isArray(param)) {
                this.buffer = new Uint8Array(param);
            }
            else {
                this.buffer = new ArrayBuffer(0);
            }
        }
    }
    fromASN(asn) {
        if (!(asn instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString)) {
            throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
        }
        this.buffer = asn.valueBlock.valueHex;
        return this;
    }
    toASN() {
        return new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({ valueHex: this.buffer });
    }
    toSchema(name) {
        return new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({ name });
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACClearAttrs: () => (/* binding */ ACClearAttrs)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class ACClearAttrs {
    constructor(params = {}) {
        this.acIssuer = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName();
        this.acSerial = 0;
        this.attrs = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], ACClearAttrs.prototype, "acIssuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], ACClearAttrs.prototype, "acSerial", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Attribute, repeated: "sequence" })
], ACClearAttrs.prototype, "attrs", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AAControls: () => (/* binding */ AAControls)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _attr_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr_spec */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js");



class AAControls {
    constructor(params = {}) {
        this.permitUnSpecified = true;
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, optional: true })
], AAControls.prototype, "pathLenConstraint", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attr_spec__WEBPACK_IMPORTED_MODULE_1__.AttrSpec, implicit: true, context: 0, optional: true })
], AAControls.prototype, "permittedAttrs", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attr_spec__WEBPACK_IMPORTED_MODULE_1__.AttrSpec, implicit: true, context: 1, optional: true })
], AAControls.prototype, "excludedAttrs", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean, defaultValue: true })
], AAControls.prototype, "permitUnSpecified", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttCertIssuer: () => (/* binding */ AttCertIssuer)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _v2_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v2_form */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js");




let AttCertIssuer = class AttCertIssuer {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName, repeated: "sequence" })
], AttCertIssuer.prototype, "v1Form", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _v2_form__WEBPACK_IMPORTED_MODULE_2__.V2Form, context: 0, implicit: true })
], AttCertIssuer.prototype, "v2Form", void 0);
AttCertIssuer = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], AttCertIssuer);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttCertValidityPeriod: () => (/* binding */ AttCertValidityPeriod)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class AttCertValidityPeriod {
    constructor(params = {}) {
        this.notBeforeTime = new Date();
        this.notAfterTime = new Date();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notBeforeTime", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notAfterTime", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttrSpec: () => (/* binding */ AttrSpec)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
var AttrSpec_1;


let AttrSpec = AttrSpec_1 = class AttrSpec extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AttrSpec_1.prototype);
    }
};
AttrSpec = AttrSpec_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], AttrSpec);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeCertificate: () => (/* binding */ AttributeCertificate)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute_certificate_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js");




class AttributeCertificate {
    constructor(params = {}) {
        this.acinfo = new _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_2__.AttributeCertificateInfo();
        this.signatureAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.signatureValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_2__.AttributeCertificateInfo })
], AttributeCertificate.prototype, "acinfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], AttributeCertificate.prototype, "signatureAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], AttributeCertificate.prototype, "signatureValue", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttCertVersion: () => (/* binding */ AttCertVersion),
/* harmony export */   AttributeCertificateInfo: () => (/* binding */ AttributeCertificateInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _holder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./holder */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js");
/* harmony import */ var _attr_cert_issuer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attr_cert_issuer */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js");
/* harmony import */ var _attr_cert_validity_period__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attr_cert_validity_period */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js");






var AttCertVersion;
(function (AttCertVersion) {
    AttCertVersion[AttCertVersion["v2"] = 1] = "v2";
})(AttCertVersion || (AttCertVersion = {}));
class AttributeCertificateInfo {
    constructor(params = {}) {
        this.version = AttCertVersion.v2;
        this.holder = new _holder__WEBPACK_IMPORTED_MODULE_2__.Holder();
        this.issuer = new _attr_cert_issuer__WEBPACK_IMPORTED_MODULE_3__.AttCertIssuer();
        this.signature = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.serialNumber = new ArrayBuffer(0);
        this.attrCertValidityPeriod = new _attr_cert_validity_period__WEBPACK_IMPORTED_MODULE_4__.AttCertValidityPeriod();
        this.attributes = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], AttributeCertificateInfo.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _holder__WEBPACK_IMPORTED_MODULE_2__.Holder })
], AttributeCertificateInfo.prototype, "holder", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attr_cert_issuer__WEBPACK_IMPORTED_MODULE_3__.AttCertIssuer })
], AttributeCertificateInfo.prototype, "issuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], AttributeCertificateInfo.prototype, "signature", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], AttributeCertificateInfo.prototype, "serialNumber", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _attr_cert_validity_period__WEBPACK_IMPORTED_MODULE_4__.AttCertValidityPeriod })
], AttributeCertificateInfo.prototype, "attrCertValidityPeriod", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Attribute, repeated: "sequence" })
], AttributeCertificateInfo.prototype, "attributes", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString, optional: true })
], AttributeCertificateInfo.prototype, "issuerUniqueID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.Extensions, optional: true })
], AttributeCertificateInfo.prototype, "extensions", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClassList: () => (/* binding */ ClassList),
/* harmony export */   ClassListFlags: () => (/* binding */ ClassListFlags)
/* harmony export */ });
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");

var ClassListFlags;
(function (ClassListFlags) {
    ClassListFlags[ClassListFlags["unmarked"] = 1] = "unmarked";
    ClassListFlags[ClassListFlags["unclassified"] = 2] = "unclassified";
    ClassListFlags[ClassListFlags["restricted"] = 4] = "restricted";
    ClassListFlags[ClassListFlags["confidential"] = 8] = "confidential";
    ClassListFlags[ClassListFlags["secret"] = 16] = "secret";
    ClassListFlags[ClassListFlags["topSecret"] = 32] = "topSecret";
})(ClassListFlags || (ClassListFlags = {}));
class ClassList extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.BitString {
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Clearance: () => (/* binding */ Clearance)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _class_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./class_list */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js");
/* harmony import */ var _security_category__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./security_category */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js");




class Clearance {
    constructor(params = {}) {
        this.policyId = "";
        this.classList = new _class_list__WEBPACK_IMPORTED_MODULE_1__.ClassList(_class_list__WEBPACK_IMPORTED_MODULE_1__.ClassListFlags.unclassified);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], Clearance.prototype, "policyId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _class_list__WEBPACK_IMPORTED_MODULE_1__.ClassList, defaultValue: new _class_list__WEBPACK_IMPORTED_MODULE_1__.ClassList(_class_list__WEBPACK_IMPORTED_MODULE_1__.ClassListFlags.unclassified) })
], Clearance.prototype, "classList", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _security_category__WEBPACK_IMPORTED_MODULE_2__.SecurityCategory, repeated: "set" })
], Clearance.prototype, "securityCategories", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Holder: () => (/* binding */ Holder)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _issuer_serial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./issuer_serial */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _object_digest_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object_digest_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js");





class Holder {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_serial__WEBPACK_IMPORTED_MODULE_1__.IssuerSerial, implicit: true, context: 0, optional: true })
], Holder.prototype, "baseCertificateID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralNames, implicit: true, context: 1, optional: true })
], Holder.prototype, "entityName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _object_digest_info__WEBPACK_IMPORTED_MODULE_3__.ObjectDigestInfo, implicit: true, context: 2, optional: true })
], Holder.prototype, "objectDigestInfo", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IetfAttrSyntax: () => (/* binding */ IetfAttrSyntax),
/* harmony export */   IetfAttrSyntaxValueChoices: () => (/* binding */ IetfAttrSyntaxValueChoices)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class IetfAttrSyntaxValueChoices {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], IetfAttrSyntaxValueChoices.prototype, "cotets", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], IetfAttrSyntaxValueChoices.prototype, "oid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Utf8String })
], IetfAttrSyntaxValueChoices.prototype, "string", void 0);
class IetfAttrSyntax {
    constructor(params = {}) {
        this.values = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralNames, implicit: true, context: 0, optional: true })
], IetfAttrSyntax.prototype, "policyAuthority", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: IetfAttrSyntaxValueChoices, repeated: "sequence" })
], IetfAttrSyntax.prototype, "values", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/index.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/index.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AAControls: () => (/* reexport safe */ _aa_controls__WEBPACK_IMPORTED_MODULE_1__.AAControls),
/* harmony export */   ACClearAttrs: () => (/* reexport safe */ _aa_clear_attrs__WEBPACK_IMPORTED_MODULE_0__.ACClearAttrs),
/* harmony export */   AttCertIssuer: () => (/* reexport safe */ _attr_cert_issuer__WEBPACK_IMPORTED_MODULE_2__.AttCertIssuer),
/* harmony export */   AttCertValidityPeriod: () => (/* reexport safe */ _attr_cert_validity_period__WEBPACK_IMPORTED_MODULE_3__.AttCertValidityPeriod),
/* harmony export */   AttCertVersion: () => (/* reexport safe */ _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_6__.AttCertVersion),
/* harmony export */   AttrSpec: () => (/* reexport safe */ _attr_spec__WEBPACK_IMPORTED_MODULE_4__.AttrSpec),
/* harmony export */   AttributeCertificate: () => (/* reexport safe */ _attribute_certificate__WEBPACK_IMPORTED_MODULE_5__.AttributeCertificate),
/* harmony export */   AttributeCertificateInfo: () => (/* reexport safe */ _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_6__.AttributeCertificateInfo),
/* harmony export */   ClassList: () => (/* reexport safe */ _class_list__WEBPACK_IMPORTED_MODULE_7__.ClassList),
/* harmony export */   ClassListFlags: () => (/* reexport safe */ _class_list__WEBPACK_IMPORTED_MODULE_7__.ClassListFlags),
/* harmony export */   Clearance: () => (/* reexport safe */ _clearance__WEBPACK_IMPORTED_MODULE_8__.Clearance),
/* harmony export */   DigestedObjectType: () => (/* reexport safe */ _object_digest_info__WEBPACK_IMPORTED_MODULE_12__.DigestedObjectType),
/* harmony export */   Holder: () => (/* reexport safe */ _holder__WEBPACK_IMPORTED_MODULE_9__.Holder),
/* harmony export */   IetfAttrSyntax: () => (/* reexport safe */ _ietf_attr_syntax__WEBPACK_IMPORTED_MODULE_10__.IetfAttrSyntax),
/* harmony export */   IetfAttrSyntaxValueChoices: () => (/* reexport safe */ _ietf_attr_syntax__WEBPACK_IMPORTED_MODULE_10__.IetfAttrSyntaxValueChoices),
/* harmony export */   IssuerSerial: () => (/* reexport safe */ _issuer_serial__WEBPACK_IMPORTED_MODULE_11__.IssuerSerial),
/* harmony export */   ObjectDigestInfo: () => (/* reexport safe */ _object_digest_info__WEBPACK_IMPORTED_MODULE_12__.ObjectDigestInfo),
/* harmony export */   ProxyInfo: () => (/* reexport safe */ _proxy_info__WEBPACK_IMPORTED_MODULE_14__.ProxyInfo),
/* harmony export */   RoleSyntax: () => (/* reexport safe */ _role_syntax__WEBPACK_IMPORTED_MODULE_15__.RoleSyntax),
/* harmony export */   SecurityCategory: () => (/* reexport safe */ _security_category__WEBPACK_IMPORTED_MODULE_16__.SecurityCategory),
/* harmony export */   SvceAuthInfo: () => (/* reexport safe */ _svce_auth_info__WEBPACK_IMPORTED_MODULE_17__.SvceAuthInfo),
/* harmony export */   Target: () => (/* reexport safe */ _target__WEBPACK_IMPORTED_MODULE_18__.Target),
/* harmony export */   TargetCert: () => (/* reexport safe */ _target__WEBPACK_IMPORTED_MODULE_18__.TargetCert),
/* harmony export */   Targets: () => (/* reexport safe */ _target__WEBPACK_IMPORTED_MODULE_18__.Targets),
/* harmony export */   V2Form: () => (/* reexport safe */ _v2_form__WEBPACK_IMPORTED_MODULE_19__.V2Form),
/* harmony export */   id_aca: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca),
/* harmony export */   id_aca_accessIdentity: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca_accessIdentity),
/* harmony export */   id_aca_authenticationInfo: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca_authenticationInfo),
/* harmony export */   id_aca_chargingIdentity: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca_chargingIdentity),
/* harmony export */   id_aca_encAttrs: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca_encAttrs),
/* harmony export */   id_aca_group: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_aca_group),
/* harmony export */   id_at: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_at),
/* harmony export */   id_at_clearance: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_at_clearance),
/* harmony export */   id_at_role: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_at_role),
/* harmony export */   id_ce_targetInformation: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_ce_targetInformation),
/* harmony export */   id_pe_aaControls: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_pe_aaControls),
/* harmony export */   id_pe_ac_auditIdentity: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_pe_ac_auditIdentity),
/* harmony export */   id_pe_ac_proxying: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_13__.id_pe_ac_proxying)
/* harmony export */ });
/* harmony import */ var _aa_clear_attrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aa_clear_attrs */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js");
/* harmony import */ var _aa_controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aa_controls */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js");
/* harmony import */ var _attr_cert_issuer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attr_cert_issuer */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js");
/* harmony import */ var _attr_cert_validity_period__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attr_cert_validity_period */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js");
/* harmony import */ var _attr_spec__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attr_spec */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js");
/* harmony import */ var _attribute_certificate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attribute_certificate */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js");
/* harmony import */ var _attribute_certificate_info__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attribute_certificate_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js");
/* harmony import */ var _class_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./class_list */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js");
/* harmony import */ var _clearance__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./clearance */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js");
/* harmony import */ var _holder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./holder */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js");
/* harmony import */ var _ietf_attr_syntax__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ietf_attr_syntax */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js");
/* harmony import */ var _issuer_serial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./issuer_serial */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js");
/* harmony import */ var _object_digest_info__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./object_digest_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js");
/* harmony import */ var _proxy_info__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./proxy_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js");
/* harmony import */ var _role_syntax__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./role_syntax */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js");
/* harmony import */ var _security_category__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./security_category */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js");
/* harmony import */ var _svce_auth_info__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./svce_auth_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js");
/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./target */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js");
/* harmony import */ var _v2_form__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./v2_form */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js");






















/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IssuerSerial: () => (/* binding */ IssuerSerial)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class IssuerSerial {
    constructor(params = {}) {
        this.issuer = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralNames();
        this.serial = new ArrayBuffer(0);
        this.issuerUID = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralNames })
], IssuerSerial.prototype, "issuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], IssuerSerial.prototype, "serial", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString, optional: true })
], IssuerSerial.prototype, "issuerUID", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DigestedObjectType: () => (/* binding */ DigestedObjectType),
/* harmony export */   ObjectDigestInfo: () => (/* binding */ ObjectDigestInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



var DigestedObjectType;
(function (DigestedObjectType) {
    DigestedObjectType[DigestedObjectType["publicKey"] = 0] = "publicKey";
    DigestedObjectType[DigestedObjectType["publicKeyCert"] = 1] = "publicKeyCert";
    DigestedObjectType[DigestedObjectType["otherObjectTypes"] = 2] = "otherObjectTypes";
})(DigestedObjectType || (DigestedObjectType = {}));
class ObjectDigestInfo {
    constructor(params = {}) {
        this.digestedObjectType = DigestedObjectType.publicKey;
        this.digestAlgorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.objectDigest = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Enumerated })
], ObjectDigestInfo.prototype, "digestedObjectType", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier, optional: true })
], ObjectDigestInfo.prototype, "otherObjectTypeID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], ObjectDigestInfo.prototype, "digestAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], ObjectDigestInfo.prototype, "objectDigest", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_aca: () => (/* binding */ id_aca),
/* harmony export */   id_aca_accessIdentity: () => (/* binding */ id_aca_accessIdentity),
/* harmony export */   id_aca_authenticationInfo: () => (/* binding */ id_aca_authenticationInfo),
/* harmony export */   id_aca_chargingIdentity: () => (/* binding */ id_aca_chargingIdentity),
/* harmony export */   id_aca_encAttrs: () => (/* binding */ id_aca_encAttrs),
/* harmony export */   id_aca_group: () => (/* binding */ id_aca_group),
/* harmony export */   id_at: () => (/* binding */ id_at),
/* harmony export */   id_at_clearance: () => (/* binding */ id_at_clearance),
/* harmony export */   id_at_role: () => (/* binding */ id_at_role),
/* harmony export */   id_ce_targetInformation: () => (/* binding */ id_ce_targetInformation),
/* harmony export */   id_pe_aaControls: () => (/* binding */ id_pe_aaControls),
/* harmony export */   id_pe_ac_auditIdentity: () => (/* binding */ id_pe_ac_auditIdentity),
/* harmony export */   id_pe_ac_proxying: () => (/* binding */ id_pe_ac_proxying)
/* harmony export */ });
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");

const id_pe_ac_auditIdentity = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.id_pe}.4`;
const id_pe_aaControls = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.id_pe}.6`;
const id_pe_ac_proxying = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.id_pe}.10`;
const id_ce_targetInformation = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.id_ce}.55`;
const id_aca = `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_0__.id_pkix}.10`;
const id_aca_authenticationInfo = `${id_aca}.1`;
const id_aca_accessIdentity = `${id_aca}.2`;
const id_aca_chargingIdentity = `${id_aca}.3`;
const id_aca_group = `${id_aca}.4`;
const id_aca_encAttrs = `${id_aca}.6`;
const id_at = "2.5.4";
const id_at_role = `${id_at}.72`;
const id_at_clearance = "2.5.1.5.55";


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyInfo: () => (/* binding */ ProxyInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./target */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js");
var ProxyInfo_1;



let ProxyInfo = ProxyInfo_1 = class ProxyInfo extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ProxyInfo_1.prototype);
    }
};
ProxyInfo = ProxyInfo_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _target__WEBPACK_IMPORTED_MODULE_1__.Targets })
], ProxyInfo);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoleSyntax: () => (/* binding */ RoleSyntax)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class RoleSyntax {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralNames, implicit: true, context: 0, optional: true })
], RoleSyntax.prototype, "roleAuthority", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName, implicit: true, context: 1 })
], RoleSyntax.prototype, "roleName", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecurityCategory: () => (/* binding */ SecurityCategory)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class SecurityCategory {
    constructor(params = {}) {
        this.type = "";
        this.value = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier, implicit: true, context: 0 })
], SecurityCategory.prototype, "type", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, implicit: true, context: 1 })
], SecurityCategory.prototype, "value", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SvceAuthInfo: () => (/* binding */ SvceAuthInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");



class SvceAuthInfo {
    constructor(params = {}) {
        this.service = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName();
        this.ident = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], SvceAuthInfo.prototype, "service", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], SvceAuthInfo.prototype, "ident", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString, optional: true })
], SvceAuthInfo.prototype, "authInfo", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Target: () => (/* binding */ Target),
/* harmony export */   TargetCert: () => (/* binding */ TargetCert),
/* harmony export */   Targets: () => (/* binding */ Targets)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _issuer_serial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./issuer_serial */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js");
/* harmony import */ var _object_digest_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object_digest_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js");
var Targets_1;





class TargetCert {
    constructor(params = {}) {
        this.targetCertificate = new _issuer_serial__WEBPACK_IMPORTED_MODULE_2__.IssuerSerial();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_serial__WEBPACK_IMPORTED_MODULE_2__.IssuerSerial })
], TargetCert.prototype, "targetCertificate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName, optional: true })
], TargetCert.prototype, "targetName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _object_digest_info__WEBPACK_IMPORTED_MODULE_3__.ObjectDigestInfo, optional: true })
], TargetCert.prototype, "certDigestInfo", void 0);
let Target = class Target {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName, context: 0, implicit: true })
], Target.prototype, "targetName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralName, context: 1, implicit: true })
], Target.prototype, "targetGroup", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: TargetCert, context: 2, implicit: true })
], Target.prototype, "targetCert", void 0);
Target = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], Target);

let Targets = Targets_1 = class Targets extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Targets_1.prototype);
    }
};
Targets = Targets_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: Target })
], Targets);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V2Form: () => (/* binding */ V2Form)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var _issuer_serial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./issuer_serial */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js");
/* harmony import */ var _object_digest_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object_digest_info */ "./node_modules/.pnpm/@peculiar+asn1-x509-attr@2.3.15/node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js");





class V2Form {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_1__.GeneralNames, optional: true })
], V2Form.prototype, "issuerName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _issuer_serial__WEBPACK_IMPORTED_MODULE_2__.IssuerSerial, context: 0, implicit: true, optional: true })
], V2Form.prototype, "baseCertificateID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _object_digest_info__WEBPACK_IMPORTED_MODULE_3__.ObjectDigestInfo, context: 1, implicit: true, optional: true })
], V2Form.prototype, "objectDigestInfo", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlgorithmIdentifier: () => (/* binding */ AlgorithmIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");



class AlgorithmIdentifier {
    constructor(params = {}) {
        this.algorithm = "";
        Object.assign(this, params);
    }
    isEqual(data) {
        return (data instanceof AlgorithmIdentifier &&
            data.algorithm == this.algorithm &&
            ((data.parameters &&
                this.parameters &&
                pvtsutils__WEBPACK_IMPORTED_MODULE_1__.isEqual(data.parameters, this.parameters)) ||
                data.parameters === this.parameters));
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier,
    })
], AlgorithmIdentifier.prototype, "algorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any,
        optional: true,
    })
], AlgorithmIdentifier.prototype, "parameters", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


class Attribute {
    constructor(params = {}) {
        this.type = "";
        this.values = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], Attribute.prototype, "type", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, repeated: "set" })
], Attribute.prototype, "values", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Certificate: () => (/* binding */ Certificate)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");
/* harmony import */ var _tbs_certificate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tbs_certificate */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js");




class Certificate {
    constructor(params = {}) {
        this.tbsCertificate = new _tbs_certificate__WEBPACK_IMPORTED_MODULE_2__.TBSCertificate();
        this.signatureAlgorithm = new _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.signatureValue = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _tbs_certificate__WEBPACK_IMPORTED_MODULE_2__.TBSCertificate })
], Certificate.prototype, "tbsCertificate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], Certificate.prototype, "signatureAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], Certificate.prototype, "signatureValue", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificateList: () => (/* binding */ CertificateList)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");
/* harmony import */ var _tbs_cert_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tbs_cert_list */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js");




class CertificateList {
    constructor(params = {}) {
        this.tbsCertList = new _tbs_cert_list__WEBPACK_IMPORTED_MODULE_2__.TBSCertList();
        this.signatureAlgorithm = new _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.signature = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _tbs_cert_list__WEBPACK_IMPORTED_MODULE_2__.TBSCertList })
], CertificateList.prototype, "tbsCertList", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], CertificateList.prototype, "signatureAlgorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], CertificateList.prototype, "signature", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extension.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extension.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension),
/* harmony export */   Extensions: () => (/* binding */ Extensions)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
var Extensions_1;


class Extension {
    constructor(params = {}) {
        this.extnID = "";
        this.critical = Extension.CRITICAL;
        this.extnValue = new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString();
        Object.assign(this, params);
    }
}
Extension.CRITICAL = false;
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], Extension.prototype, "extnID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean,
        defaultValue: Extension.CRITICAL,
    })
], Extension.prototype, "critical", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString })
], Extension.prototype, "extnValue", void 0);
let Extensions = Extensions_1 = class Extensions extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Extensions_1.prototype);
    }
};
Extensions = Extensions_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: Extension })
], Extensions);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessDescription: () => (/* binding */ AccessDescription),
/* harmony export */   AuthorityInfoAccessSyntax: () => (/* binding */ AuthorityInfoAccessSyntax),
/* harmony export */   id_pe_authorityInfoAccess: () => (/* binding */ id_pe_authorityInfoAccess)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var AuthorityInfoAccessSyntax_1;




const id_pe_authorityInfoAccess = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_pe}.1`;
class AccessDescription {
    constructor(params = {}) {
        this.accessMethod = "";
        this.accessLocation = new _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], AccessDescription.prototype, "accessMethod", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], AccessDescription.prototype, "accessLocation", void 0);
let AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
    }
};
AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: AccessDescription })
], AuthorityInfoAccessSyntax);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthorityKeyIdentifier: () => (/* binding */ AuthorityKeyIdentifier),
/* harmony export */   KeyIdentifier: () => (/* binding */ KeyIdentifier),
/* harmony export */   id_ce_authorityKeyIdentifier: () => (/* binding */ id_ce_authorityKeyIdentifier)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");




const id_ce_authorityKeyIdentifier = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.35`;
class KeyIdentifier extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.OctetString {
}
class AuthorityKeyIdentifier {
    constructor(params = {}) {
        if (params) {
            Object.assign(this, params);
        }
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier.prototype, "keyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer,
        context: 2,
        optional: true,
        implicit: true,
        converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter,
    })
], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicConstraints: () => (/* binding */ BasicConstraints),
/* harmony export */   id_ce_basicConstraints: () => (/* binding */ id_ce_basicConstraints)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_basicConstraints = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.19`;
class BasicConstraints {
    constructor(params = {}) {
        this.cA = false;
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean, defaultValue: false })
], BasicConstraints.prototype, "cA", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, optional: true })
], BasicConstraints.prototype, "pathLenConstraint", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificateIssuer: () => (/* binding */ CertificateIssuer),
/* harmony export */   id_ce_certificateIssuer: () => (/* binding */ id_ce_certificateIssuer)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_names */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var CertificateIssuer_1;




const id_ce_certificateIssuer = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.29`;
let CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer extends _general_names__WEBPACK_IMPORTED_MODULE_1__.GeneralNames {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
    }
};
CertificateIssuer = CertificateIssuer_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], CertificateIssuer);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificatePolicies: () => (/* binding */ CertificatePolicies),
/* harmony export */   DisplayText: () => (/* binding */ DisplayText),
/* harmony export */   NoticeReference: () => (/* binding */ NoticeReference),
/* harmony export */   PolicyInformation: () => (/* binding */ PolicyInformation),
/* harmony export */   PolicyQualifierInfo: () => (/* binding */ PolicyQualifierInfo),
/* harmony export */   Qualifier: () => (/* binding */ Qualifier),
/* harmony export */   UserNotice: () => (/* binding */ UserNotice),
/* harmony export */   id_ce_certificatePolicies: () => (/* binding */ id_ce_certificatePolicies),
/* harmony export */   id_ce_certificatePolicies_anyPolicy: () => (/* binding */ id_ce_certificatePolicies_anyPolicy)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var CertificatePolicies_1;



const id_ce_certificatePolicies = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.32`;
const id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
let DisplayText = class DisplayText {
    constructor(params = {}) {
        Object.assign(this, params);
    }
    toString() {
        return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String })
], DisplayText.prototype, "ia5String", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.VisibleString })
], DisplayText.prototype, "visibleString", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BmpString })
], DisplayText.prototype, "bmpString", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Utf8String })
], DisplayText.prototype, "utf8String", void 0);
DisplayText = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], DisplayText);

class NoticeReference {
    constructor(params = {}) {
        this.organization = new DisplayText();
        this.noticeNumbers = [];
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: DisplayText })
], NoticeReference.prototype, "organization", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, repeated: "sequence" })
], NoticeReference.prototype, "noticeNumbers", void 0);
class UserNotice {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: NoticeReference, optional: true })
], UserNotice.prototype, "noticeRef", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: DisplayText, optional: true })
], UserNotice.prototype, "explicitText", void 0);
let Qualifier = class Qualifier {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String })
], Qualifier.prototype, "cPSuri", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: UserNotice })
], Qualifier.prototype, "userNotice", void 0);
Qualifier = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], Qualifier);

class PolicyQualifierInfo {
    constructor(params = {}) {
        this.policyQualifierId = "";
        this.qualifier = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], PolicyQualifierInfo.prototype, "policyQualifierId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], PolicyQualifierInfo.prototype, "qualifier", void 0);
class PolicyInformation {
    constructor(params = {}) {
        this.policyIdentifier = "";
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], PolicyInformation.prototype, "policyIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
], PolicyInformation.prototype, "policyQualifiers", void 0);
let CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
    }
};
CertificatePolicies = CertificatePolicies_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: PolicyInformation })
], CertificatePolicies);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseCRLNumber: () => (/* binding */ BaseCRLNumber),
/* harmony export */   id_ce_deltaCRLIndicator: () => (/* binding */ id_ce_deltaCRLIndicator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
/* harmony import */ var _crl_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crl_number */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js");




const id_ce_deltaCRLIndicator = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.27`;
let BaseCRLNumber = class BaseCRLNumber extends _crl_number__WEBPACK_IMPORTED_MODULE_2__.CRLNumber {
};
BaseCRLNumber = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], BaseCRLNumber);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRLDistributionPoints: () => (/* binding */ CRLDistributionPoints),
/* harmony export */   DistributionPoint: () => (/* binding */ DistributionPoint),
/* harmony export */   DistributionPointName: () => (/* binding */ DistributionPointName),
/* harmony export */   Reason: () => (/* binding */ Reason),
/* harmony export */   ReasonFlags: () => (/* binding */ ReasonFlags),
/* harmony export */   id_ce_cRLDistributionPoints: () => (/* binding */ id_ce_cRLDistributionPoints)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var CRLDistributionPoints_1;





const id_ce_cRLDistributionPoints = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_3__.id_ce}.31`;
var ReasonFlags;
(function (ReasonFlags) {
    ReasonFlags[ReasonFlags["unused"] = 1] = "unused";
    ReasonFlags[ReasonFlags["keyCompromise"] = 2] = "keyCompromise";
    ReasonFlags[ReasonFlags["cACompromise"] = 4] = "cACompromise";
    ReasonFlags[ReasonFlags["affiliationChanged"] = 8] = "affiliationChanged";
    ReasonFlags[ReasonFlags["superseded"] = 16] = "superseded";
    ReasonFlags[ReasonFlags["cessationOfOperation"] = 32] = "cessationOfOperation";
    ReasonFlags[ReasonFlags["certificateHold"] = 64] = "certificateHold";
    ReasonFlags[ReasonFlags["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
    ReasonFlags[ReasonFlags["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags || (ReasonFlags = {}));
class Reason extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.BitString {
    toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & ReasonFlags.aACompromise) {
            res.push("aACompromise");
        }
        if (flags & ReasonFlags.affiliationChanged) {
            res.push("affiliationChanged");
        }
        if (flags & ReasonFlags.cACompromise) {
            res.push("cACompromise");
        }
        if (flags & ReasonFlags.certificateHold) {
            res.push("certificateHold");
        }
        if (flags & ReasonFlags.cessationOfOperation) {
            res.push("cessationOfOperation");
        }
        if (flags & ReasonFlags.keyCompromise) {
            res.push("keyCompromise");
        }
        if (flags & ReasonFlags.privilegeWithdrawn) {
            res.push("privilegeWithdrawn");
        }
        if (flags & ReasonFlags.superseded) {
            res.push("superseded");
        }
        if (flags & ReasonFlags.unused) {
            res.push("unused");
        }
        return res;
    }
    toString() {
        return `[${this.toJSON().join(", ")}]`;
    }
}
let DistributionPointName = class DistributionPointName {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _general_name__WEBPACK_IMPORTED_MODULE_2__.GeneralName, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName.prototype, "fullName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_1__.RelativeDistinguishedName, context: 1, implicit: true })
], DistributionPointName.prototype, "nameRelativeToCRLIssuer", void 0);
DistributionPointName = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], DistributionPointName);

class DistributionPoint {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: DistributionPointName, context: 0, optional: true })
], DistributionPoint.prototype, "distributionPoint", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: Reason, context: 1, optional: true, implicit: true })
], DistributionPoint.prototype, "reasons", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _general_name__WEBPACK_IMPORTED_MODULE_2__.GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint.prototype, "cRLIssuer", void 0);
let CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
    }
};
CRLDistributionPoints = CRLDistributionPoints_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: DistributionPoint })
], CRLDistributionPoints);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreshestCRL: () => (/* binding */ FreshestCRL),
/* harmony export */   id_ce_freshestCRL: () => (/* binding */ id_ce_freshestCRL)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
/* harmony import */ var _crl_distribution_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crl_distribution_points */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js");
var FreshestCRL_1;




const id_ce_freshestCRL = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.46`;
let FreshestCRL = FreshestCRL_1 = class FreshestCRL extends _crl_distribution_points__WEBPACK_IMPORTED_MODULE_2__.CRLDistributionPoints {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, FreshestCRL_1.prototype);
    }
};
FreshestCRL = FreshestCRL_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _crl_distribution_points__WEBPACK_IMPORTED_MODULE_2__.DistributionPoint })
], FreshestCRL);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IssuingDistributionPoint: () => (/* binding */ IssuingDistributionPoint),
/* harmony export */   id_ce_issuingDistributionPoint: () => (/* binding */ id_ce_issuingDistributionPoint)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _crl_distribution_points__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crl_distribution_points */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");





const id_ce_issuingDistributionPoint = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.28`;
class IssuingDistributionPoint {
    constructor(params = {}) {
        this.onlyContainsUserCerts = IssuingDistributionPoint.ONLY;
        this.onlyContainsCACerts = IssuingDistributionPoint.ONLY;
        this.indirectCRL = IssuingDistributionPoint.ONLY;
        this.onlyContainsAttributeCerts = IssuingDistributionPoint.ONLY;
        Object.assign(this, params);
    }
}
IssuingDistributionPoint.ONLY = false;
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _crl_distribution_points__WEBPACK_IMPORTED_MODULE_1__.DistributionPointName, context: 0, optional: true })
], IssuingDistributionPoint.prototype, "distributionPoint", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean,
        context: 1,
        defaultValue: IssuingDistributionPoint.ONLY,
        implicit: true,
    })
], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean,
        context: 2,
        defaultValue: IssuingDistributionPoint.ONLY,
        implicit: true,
    })
], IssuingDistributionPoint.prototype, "onlyContainsCACerts", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _crl_distribution_points__WEBPACK_IMPORTED_MODULE_1__.Reason, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint.prototype, "onlySomeReasons", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean,
        context: 4,
        defaultValue: IssuingDistributionPoint.ONLY,
        implicit: true,
    })
], IssuingDistributionPoint.prototype, "indirectCRL", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Boolean,
        context: 5,
        defaultValue: IssuingDistributionPoint.ONLY,
        implicit: true,
    })
], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRLNumber: () => (/* binding */ CRLNumber),
/* harmony export */   id_ce_cRLNumber: () => (/* binding */ id_ce_cRLNumber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_cRLNumber = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.20`;
let CRLNumber = class CRLNumber {
    constructor(value = 0) {
        this.value = value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer })
], CRLNumber.prototype, "value", void 0);
CRLNumber = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], CRLNumber);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRLReason: () => (/* binding */ CRLReason),
/* harmony export */   CRLReasons: () => (/* binding */ CRLReasons),
/* harmony export */   id_ce_cRLReasons: () => (/* binding */ id_ce_cRLReasons)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_cRLReasons = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.21`;
var CRLReasons;
(function (CRLReasons) {
    CRLReasons[CRLReasons["unspecified"] = 0] = "unspecified";
    CRLReasons[CRLReasons["keyCompromise"] = 1] = "keyCompromise";
    CRLReasons[CRLReasons["cACompromise"] = 2] = "cACompromise";
    CRLReasons[CRLReasons["affiliationChanged"] = 3] = "affiliationChanged";
    CRLReasons[CRLReasons["superseded"] = 4] = "superseded";
    CRLReasons[CRLReasons["cessationOfOperation"] = 5] = "cessationOfOperation";
    CRLReasons[CRLReasons["certificateHold"] = 6] = "certificateHold";
    CRLReasons[CRLReasons["removeFromCRL"] = 8] = "removeFromCRL";
    CRLReasons[CRLReasons["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
    CRLReasons[CRLReasons["aACompromise"] = 10] = "aACompromise";
})(CRLReasons || (CRLReasons = {}));
let CRLReason = class CRLReason {
    constructor(reason = CRLReasons.unspecified) {
        this.reason = CRLReasons.unspecified;
        this.reason = reason;
    }
    toJSON() {
        return CRLReasons[this.reason];
    }
    toString() {
        return this.toJSON();
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Enumerated })
], CRLReason.prototype, "reason", void 0);
CRLReason = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], CRLReason);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntrustInfo: () => (/* binding */ EntrustInfo),
/* harmony export */   EntrustInfoFlags: () => (/* binding */ EntrustInfoFlags),
/* harmony export */   EntrustVersionInfo: () => (/* binding */ EntrustVersionInfo),
/* harmony export */   id_entrust_entrustVersInfo: () => (/* binding */ id_entrust_entrustVersInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


const id_entrust_entrustVersInfo = "1.2.840.113533.7.65.0";
var EntrustInfoFlags;
(function (EntrustInfoFlags) {
    EntrustInfoFlags[EntrustInfoFlags["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
    EntrustInfoFlags[EntrustInfoFlags["newExtensions"] = 2] = "newExtensions";
    EntrustInfoFlags[EntrustInfoFlags["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags || (EntrustInfoFlags = {}));
class EntrustInfo extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.BitString {
    toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & EntrustInfoFlags.pKIXCertificate) {
            res.push("pKIXCertificate");
        }
        if (flags & EntrustInfoFlags.newExtensions) {
            res.push("newExtensions");
        }
        if (flags & EntrustInfoFlags.keyUpdateAllowed) {
            res.push("keyUpdateAllowed");
        }
        return res;
    }
    toString() {
        return `[${this.toJSON().join(", ")}]`;
    }
}
class EntrustVersionInfo {
    constructor(params = {}) {
        this.entrustVers = "";
        this.entrustInfoFlags = new EntrustInfo();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralString })
], EntrustVersionInfo.prototype, "entrustVers", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: EntrustInfo })
], EntrustVersionInfo.prototype, "entrustInfoFlags", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtendedKeyUsage: () => (/* binding */ ExtendedKeyUsage),
/* harmony export */   anyExtendedKeyUsage: () => (/* binding */ anyExtendedKeyUsage),
/* harmony export */   id_ce_extKeyUsage: () => (/* binding */ id_ce_extKeyUsage),
/* harmony export */   id_kp_OCSPSigning: () => (/* binding */ id_kp_OCSPSigning),
/* harmony export */   id_kp_clientAuth: () => (/* binding */ id_kp_clientAuth),
/* harmony export */   id_kp_codeSigning: () => (/* binding */ id_kp_codeSigning),
/* harmony export */   id_kp_emailProtection: () => (/* binding */ id_kp_emailProtection),
/* harmony export */   id_kp_serverAuth: () => (/* binding */ id_kp_serverAuth),
/* harmony export */   id_kp_timeStamping: () => (/* binding */ id_kp_timeStamping)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var ExtendedKeyUsage_1;



const id_ce_extKeyUsage = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.37`;
let ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
    }
};
ExtendedKeyUsage = ExtendedKeyUsage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], ExtendedKeyUsage);

const anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
const id_kp_serverAuth = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.1`;
const id_kp_clientAuth = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.2`;
const id_kp_codeSigning = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.3`;
const id_kp_emailProtection = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.4`;
const id_kp_timeStamping = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.8`;
const id_kp_OCSPSigning = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_kp}.9`;


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/index.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/index.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessDescription: () => (/* reexport safe */ _authority_information_access__WEBPACK_IMPORTED_MODULE_0__.AccessDescription),
/* harmony export */   AuthorityInfoAccessSyntax: () => (/* reexport safe */ _authority_information_access__WEBPACK_IMPORTED_MODULE_0__.AuthorityInfoAccessSyntax),
/* harmony export */   AuthorityKeyIdentifier: () => (/* reexport safe */ _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__.AuthorityKeyIdentifier),
/* harmony export */   BaseCRLNumber: () => (/* reexport safe */ _crl_delta_indicator__WEBPACK_IMPORTED_MODULE_5__.BaseCRLNumber),
/* harmony export */   BasicConstraints: () => (/* reexport safe */ _basic_constraints__WEBPACK_IMPORTED_MODULE_2__.BasicConstraints),
/* harmony export */   CRLDistributionPoints: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.CRLDistributionPoints),
/* harmony export */   CRLNumber: () => (/* reexport safe */ _crl_number__WEBPACK_IMPORTED_MODULE_9__.CRLNumber),
/* harmony export */   CRLReason: () => (/* reexport safe */ _crl_reason__WEBPACK_IMPORTED_MODULE_10__.CRLReason),
/* harmony export */   CRLReasons: () => (/* reexport safe */ _crl_reason__WEBPACK_IMPORTED_MODULE_10__.CRLReasons),
/* harmony export */   CertificateIssuer: () => (/* reexport safe */ _certificate_issuer__WEBPACK_IMPORTED_MODULE_3__.CertificateIssuer),
/* harmony export */   CertificatePolicies: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.CertificatePolicies),
/* harmony export */   DisplayText: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.DisplayText),
/* harmony export */   DistributionPoint: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.DistributionPoint),
/* harmony export */   DistributionPointName: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.DistributionPointName),
/* harmony export */   EntrustInfo: () => (/* reexport safe */ _entrust_version_info__WEBPACK_IMPORTED_MODULE_23__.EntrustInfo),
/* harmony export */   EntrustInfoFlags: () => (/* reexport safe */ _entrust_version_info__WEBPACK_IMPORTED_MODULE_23__.EntrustInfoFlags),
/* harmony export */   EntrustVersionInfo: () => (/* reexport safe */ _entrust_version_info__WEBPACK_IMPORTED_MODULE_23__.EntrustVersionInfo),
/* harmony export */   ExtendedKeyUsage: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.ExtendedKeyUsage),
/* harmony export */   FreshestCRL: () => (/* reexport safe */ _crl_freshest__WEBPACK_IMPORTED_MODULE_7__.FreshestCRL),
/* harmony export */   GeneralSubtree: () => (/* reexport safe */ _name_constraints__WEBPACK_IMPORTED_MODULE_16__.GeneralSubtree),
/* harmony export */   GeneralSubtrees: () => (/* reexport safe */ _name_constraints__WEBPACK_IMPORTED_MODULE_16__.GeneralSubtrees),
/* harmony export */   InhibitAnyPolicy: () => (/* reexport safe */ _inhibit_any_policy__WEBPACK_IMPORTED_MODULE_12__.InhibitAnyPolicy),
/* harmony export */   InvalidityDate: () => (/* reexport safe */ _invalidity_date__WEBPACK_IMPORTED_MODULE_13__.InvalidityDate),
/* harmony export */   IssueAlternativeName: () => (/* reexport safe */ _issuer_alternative_name__WEBPACK_IMPORTED_MODULE_14__.IssueAlternativeName),
/* harmony export */   IssuingDistributionPoint: () => (/* reexport safe */ _crl_issuing_distribution_point__WEBPACK_IMPORTED_MODULE_8__.IssuingDistributionPoint),
/* harmony export */   KeyIdentifier: () => (/* reexport safe */ _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__.KeyIdentifier),
/* harmony export */   KeyUsage: () => (/* reexport safe */ _key_usage__WEBPACK_IMPORTED_MODULE_15__.KeyUsage),
/* harmony export */   KeyUsageFlags: () => (/* reexport safe */ _key_usage__WEBPACK_IMPORTED_MODULE_15__.KeyUsageFlags),
/* harmony export */   NameConstraints: () => (/* reexport safe */ _name_constraints__WEBPACK_IMPORTED_MODULE_16__.NameConstraints),
/* harmony export */   NoticeReference: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.NoticeReference),
/* harmony export */   PolicyConstraints: () => (/* reexport safe */ _policy_constraints__WEBPACK_IMPORTED_MODULE_17__.PolicyConstraints),
/* harmony export */   PolicyInformation: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.PolicyInformation),
/* harmony export */   PolicyMapping: () => (/* reexport safe */ _policy_mappings__WEBPACK_IMPORTED_MODULE_18__.PolicyMapping),
/* harmony export */   PolicyMappings: () => (/* reexport safe */ _policy_mappings__WEBPACK_IMPORTED_MODULE_18__.PolicyMappings),
/* harmony export */   PolicyQualifierInfo: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.PolicyQualifierInfo),
/* harmony export */   PrivateKeyUsagePeriod: () => (/* reexport safe */ _private_key_usage_period__WEBPACK_IMPORTED_MODULE_22__.PrivateKeyUsagePeriod),
/* harmony export */   Qualifier: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.Qualifier),
/* harmony export */   Reason: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.Reason),
/* harmony export */   ReasonFlags: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.ReasonFlags),
/* harmony export */   SubjectAlternativeName: () => (/* reexport safe */ _subject_alternative_name__WEBPACK_IMPORTED_MODULE_19__.SubjectAlternativeName),
/* harmony export */   SubjectDirectoryAttributes: () => (/* reexport safe */ _subject_directory_attributes__WEBPACK_IMPORTED_MODULE_20__.SubjectDirectoryAttributes),
/* harmony export */   SubjectInfoAccessSyntax: () => (/* reexport safe */ _subject_info_access__WEBPACK_IMPORTED_MODULE_24__.SubjectInfoAccessSyntax),
/* harmony export */   SubjectKeyIdentifier: () => (/* reexport safe */ _subject_key_identifier__WEBPACK_IMPORTED_MODULE_21__.SubjectKeyIdentifier),
/* harmony export */   UserNotice: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.UserNotice),
/* harmony export */   anyExtendedKeyUsage: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.anyExtendedKeyUsage),
/* harmony export */   id_ce_authorityKeyIdentifier: () => (/* reexport safe */ _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__.id_ce_authorityKeyIdentifier),
/* harmony export */   id_ce_basicConstraints: () => (/* reexport safe */ _basic_constraints__WEBPACK_IMPORTED_MODULE_2__.id_ce_basicConstraints),
/* harmony export */   id_ce_cRLDistributionPoints: () => (/* reexport safe */ _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__.id_ce_cRLDistributionPoints),
/* harmony export */   id_ce_cRLNumber: () => (/* reexport safe */ _crl_number__WEBPACK_IMPORTED_MODULE_9__.id_ce_cRLNumber),
/* harmony export */   id_ce_cRLReasons: () => (/* reexport safe */ _crl_reason__WEBPACK_IMPORTED_MODULE_10__.id_ce_cRLReasons),
/* harmony export */   id_ce_certificateIssuer: () => (/* reexport safe */ _certificate_issuer__WEBPACK_IMPORTED_MODULE_3__.id_ce_certificateIssuer),
/* harmony export */   id_ce_certificatePolicies: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.id_ce_certificatePolicies),
/* harmony export */   id_ce_certificatePolicies_anyPolicy: () => (/* reexport safe */ _certificate_policies__WEBPACK_IMPORTED_MODULE_4__.id_ce_certificatePolicies_anyPolicy),
/* harmony export */   id_ce_deltaCRLIndicator: () => (/* reexport safe */ _crl_delta_indicator__WEBPACK_IMPORTED_MODULE_5__.id_ce_deltaCRLIndicator),
/* harmony export */   id_ce_extKeyUsage: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_ce_extKeyUsage),
/* harmony export */   id_ce_freshestCRL: () => (/* reexport safe */ _crl_freshest__WEBPACK_IMPORTED_MODULE_7__.id_ce_freshestCRL),
/* harmony export */   id_ce_inhibitAnyPolicy: () => (/* reexport safe */ _inhibit_any_policy__WEBPACK_IMPORTED_MODULE_12__.id_ce_inhibitAnyPolicy),
/* harmony export */   id_ce_invalidityDate: () => (/* reexport safe */ _invalidity_date__WEBPACK_IMPORTED_MODULE_13__.id_ce_invalidityDate),
/* harmony export */   id_ce_issuerAltName: () => (/* reexport safe */ _issuer_alternative_name__WEBPACK_IMPORTED_MODULE_14__.id_ce_issuerAltName),
/* harmony export */   id_ce_issuingDistributionPoint: () => (/* reexport safe */ _crl_issuing_distribution_point__WEBPACK_IMPORTED_MODULE_8__.id_ce_issuingDistributionPoint),
/* harmony export */   id_ce_keyUsage: () => (/* reexport safe */ _key_usage__WEBPACK_IMPORTED_MODULE_15__.id_ce_keyUsage),
/* harmony export */   id_ce_nameConstraints: () => (/* reexport safe */ _name_constraints__WEBPACK_IMPORTED_MODULE_16__.id_ce_nameConstraints),
/* harmony export */   id_ce_policyConstraints: () => (/* reexport safe */ _policy_constraints__WEBPACK_IMPORTED_MODULE_17__.id_ce_policyConstraints),
/* harmony export */   id_ce_policyMappings: () => (/* reexport safe */ _policy_mappings__WEBPACK_IMPORTED_MODULE_18__.id_ce_policyMappings),
/* harmony export */   id_ce_privateKeyUsagePeriod: () => (/* reexport safe */ _private_key_usage_period__WEBPACK_IMPORTED_MODULE_22__.id_ce_privateKeyUsagePeriod),
/* harmony export */   id_ce_subjectAltName: () => (/* reexport safe */ _subject_alternative_name__WEBPACK_IMPORTED_MODULE_19__.id_ce_subjectAltName),
/* harmony export */   id_ce_subjectDirectoryAttributes: () => (/* reexport safe */ _subject_directory_attributes__WEBPACK_IMPORTED_MODULE_20__.id_ce_subjectDirectoryAttributes),
/* harmony export */   id_ce_subjectKeyIdentifier: () => (/* reexport safe */ _subject_key_identifier__WEBPACK_IMPORTED_MODULE_21__.id_ce_subjectKeyIdentifier),
/* harmony export */   id_entrust_entrustVersInfo: () => (/* reexport safe */ _entrust_version_info__WEBPACK_IMPORTED_MODULE_23__.id_entrust_entrustVersInfo),
/* harmony export */   id_kp_OCSPSigning: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_OCSPSigning),
/* harmony export */   id_kp_clientAuth: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_clientAuth),
/* harmony export */   id_kp_codeSigning: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_codeSigning),
/* harmony export */   id_kp_emailProtection: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_emailProtection),
/* harmony export */   id_kp_serverAuth: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_serverAuth),
/* harmony export */   id_kp_timeStamping: () => (/* reexport safe */ _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__.id_kp_timeStamping),
/* harmony export */   id_pe_authorityInfoAccess: () => (/* reexport safe */ _authority_information_access__WEBPACK_IMPORTED_MODULE_0__.id_pe_authorityInfoAccess),
/* harmony export */   id_pe_subjectInfoAccess: () => (/* reexport safe */ _subject_info_access__WEBPACK_IMPORTED_MODULE_24__.id_pe_subjectInfoAccess)
/* harmony export */ });
/* harmony import */ var _authority_information_access__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./authority_information_access */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js");
/* harmony import */ var _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authority_key_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js");
/* harmony import */ var _basic_constraints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic_constraints */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js");
/* harmony import */ var _certificate_issuer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./certificate_issuer */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js");
/* harmony import */ var _certificate_policies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./certificate_policies */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js");
/* harmony import */ var _crl_delta_indicator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./crl_delta_indicator */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js");
/* harmony import */ var _crl_distribution_points__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./crl_distribution_points */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js");
/* harmony import */ var _crl_freshest__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./crl_freshest */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js");
/* harmony import */ var _crl_issuing_distribution_point__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./crl_issuing_distribution_point */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js");
/* harmony import */ var _crl_number__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./crl_number */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js");
/* harmony import */ var _crl_reason__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./crl_reason */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js");
/* harmony import */ var _extended_key_usage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extended_key_usage */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js");
/* harmony import */ var _inhibit_any_policy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./inhibit_any_policy */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js");
/* harmony import */ var _invalidity_date__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./invalidity_date */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js");
/* harmony import */ var _issuer_alternative_name__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./issuer_alternative_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js");
/* harmony import */ var _key_usage__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./key_usage */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js");
/* harmony import */ var _name_constraints__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./name_constraints */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js");
/* harmony import */ var _policy_constraints__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./policy_constraints */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js");
/* harmony import */ var _policy_mappings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./policy_mappings */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js");
/* harmony import */ var _subject_alternative_name__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./subject_alternative_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js");
/* harmony import */ var _subject_directory_attributes__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./subject_directory_attributes */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js");
/* harmony import */ var _subject_key_identifier__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./subject_key_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js");
/* harmony import */ var _private_key_usage_period__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./private_key_usage_period */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js");
/* harmony import */ var _entrust_version_info__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./entrust_version_info */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js");
/* harmony import */ var _subject_info_access__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./subject_info_access */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js");



























/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InhibitAnyPolicy: () => (/* binding */ InhibitAnyPolicy),
/* harmony export */   id_ce_inhibitAnyPolicy: () => (/* binding */ id_ce_inhibitAnyPolicy)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_inhibitAnyPolicy = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.54`;
let InhibitAnyPolicy = class InhibitAnyPolicy {
    constructor(value = new ArrayBuffer(0)) {
        this.value = value;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], InhibitAnyPolicy.prototype, "value", void 0);
InhibitAnyPolicy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], InhibitAnyPolicy);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InvalidityDate: () => (/* binding */ InvalidityDate),
/* harmony export */   id_ce_invalidityDate: () => (/* binding */ id_ce_invalidityDate)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_invalidityDate = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.24`;
let InvalidityDate = class InvalidityDate {
    constructor(value) {
        this.value = new Date();
        if (value) {
            this.value = value;
        }
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime })
], InvalidityDate.prototype, "value", void 0);
InvalidityDate = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], InvalidityDate);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IssueAlternativeName: () => (/* binding */ IssueAlternativeName),
/* harmony export */   id_ce_issuerAltName: () => (/* binding */ id_ce_issuerAltName)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_names */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var IssueAlternativeName_1;




const id_ce_issuerAltName = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.18`;
let IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName extends _general_names__WEBPACK_IMPORTED_MODULE_1__.GeneralNames {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
    }
};
IssueAlternativeName = IssueAlternativeName_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], IssueAlternativeName);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyUsage: () => (/* binding */ KeyUsage),
/* harmony export */   KeyUsageFlags: () => (/* binding */ KeyUsageFlags),
/* harmony export */   id_ce_keyUsage: () => (/* binding */ id_ce_keyUsage)
/* harmony export */ });
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");


const id_ce_keyUsage = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.15`;
var KeyUsageFlags;
(function (KeyUsageFlags) {
    KeyUsageFlags[KeyUsageFlags["digitalSignature"] = 1] = "digitalSignature";
    KeyUsageFlags[KeyUsageFlags["nonRepudiation"] = 2] = "nonRepudiation";
    KeyUsageFlags[KeyUsageFlags["keyEncipherment"] = 4] = "keyEncipherment";
    KeyUsageFlags[KeyUsageFlags["dataEncipherment"] = 8] = "dataEncipherment";
    KeyUsageFlags[KeyUsageFlags["keyAgreement"] = 16] = "keyAgreement";
    KeyUsageFlags[KeyUsageFlags["keyCertSign"] = 32] = "keyCertSign";
    KeyUsageFlags[KeyUsageFlags["cRLSign"] = 64] = "cRLSign";
    KeyUsageFlags[KeyUsageFlags["encipherOnly"] = 128] = "encipherOnly";
    KeyUsageFlags[KeyUsageFlags["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags || (KeyUsageFlags = {}));
class KeyUsage extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.BitString {
    toJSON() {
        const flag = this.toNumber();
        const res = [];
        if (flag & KeyUsageFlags.cRLSign) {
            res.push("crlSign");
        }
        if (flag & KeyUsageFlags.dataEncipherment) {
            res.push("dataEncipherment");
        }
        if (flag & KeyUsageFlags.decipherOnly) {
            res.push("decipherOnly");
        }
        if (flag & KeyUsageFlags.digitalSignature) {
            res.push("digitalSignature");
        }
        if (flag & KeyUsageFlags.encipherOnly) {
            res.push("encipherOnly");
        }
        if (flag & KeyUsageFlags.keyAgreement) {
            res.push("keyAgreement");
        }
        if (flag & KeyUsageFlags.keyCertSign) {
            res.push("keyCertSign");
        }
        if (flag & KeyUsageFlags.keyEncipherment) {
            res.push("keyEncipherment");
        }
        if (flag & KeyUsageFlags.nonRepudiation) {
            res.push("nonRepudiation");
        }
        return res;
    }
    toString() {
        return `[${this.toJSON().join(", ")}]`;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeneralSubtree: () => (/* binding */ GeneralSubtree),
/* harmony export */   GeneralSubtrees: () => (/* binding */ GeneralSubtrees),
/* harmony export */   NameConstraints: () => (/* binding */ NameConstraints),
/* harmony export */   id_ce_nameConstraints: () => (/* binding */ id_ce_nameConstraints)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var GeneralSubtrees_1;




const id_ce_nameConstraints = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.30`;
class GeneralSubtree {
    constructor(params = {}) {
        this.base = new _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName();
        this.minimum = 0;
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], GeneralSubtree.prototype, "base", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree.prototype, "minimum", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree.prototype, "maximum", void 0);
let GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
    }
};
GeneralSubtrees = GeneralSubtrees_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: GeneralSubtree })
], GeneralSubtrees);

class NameConstraints {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
], NameConstraints.prototype, "permittedSubtrees", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
], NameConstraints.prototype, "excludedSubtrees", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolicyConstraints: () => (/* binding */ PolicyConstraints),
/* harmony export */   id_ce_policyConstraints: () => (/* binding */ id_ce_policyConstraints)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_policyConstraints = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.36`;
class PolicyConstraints {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer,
        context: 0,
        implicit: true,
        optional: true,
        converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter,
    })
], PolicyConstraints.prototype, "requireExplicitPolicy", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer,
        context: 1,
        implicit: true,
        optional: true,
        converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter,
    })
], PolicyConstraints.prototype, "inhibitPolicyMapping", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolicyMapping: () => (/* binding */ PolicyMapping),
/* harmony export */   PolicyMappings: () => (/* binding */ PolicyMappings),
/* harmony export */   id_ce_policyMappings: () => (/* binding */ id_ce_policyMappings)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var PolicyMappings_1;



const id_ce_policyMappings = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.33`;
class PolicyMapping {
    constructor(params = {}) {
        this.issuerDomainPolicy = "";
        this.subjectDomainPolicy = "";
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "issuerDomainPolicy", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "subjectDomainPolicy", void 0);
let PolicyMappings = PolicyMappings_1 = class PolicyMappings extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, PolicyMappings_1.prototype);
    }
};
PolicyMappings = PolicyMappings_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: PolicyMapping })
], PolicyMappings);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrivateKeyUsagePeriod: () => (/* binding */ PrivateKeyUsagePeriod),
/* harmony export */   id_ce_privateKeyUsagePeriod: () => (/* binding */ id_ce_privateKeyUsagePeriod)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");



const id_ce_privateKeyUsagePeriod = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_ce}.16`;
class PrivateKeyUsagePeriod {
    constructor(params = {}) {
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notBefore", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notAfter", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubjectAlternativeName: () => (/* binding */ SubjectAlternativeName),
/* harmony export */   id_ce_subjectAltName: () => (/* binding */ id_ce_subjectAltName)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general_names */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var SubjectAlternativeName_1;




const id_ce_subjectAltName = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.17`;
let SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName extends _general_names__WEBPACK_IMPORTED_MODULE_1__.GeneralNames {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
    }
};
SubjectAlternativeName = SubjectAlternativeName_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], SubjectAlternativeName);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubjectDirectoryAttributes: () => (/* binding */ SubjectDirectoryAttributes),
/* harmony export */   id_ce_subjectDirectoryAttributes: () => (/* binding */ id_ce_subjectDirectoryAttributes)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../attribute */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
var SubjectDirectoryAttributes_1;




const id_ce_subjectDirectoryAttributes = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_2__.id_ce}.9`;
let SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
    }
};
SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute })
], SubjectDirectoryAttributes);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubjectInfoAccessSyntax: () => (/* binding */ SubjectInfoAccessSyntax),
/* harmony export */   id_pe_subjectInfoAccess: () => (/* binding */ id_pe_subjectInfoAccess)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
/* harmony import */ var _authority_information_access__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./authority_information_access */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js");
var SubjectInfoAccessSyntax_1;




const id_pe_subjectInfoAccess = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_1__.id_pe}.11`;
let SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
    }
};
SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _authority_information_access__WEBPACK_IMPORTED_MODULE_2__.AccessDescription })
], SubjectInfoAccessSyntax);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubjectKeyIdentifier: () => (/* binding */ SubjectKeyIdentifier),
/* harmony export */   id_ce_subjectKeyIdentifier: () => (/* binding */ id_ce_subjectKeyIdentifier)
/* harmony export */ });
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
/* harmony import */ var _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authority_key_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js");


const id_ce_subjectKeyIdentifier = `${_object_identifiers__WEBPACK_IMPORTED_MODULE_0__.id_ce}.14`;
class SubjectKeyIdentifier extends _authority_key_identifier__WEBPACK_IMPORTED_MODULE_1__.KeyIdentifier {
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsnIpConverter: () => (/* binding */ AsnIpConverter),
/* harmony export */   EDIPartyName: () => (/* binding */ EDIPartyName),
/* harmony export */   GeneralName: () => (/* binding */ GeneralName),
/* harmony export */   OtherName: () => (/* binding */ OtherName)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _ip_converter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ip_converter */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js");
/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js");




const AsnIpConverter = {
    fromASN: (value) => _ip_converter__WEBPACK_IMPORTED_MODULE_1__.IpConverter.toString(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnOctetStringConverter.fromASN(value)),
    toASN: (value) => _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnOctetStringConverter.toASN(_ip_converter__WEBPACK_IMPORTED_MODULE_1__.IpConverter.fromString(value)),
};
class OtherName {
    constructor(params = {}) {
        this.typeId = "";
        this.value = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], OtherName.prototype, "typeId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 0 })
], OtherName.prototype, "value", void 0);
class EDIPartyName {
    constructor(params = {}) {
        this.partyName = new _name__WEBPACK_IMPORTED_MODULE_2__.DirectoryString();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.DirectoryString, optional: true, context: 0, implicit: true })
], EDIPartyName.prototype, "nameAssigner", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.DirectoryString, context: 1, implicit: true })
], EDIPartyName.prototype, "partyName", void 0);
let GeneralName = class GeneralName {
    constructor(params = {}) {
        Object.assign(this, params);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: OtherName, context: 0, implicit: true })
], GeneralName.prototype, "otherName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String, context: 1, implicit: true })
], GeneralName.prototype, "rfc822Name", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String, context: 2, implicit: true })
], GeneralName.prototype, "dNSName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any, context: 3, implicit: true })
], GeneralName.prototype, "x400Address", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.Name, context: 4, implicit: false })
], GeneralName.prototype, "directoryName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: EDIPartyName, context: 5 })
], GeneralName.prototype, "ediPartyName", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String, context: 6, implicit: true })
], GeneralName.prototype, "uniformResourceIdentifier", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.OctetString,
        context: 7,
        implicit: true,
        converter: AsnIpConverter,
    })
], GeneralName.prototype, "iPAddress", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
], GeneralName.prototype, "registeredID", void 0);
GeneralName = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], GeneralName);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeneralNames: () => (/* binding */ GeneralNames)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
var GeneralNames_1;




let GeneralNames = GeneralNames_1 = class GeneralNames extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralNames_1.prototype);
    }
};
GeneralNames = GeneralNames_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: _general_name__WEBPACK_IMPORTED_MODULE_1__.GeneralName })
], GeneralNames);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessDescription: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.AccessDescription),
/* harmony export */   AlgorithmIdentifier: () => (/* reexport safe */ _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier),
/* harmony export */   AsnIpConverter: () => (/* reexport safe */ _general_name__WEBPACK_IMPORTED_MODULE_6__.AsnIpConverter),
/* harmony export */   Attribute: () => (/* reexport safe */ _attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute),
/* harmony export */   AttributeTypeAndValue: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.AttributeTypeAndValue),
/* harmony export */   AttributeValue: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.AttributeValue),
/* harmony export */   AuthorityInfoAccessSyntax: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.AuthorityInfoAccessSyntax),
/* harmony export */   AuthorityKeyIdentifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.AuthorityKeyIdentifier),
/* harmony export */   BaseCRLNumber: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.BaseCRLNumber),
/* harmony export */   BasicConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.BasicConstraints),
/* harmony export */   CRLDistributionPoints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CRLDistributionPoints),
/* harmony export */   CRLNumber: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CRLNumber),
/* harmony export */   CRLReason: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CRLReason),
/* harmony export */   CRLReasons: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CRLReasons),
/* harmony export */   Certificate: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.Certificate),
/* harmony export */   CertificateIssuer: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CertificateIssuer),
/* harmony export */   CertificateList: () => (/* reexport safe */ _certificate_list__WEBPACK_IMPORTED_MODULE_4__.CertificateList),
/* harmony export */   CertificatePolicies: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.CertificatePolicies),
/* harmony export */   DirectoryString: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.DirectoryString),
/* harmony export */   DisplayText: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.DisplayText),
/* harmony export */   DistributionPoint: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.DistributionPoint),
/* harmony export */   DistributionPointName: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.DistributionPointName),
/* harmony export */   EDIPartyName: () => (/* reexport safe */ _general_name__WEBPACK_IMPORTED_MODULE_6__.EDIPartyName),
/* harmony export */   EntrustInfo: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.EntrustInfo),
/* harmony export */   EntrustInfoFlags: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.EntrustInfoFlags),
/* harmony export */   EntrustVersionInfo: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.EntrustVersionInfo),
/* harmony export */   ExtendedKeyUsage: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.ExtendedKeyUsage),
/* harmony export */   Extension: () => (/* reexport safe */ _extension__WEBPACK_IMPORTED_MODULE_5__.Extension),
/* harmony export */   Extensions: () => (/* reexport safe */ _extension__WEBPACK_IMPORTED_MODULE_5__.Extensions),
/* harmony export */   FreshestCRL: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.FreshestCRL),
/* harmony export */   GeneralName: () => (/* reexport safe */ _general_name__WEBPACK_IMPORTED_MODULE_6__.GeneralName),
/* harmony export */   GeneralNames: () => (/* reexport safe */ _general_names__WEBPACK_IMPORTED_MODULE_7__.GeneralNames),
/* harmony export */   GeneralSubtree: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.GeneralSubtree),
/* harmony export */   GeneralSubtrees: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.GeneralSubtrees),
/* harmony export */   InhibitAnyPolicy: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.InhibitAnyPolicy),
/* harmony export */   InvalidityDate: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.InvalidityDate),
/* harmony export */   IssueAlternativeName: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.IssueAlternativeName),
/* harmony export */   IssuingDistributionPoint: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.IssuingDistributionPoint),
/* harmony export */   KeyIdentifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.KeyIdentifier),
/* harmony export */   KeyUsage: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.KeyUsage),
/* harmony export */   KeyUsageFlags: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.KeyUsageFlags),
/* harmony export */   Name: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.Name),
/* harmony export */   NameConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.NameConstraints),
/* harmony export */   NoticeReference: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.NoticeReference),
/* harmony export */   OtherName: () => (/* reexport safe */ _general_name__WEBPACK_IMPORTED_MODULE_6__.OtherName),
/* harmony export */   PolicyConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PolicyConstraints),
/* harmony export */   PolicyInformation: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PolicyInformation),
/* harmony export */   PolicyMapping: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PolicyMapping),
/* harmony export */   PolicyMappings: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PolicyMappings),
/* harmony export */   PolicyQualifierInfo: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PolicyQualifierInfo),
/* harmony export */   PrivateKeyUsagePeriod: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyUsagePeriod),
/* harmony export */   Qualifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.Qualifier),
/* harmony export */   RDNSequence: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.RDNSequence),
/* harmony export */   Reason: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.Reason),
/* harmony export */   ReasonFlags: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.ReasonFlags),
/* harmony export */   RelativeDistinguishedName: () => (/* reexport safe */ _name__WEBPACK_IMPORTED_MODULE_8__.RelativeDistinguishedName),
/* harmony export */   RevokedCertificate: () => (/* reexport safe */ _tbs_cert_list__WEBPACK_IMPORTED_MODULE_11__.RevokedCertificate),
/* harmony export */   SubjectAlternativeName: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.SubjectAlternativeName),
/* harmony export */   SubjectDirectoryAttributes: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.SubjectDirectoryAttributes),
/* harmony export */   SubjectInfoAccessSyntax: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.SubjectInfoAccessSyntax),
/* harmony export */   SubjectKeyIdentifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.SubjectKeyIdentifier),
/* harmony export */   SubjectPublicKeyInfo: () => (/* reexport safe */ _subject_public_key_info__WEBPACK_IMPORTED_MODULE_10__.SubjectPublicKeyInfo),
/* harmony export */   TBSCertList: () => (/* reexport safe */ _tbs_cert_list__WEBPACK_IMPORTED_MODULE_11__.TBSCertList),
/* harmony export */   TBSCertificate: () => (/* reexport safe */ _tbs_certificate__WEBPACK_IMPORTED_MODULE_12__.TBSCertificate),
/* harmony export */   Time: () => (/* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_13__.Time),
/* harmony export */   UserNotice: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.UserNotice),
/* harmony export */   Validity: () => (/* reexport safe */ _validity__WEBPACK_IMPORTED_MODULE_15__.Validity),
/* harmony export */   Version: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_14__.Version),
/* harmony export */   anyExtendedKeyUsage: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.anyExtendedKeyUsage),
/* harmony export */   id_ad: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ad),
/* harmony export */   id_ad_caIssuers: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ad_caIssuers),
/* harmony export */   id_ad_caRepository: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ad_caRepository),
/* harmony export */   id_ad_ocsp: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ad_ocsp),
/* harmony export */   id_ad_timeStamping: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ad_timeStamping),
/* harmony export */   id_ce: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_ce),
/* harmony export */   id_ce_authorityKeyIdentifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_authorityKeyIdentifier),
/* harmony export */   id_ce_basicConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_basicConstraints),
/* harmony export */   id_ce_cRLDistributionPoints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_cRLDistributionPoints),
/* harmony export */   id_ce_cRLNumber: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_cRLNumber),
/* harmony export */   id_ce_cRLReasons: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_cRLReasons),
/* harmony export */   id_ce_certificateIssuer: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_certificateIssuer),
/* harmony export */   id_ce_certificatePolicies: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_certificatePolicies),
/* harmony export */   id_ce_certificatePolicies_anyPolicy: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_certificatePolicies_anyPolicy),
/* harmony export */   id_ce_deltaCRLIndicator: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_deltaCRLIndicator),
/* harmony export */   id_ce_extKeyUsage: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_extKeyUsage),
/* harmony export */   id_ce_freshestCRL: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_freshestCRL),
/* harmony export */   id_ce_inhibitAnyPolicy: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_inhibitAnyPolicy),
/* harmony export */   id_ce_invalidityDate: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_invalidityDate),
/* harmony export */   id_ce_issuerAltName: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_issuerAltName),
/* harmony export */   id_ce_issuingDistributionPoint: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_issuingDistributionPoint),
/* harmony export */   id_ce_keyUsage: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_keyUsage),
/* harmony export */   id_ce_nameConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_nameConstraints),
/* harmony export */   id_ce_policyConstraints: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_policyConstraints),
/* harmony export */   id_ce_policyMappings: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_policyMappings),
/* harmony export */   id_ce_privateKeyUsagePeriod: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_privateKeyUsagePeriod),
/* harmony export */   id_ce_subjectAltName: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_subjectAltName),
/* harmony export */   id_ce_subjectDirectoryAttributes: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_subjectDirectoryAttributes),
/* harmony export */   id_ce_subjectKeyIdentifier: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_ce_subjectKeyIdentifier),
/* harmony export */   id_entrust_entrustVersInfo: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_entrust_entrustVersInfo),
/* harmony export */   id_kp: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_kp),
/* harmony export */   id_kp_OCSPSigning: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_OCSPSigning),
/* harmony export */   id_kp_clientAuth: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_clientAuth),
/* harmony export */   id_kp_codeSigning: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_codeSigning),
/* harmony export */   id_kp_emailProtection: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_emailProtection),
/* harmony export */   id_kp_serverAuth: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_serverAuth),
/* harmony export */   id_kp_timeStamping: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_kp_timeStamping),
/* harmony export */   id_pe: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_pe),
/* harmony export */   id_pe_authorityInfoAccess: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_pe_authorityInfoAccess),
/* harmony export */   id_pe_subjectInfoAccess: () => (/* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_0__.id_pe_subjectInfoAccess),
/* harmony export */   id_pkix: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_pkix),
/* harmony export */   id_qt: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_qt),
/* harmony export */   id_qt_csp: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_qt_csp),
/* harmony export */   id_qt_unotice: () => (/* reexport safe */ _object_identifiers__WEBPACK_IMPORTED_MODULE_9__.id_qt_unotice)
/* harmony export */ });
/* harmony import */ var _extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extensions */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extensions/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/attribute.js");
/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./certificate */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate.js");
/* harmony import */ var _certificate_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./certificate_list */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extension */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extension.js");
/* harmony import */ var _general_name__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./general_name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_name.js");
/* harmony import */ var _general_names__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./general_names */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/general_names.js");
/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js");
/* harmony import */ var _object_identifiers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object_identifiers */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js");
/* harmony import */ var _subject_public_key_info__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./subject_public_key_info */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js");
/* harmony import */ var _tbs_cert_list__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tbs_cert_list */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js");
/* harmony import */ var _tbs_certificate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tbs_certificate */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./time */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/time.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/types.js");
/* harmony import */ var _validity__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./validity */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/validity.js");


















/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IpConverter: () => (/* binding */ IpConverter)
/* harmony export */ });
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");

class IpConverter {
    static isIPv4(ip) {
        return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip);
    }
    static parseIPv4(ip) {
        const parts = ip.split(".");
        if (parts.length !== 4) {
            throw new Error("Invalid IPv4 address");
        }
        return parts.map((part) => {
            const num = parseInt(part, 10);
            if (isNaN(num) || num < 0 || num > 255) {
                throw new Error("Invalid IPv4 address part");
            }
            return num;
        });
    }
    static parseIPv6(ip) {
        const expandedIP = this.expandIPv6(ip);
        const parts = expandedIP.split(":");
        if (parts.length !== 8) {
            throw new Error("Invalid IPv6 address");
        }
        return parts.reduce((bytes, part) => {
            const num = parseInt(part, 16);
            if (isNaN(num) || num < 0 || num > 0xffff) {
                throw new Error("Invalid IPv6 address part");
            }
            bytes.push((num >> 8) & 0xff);
            bytes.push(num & 0xff);
            return bytes;
        }, []);
    }
    static expandIPv6(ip) {
        if (!ip.includes("::")) {
            return ip;
        }
        const parts = ip.split("::");
        if (parts.length > 2) {
            throw new Error("Invalid IPv6 address");
        }
        const left = parts[0] ? parts[0].split(":") : [];
        const right = parts[1] ? parts[1].split(":") : [];
        const missing = 8 - (left.length + right.length);
        if (missing < 0) {
            throw new Error("Invalid IPv6 address");
        }
        return [...left, ...Array(missing).fill("0"), ...right].join(":");
    }
    static formatIPv6(bytes) {
        const parts = [];
        for (let i = 0; i < 16; i += 2) {
            parts.push(((bytes[i] << 8) | bytes[i + 1]).toString(16));
        }
        return this.compressIPv6(parts.join(":"));
    }
    static compressIPv6(ip) {
        const parts = ip.split(":");
        let longestZeroStart = -1;
        let longestZeroLength = 0;
        let currentZeroStart = -1;
        let currentZeroLength = 0;
        for (let i = 0; i < parts.length; i++) {
            if (parts[i] === "0") {
                if (currentZeroStart === -1) {
                    currentZeroStart = i;
                }
                currentZeroLength++;
            }
            else {
                if (currentZeroLength > longestZeroLength) {
                    longestZeroStart = currentZeroStart;
                    longestZeroLength = currentZeroLength;
                }
                currentZeroStart = -1;
                currentZeroLength = 0;
            }
        }
        if (currentZeroLength > longestZeroLength) {
            longestZeroStart = currentZeroStart;
            longestZeroLength = currentZeroLength;
        }
        if (longestZeroLength > 1) {
            const before = parts.slice(0, longestZeroStart).join(":");
            const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
            return `${before}::${after}`;
        }
        return ip;
    }
    static parseCIDR(text) {
        const [addr, prefixStr] = text.split("/");
        const prefix = parseInt(prefixStr, 10);
        if (this.isIPv4(addr)) {
            if (prefix < 0 || prefix > 32) {
                throw new Error("Invalid IPv4 prefix length");
            }
            return [this.parseIPv4(addr), prefix];
        }
        else {
            if (prefix < 0 || prefix > 128) {
                throw new Error("Invalid IPv6 prefix length");
            }
            return [this.parseIPv6(addr), prefix];
        }
    }
    static decodeIP(value) {
        if (value.length === 64 && parseInt(value, 16) === 0) {
            return "::/0";
        }
        if (value.length !== 16) {
            return value;
        }
        const mask = parseInt(value.slice(8), 16)
            .toString(2)
            .split("")
            .reduce((a, k) => a + +k, 0);
        let ip = value.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
        ip = ip.slice(0, -1);
        return `${ip}/${mask}`;
    }
    static toString(buf) {
        const uint8 = new Uint8Array(buf);
        if (uint8.length === 4) {
            return Array.from(uint8).join(".");
        }
        if (uint8.length === 16) {
            return this.formatIPv6(uint8);
        }
        if (uint8.length === 8 || uint8.length === 32) {
            const half = uint8.length / 2;
            const addrBytes = uint8.slice(0, half);
            const maskBytes = uint8.slice(half);
            const isAllZeros = uint8.every((byte) => byte === 0);
            if (isAllZeros) {
                return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
            }
            const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
            if (uint8.length === 8) {
                const addrStr = Array.from(addrBytes).join(".");
                return `${addrStr}/${prefixLen}`;
            }
            else {
                const addrStr = this.formatIPv6(addrBytes);
                return `${addrStr}/${prefixLen}`;
            }
        }
        return this.decodeIP(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(buf));
    }
    static fromString(text) {
        if (text.includes("/")) {
            const [addr, prefix] = this.parseCIDR(text);
            const maskBytes = new Uint8Array(addr.length);
            let bitsLeft = prefix;
            for (let i = 0; i < maskBytes.length; i++) {
                if (bitsLeft >= 8) {
                    maskBytes[i] = 0xff;
                    bitsLeft -= 8;
                }
                else if (bitsLeft > 0) {
                    maskBytes[i] = 0xff << (8 - bitsLeft);
                    bitsLeft = 0;
                }
            }
            const out = new Uint8Array(addr.length * 2);
            out.set(addr, 0);
            out.set(maskBytes, addr.length);
            return out.buffer;
        }
        const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
        return new Uint8Array(bytes).buffer;
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeTypeAndValue: () => (/* binding */ AttributeTypeAndValue),
/* harmony export */   AttributeValue: () => (/* binding */ AttributeValue),
/* harmony export */   DirectoryString: () => (/* binding */ DirectoryString),
/* harmony export */   Name: () => (/* binding */ Name),
/* harmony export */   RDNSequence: () => (/* binding */ RDNSequence),
/* harmony export */   RelativeDistinguishedName: () => (/* binding */ RelativeDistinguishedName)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");
var RelativeDistinguishedName_1, RDNSequence_1, Name_1;



let DirectoryString = class DirectoryString {
    constructor(params = {}) {
        Object.assign(this, params);
    }
    toString() {
        return (this.bmpString ||
            this.printableString ||
            this.teletexString ||
            this.universalString ||
            this.utf8String ||
            "");
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.TeletexString })
], DirectoryString.prototype, "teletexString", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.PrintableString })
], DirectoryString.prototype, "printableString", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.UniversalString })
], DirectoryString.prototype, "universalString", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Utf8String })
], DirectoryString.prototype, "utf8String", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BmpString })
], DirectoryString.prototype, "bmpString", void 0);
DirectoryString = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], DirectoryString);

let AttributeValue = class AttributeValue extends DirectoryString {
    constructor(params = {}) {
        super(params);
        Object.assign(this, params);
    }
    toString() {
        return this.ia5String || (this.anyValue ? pvtsutils__WEBPACK_IMPORTED_MODULE_1__.Convert.ToHex(this.anyValue) : super.toString());
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.IA5String })
], AttributeValue.prototype, "ia5String", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Any })
], AttributeValue.prototype, "anyValue", void 0);
AttributeValue = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], AttributeValue);

class AttributeTypeAndValue {
    constructor(params = {}) {
        this.type = "";
        this.value = new AttributeValue();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.ObjectIdentifier })
], AttributeTypeAndValue.prototype, "type", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: AttributeValue })
], AttributeTypeAndValue.prototype, "value", void 0);
let RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
    }
};
RelativeDistinguishedName = RelativeDistinguishedName_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
], RelativeDistinguishedName);

let RDNSequence = RDNSequence_1 = class RDNSequence extends _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnArray {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RDNSequence_1.prototype);
    }
};
RDNSequence = RDNSequence_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
], RDNSequence);

let Name = Name_1 = class Name extends RDNSequence {
    constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Name_1.prototype);
    }
};
Name = Name_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Sequence })
], Name);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id_ad: () => (/* binding */ id_ad),
/* harmony export */   id_ad_caIssuers: () => (/* binding */ id_ad_caIssuers),
/* harmony export */   id_ad_caRepository: () => (/* binding */ id_ad_caRepository),
/* harmony export */   id_ad_ocsp: () => (/* binding */ id_ad_ocsp),
/* harmony export */   id_ad_timeStamping: () => (/* binding */ id_ad_timeStamping),
/* harmony export */   id_ce: () => (/* binding */ id_ce),
/* harmony export */   id_kp: () => (/* binding */ id_kp),
/* harmony export */   id_pe: () => (/* binding */ id_pe),
/* harmony export */   id_pkix: () => (/* binding */ id_pkix),
/* harmony export */   id_qt: () => (/* binding */ id_qt),
/* harmony export */   id_qt_csp: () => (/* binding */ id_qt_csp),
/* harmony export */   id_qt_unotice: () => (/* binding */ id_qt_unotice)
/* harmony export */ });
const id_pkix = "1.3.6.1.5.5.7";
const id_pe = `${id_pkix}.1`;
const id_qt = `${id_pkix}.2`;
const id_kp = `${id_pkix}.3`;
const id_ad = `${id_pkix}.48`;
const id_qt_csp = `${id_qt}.1`;
const id_qt_unotice = `${id_qt}.2`;
const id_ad_ocsp = `${id_ad}.1`;
const id_ad_caIssuers = `${id_ad}.2`;
const id_ad_timeStamping = `${id_ad}.3`;
const id_ad_caRepository = `${id_ad}.5`;
const id_ce = "2.5.29";


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubjectPublicKeyInfo: () => (/* binding */ SubjectPublicKeyInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");



class SubjectPublicKeyInfo {
    constructor(params = {}) {
        this.algorithm = new _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.subjectPublicKey = new ArrayBuffer(0);
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], SubjectPublicKeyInfo.prototype, "algorithm", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString })
], SubjectPublicKeyInfo.prototype, "subjectPublicKey", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RevokedCertificate: () => (/* binding */ RevokedCertificate),
/* harmony export */   TBSCertList: () => (/* binding */ TBSCertList)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");
/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./time */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/time.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extension */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extension.js");






class RevokedCertificate {
    constructor(params = {}) {
        this.userCertificate = new ArrayBuffer(0);
        this.revocationDate = new _time__WEBPACK_IMPORTED_MODULE_3__.Time();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter })
], RevokedCertificate.prototype, "userCertificate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _time__WEBPACK_IMPORTED_MODULE_3__.Time })
], RevokedCertificate.prototype, "revocationDate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _extension__WEBPACK_IMPORTED_MODULE_4__.Extension, optional: true, repeated: "sequence" })
], RevokedCertificate.prototype, "crlEntryExtensions", void 0);
class TBSCertList {
    constructor(params = {}) {
        this.signature = new _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.issuer = new _name__WEBPACK_IMPORTED_MODULE_2__.Name();
        this.thisUpdate = new _time__WEBPACK_IMPORTED_MODULE_3__.Time();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer, optional: true })
], TBSCertList.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], TBSCertList.prototype, "signature", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.Name })
], TBSCertList.prototype, "issuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _time__WEBPACK_IMPORTED_MODULE_3__.Time })
], TBSCertList.prototype, "thisUpdate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _time__WEBPACK_IMPORTED_MODULE_3__.Time, optional: true })
], TBSCertList.prototype, "nextUpdate", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: RevokedCertificate, repeated: "sequence", optional: true })
], TBSCertList.prototype, "revokedCertificates", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _extension__WEBPACK_IMPORTED_MODULE_4__.Extension, optional: true, context: 0, repeated: "sequence" })
], TBSCertList.prototype, "crlExtensions", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TBSCertificate: () => (/* binding */ TBSCertificate)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithm_identifier */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js");
/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/name.js");
/* harmony import */ var _subject_public_key_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./subject_public_key_info */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js");
/* harmony import */ var _validity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validity */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/validity.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extension */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/extension.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/types.js");








class TBSCertificate {
    constructor(params = {}) {
        this.version = _types__WEBPACK_IMPORTED_MODULE_6__.Version.v1;
        this.serialNumber = new ArrayBuffer(0);
        this.signature = new _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier();
        this.issuer = new _name__WEBPACK_IMPORTED_MODULE_2__.Name();
        this.validity = new _validity__WEBPACK_IMPORTED_MODULE_4__.Validity();
        this.subject = new _name__WEBPACK_IMPORTED_MODULE_2__.Name();
        this.subjectPublicKeyInfo = new _subject_public_key_info__WEBPACK_IMPORTED_MODULE_3__.SubjectPublicKeyInfo();
        Object.assign(this, params);
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer,
        context: 0,
        defaultValue: _types__WEBPACK_IMPORTED_MODULE_6__.Version.v1,
    })
], TBSCertificate.prototype, "version", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.Integer,
        converter: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnIntegerArrayBufferConverter,
    })
], TBSCertificate.prototype, "serialNumber", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _algorithm_identifier__WEBPACK_IMPORTED_MODULE_1__.AlgorithmIdentifier })
], TBSCertificate.prototype, "signature", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.Name })
], TBSCertificate.prototype, "issuer", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _validity__WEBPACK_IMPORTED_MODULE_4__.Validity })
], TBSCertificate.prototype, "validity", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _name__WEBPACK_IMPORTED_MODULE_2__.Name })
], TBSCertificate.prototype, "subject", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _subject_public_key_info__WEBPACK_IMPORTED_MODULE_3__.SubjectPublicKeyInfo })
], TBSCertificate.prototype, "subjectPublicKeyInfo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString,
        context: 1,
        implicit: true,
        optional: true,
    })
], TBSCertificate.prototype, "issuerUniqueID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate.prototype, "subjectUniqueID", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _extension__WEBPACK_IMPORTED_MODULE_5__.Extensions, context: 3, optional: true })
], TBSCertificate.prototype, "extensions", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/time.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/time.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Time: () => (/* binding */ Time)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");


let Time = class Time {
    constructor(time) {
        if (time) {
            if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
                const date = new Date(time);
                if (date.getUTCFullYear() > 2049) {
                    this.generalTime = date;
                }
                else {
                    this.utcTime = date;
                }
            }
            else {
                Object.assign(this, time);
            }
        }
    }
    getTime() {
        const time = this.utcTime || this.generalTime;
        if (!time) {
            throw new Error("Cannot get time from CHOICE object");
        }
        return time;
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.UTCTime,
    })
], Time.prototype, "utcTime", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({
        type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnPropTypes.GeneralizedTime,
    })
], Time.prototype, "generalTime", void 0);
Time = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnType)({ type: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnTypeTypes.Choice })
], Time);



/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/types.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/types.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Version: () => (/* binding */ Version)
/* harmony export */ });
var Version;
(function (Version) {
    Version[Version["v1"] = 0] = "v1";
    Version[Version["v2"] = 1] = "v2";
    Version[Version["v3"] = 2] = "v3";
})(Version || (Version = {}));


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/validity.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/validity.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Validity: () => (/* binding */ Validity)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/time.js");



class Validity {
    constructor(params) {
        this.notBefore = new _time__WEBPACK_IMPORTED_MODULE_1__.Time(new Date());
        this.notAfter = new _time__WEBPACK_IMPORTED_MODULE_1__.Time(new Date());
        if (params) {
            this.notBefore = new _time__WEBPACK_IMPORTED_MODULE_1__.Time(params.notBefore);
            this.notAfter = new _time__WEBPACK_IMPORTED_MODULE_1__.Time(params.notAfter);
        }
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _time__WEBPACK_IMPORTED_MODULE_1__.Time })
], Validity.prototype, "notBefore", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([
    (0,_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_0__.AsnProp)({ type: _time__WEBPACK_IMPORTED_MODULE_1__.Time })
], Validity.prototype, "notAfter", void 0);


/***/ }),

/***/ "./node_modules/.pnpm/@peculiar+x509@1.12.4/node_modules/@peculiar/x509/build/x509.es.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+x509@1.12.4/node_modules/@peculiar/x509/build/x509.es.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlgorithmProvider: () => (/* binding */ AlgorithmProvider),
/* harmony export */   AsnData: () => (/* binding */ AsnData),
/* harmony export */   AsnDefaultSignatureFormatter: () => (/* binding */ AsnDefaultSignatureFormatter),
/* harmony export */   AsnEcSignatureFormatter: () => (/* binding */ AsnEcSignatureFormatter),
/* harmony export */   Attribute: () => (/* binding */ Attribute),
/* harmony export */   AttributeFactory: () => (/* binding */ AttributeFactory),
/* harmony export */   AuthorityInfoAccessExtension: () => (/* binding */ AuthorityInfoAccessExtension),
/* harmony export */   AuthorityKeyIdentifierExtension: () => (/* binding */ AuthorityKeyIdentifierExtension),
/* harmony export */   BasicConstraintsExtension: () => (/* binding */ BasicConstraintsExtension),
/* harmony export */   CRLDistributionPointsExtension: () => (/* binding */ CRLDistributionPointsExtension),
/* harmony export */   CertificatePolicyExtension: () => (/* binding */ CertificatePolicyExtension),
/* harmony export */   ChallengePasswordAttribute: () => (/* binding */ ChallengePasswordAttribute),
/* harmony export */   CryptoProvider: () => (/* binding */ CryptoProvider),
/* harmony export */   DefaultAlgorithmSerializer: () => (/* binding */ DefaultAlgorithmSerializer),
/* harmony export */   EcAlgorithm: () => (/* binding */ EcAlgorithm),
/* harmony export */   EdAlgorithm: () => (/* binding */ EdAlgorithm),
/* harmony export */   ExtendedKeyUsage: () => (/* binding */ ExtendedKeyUsage),
/* harmony export */   ExtendedKeyUsageExtension: () => (/* binding */ ExtendedKeyUsageExtension),
/* harmony export */   Extension: () => (/* binding */ Extension),
/* harmony export */   ExtensionFactory: () => (/* binding */ ExtensionFactory),
/* harmony export */   ExtensionsAttribute: () => (/* binding */ ExtensionsAttribute),
/* harmony export */   GeneralName: () => (/* binding */ GeneralName),
/* harmony export */   GeneralNames: () => (/* binding */ GeneralNames),
/* harmony export */   KeyUsageFlags: () => (/* binding */ KeyUsageFlags),
/* harmony export */   KeyUsagesExtension: () => (/* binding */ KeyUsagesExtension),
/* harmony export */   Name: () => (/* binding */ Name),
/* harmony export */   NameIdentifier: () => (/* binding */ NameIdentifier),
/* harmony export */   OidSerializer: () => (/* binding */ OidSerializer),
/* harmony export */   PemConverter: () => (/* binding */ PemConverter),
/* harmony export */   PemData: () => (/* binding */ PemData),
/* harmony export */   Pkcs10CertificateRequest: () => (/* binding */ Pkcs10CertificateRequest),
/* harmony export */   Pkcs10CertificateRequestGenerator: () => (/* binding */ Pkcs10CertificateRequestGenerator),
/* harmony export */   PublicKey: () => (/* binding */ PublicKey),
/* harmony export */   RsaAlgorithm: () => (/* binding */ RsaAlgorithm),
/* harmony export */   ShaAlgorithm: () => (/* binding */ ShaAlgorithm),
/* harmony export */   SubjectAlternativeNameExtension: () => (/* binding */ SubjectAlternativeNameExtension),
/* harmony export */   SubjectKeyIdentifierExtension: () => (/* binding */ SubjectKeyIdentifierExtension),
/* harmony export */   TextConverter: () => (/* binding */ TextConverter),
/* harmony export */   TextObject: () => (/* binding */ TextObject),
/* harmony export */   X509Certificate: () => (/* binding */ X509Certificate),
/* harmony export */   X509CertificateGenerator: () => (/* binding */ X509CertificateGenerator),
/* harmony export */   X509Certificates: () => (/* binding */ X509Certificates),
/* harmony export */   X509ChainBuilder: () => (/* binding */ X509ChainBuilder),
/* harmony export */   X509Crl: () => (/* binding */ X509Crl),
/* harmony export */   X509CrlEntry: () => (/* binding */ X509CrlEntry),
/* harmony export */   X509CrlGenerator: () => (/* binding */ X509CrlGenerator),
/* harmony export */   X509CrlReason: () => (/* binding */ X509CrlReason),
/* harmony export */   cryptoProvider: () => (/* binding */ cryptoProvider),
/* harmony export */   diAlgorithm: () => (/* binding */ diAlgorithm),
/* harmony export */   diAlgorithmProvider: () => (/* binding */ diAlgorithmProvider),
/* harmony export */   diAsnSignatureFormatter: () => (/* binding */ diAsnSignatureFormatter),
/* harmony export */   idEd25519: () => (/* binding */ idEd25519),
/* harmony export */   idEd448: () => (/* binding */ idEd448),
/* harmony export */   idX25519: () => (/* binding */ idX25519),
/* harmony export */   idX448: () => (/* binding */ idX448)
/* harmony export */ });
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @peculiar/asn1-schema */ "./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @peculiar/asn1-x509 */ "./node_modules/.pnpm/@peculiar+asn1-x509@2.3.15/node_modules/@peculiar/asn1-x509/build/es2015/index.js");
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");
/* harmony import */ var _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @peculiar/asn1-cms */ "./node_modules/.pnpm/@peculiar+asn1-cms@2.3.15/node_modules/@peculiar/asn1-cms/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @peculiar/asn1-ecc */ "./node_modules/.pnpm/@peculiar+asn1-ecc@2.3.15/node_modules/@peculiar/asn1-ecc/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @peculiar/asn1-rsa */ "./node_modules/.pnpm/@peculiar+asn1-rsa@2.3.15/node_modules/@peculiar/asn1-rsa/build/es2015/index.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var tsyringe__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tsyringe */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/index.js");
/* harmony import */ var _peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @peculiar/asn1-pkcs9 */ "./node_modules/.pnpm/@peculiar+asn1-pkcs9@2.3.15/node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js");
/* harmony import */ var _peculiar_asn1_csr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @peculiar/asn1-csr */ "./node_modules/.pnpm/@peculiar+asn1-csr@2.3.15/node_modules/@peculiar/asn1-csr/build/es2015/index.js");
/*!
 * MIT License
 * 
 * Copyright (c) Peculiar Ventures. All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
















const diAlgorithm = "crypto.algorithm";
class AlgorithmProvider {
    getAlgorithms() {
        return tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAlgorithm);
    }
    toAsnAlgorithm(alg) {
        ({ ...alg });
        for (const algorithm of this.getAlgorithms()) {
            const res = algorithm.toAsnAlgorithm(alg);
            if (res) {
                return res;
            }
        }
        if (/^[0-9.]+$/.test(alg.name)) {
            const res = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({
                algorithm: alg.name,
            });
            if ("parameters" in alg) {
                const unknown = alg;
                res.parameters = unknown.parameters;
            }
            return res;
        }
        throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm");
    }
    toWebAlgorithm(alg) {
        for (const algorithm of this.getAlgorithms()) {
            const res = algorithm.toWebAlgorithm(alg);
            if (res) {
                return res;
            }
        }
        const unknown = {
            name: alg.algorithm,
            parameters: alg.parameters,
        };
        return unknown;
    }
}
const diAlgorithmProvider = "crypto.algorithmProvider";
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAlgorithmProvider, AlgorithmProvider);

var EcAlgorithm_1;
const idVersionOne = "1.3.36.3.3.2.8.1.1";
const idBrainpoolP160r1 = `${idVersionOne}.1`;
const idBrainpoolP160t1 = `${idVersionOne}.2`;
const idBrainpoolP192r1 = `${idVersionOne}.3`;
const idBrainpoolP192t1 = `${idVersionOne}.4`;
const idBrainpoolP224r1 = `${idVersionOne}.5`;
const idBrainpoolP224t1 = `${idVersionOne}.6`;
const idBrainpoolP256r1 = `${idVersionOne}.7`;
const idBrainpoolP256t1 = `${idVersionOne}.8`;
const idBrainpoolP320r1 = `${idVersionOne}.9`;
const idBrainpoolP320t1 = `${idVersionOne}.10`;
const idBrainpoolP384r1 = `${idVersionOne}.11`;
const idBrainpoolP384t1 = `${idVersionOne}.12`;
const idBrainpoolP512r1 = `${idVersionOne}.13`;
const idBrainpoolP512t1 = `${idVersionOne}.14`;
const brainpoolP160r1 = "brainpoolP160r1";
const brainpoolP160t1 = "brainpoolP160t1";
const brainpoolP192r1 = "brainpoolP192r1";
const brainpoolP192t1 = "brainpoolP192t1";
const brainpoolP224r1 = "brainpoolP224r1";
const brainpoolP224t1 = "brainpoolP224t1";
const brainpoolP256r1 = "brainpoolP256r1";
const brainpoolP256t1 = "brainpoolP256t1";
const brainpoolP320r1 = "brainpoolP320r1";
const brainpoolP320t1 = "brainpoolP320t1";
const brainpoolP384r1 = "brainpoolP384r1";
const brainpoolP384t1 = "brainpoolP384t1";
const brainpoolP512r1 = "brainpoolP512r1";
const brainpoolP512t1 = "brainpoolP512t1";
const ECDSA = "ECDSA";
let EcAlgorithm = EcAlgorithm_1 = class EcAlgorithm {
    toAsnAlgorithm(alg) {
        switch (alg.name.toLowerCase()) {
            case ECDSA.toLowerCase():
                if ("hash" in alg) {
                    const hash = typeof alg.hash === "string" ? alg.hash : alg.hash.name;
                    switch (hash.toLowerCase()) {
                        case "sha-1":
                            return _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ecdsaWithSHA1;
                        case "sha-256":
                            return _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ecdsaWithSHA256;
                        case "sha-384":
                            return _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ecdsaWithSHA384;
                        case "sha-512":
                            return _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ecdsaWithSHA512;
                    }
                }
                else if ("namedCurve" in alg) {
                    let parameters = "";
                    switch (alg.namedCurve) {
                        case "P-256":
                            parameters = _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp256r1;
                            break;
                        case "K-256":
                            parameters = EcAlgorithm_1.SECP256K1;
                            break;
                        case "P-384":
                            parameters = _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp384r1;
                            break;
                        case "P-521":
                            parameters = _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp521r1;
                            break;
                        case brainpoolP160r1:
                            parameters = idBrainpoolP160r1;
                            break;
                        case brainpoolP160t1:
                            parameters = idBrainpoolP160t1;
                            break;
                        case brainpoolP192r1:
                            parameters = idBrainpoolP192r1;
                            break;
                        case brainpoolP192t1:
                            parameters = idBrainpoolP192t1;
                            break;
                        case brainpoolP224r1:
                            parameters = idBrainpoolP224r1;
                            break;
                        case brainpoolP224t1:
                            parameters = idBrainpoolP224t1;
                            break;
                        case brainpoolP256r1:
                            parameters = idBrainpoolP256r1;
                            break;
                        case brainpoolP256t1:
                            parameters = idBrainpoolP256t1;
                            break;
                        case brainpoolP320r1:
                            parameters = idBrainpoolP320r1;
                            break;
                        case brainpoolP320t1:
                            parameters = idBrainpoolP320t1;
                            break;
                        case brainpoolP384r1:
                            parameters = idBrainpoolP384r1;
                            break;
                        case brainpoolP384t1:
                            parameters = idBrainpoolP384t1;
                            break;
                        case brainpoolP512r1:
                            parameters = idBrainpoolP512r1;
                            break;
                        case brainpoolP512t1:
                            parameters = idBrainpoolP512t1;
                            break;
                    }
                    if (parameters) {
                        return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({
                            algorithm: _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecPublicKey,
                            parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ECParameters({ namedCurve: parameters })),
                        });
                    }
                }
        }
        return null;
    }
    toWebAlgorithm(alg) {
        switch (alg.algorithm) {
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA1:
                return { name: ECDSA, hash: { name: "SHA-1" } };
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA256:
                return { name: ECDSA, hash: { name: "SHA-256" } };
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA384:
                return { name: ECDSA, hash: { name: "SHA-384" } };
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA512:
                return { name: ECDSA, hash: { name: "SHA-512" } };
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecPublicKey: {
                if (!alg.parameters) {
                    throw new TypeError("Cannot get required parameters from EC algorithm");
                }
                const parameters = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(alg.parameters, _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ECParameters);
                switch (parameters.namedCurve) {
                    case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp256r1:
                        return { name: ECDSA, namedCurve: "P-256" };
                    case EcAlgorithm_1.SECP256K1:
                        return { name: ECDSA, namedCurve: "K-256" };
                    case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp384r1:
                        return { name: ECDSA, namedCurve: "P-384" };
                    case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_secp521r1:
                        return { name: ECDSA, namedCurve: "P-521" };
                    case idBrainpoolP160r1:
                        return { name: ECDSA, namedCurve: brainpoolP160r1 };
                    case idBrainpoolP160t1:
                        return { name: ECDSA, namedCurve: brainpoolP160t1 };
                    case idBrainpoolP192r1:
                        return { name: ECDSA, namedCurve: brainpoolP192r1 };
                    case idBrainpoolP192t1:
                        return { name: ECDSA, namedCurve: brainpoolP192t1 };
                    case idBrainpoolP224r1:
                        return { name: ECDSA, namedCurve: brainpoolP224r1 };
                    case idBrainpoolP224t1:
                        return { name: ECDSA, namedCurve: brainpoolP224t1 };
                    case idBrainpoolP256r1:
                        return { name: ECDSA, namedCurve: brainpoolP256r1 };
                    case idBrainpoolP256t1:
                        return { name: ECDSA, namedCurve: brainpoolP256t1 };
                    case idBrainpoolP320r1:
                        return { name: ECDSA, namedCurve: brainpoolP320r1 };
                    case idBrainpoolP320t1:
                        return { name: ECDSA, namedCurve: brainpoolP320t1 };
                    case idBrainpoolP384r1:
                        return { name: ECDSA, namedCurve: brainpoolP384r1 };
                    case idBrainpoolP384t1:
                        return { name: ECDSA, namedCurve: brainpoolP384t1 };
                    case idBrainpoolP512r1:
                        return { name: ECDSA, namedCurve: brainpoolP512r1 };
                    case idBrainpoolP512t1:
                        return { name: ECDSA, namedCurve: brainpoolP512t1 };
                }
            }
        }
        return null;
    }
};
EcAlgorithm.SECP256K1 = "1.3.132.0.10";
EcAlgorithm = EcAlgorithm_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([
    (0,tsyringe__WEBPACK_IMPORTED_MODULE_7__.injectable)()
], EcAlgorithm);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAlgorithm, EcAlgorithm);

const NAME = Symbol("name");
const VALUE = Symbol("value");
class TextObject {
    constructor(name, items = {}, value = "") {
        this[NAME] = name;
        this[VALUE] = value;
        for (const key in items) {
            this[key] = items[key];
        }
    }
}
TextObject.NAME = NAME;
TextObject.VALUE = VALUE;
class DefaultAlgorithmSerializer {
    static toTextObject(alg) {
        const obj = new TextObject("Algorithm Identifier", {}, OidSerializer.toString(alg.algorithm));
        if (alg.parameters) {
            switch (alg.algorithm) {
                case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecPublicKey: {
                    const ecAlg = new EcAlgorithm().toWebAlgorithm(alg);
                    if (ecAlg && "namedCurve" in ecAlg) {
                        obj["Named Curve"] = ecAlg.namedCurve;
                    }
                    else {
                        obj["Parameters"] = alg.parameters;
                    }
                    break;
                }
                default:
                    obj["Parameters"] = alg.parameters;
            }
        }
        return obj;
    }
}
class OidSerializer {
    static toString(oid) {
        const name = this.items[oid];
        if (name) {
            return name;
        }
        return oid;
    }
}
OidSerializer.items = {
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1]: "sha1",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha224]: "sha224",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256]: "sha256",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384]: "sha384",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512]: "sha512",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption]: "rsaEncryption",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1WithRSAEncryption]: "sha1WithRSAEncryption",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha224WithRSAEncryption]: "sha224WithRSAEncryption",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256WithRSAEncryption]: "sha256WithRSAEncryption",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384WithRSAEncryption]: "sha384WithRSAEncryption",
    [_peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512WithRSAEncryption]: "sha512WithRSAEncryption",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecPublicKey]: "ecPublicKey",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA1]: "ecdsaWithSHA1",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA224]: "ecdsaWithSHA224",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA256]: "ecdsaWithSHA256",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA384]: "ecdsaWithSHA384",
    [_peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecdsaWithSHA512]: "ecdsaWithSHA512",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_serverAuth]: "TLS WWW server authentication",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_clientAuth]: "TLS WWW client authentication",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_codeSigning]: "Code Signing",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_emailProtection]: "E-mail Protection",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_timeStamping]: "Time Stamping",
    [_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_kp_OCSPSigning]: "OCSP Signing",
    [_peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.id_signedData]: "Signed Data",
};
class TextConverter {
    static serialize(obj) {
        return this.serializeObj(obj).join("\n");
    }
    static pad(deep = 0) {
        return "".padStart(2 * deep, " ");
    }
    static serializeObj(obj, deep = 0) {
        const res = [];
        let pad = this.pad(deep++);
        let value = "";
        const objValue = obj[TextObject.VALUE];
        if (objValue) {
            value = ` ${objValue}`;
        }
        res.push(`${pad}${obj[TextObject.NAME]}:${value}`);
        pad = this.pad(deep);
        for (const key in obj) {
            if (typeof key === "symbol") {
                continue;
            }
            const value = obj[key];
            const keyValue = key ? `${key}: ` : "";
            if (typeof value === "string" ||
                typeof value === "number" ||
                typeof value === "boolean") {
                res.push(`${pad}${keyValue}${value}`);
            }
            else if (value instanceof Date) {
                res.push(`${pad}${keyValue}${value.toUTCString()}`);
            }
            else if (Array.isArray(value)) {
                for (const obj of value) {
                    obj[TextObject.NAME] = key;
                    res.push(...this.serializeObj(obj, deep));
                }
            }
            else if (value instanceof TextObject) {
                value[TextObject.NAME] = key;
                res.push(...this.serializeObj(value, deep));
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(value)) {
                if (key) {
                    res.push(`${pad}${keyValue}`);
                    res.push(...this.serializeBufferSource(value, deep + 1));
                }
                else {
                    res.push(...this.serializeBufferSource(value, deep));
                }
            }
            else if ("toTextObject" in value) {
                const obj = value.toTextObject();
                obj[TextObject.NAME] = key;
                res.push(...this.serializeObj(obj, deep));
            }
            else {
                throw new TypeError("Cannot serialize data in text format. Unsupported type.");
            }
        }
        return res;
    }
    static serializeBufferSource(buffer, deep = 0) {
        const pad = this.pad(deep);
        const view = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(buffer);
        const res = [];
        for (let i = 0; i < view.length;) {
            const row = [];
            for (let j = 0; j < 16 && i < view.length; j++) {
                if (j === 8) {
                    row.push("");
                }
                const hex = view[i++].toString(16).padStart(2, "0");
                row.push(hex);
            }
            res.push(`${pad}${row.join(" ")}`);
        }
        return res;
    }
    static serializeAlgorithm(alg) {
        return this.algorithmSerializer.toTextObject(alg);
    }
}
TextConverter.oidSerializer = OidSerializer;
TextConverter.algorithmSerializer = DefaultAlgorithmSerializer;

class AsnData {
    constructor(...args) {
        if (args.length === 1) {
            const asn = args[0];
            this.rawData = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asn);
            this.onInit(asn);
        }
        else {
            const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(args[0], args[1]);
            this.rawData = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(args[0]);
            this.onInit(asn);
        }
    }
    equal(data) {
        if (data instanceof AsnData) {
            return (0,pvtsutils__WEBPACK_IMPORTED_MODULE_3__.isEqual)(data.rawData, this.rawData);
        }
        return false;
    }
    toString(format = "text") {
        switch (format) {
            case "asn":
                return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.toString(this.rawData);
            case "text":
                return TextConverter.serialize(this.toTextObject());
            case "hex":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(this.rawData);
            case "base64":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBase64(this.rawData);
            case "base64url":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBase64Url(this.rawData);
            default:
                throw TypeError("Argument 'format' is unsupported value");
        }
    }
    getTextName() {
        const constructor = this.constructor;
        return constructor.NAME;
    }
    toTextObject() {
        const obj = this.toTextObjectEmpty();
        obj[""] = this.rawData;
        return obj;
    }
    toTextObjectEmpty(value) {
        return new TextObject(this.getTextName(), {}, value);
    }
}
AsnData.NAME = "ASN";

class Extension extends AsnData {
    constructor(...args) {
        let raw;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            raw = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(args[0]);
        }
        else {
            raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension({
                extnID: args[0],
                critical: args[1],
                extnValue: new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(args[2])),
            }));
        }
        super(raw, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension);
    }
    onInit(asn) {
        this.type = asn.extnID;
        this.critical = asn.critical;
        this.value = asn.extnValue.buffer;
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[""] = this.value;
        return obj;
    }
    toTextObjectWithoutValue() {
        const obj = this.toTextObjectEmpty(this.critical ? "critical" : undefined);
        if (obj[TextObject.NAME] === Extension.NAME) {
            obj[TextObject.NAME] = OidSerializer.toString(this.type);
        }
        return obj;
    }
}

var _a;
class CryptoProvider {
    static isCryptoKeyPair(data) {
        return data && data.privateKey && data.publicKey;
    }
    static isCryptoKey(data) {
        return data && data.usages && data.type && data.algorithm && data.extractable !== undefined;
    }
    constructor() {
        this.items = new Map();
        this[_a] = "CryptoProvider";
        if (typeof self !== "undefined" && typeof crypto !== "undefined") {
            this.set(CryptoProvider.DEFAULT, crypto);
        }
        else if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.crypto && __webpack_require__.g.crypto.subtle) {
            this.set(CryptoProvider.DEFAULT, __webpack_require__.g.crypto);
        }
    }
    clear() {
        this.items.clear();
    }
    delete(key) {
        return this.items.delete(key);
    }
    forEach(callbackfn, thisArg) {
        return this.items.forEach(callbackfn, thisArg);
    }
    has(key) {
        return this.items.has(key);
    }
    get size() {
        return this.items.size;
    }
    entries() {
        return this.items.entries();
    }
    keys() {
        return this.items.keys();
    }
    values() {
        return this.items.values();
    }
    [Symbol.iterator]() {
        return this.items[Symbol.iterator]();
    }
    get(key = CryptoProvider.DEFAULT) {
        const crypto = this.items.get(key.toLowerCase());
        if (!crypto) {
            throw new Error(`Cannot get Crypto by name '${key}'`);
        }
        return crypto;
    }
    set(key, value) {
        if (typeof key === "string") {
            if (!value) {
                throw new TypeError("Argument 'value' is required");
            }
            this.items.set(key.toLowerCase(), value);
        }
        else {
            this.items.set(CryptoProvider.DEFAULT, key);
        }
        return this;
    }
}
_a = Symbol.toStringTag;
CryptoProvider.DEFAULT = "default";
const cryptoProvider = new CryptoProvider();

const OID_REGEX = /^[0-2](?:\.[1-9][0-9]*)+$/;
function isOID(id) {
    return new RegExp(OID_REGEX).test(id);
}
class NameIdentifier {
    constructor(names = {}) {
        this.items = {};
        for (const id in names) {
            this.register(id, names[id]);
        }
    }
    get(idOrName) {
        return this.items[idOrName] || null;
    }
    findId(idOrName) {
        if (!isOID(idOrName)) {
            return this.get(idOrName);
        }
        return idOrName;
    }
    register(id, name) {
        this.items[id] = name;
        this.items[name] = id;
    }
}
const names = new NameIdentifier();
names.register("CN", "2.5.4.3");
names.register("L", "2.5.4.7");
names.register("ST", "2.5.4.8");
names.register("O", "2.5.4.10");
names.register("OU", "2.5.4.11");
names.register("C", "2.5.4.6");
names.register("DC", "0.9.2342.19200300.100.1.25");
names.register("E", "1.2.840.113549.1.9.1");
names.register("G", "2.5.4.42");
names.register("I", "2.5.4.43");
names.register("SN", "2.5.4.4");
names.register("T", "2.5.4.12");
function replaceUnknownCharacter(text, char) {
    return `\\${pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromUtf8String(char)).toUpperCase()}`;
}
function escape(data) {
    return data
        .replace(/([,+"\\<>;])/g, "\\$1")
        .replace(/^([ #])/, "\\$1")
        .replace(/([ ]$)/, "\\$1")
        .replace(/([\r\n\t])/, replaceUnknownCharacter);
}
class Name {
    static isASCII(text) {
        for (let i = 0; i < text.length; i++) {
            const code = text.charCodeAt(i);
            if (code > 0xFF) {
                return false;
            }
        }
        return true;
    }
    static isPrintableString(text) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/g.test(text);
    }
    constructor(data, extraNames = {}) {
        this.extraNames = new NameIdentifier();
        this.asn = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name();
        for (const key in extraNames) {
            if (Object.prototype.hasOwnProperty.call(extraNames, key)) {
                const value = extraNames[key];
                this.extraNames.register(key, value);
            }
        }
        if (typeof data === "string") {
            this.asn = this.fromString(data);
        }
        else if (data instanceof _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name) {
            this.asn = data;
        }
        else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(data)) {
            this.asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(data, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name);
        }
        else {
            this.asn = this.fromJSON(data);
        }
    }
    getField(idOrName) {
        const id = this.extraNames.findId(idOrName) || names.findId(idOrName);
        const res = [];
        for (const name of this.asn) {
            for (const rdn of name) {
                if (rdn.type === id) {
                    res.push(rdn.value.toString());
                }
            }
        }
        return res;
    }
    getName(idOrName) {
        return this.extraNames.get(idOrName) || names.get(idOrName);
    }
    toString() {
        return this.asn.map(rdn => rdn.map(o => {
            const type = this.getName(o.type) || o.type;
            const value = o.value.anyValue
                ? `#${pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(o.value.anyValue)}`
                : escape(o.value.toString());
            return `${type}=${value}`;
        })
            .join("+"))
            .join(", ");
    }
    toJSON() {
        var _a;
        const json = [];
        for (const rdn of this.asn) {
            const jsonItem = {};
            for (const attr of rdn) {
                const type = this.getName(attr.type) || attr.type;
                (_a = jsonItem[type]) !== null && _a !== void 0 ? _a : (jsonItem[type] = []);
                jsonItem[type].push(attr.value.anyValue ? `#${pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(attr.value.anyValue)}` : attr.value.toString());
            }
            json.push(jsonItem);
        }
        return json;
    }
    fromString(data) {
        const asn = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name();
        const regex = /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+"\\](?=[,+]|$))|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
        let matches = null;
        let level = ",";
        while (matches = regex.exec(`${data},`)) {
            let [, type, value] = matches;
            const lastChar = value[value.length - 1];
            if (lastChar === "," || lastChar === "+") {
                value = value.slice(0, value.length - 1);
                matches[3] = lastChar;
            }
            const next = matches[3];
            type = this.getTypeOid(type);
            const attr = this.createAttribute(type, value);
            if (level === "+") {
                asn[asn.length - 1].push(attr);
            }
            else {
                asn.push(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.RelativeDistinguishedName([attr]));
            }
            level = next;
        }
        return asn;
    }
    fromJSON(data) {
        const asn = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name();
        for (const item of data) {
            const asnRdn = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.RelativeDistinguishedName();
            for (const type in item) {
                const typeId = this.getTypeOid(type);
                const values = item[type];
                for (const value of values) {
                    const asnAttr = this.createAttribute(typeId, value);
                    asnRdn.push(asnAttr);
                }
            }
            asn.push(asnRdn);
        }
        return asn;
    }
    getTypeOid(type) {
        if (!/[\d.]+/.test(type)) {
            type = this.getName(type) || "";
        }
        if (!type) {
            throw new Error(`Cannot get OID for name type '${type}'`);
        }
        return type;
    }
    createAttribute(type, value) {
        const attr = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AttributeTypeAndValue({ type });
        if (typeof value === "object") {
            for (const key in value) {
                switch (key) {
                    case "ia5String":
                        attr.value.ia5String = value[key];
                        break;
                    case "utf8String":
                        attr.value.utf8String = value[key];
                        break;
                    case "universalString":
                        attr.value.universalString = value[key];
                        break;
                    case "bmpString":
                        attr.value.bmpString = value[key];
                        break;
                    case "printableString":
                        attr.value.printableString = value[key];
                        break;
                }
            }
        }
        else if (value[0] === "#") {
            attr.value.anyValue = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(value.slice(1));
        }
        else {
            const processedValue = this.processStringValue(value);
            if (type === this.getName("E") || type === this.getName("DC")) {
                attr.value.ia5String = processedValue;
            }
            else {
                if (Name.isPrintableString(processedValue)) {
                    attr.value.printableString = processedValue;
                }
                else {
                    attr.value.utf8String = processedValue;
                }
            }
        }
        return attr;
    }
    processStringValue(value) {
        const quotedMatches = /"(.*?[^\\])?"/.exec(value);
        if (quotedMatches) {
            value = quotedMatches[1];
        }
        return value
            .replace(/\\0a/ig, "\n")
            .replace(/\\0d/ig, "\r")
            .replace(/\\0g/ig, "\t")
            .replace(/\\(.)/g, "$1");
    }
    toArrayBuffer() {
        return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(this.asn);
    }
    async getThumbprint(...args) {
        var _a;
        let crypto;
        let algorithm = "SHA-1";
        if (args.length >= 1 && !((_a = args[0]) === null || _a === void 0 ? void 0 : _a.subtle)) {
            algorithm = args[0] || algorithm;
            crypto = args[1] || cryptoProvider.get();
        }
        else {
            crypto = args[0] || cryptoProvider.get();
        }
        return await crypto.subtle.digest(algorithm, this.toArrayBuffer());
    }
}

const ERR_GN_CONSTRUCTOR = "Cannot initialize GeneralName from ASN.1 data.";
const ERR_GN_STRING_FORMAT = `${ERR_GN_CONSTRUCTOR} Unsupported string format in use.`;
const ERR_GUID = `${ERR_GN_CONSTRUCTOR} Value doesn't match to GUID regular expression.`;
const GUID_REGEX = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i;
const id_GUID = "1.3.6.1.4.1.311.25.1";
const id_UPN = "1.3.6.1.4.1.311.20.2.3";
const DNS = "dns";
const DN = "dn";
const EMAIL = "email";
const IP = "ip";
const URL = "url";
const GUID = "guid";
const UPN = "upn";
const REGISTERED_ID = "id";
class GeneralName extends AsnData {
    constructor(...args) {
        let name;
        if (args.length === 2) {
            switch (args[0]) {
                case DN: {
                    const derName = new Name(args[1]).toArrayBuffer();
                    const asnName = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(derName, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name);
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ directoryName: asnName });
                    break;
                }
                case DNS:
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ dNSName: args[1] });
                    break;
                case EMAIL:
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ rfc822Name: args[1] });
                    break;
                case GUID: {
                    const matches = new RegExp(GUID_REGEX, "i").exec(args[1]);
                    if (!matches) {
                        throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");
                    }
                    const hex = matches
                        .slice(1)
                        .map((o, i) => {
                        if (i < 3) {
                            return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(o)).reverse());
                        }
                        return o;
                    })
                        .join("");
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({
                        otherName: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.OtherName({
                            typeId: id_GUID,
                            value: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(hex))),
                        }),
                    });
                    break;
                }
                case IP:
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ iPAddress: args[1] });
                    break;
                case REGISTERED_ID:
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ registeredID: args[1] });
                    break;
                case UPN: {
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({
                        otherName: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.OtherName({
                            typeId: id_UPN,
                            value: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnUtf8StringConverter.toASN(args[1])),
                        })
                    });
                    break;
                }
                case URL:
                    name = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ uniformResourceIdentifier: args[1] });
                    break;
                default:
                    throw new Error("Cannot create GeneralName. Unsupported type of the name");
            }
        }
        else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            name = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(args[0], _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName);
        }
        else {
            name = args[0];
        }
        super(name);
    }
    onInit(asn) {
        if (asn.dNSName != undefined) {
            this.type = DNS;
            this.value = asn.dNSName;
        }
        else if (asn.rfc822Name != undefined) {
            this.type = EMAIL;
            this.value = asn.rfc822Name;
        }
        else if (asn.iPAddress != undefined) {
            this.type = IP;
            this.value = asn.iPAddress;
        }
        else if (asn.uniformResourceIdentifier != undefined) {
            this.type = URL;
            this.value = asn.uniformResourceIdentifier;
        }
        else if (asn.registeredID != undefined) {
            this.type = REGISTERED_ID;
            this.value = asn.registeredID;
        }
        else if (asn.directoryName != undefined) {
            this.type = DN;
            this.value = new Name(asn.directoryName).toString();
        }
        else if (asn.otherName != undefined) {
            if (asn.otherName.typeId === id_GUID) {
                this.type = GUID;
                const guid = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.otherName.value, _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString);
                const matches = new RegExp(GUID_REGEX, "i").exec(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(guid));
                if (!matches) {
                    throw new Error(ERR_GUID);
                }
                this.value = matches
                    .slice(1)
                    .map((o, i) => {
                    if (i < 3) {
                        return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(o)).reverse());
                    }
                    return o;
                })
                    .join("-");
            }
            else if (asn.otherName.typeId === id_UPN) {
                this.type = UPN;
                this.value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.otherName.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.DirectoryString).toString();
            }
            else {
                throw new Error(ERR_GN_STRING_FORMAT);
            }
        }
        else {
            throw new Error(ERR_GN_STRING_FORMAT);
        }
    }
    toJSON() {
        return {
            type: this.type,
            value: this.value,
        };
    }
    toTextObject() {
        let type;
        switch (this.type) {
            case DN:
            case DNS:
            case GUID:
            case IP:
            case REGISTERED_ID:
            case UPN:
            case URL:
                type = this.type.toUpperCase();
                break;
            case EMAIL:
                type = "Email";
                break;
            default:
                throw new Error("Unsupported GeneralName type");
        }
        let value = this.value;
        if (this.type === REGISTERED_ID) {
            value = OidSerializer.toString(value);
        }
        return new TextObject(type, undefined, value);
    }
}
class GeneralNames extends AsnData {
    constructor(params) {
        let names;
        if (params instanceof _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralNames) {
            names = params;
        }
        else if (Array.isArray(params)) {
            const items = [];
            for (const name of params) {
                if (name instanceof _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName) {
                    items.push(name);
                }
                else {
                    const asnName = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(new GeneralName(name.type, name.value).rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName);
                    items.push(asnName);
                }
            }
            names = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralNames(items);
        }
        else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(params)) {
            names = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(params, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralNames);
        }
        else {
            throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");
        }
        super(names);
    }
    onInit(asn) {
        const items = [];
        for (const asnName of asn) {
            let name = null;
            try {
                name = new GeneralName(asnName);
            }
            catch {
                continue;
            }
            items.push(name);
        }
        this.items = items;
    }
    toJSON() {
        return this.items.map(o => o.toJSON());
    }
    toTextObject() {
        const res = super.toTextObjectEmpty();
        for (const name of this.items) {
            const nameObj = name.toTextObject();
            let field = res[nameObj[TextObject.NAME]];
            if (!Array.isArray(field)) {
                field = [];
                res[nameObj[TextObject.NAME]] = field;
            }
            field.push(nameObj);
        }
        return res;
    }
}
GeneralNames.NAME = "GeneralNames";

const rPaddingTag = "-{5}";
const rEolChars = "\\n";
const rNameTag = `[^${rEolChars}]+`;
const rBeginTag = `${rPaddingTag}BEGIN (${rNameTag}(?=${rPaddingTag}))${rPaddingTag}`;
const rEndTag = `${rPaddingTag}END \\1${rPaddingTag}`;
const rEolGroup = "\\n";
const rHeaderKey = `[^:${rEolChars}]+`;
const rHeaderValue = `(?:[^${rEolChars}]+${rEolGroup}(?: +[^${rEolChars}]+${rEolGroup})*)`;
const rBase64Chars = "[a-zA-Z0-9=+/]+";
const rBase64 = `(?:${rBase64Chars}${rEolGroup})+`;
const rPem = `${rBeginTag}${rEolGroup}(?:((?:${rHeaderKey}: ${rHeaderValue})+))?${rEolGroup}?(${rBase64})${rEndTag}`;
class PemConverter {
    static isPem(data) {
        return typeof data === "string"
            && new RegExp(rPem, "g").test(data.replace(/\r/g, ""));
    }
    static decodeWithHeaders(pem) {
        pem = pem.replace(/\r/g, "");
        const pattern = new RegExp(rPem, "g");
        const res = [];
        let matches = null;
        while (matches = pattern.exec(pem)) {
            const base64 = matches[3]
                .replace(new RegExp(`[${rEolChars}]+`, "g"), "");
            const pemStruct = {
                type: matches[1],
                headers: [],
                rawData: pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromBase64(base64),
            };
            const headersString = matches[2];
            if (headersString) {
                const headers = headersString.split(new RegExp(rEolGroup, "g"));
                let lastHeader = null;
                for (const header of headers) {
                    const [key, value] = header.split(/:(.*)/);
                    if (value === undefined) {
                        if (!lastHeader) {
                            throw new Error("Cannot parse PEM string. Incorrect header value");
                        }
                        lastHeader.value += key.trim();
                    }
                    else {
                        if (lastHeader) {
                            pemStruct.headers.push(lastHeader);
                        }
                        lastHeader = { key, value: value.trim() };
                    }
                }
                if (lastHeader) {
                    pemStruct.headers.push(lastHeader);
                }
            }
            res.push(pemStruct);
        }
        return res;
    }
    static decode(pem) {
        const blocks = this.decodeWithHeaders(pem);
        return blocks.map(o => o.rawData);
    }
    static decodeFirst(pem) {
        const items = this.decode(pem);
        if (!items.length) {
            throw new RangeError("PEM string doesn't contain any objects");
        }
        return items[0];
    }
    static encode(rawData, tag) {
        if (Array.isArray(rawData)) {
            const raws = new Array();
            if (tag) {
                rawData.forEach(element => {
                    if (!pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(element)) {
                        throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");
                    }
                    raws.push(this.encodeStruct({
                        type: tag,
                        rawData: pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(element),
                    }));
                });
            }
            else {
                rawData.forEach(element => {
                    if (!("type" in element)) {
                        throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");
                    }
                    raws.push(this.encodeStruct(element));
                });
            }
            return raws.join("\n");
        }
        else {
            if (!tag) {
                throw new Error("Required argument 'tag' is missed");
            }
            return this.encodeStruct({
                type: tag,
                rawData: pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(rawData),
            });
        }
    }
    static encodeStruct(pem) {
        var _a;
        const upperCaseType = pem.type.toLocaleUpperCase();
        const res = [];
        res.push(`-----BEGIN ${upperCaseType}-----`);
        if ((_a = pem.headers) === null || _a === void 0 ? void 0 : _a.length) {
            for (const header of pem.headers) {
                res.push(`${header.key}: ${header.value}`);
            }
            res.push("");
        }
        const base64 = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBase64(pem.rawData);
        let sliced;
        let offset = 0;
        const rows = Array();
        while (offset < base64.length) {
            if (base64.length - offset < 64) {
                sliced = base64.substring(offset);
            }
            else {
                sliced = base64.substring(offset, offset + 64);
                offset += 64;
            }
            if (sliced.length !== 0) {
                rows.push(sliced);
                if (sliced.length < 64) {
                    break;
                }
            }
            else {
                break;
            }
        }
        res.push(...rows);
        res.push(`-----END ${upperCaseType}-----`);
        return res.join("\n");
    }
}
PemConverter.CertificateTag = "CERTIFICATE";
PemConverter.CrlTag = "CRL";
PemConverter.CertificateRequestTag = "CERTIFICATE REQUEST";
PemConverter.PublicKeyTag = "PUBLIC KEY";
PemConverter.PrivateKeyTag = "PRIVATE KEY";

class PemData extends AsnData {
    static isAsnEncoded(data) {
        return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(data) || typeof data === "string";
    }
    static toArrayBuffer(raw) {
        if (typeof raw === "string") {
            if (PemConverter.isPem(raw)) {
                return PemConverter.decode(raw)[0];
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isHex(raw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(raw);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isBase64(raw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromBase64(raw);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isBase64Url(raw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromBase64Url(raw);
            }
            else {
                throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
            }
        }
        else {
            const stringRaw = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBinary(raw);
            if (PemConverter.isPem(stringRaw)) {
                return PemConverter.decode(stringRaw)[0];
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isHex(stringRaw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(stringRaw);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isBase64(stringRaw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromBase64(stringRaw);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.isBase64Url(stringRaw)) {
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromBase64Url(stringRaw);
            }
            return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(raw);
        }
    }
    constructor(...args) {
        if (PemData.isAsnEncoded(args[0])) {
            super(PemData.toArrayBuffer(args[0]), args[1]);
        }
        else {
            super(args[0]);
        }
    }
    toString(format = "pem") {
        switch (format) {
            case "pem":
                return PemConverter.encode(this.rawData, this.tag);
            default:
                return super.toString(format);
        }
    }
}

class PublicKey extends PemData {
    static async create(data, crypto = cryptoProvider.get()) {
        if (data instanceof PublicKey) {
            return data;
        }
        else if (CryptoProvider.isCryptoKey(data)) {
            if (data.type !== "public") {
                throw new TypeError("Public key is required");
            }
            const spki = await crypto.subtle.exportKey("spki", data);
            return new PublicKey(spki);
        }
        else if (data.publicKey) {
            return data.publicKey;
        }
        else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(data)) {
            return new PublicKey(data);
        }
        else {
            throw new TypeError("Unsupported PublicKeyType");
        }
    }
    constructor(param) {
        if (PemData.isAsnEncoded(param)) {
            super(param, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo);
        }
        else {
            super(param);
        }
        this.tag = PemConverter.PublicKeyTag;
    }
    async export(...args) {
        let crypto;
        let keyUsages = ["verify"];
        let algorithm = { hash: "SHA-256", ...this.algorithm };
        if (args.length > 1) {
            algorithm = args[0] || algorithm;
            keyUsages = args[1] || keyUsages;
            crypto = args[2] || cryptoProvider.get();
        }
        else {
            crypto = args[0] || cryptoProvider.get();
        }
        let raw = this.rawData;
        const asnSpki = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo);
        if (asnSpki.algorithm.algorithm === _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_RSASSA_PSS) {
            raw = convertSpkiToRsaPkcs1(asnSpki, raw);
        }
        return crypto.subtle.importKey("spki", raw, algorithm, true, keyUsages);
    }
    onInit(asn) {
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        const algorithm = this.algorithm = algProv.toWebAlgorithm(asn.algorithm);
        switch (asn.algorithm.algorithm) {
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption:
                {
                    const rsaPublicKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.subjectPublicKey, _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.RSAPublicKey);
                    const modulus = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(rsaPublicKey.modulus);
                    algorithm.publicExponent = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(rsaPublicKey.publicExponent);
                    algorithm.modulusLength = (!modulus[0] ? modulus.slice(1) : modulus).byteLength << 3;
                    break;
                }
        }
    }
    async getThumbprint(...args) {
        var _a;
        let crypto;
        let algorithm = "SHA-1";
        if (args.length >= 1 && !((_a = args[0]) === null || _a === void 0 ? void 0 : _a.subtle)) {
            algorithm = args[0] || algorithm;
            crypto = args[1] || cryptoProvider.get();
        }
        else {
            crypto = args[0] || cryptoProvider.get();
        }
        return await crypto.subtle.digest(algorithm, this.rawData);
    }
    async getKeyIdentifier(...args) {
        let crypto;
        let algorithm = "SHA-1";
        if (args.length === 1) {
            if (typeof args[0] === "string") {
                algorithm = args[0];
                crypto = cryptoProvider.get();
            }
            else {
                crypto = args[0];
            }
        }
        else if (args.length === 2) {
            algorithm = args[0];
            crypto = args[1];
        }
        else {
            crypto = cryptoProvider.get();
        }
        const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo);
        return await crypto.subtle.digest(algorithm, asn.subjectPublicKey);
    }
    toTextObject() {
        const obj = this.toTextObjectEmpty();
        const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo);
        obj["Algorithm"] = TextConverter.serializeAlgorithm(asn.algorithm);
        switch (asn.algorithm.algorithm) {
            case _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.id_ecPublicKey:
                obj["EC Point"] = asn.subjectPublicKey;
                break;
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption:
            default:
                obj["Raw Data"] = asn.subjectPublicKey;
        }
        return obj;
    }
}
function convertSpkiToRsaPkcs1(asnSpki, raw) {
    asnSpki.algorithm = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({
        algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption,
        parameters: null,
    });
    raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnSpki);
    return raw;
}

class AuthorityKeyIdentifierExtension extends Extension {
    static async create(param, critical = false, crypto = cryptoProvider.get()) {
        if ("name" in param && "serialNumber" in param) {
            return new AuthorityKeyIdentifierExtension(param, critical);
        }
        const key = await PublicKey.create(param, crypto);
        const id = await key.getKeyIdentifier(crypto);
        return new AuthorityKeyIdentifierExtension(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(id), critical);
    }
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else if (typeof args[0] === "string") {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityKeyIdentifier({ keyIdentifier: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.KeyIdentifier(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(args[0])) });
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_authorityKeyIdentifier, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
        else {
            const certId = args[0];
            const certIdName = certId.name instanceof GeneralNames
                ? _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(certId.name.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralNames)
                : certId.name;
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityKeyIdentifier({
                authorityCertIssuer: certIdName,
                authorityCertSerialNumber: pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(certId.serialNumber),
            });
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_authorityKeyIdentifier, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
    }
    onInit(asn) {
        super.onInit(asn);
        const aki = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.extnValue, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityKeyIdentifier);
        if (aki.keyIdentifier) {
            this.keyId = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(aki.keyIdentifier);
        }
        if (aki.authorityCertIssuer || aki.authorityCertSerialNumber) {
            this.certId = {
                name: aki.authorityCertIssuer || [],
                serialNumber: aki.authorityCertSerialNumber ? pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(aki.authorityCertSerialNumber) : "",
            };
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityKeyIdentifier);
        if (asn.authorityCertIssuer) {
            obj["Authority Issuer"] = new GeneralNames(asn.authorityCertIssuer).toTextObject();
        }
        if (asn.authorityCertSerialNumber) {
            obj["Authority Serial Number"] = asn.authorityCertSerialNumber;
        }
        if (asn.keyIdentifier) {
            obj[""] = asn.keyIdentifier;
        }
        return obj;
    }
}
AuthorityKeyIdentifierExtension.NAME = "Authority Key Identifier";

class BasicConstraintsExtension extends Extension {
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.BasicConstraints);
            this.ca = value.cA;
            this.pathLength = value.pathLenConstraint;
        }
        else {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.BasicConstraints({
                cA: args[0],
                pathLenConstraint: args[1],
            });
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_basicConstraints, args[2], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
            this.ca = args[0];
            this.pathLength = args[1];
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        if (this.ca) {
            obj["CA"] = this.ca;
        }
        if (this.pathLength !== undefined) {
            obj["Path Length"] = this.pathLength;
        }
        return obj;
    }
}
BasicConstraintsExtension.NAME = "Basic Constraints";

var ExtendedKeyUsage;
(function (ExtendedKeyUsage) {
    ExtendedKeyUsage["serverAuth"] = "1.3.6.1.5.5.7.3.1";
    ExtendedKeyUsage["clientAuth"] = "1.3.6.1.5.5.7.3.2";
    ExtendedKeyUsage["codeSigning"] = "1.3.6.1.5.5.7.3.3";
    ExtendedKeyUsage["emailProtection"] = "1.3.6.1.5.5.7.3.4";
    ExtendedKeyUsage["timeStamping"] = "1.3.6.1.5.5.7.3.8";
    ExtendedKeyUsage["ocspSigning"] = "1.3.6.1.5.5.7.3.9";
})(ExtendedKeyUsage || (ExtendedKeyUsage = {}));
class ExtendedKeyUsageExtension extends Extension {
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.ExtendedKeyUsage);
            this.usages = value.map(o => o);
        }
        else {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.ExtendedKeyUsage(args[0]);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_extKeyUsage, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
            this.usages = args[0];
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[""] = this.usages.map(o => OidSerializer.toString(o)).join(", ");
        return obj;
    }
}
ExtendedKeyUsageExtension.NAME = "Extended Key Usages";

var KeyUsageFlags;
(function (KeyUsageFlags) {
    KeyUsageFlags[KeyUsageFlags["digitalSignature"] = 1] = "digitalSignature";
    KeyUsageFlags[KeyUsageFlags["nonRepudiation"] = 2] = "nonRepudiation";
    KeyUsageFlags[KeyUsageFlags["keyEncipherment"] = 4] = "keyEncipherment";
    KeyUsageFlags[KeyUsageFlags["dataEncipherment"] = 8] = "dataEncipherment";
    KeyUsageFlags[KeyUsageFlags["keyAgreement"] = 16] = "keyAgreement";
    KeyUsageFlags[KeyUsageFlags["keyCertSign"] = 32] = "keyCertSign";
    KeyUsageFlags[KeyUsageFlags["cRLSign"] = 64] = "cRLSign";
    KeyUsageFlags[KeyUsageFlags["encipherOnly"] = 128] = "encipherOnly";
    KeyUsageFlags[KeyUsageFlags["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags || (KeyUsageFlags = {}));
class KeyUsagesExtension extends Extension {
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.KeyUsage);
            this.usages = value.toNumber();
        }
        else {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.KeyUsage(args[0]);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_keyUsage, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
            this.usages = args[0];
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.KeyUsage);
        obj[""] = asn.toJSON().join(", ");
        return obj;
    }
}
KeyUsagesExtension.NAME = "Key Usages";

class SubjectKeyIdentifierExtension extends Extension {
    static async create(publicKey, critical = false, crypto = cryptoProvider.get()) {
        const key = await PublicKey.create(publicKey, crypto);
        const id = await key.getKeyIdentifier(crypto);
        return new SubjectKeyIdentifierExtension(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(id), critical);
    }
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectKeyIdentifier);
            this.keyId = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(value);
        }
        else {
            const identifier = typeof args[0] === "string"
                ? pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(args[0])
                : args[0];
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectKeyIdentifier(identifier);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectKeyIdentifier, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
            this.keyId = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(identifier);
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectKeyIdentifier);
        obj[""] = asn;
        return obj;
    }
}
SubjectKeyIdentifierExtension.NAME = "Subject Key Identifier";

class SubjectAlternativeNameExtension extends Extension {
    constructor(...args) {
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else {
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectAltName, args[1], new GeneralNames(args[0] || []).rawData);
        }
    }
    onInit(asn) {
        super.onInit(asn);
        const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.extnValue, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectAlternativeName);
        this.names = new GeneralNames(value);
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const namesObj = this.names.toTextObject();
        for (const key in namesObj) {
            obj[key] = namesObj[key];
        }
        return obj;
    }
}
SubjectAlternativeNameExtension.NAME = "Subject Alternative Name";

class ExtensionFactory {
    static register(id, type) {
        this.items.set(id, type);
    }
    static create(data) {
        const extension = new Extension(data);
        const Type = this.items.get(extension.type);
        if (Type) {
            return new Type(data);
        }
        return extension;
    }
}
ExtensionFactory.items = new Map();

class CertificatePolicyExtension extends Extension {
    constructor(...args) {
        var _a;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
            const asnPolicies = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CertificatePolicies);
            this.policies = asnPolicies.map(o => o.policyIdentifier);
        }
        else {
            const policies = args[0];
            const critical = (_a = args[1]) !== null && _a !== void 0 ? _a : false;
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CertificatePolicies(policies.map(o => (new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.PolicyInformation({
                policyIdentifier: o,
            }))));
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_certificatePolicies, critical, _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
            this.policies = policies;
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj["Policy"] = this.policies.map(o => new TextObject("", {}, OidSerializer.toString(o)));
        return obj;
    }
}
CertificatePolicyExtension.NAME = "Certificate Policies";
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_certificatePolicies, CertificatePolicyExtension);

class CRLDistributionPointsExtension extends Extension {
    constructor(...args) {
        var _a;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else if (Array.isArray(args[0]) && typeof args[0][0] === "string") {
            const urls = args[0];
            const dps = urls.map(url => {
                return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.DistributionPoint({
                    distributionPoint: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.DistributionPointName({
                        fullName: [new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName({ uniformResourceIdentifier: url })],
                    }),
                });
            });
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CRLDistributionPoints(dps);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_cRLDistributionPoints, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
        else {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CRLDistributionPoints(args[0]);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_cRLDistributionPoints, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
        (_a = this.distributionPoints) !== null && _a !== void 0 ? _a : (this.distributionPoints = []);
    }
    onInit(asn) {
        super.onInit(asn);
        const crlExt = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.extnValue, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CRLDistributionPoints);
        this.distributionPoints = crlExt;
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj["Distribution Point"] = this.distributionPoints.map(dp => {
            var _a;
            const dpObj = {};
            if (dp.distributionPoint) {
                dpObj[""] = (_a = dp.distributionPoint.fullName) === null || _a === void 0 ? void 0 : _a.map(name => new GeneralName(name).toString()).join(", ");
            }
            if (dp.reasons) {
                dpObj["Reasons"] = dp.reasons.toString();
            }
            if (dp.cRLIssuer) {
                dpObj["CRL Issuer"] = dp.cRLIssuer.map(issuer => issuer.toString()).join(", ");
            }
            return dpObj;
        });
        return obj;
    }
}
CRLDistributionPointsExtension.NAME = "CRL Distribution Points";

class AuthorityInfoAccessExtension extends Extension {
    constructor(...args) {
        var _a, _b, _c, _d;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else if (args[0] instanceof _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityInfoAccessSyntax) {
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityInfoAccessSyntax(args[0]);
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_pe_authorityInfoAccess, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
        else {
            const params = args[0];
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityInfoAccessSyntax();
            addAccessDescriptions(value, params, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_ocsp, "ocsp");
            addAccessDescriptions(value, params, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_caIssuers, "caIssuers");
            addAccessDescriptions(value, params, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_timeStamping, "timeStamping");
            addAccessDescriptions(value, params, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_caRepository, "caRepository");
            super(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_pe_authorityInfoAccess, args[1], _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value));
        }
        (_a = this.ocsp) !== null && _a !== void 0 ? _a : (this.ocsp = []);
        (_b = this.caIssuers) !== null && _b !== void 0 ? _b : (this.caIssuers = []);
        (_c = this.timeStamping) !== null && _c !== void 0 ? _c : (this.timeStamping = []);
        (_d = this.caRepository) !== null && _d !== void 0 ? _d : (this.caRepository = []);
    }
    onInit(asn) {
        super.onInit(asn);
        this.ocsp = [];
        this.caIssuers = [];
        this.timeStamping = [];
        this.caRepository = [];
        const aia = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(asn.extnValue, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AuthorityInfoAccessSyntax);
        aia.forEach(accessDescription => {
            switch (accessDescription.accessMethod) {
                case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_ocsp:
                    this.ocsp.push(new GeneralName(accessDescription.accessLocation));
                    break;
                case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_caIssuers:
                    this.caIssuers.push(new GeneralName(accessDescription.accessLocation));
                    break;
                case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_timeStamping:
                    this.timeStamping.push(new GeneralName(accessDescription.accessLocation));
                    break;
                case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ad_caRepository:
                    this.caRepository.push(new GeneralName(accessDescription.accessLocation));
                    break;
            }
        });
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        if (this.ocsp.length) {
            addUrlsToObject(obj, "OCSP", this.ocsp);
        }
        if (this.caIssuers.length) {
            addUrlsToObject(obj, "CA Issuers", this.caIssuers);
        }
        if (this.timeStamping.length) {
            addUrlsToObject(obj, "Time Stamping", this.timeStamping);
        }
        if (this.caRepository.length) {
            addUrlsToObject(obj, "CA Repository", this.caRepository);
        }
        return obj;
    }
}
AuthorityInfoAccessExtension.NAME = "Authority Info Access";
function addUrlsToObject(obj, key, urls) {
    if (urls.length === 1) {
        obj[key] = urls[0].toTextObject();
    }
    else {
        const names = new TextObject("");
        urls.forEach((name, index) => {
            const nameObj = name.toTextObject();
            const indexedKey = `${nameObj[TextObject.NAME]} ${index + 1}`;
            let field = names[indexedKey];
            if (!Array.isArray(field)) {
                field = [];
                names[indexedKey] = field;
            }
            field.push(nameObj);
        });
        obj[key] = names;
    }
}
function addAccessDescriptions(value, params, method, key) {
    const items = params[key];
    if (items) {
        const array = Array.isArray(items) ? items : [items];
        array.forEach(url => {
            if (typeof url === "string") {
                url = new GeneralName("url", url);
            }
            value.push(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AccessDescription({
                accessMethod: method,
                accessLocation: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(url.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.GeneralName),
            }));
        });
    }
}

class Attribute extends AsnData {
    constructor(...args) {
        let raw;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            raw = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(args[0]);
        }
        else {
            const type = args[0];
            const values = Array.isArray(args[1]) ? args[1].map(o => pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(o)) : [];
            raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Attribute({ type, values }));
        }
        super(raw, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Attribute);
    }
    onInit(asn) {
        this.type = asn.type;
        this.values = asn.values;
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj["Value"] = this.values.map(o => new TextObject("", { "": o }));
        return obj;
    }
    toTextObjectWithoutValue() {
        const obj = this.toTextObjectEmpty();
        if (obj[TextObject.NAME] === Attribute.NAME) {
            obj[TextObject.NAME] = OidSerializer.toString(this.type);
        }
        return obj;
    }
}
Attribute.NAME = "Attribute";

class ChallengePasswordAttribute extends Attribute {
    constructor(...args) {
        var _a;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else {
            const value = new _peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.ChallengePassword({
                printableString: args[0],
            });
            super(_peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_challengePassword, [_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value)]);
        }
        (_a = this.password) !== null && _a !== void 0 ? _a : (this.password = "");
    }
    onInit(asn) {
        super.onInit(asn);
        if (this.values[0]) {
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.values[0], _peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.ChallengePassword);
            this.password = value.toString();
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[TextObject.VALUE] = this.password;
        return obj;
    }
}
ChallengePasswordAttribute.NAME = "Challenge Password";

class ExtensionsAttribute extends Attribute {
    constructor(...args) {
        var _a;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            super(args[0]);
        }
        else {
            const extensions = args[0];
            const value = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extensions();
            for (const extension of extensions) {
                value.push(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(extension.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension));
            }
            super(_peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_extensionRequest, [_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(value)]);
        }
        (_a = this.items) !== null && _a !== void 0 ? _a : (this.items = []);
    }
    onInit(asn) {
        super.onInit(asn);
        if (this.values[0]) {
            const value = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.values[0], _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extensions);
            this.items = value.map(o => ExtensionFactory.create(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o)));
        }
    }
    toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const extensions = this.items.map(o => o.toTextObject());
        for (const extension of extensions) {
            obj[extension[TextObject.NAME]] = extension;
        }
        return obj;
    }
}
ExtensionsAttribute.NAME = "Extensions";

class AttributeFactory {
    static register(id, type) {
        this.items.set(id, type);
    }
    static create(data) {
        const attribute = new Attribute(data);
        const Type = this.items.get(attribute.type);
        if (Type) {
            return new Type(data);
        }
        return attribute;
    }
}
AttributeFactory.items = new Map();

const diAsnSignatureFormatter = "crypto.signatureFormatter";
class AsnDefaultSignatureFormatter {
    toAsnSignature(algorithm, signature) {
        return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(signature);
    }
    toWebSignature(algorithm, signature) {
        return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(signature);
    }
}

var RsaAlgorithm_1;
let RsaAlgorithm = RsaAlgorithm_1 = class RsaAlgorithm {
    static createPssParams(hash, saltLength) {
        const hashAlgorithm = RsaAlgorithm_1.getHashAlgorithm(hash);
        if (!hashAlgorithm) {
            return null;
        }
        return new _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.RsaSaPssParams({
            hashAlgorithm,
            maskGenAlgorithm: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({
                algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_mgf1,
                parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(hashAlgorithm),
            }),
            saltLength,
        });
    }
    static getHashAlgorithm(alg) {
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        if (typeof alg === "string") {
            return algProv.toAsnAlgorithm({ name: alg });
        }
        if (typeof alg === "object" && alg && "name" in alg) {
            return algProv.toAsnAlgorithm(alg);
        }
        return null;
    }
    toAsnAlgorithm(alg) {
        switch (alg.name.toLowerCase()) {
            case "rsassa-pkcs1-v1_5":
                if ("hash" in alg) {
                    let hash;
                    if (typeof alg.hash === "string") {
                        hash = alg.hash;
                    }
                    else if (alg.hash && typeof alg.hash === "object"
                        && "name" in alg.hash && typeof alg.hash.name === "string") {
                        hash = alg.hash.name.toUpperCase();
                    }
                    else {
                        throw new Error("Cannot get hash algorithm name");
                    }
                    switch (hash.toLowerCase()) {
                        case "sha-1":
                            return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1WithRSAEncryption, parameters: null });
                        case "sha-256":
                            return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256WithRSAEncryption, parameters: null });
                        case "sha-384":
                            return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384WithRSAEncryption, parameters: null });
                        case "sha-512":
                            return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512WithRSAEncryption, parameters: null });
                    }
                }
                else {
                    return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption, parameters: null });
                }
                break;
            case "rsa-pss":
                if ("hash" in alg) {
                    if (!("saltLength" in alg && typeof alg.saltLength === "number")) {
                        throw new Error("Cannot get 'saltLength' from 'alg' argument");
                    }
                    const pssParams = RsaAlgorithm_1.createPssParams(alg.hash, alg.saltLength);
                    if (!pssParams) {
                        throw new Error("Cannot create PSS parameters");
                    }
                    return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_RSASSA_PSS, parameters: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(pssParams) });
                }
                else {
                    return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_RSASSA_PSS, parameters: null });
                }
        }
        return null;
    }
    toWebAlgorithm(alg) {
        switch (alg.algorithm) {
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_rsaEncryption:
                return { name: "RSASSA-PKCS1-v1_5" };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1WithRSAEncryption:
                return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256WithRSAEncryption:
                return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384WithRSAEncryption:
                return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512WithRSAEncryption:
                return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_RSASSA_PSS:
                if (alg.parameters) {
                    const pssParams = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(alg.parameters, _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.RsaSaPssParams);
                    const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
                    const hashAlg = algProv.toWebAlgorithm(pssParams.hashAlgorithm);
                    return {
                        name: "RSA-PSS",
                        hash: hashAlg,
                        saltLength: pssParams.saltLength,
                    };
                }
                else {
                    return { name: "RSA-PSS" };
                }
        }
        return null;
    }
};
RsaAlgorithm = RsaAlgorithm_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([
    (0,tsyringe__WEBPACK_IMPORTED_MODULE_7__.injectable)()
], RsaAlgorithm);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAlgorithm, RsaAlgorithm);

let ShaAlgorithm = class ShaAlgorithm {
    toAsnAlgorithm(alg) {
        switch (alg.name.toLowerCase()) {
            case "sha-1":
                return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1 });
            case "sha-256":
                return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256 });
            case "sha-384":
                return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384 });
            case "sha-512":
                return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({ algorithm: _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512 });
        }
        return null;
    }
    toWebAlgorithm(alg) {
        switch (alg.algorithm) {
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha1:
                return { name: "SHA-1" };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha256:
                return { name: "SHA-256" };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha384:
                return { name: "SHA-384" };
            case _peculiar_asn1_rsa__WEBPACK_IMPORTED_MODULE_6__.id_sha512:
                return { name: "SHA-512" };
        }
        return null;
    }
};
ShaAlgorithm = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([
    (0,tsyringe__WEBPACK_IMPORTED_MODULE_7__.injectable)()
], ShaAlgorithm);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAlgorithm, ShaAlgorithm);

class AsnEcSignatureFormatter {
    addPadding(pointSize, data) {
        const bytes = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(data);
        const res = new Uint8Array(pointSize);
        res.set(bytes, pointSize - bytes.length);
        return res;
    }
    removePadding(data, positive = false) {
        let bytes = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(data);
        for (let i = 0; i < bytes.length; i++) {
            if (!bytes[i]) {
                continue;
            }
            bytes = bytes.slice(i);
            break;
        }
        if (positive && bytes[0] > 127) {
            const result = new Uint8Array(bytes.length + 1);
            result.set(bytes, 1);
            return result.buffer;
        }
        return bytes.buffer;
    }
    toAsnSignature(algorithm, signature) {
        if (algorithm.name === "ECDSA") {
            const namedCurve = algorithm.namedCurve;
            const pointSize = AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || AsnEcSignatureFormatter.defaultNamedCurveSize;
            const ecSignature = new _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ECDSASigValue();
            const uint8Signature = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(signature);
            ecSignature.r = this.removePadding(uint8Signature.slice(0, pointSize), true);
            ecSignature.s = this.removePadding(uint8Signature.slice(pointSize, pointSize + pointSize), true);
            return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(ecSignature);
        }
        return null;
    }
    toWebSignature(algorithm, signature) {
        if (algorithm.name === "ECDSA") {
            const ecSigValue = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(signature, _peculiar_asn1_ecc__WEBPACK_IMPORTED_MODULE_5__.ECDSASigValue);
            const namedCurve = algorithm.namedCurve;
            const pointSize = AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || AsnEcSignatureFormatter.defaultNamedCurveSize;
            const r = this.addPadding(pointSize, this.removePadding(ecSigValue.r));
            const s = this.addPadding(pointSize, this.removePadding(ecSigValue.s));
            return (0,pvtsutils__WEBPACK_IMPORTED_MODULE_3__.combine)(r, s);
        }
        return null;
    }
}
AsnEcSignatureFormatter.namedCurveSize = new Map();
AsnEcSignatureFormatter.defaultNamedCurveSize = 32;

const idX25519 = "1.3.101.110";
const idX448 = "1.3.101.111";
const idEd25519 = "1.3.101.112";
const idEd448 = "1.3.101.113";
let EdAlgorithm = class EdAlgorithm {
    toAsnAlgorithm(alg) {
        let algorithm = null;
        switch (alg.name.toLowerCase()) {
            case "ed25519":
                algorithm = idEd25519;
                break;
            case "x25519":
                algorithm = idX25519;
                break;
            case "eddsa":
                switch (alg.namedCurve.toLowerCase()) {
                    case "ed25519":
                        algorithm = idEd25519;
                        break;
                    case "ed448":
                        algorithm = idEd448;
                        break;
                }
                break;
            case "ecdh-es":
                switch (alg.namedCurve.toLowerCase()) {
                    case "x25519":
                        algorithm = idX25519;
                        break;
                    case "x448":
                        algorithm = idX448;
                        break;
                }
        }
        if (algorithm) {
            return new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.AlgorithmIdentifier({
                algorithm,
            });
        }
        return null;
    }
    toWebAlgorithm(alg) {
        switch (alg.algorithm) {
            case idEd25519:
                return { name: "Ed25519" };
            case idEd448:
                return { name: "EdDSA", namedCurve: "Ed448" };
            case idX25519:
                return { name: "X25519" };
            case idX448:
                return { name: "ECDH-ES", namedCurve: "X448" };
        }
        return null;
    }
};
EdAlgorithm = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([
    (0,tsyringe__WEBPACK_IMPORTED_MODULE_7__.injectable)()
], EdAlgorithm);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAlgorithm, EdAlgorithm);

class Pkcs10CertificateRequest extends PemData {
    constructor(param) {
        if (PemData.isAsnEncoded(param)) {
            super(param, _peculiar_asn1_csr__WEBPACK_IMPORTED_MODULE_9__.CertificationRequest);
        }
        else {
            super(param);
        }
        this.tag = PemConverter.CertificateRequestTag;
    }
    onInit(asn) {
        this.tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asn.certificationRequestInfo);
        this.publicKey = new PublicKey(asn.certificationRequestInfo.subjectPKInfo);
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.signature = asn.signature;
        this.attributes = asn.certificationRequestInfo.attributes
            .map(o => AttributeFactory.create(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o)));
        const extensions = this.getAttribute(_peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_extensionRequest);
        this.extensions = [];
        if (extensions instanceof ExtensionsAttribute) {
            this.extensions = extensions.items;
        }
        this.subjectName = new Name(asn.certificationRequestInfo.subject);
        this.subject = this.subjectName.toString();
    }
    getAttribute(type) {
        for (const attr of this.attributes) {
            if (attr.type === type) {
                return attr;
            }
        }
        return null;
    }
    getAttributes(type) {
        return this.attributes.filter(o => o.type === type);
    }
    getExtension(type) {
        for (const ext of this.extensions) {
            if (ext.type === type) {
                return ext;
            }
        }
        return null;
    }
    getExtensions(type) {
        return this.extensions.filter(o => o.type === type);
    }
    async verify(crypto = cryptoProvider.get()) {
        const algorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
        const publicKey = await this.publicKey.export(algorithm, ["verify"], crypto);
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
            signature = signatureFormatter.toWebSignature(algorithm, this.signature);
            if (signature) {
                break;
            }
        }
        if (!signature) {
            throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
        }
        const ok = await crypto.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
        return ok;
    }
    toTextObject() {
        const obj = this.toTextObjectEmpty();
        const req = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.rawData, _peculiar_asn1_csr__WEBPACK_IMPORTED_MODULE_9__.CertificationRequest);
        const tbs = req.certificationRequestInfo;
        const data = new TextObject("", {
            "Version": `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Version[tbs.version]} (${tbs.version})`,
            "Subject": this.subject,
            "Subject Public Key Info": this.publicKey,
        });
        if (this.attributes.length) {
            const attrs = new TextObject("");
            for (const ext of this.attributes) {
                const attrObj = ext.toTextObject();
                attrs[attrObj[TextObject.NAME]] = attrObj;
            }
            data["Attributes"] = attrs;
        }
        obj["Data"] = data;
        obj["Signature"] = new TextObject("", {
            "Algorithm": TextConverter.serializeAlgorithm(req.signatureAlgorithm),
            "": req.signature,
        });
        return obj;
    }
}
Pkcs10CertificateRequest.NAME = "PKCS#10 Certificate Request";

class Pkcs10CertificateRequestGenerator {
    static async create(params, crypto = cryptoProvider.get()) {
        if (!params.keys.privateKey) {
            throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
        }
        if (!params.keys.publicKey) {
            throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");
        }
        const spki = await crypto.subtle.exportKey("spki", params.keys.publicKey);
        const asnReq = new _peculiar_asn1_csr__WEBPACK_IMPORTED_MODULE_9__.CertificationRequest({
            certificationRequestInfo: new _peculiar_asn1_csr__WEBPACK_IMPORTED_MODULE_9__.CertificationRequestInfo({
                subjectPKInfo: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(spki, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo),
            }),
        });
        if (params.name) {
            const name = params.name instanceof Name
                ? params.name
                : new Name(params.name);
            asnReq.certificationRequestInfo.subject = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(name.toArrayBuffer(), _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name);
        }
        if (params.attributes) {
            for (const o of params.attributes) {
                asnReq.certificationRequestInfo.attributes.push(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Attribute));
            }
        }
        if (params.extensions && params.extensions.length) {
            const attr = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Attribute({ type: _peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_extensionRequest });
            const extensions = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extensions();
            for (const o of params.extensions) {
                extensions.push(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension));
            }
            attr.values.push(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(extensions));
            asnReq.certificationRequestInfo.attributes.push(attr);
        }
        const signingAlgorithm = { ...params.signingAlgorithm, ...params.keys.privateKey.algorithm };
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        asnReq.signatureAlgorithm = algProv.toAsnAlgorithm(signingAlgorithm);
        const tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnReq.certificationRequestInfo);
        const signature = await crypto.subtle.sign(signingAlgorithm, params.keys.privateKey, tbs);
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
            asnSignature = signatureFormatter.toAsnSignature(signingAlgorithm, signature);
            if (asnSignature) {
                break;
            }
        }
        if (!asnSignature) {
            throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
        }
        asnReq.signature = asnSignature;
        return new Pkcs10CertificateRequest(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnReq));
    }
}

class X509Certificate extends PemData {
    constructor(param) {
        if (PemData.isAsnEncoded(param)) {
            super(param, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Certificate);
        }
        else {
            super(param);
        }
        this.tag = PemConverter.CertificateTag;
    }
    onInit(asn) {
        const tbs = asn.tbsCertificate;
        this.tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(tbs);
        let serialNumberBytes = new Uint8Array(tbs.serialNumber);
        if (serialNumberBytes.length > 1 && serialNumberBytes[0] === 0x00 && serialNumberBytes[1] > 0x7F) {
            serialNumberBytes = serialNumberBytes.slice(1);
        }
        this.serialNumber = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(serialNumberBytes);
        this.subjectName = new Name(tbs.subject);
        this.subject = new Name(tbs.subject).toString();
        this.issuerName = new Name(tbs.issuer);
        this.issuer = this.issuerName.toString();
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.signature = asn.signatureValue;
        const notBefore = tbs.validity.notBefore.utcTime || tbs.validity.notBefore.generalTime;
        if (!notBefore) {
            throw new Error("Cannot get 'notBefore' value");
        }
        this.notBefore = notBefore;
        const notAfter = tbs.validity.notAfter.utcTime || tbs.validity.notAfter.generalTime;
        if (!notAfter) {
            throw new Error("Cannot get 'notAfter' value");
        }
        this.notAfter = notAfter;
        this.extensions = [];
        if (tbs.extensions) {
            this.extensions = tbs.extensions.map(o => ExtensionFactory.create(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o)));
        }
        this.publicKey = new PublicKey(tbs.subjectPublicKeyInfo);
    }
    getExtension(type) {
        for (const ext of this.extensions) {
            if (typeof type === "string") {
                if (ext.type === type) {
                    return ext;
                }
            }
            else {
                if (ext instanceof type) {
                    return ext;
                }
            }
        }
        return null;
    }
    getExtensions(type) {
        return this.extensions.filter(o => {
            if (typeof type === "string") {
                return o.type === type;
            }
            else {
                return o instanceof type;
            }
        });
    }
    async verify(params = {}, crypto = cryptoProvider.get()) {
        let keyAlgorithm;
        let publicKey;
        const paramsKey = params.publicKey;
        try {
            if (!paramsKey) {
                keyAlgorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
                publicKey = await this.publicKey.export(keyAlgorithm, ["verify"], crypto);
            }
            else if ("publicKey" in paramsKey) {
                keyAlgorithm = { ...paramsKey.publicKey.algorithm, ...this.signatureAlgorithm };
                publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"], crypto);
            }
            else if (paramsKey instanceof PublicKey) {
                keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
                publicKey = await paramsKey.export(keyAlgorithm, ["verify"], crypto);
            }
            else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(paramsKey)) {
                const key = new PublicKey(paramsKey);
                keyAlgorithm = { ...key.algorithm, ...this.signatureAlgorithm };
                publicKey = await key.export(keyAlgorithm, ["verify"], crypto);
            }
            else {
                keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
                publicKey = paramsKey;
            }
        }
        catch (_e) {
            return false;
        }
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
            signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
            if (signature) {
                break;
            }
        }
        if (!signature) {
            throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        const ok = await crypto.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
        if (params.signatureOnly) {
            return ok;
        }
        else {
            const date = params.date || new Date();
            const time = date.getTime();
            return ok && this.notBefore.getTime() < time && time < this.notAfter.getTime();
        }
    }
    async getThumbprint(...args) {
        let crypto;
        let algorithm = "SHA-1";
        if (args[0]) {
            if (!args[0].subtle) {
                algorithm = args[0] || algorithm;
                crypto = args[1];
            }
            else {
                crypto = args[0];
            }
        }
        crypto !== null && crypto !== void 0 ? crypto : (crypto = cryptoProvider.get());
        return await crypto.subtle.digest(algorithm, this.rawData);
    }
    async isSelfSigned(crypto = cryptoProvider.get()) {
        return this.subject === this.issuer && await this.verify({ signatureOnly: true }, crypto);
    }
    toTextObject() {
        const obj = this.toTextObjectEmpty();
        const cert = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Certificate);
        const tbs = cert.tbsCertificate;
        const data = new TextObject("", {
            "Version": `${_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Version[tbs.version]} (${tbs.version})`,
            "Serial Number": tbs.serialNumber,
            "Signature Algorithm": TextConverter.serializeAlgorithm(tbs.signature),
            "Issuer": this.issuer,
            "Validity": new TextObject("", {
                "Not Before": tbs.validity.notBefore.getTime(),
                "Not After": tbs.validity.notAfter.getTime(),
            }),
            "Subject": this.subject,
            "Subject Public Key Info": this.publicKey,
        });
        if (tbs.issuerUniqueID) {
            data["Issuer Unique ID"] = tbs.issuerUniqueID;
        }
        if (tbs.subjectUniqueID) {
            data["Subject Unique ID"] = tbs.subjectUniqueID;
        }
        if (this.extensions.length) {
            const extensions = new TextObject("");
            for (const ext of this.extensions) {
                const extObj = ext.toTextObject();
                extensions[extObj[TextObject.NAME]] = extObj;
            }
            data["Extensions"] = extensions;
        }
        obj["Data"] = data;
        obj["Signature"] = new TextObject("", {
            "Algorithm": TextConverter.serializeAlgorithm(cert.signatureAlgorithm),
            "": cert.signatureValue,
        });
        return obj;
    }
}
X509Certificate.NAME = "Certificate";

class X509Certificates extends Array {
    constructor(param) {
        super();
        if (PemData.isAsnEncoded(param)) {
            this.import(param);
        }
        else if (param instanceof X509Certificate) {
            this.push(param);
        }
        else if (Array.isArray(param)) {
            for (const item of param) {
                this.push(item);
            }
        }
    }
    export(format) {
        const signedData = new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.SignedData();
        signedData.version = 1;
        signedData.encapContentInfo.eContentType = _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.id_data;
        signedData.encapContentInfo.eContent = new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.EncapsulatedContent({
            single: new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(),
        });
        signedData.certificates = new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.CertificateSet(this.map(o => new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.CertificateChoices({
            certificate: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Certificate)
        })));
        const cms = new _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.ContentInfo({
            contentType: _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.id_signedData,
            content: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(signedData),
        });
        const raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(cms);
        if (format === "raw") {
            return raw;
        }
        return this.toString(format);
    }
    import(data) {
        const raw = PemData.toArrayBuffer(data);
        const cms = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(raw, _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.ContentInfo);
        if (cms.contentType !== _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.id_signedData) {
            throw new TypeError("Cannot parse CMS package. Incoming data is not a SignedData object.");
        }
        const signedData = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(cms.content, _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.SignedData);
        this.clear();
        for (const item of signedData.certificates || []) {
            if (item.certificate) {
                this.push(new X509Certificate(item.certificate));
            }
        }
    }
    clear() {
        while (this.pop()) {
        }
    }
    toString(format = "pem") {
        const raw = this.export("raw");
        switch (format) {
            case "pem":
                return PemConverter.encode(raw, "CMS");
            case "pem-chain":
                return this
                    .map(o => o.toString("pem"))
                    .join("\n");
            case "asn":
                return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.toString(raw);
            case "hex":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(raw);
            case "base64":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBase64(raw);
            case "base64url":
                return pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToBase64Url(raw);
            case "text":
                return TextConverter.serialize(this.toTextObject());
            default:
                throw TypeError("Argument 'format' is unsupported value");
        }
    }
    toTextObject() {
        const contentInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(this.export("raw"), _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.ContentInfo);
        const signedData = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(contentInfo.content, _peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.SignedData);
        const obj = new TextObject("X509Certificates", {
            "Content Type": OidSerializer.toString(contentInfo.contentType),
            "Content": new TextObject("", {
                "Version": `${_peculiar_asn1_cms__WEBPACK_IMPORTED_MODULE_4__.CMSVersion[signedData.version]} (${signedData.version})`,
                "Certificates": new TextObject("", { "Certificate": this.map(o => o.toTextObject()) }),
            }),
        });
        return obj;
    }
}

class X509ChainBuilder {
    constructor(params = {}) {
        this.certificates = [];
        if (params.certificates) {
            this.certificates = params.certificates;
        }
    }
    async build(cert, crypto = cryptoProvider.get()) {
        const chain = new X509Certificates(cert);
        let current = cert;
        while (current = await this.findIssuer(current, crypto)) {
            const thumbprint = await current.getThumbprint(crypto);
            for (const item of chain) {
                const thumbprint2 = await item.getThumbprint(crypto);
                if ((0,pvtsutils__WEBPACK_IMPORTED_MODULE_3__.isEqual)(thumbprint, thumbprint2)) {
                    throw new Error("Cannot build a certificate chain. Circular dependency.");
                }
            }
            chain.push(current);
        }
        return chain;
    }
    async findIssuer(cert, crypto = cryptoProvider.get()) {
        if (!await cert.isSelfSigned(crypto)) {
            const akiExt = cert.getExtension(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_authorityKeyIdentifier);
            for (const item of this.certificates) {
                if (item.subject !== cert.issuer) {
                    continue;
                }
                if (akiExt) {
                    if (akiExt.keyId) {
                        const skiExt = item.getExtension(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectKeyIdentifier);
                        if (skiExt && skiExt.keyId !== akiExt.keyId) {
                            continue;
                        }
                    }
                    else if (akiExt.certId) {
                        const sanExt = item.getExtension(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectAltName);
                        if (sanExt &&
                            !(akiExt.certId.serialNumber === item.serialNumber && (0,pvtsutils__WEBPACK_IMPORTED_MODULE_3__.isEqual)(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(akiExt.certId.name), _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(sanExt)))) {
                            continue;
                        }
                    }
                }
                try {
                    const algorithm = { ...item.publicKey.algorithm, ...cert.signatureAlgorithm };
                    const publicKey = await item.publicKey.export(algorithm, ["verify"], crypto);
                    const ok = await cert.verify({ publicKey, signatureOnly: true }, crypto);
                    if (!ok) {
                        continue;
                    }
                }
                catch (_e) {
                    continue;
                }
                return item;
            }
        }
        return null;
    }
}

class X509CertificateGenerator {
    static async createSelfSigned(params, crypto = cryptoProvider.get()) {
        if (!params.keys.privateKey) {
            throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
        }
        if (!params.keys.publicKey) {
            throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");
        }
        return this.create({
            serialNumber: params.serialNumber,
            subject: params.name,
            issuer: params.name,
            notBefore: params.notBefore,
            notAfter: params.notAfter,
            publicKey: params.keys.publicKey,
            signingKey: params.keys.privateKey,
            signingAlgorithm: params.signingAlgorithm,
            extensions: params.extensions,
        }, crypto);
    }
    static async create(params, crypto = cryptoProvider.get()) {
        var _a;
        let spki;
        if (params.publicKey instanceof PublicKey) {
            spki = params.publicKey.rawData;
        }
        else if ("publicKey" in params.publicKey) {
            spki = params.publicKey.publicKey.rawData;
        }
        else if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(params.publicKey)) {
            spki = params.publicKey;
        }
        else {
            spki = await crypto.subtle.exportKey("spki", params.publicKey);
        }
        let serialNumber = params.serialNumber
            ? pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toUint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.FromHex(params.serialNumber))
            : crypto.getRandomValues(new Uint8Array(16));
        if (serialNumber[0] > 0x7F) {
            const newSerialNumber = new Uint8Array(serialNumber.length + 1);
            newSerialNumber[0] = 0x00;
            newSerialNumber.set(serialNumber, 1);
            serialNumber = newSerialNumber;
        }
        const notBefore = params.notBefore || new Date();
        const notAfter = params.notAfter || new Date(notBefore.getTime() + 31536000000);
        const asnX509 = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Certificate({
            tbsCertificate: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.TBSCertificate({
                version: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Version.v3,
                serialNumber: serialNumber,
                validity: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Validity({
                    notBefore,
                    notAfter,
                }),
                extensions: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extensions(((_a = params.extensions) === null || _a === void 0 ? void 0 : _a.map(o => _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension))) || []),
                subjectPublicKeyInfo: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(spki, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.SubjectPublicKeyInfo),
            }),
        });
        if (params.subject) {
            const name = params.subject instanceof Name
                ? params.subject
                : new Name(params.subject);
            asnX509.tbsCertificate.subject = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(name.toArrayBuffer(), _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name);
        }
        if (params.issuer) {
            const name = params.issuer instanceof Name
                ? params.issuer
                : new Name(params.issuer);
            asnX509.tbsCertificate.issuer = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(name.toArrayBuffer(), _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name);
        }
        const defaultSigningAlgorithm = {
            hash: "SHA-256",
        };
        const signatureAlgorithm = ("signingKey" in params)
            ? { ...defaultSigningAlgorithm, ...params.signingAlgorithm, ...params.signingKey.algorithm }
            : { ...defaultSigningAlgorithm, ...params.signingAlgorithm };
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        asnX509.tbsCertificate.signature = asnX509.signatureAlgorithm = algProv.toAsnAlgorithm(signatureAlgorithm);
        const tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnX509.tbsCertificate);
        const signatureValue = ("signingKey" in params)
            ? await crypto.subtle.sign(signatureAlgorithm, params.signingKey, tbs)
            : params.signature;
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
            asnSignature = signatureFormatter.toAsnSignature(signatureAlgorithm, signatureValue);
            if (asnSignature) {
                break;
            }
        }
        if (!asnSignature) {
            throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        asnX509.signatureValue = asnSignature;
        return new X509Certificate(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnX509));
    }
}

var X509CrlReason;
(function (X509CrlReason) {
    X509CrlReason[X509CrlReason["unspecified"] = 0] = "unspecified";
    X509CrlReason[X509CrlReason["keyCompromise"] = 1] = "keyCompromise";
    X509CrlReason[X509CrlReason["cACompromise"] = 2] = "cACompromise";
    X509CrlReason[X509CrlReason["affiliationChanged"] = 3] = "affiliationChanged";
    X509CrlReason[X509CrlReason["superseded"] = 4] = "superseded";
    X509CrlReason[X509CrlReason["cessationOfOperation"] = 5] = "cessationOfOperation";
    X509CrlReason[X509CrlReason["certificateHold"] = 6] = "certificateHold";
    X509CrlReason[X509CrlReason["removeFromCRL"] = 8] = "removeFromCRL";
    X509CrlReason[X509CrlReason["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
    X509CrlReason[X509CrlReason["aACompromise"] = 10] = "aACompromise";
})(X509CrlReason || (X509CrlReason = {}));
class X509CrlEntry extends AsnData {
    constructor(...args) {
        let raw;
        if (pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.isBufferSource(args[0])) {
            raw = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.BufferSourceConverter.toArrayBuffer(args[0]);
        }
        else {
            raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.RevokedCertificate({
                userCertificate: args[0],
                revocationDate: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Time(args[1]),
                crlEntryExtensions: args[2],
            }));
        }
        super(raw, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.RevokedCertificate);
    }
    onInit(asn) {
        this.serialNumber = pvtsutils__WEBPACK_IMPORTED_MODULE_3__.Convert.ToHex(asn.userCertificate);
        this.revocationDate = asn.revocationDate.getTime();
        this.extensions = [];
        if (asn.crlEntryExtensions) {
            this.extensions = asn.crlEntryExtensions.map((o) => {
                const extension = ExtensionFactory.create(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o));
                switch (extension.type) {
                    case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_cRLReasons:
                        this.reason = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(extension.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CRLReason).reason;
                        break;
                    case _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_invalidityDate:
                        this.invalidity = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(extension.value, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.InvalidityDate).value;
                        break;
                }
                return extension;
            });
        }
    }
}

class X509Crl extends PemData {
    constructor(param) {
        if (PemData.isAsnEncoded(param)) {
            super(param, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CertificateList);
        }
        else {
            super(param);
        }
        this.tag = PemConverter.CrlTag;
    }
    onInit(asn) {
        var _a, _b;
        const tbs = asn.tbsCertList;
        this.tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(tbs);
        this.version = tbs.version;
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.tbsCertListSignatureAlgorithm = tbs.signature;
        this.certListSignatureAlgorithm = asn.signatureAlgorithm;
        this.signature = asn.signature;
        this.issuerName = new Name(tbs.issuer);
        this.issuer = this.issuerName.toString();
        const thisUpdate = tbs.thisUpdate.getTime();
        if (!thisUpdate) {
            throw new Error("Cannot get 'thisUpdate' value");
        }
        this.thisUpdate = thisUpdate;
        const nextUpdate = (_a = tbs.nextUpdate) === null || _a === void 0 ? void 0 : _a.getTime();
        this.nextUpdate = nextUpdate;
        this.entries = ((_b = tbs.revokedCertificates) === null || _b === void 0 ? void 0 : _b.map(o => new X509CrlEntry(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o)))) || [];
        this.extensions = [];
        if (tbs.crlExtensions) {
            this.extensions = tbs.crlExtensions.map((o) => ExtensionFactory.create(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(o)));
        }
    }
    getExtension(type) {
        for (const ext of this.extensions) {
            if (typeof type === "string") {
                if (ext.type === type) {
                    return ext;
                }
            }
            else {
                if (ext instanceof type) {
                    return ext;
                }
            }
        }
        return null;
    }
    getExtensions(type) {
        return this.extensions.filter((o) => {
            if (typeof type === "string") {
                return o.type === type;
            }
            else {
                return o instanceof type;
            }
        });
    }
    async verify(params, crypto = cryptoProvider.get()) {
        if (!this.certListSignatureAlgorithm.isEqual(this.tbsCertListSignatureAlgorithm)) {
            throw new Error("algorithm identifier in the sequence tbsCertList and CertificateList mismatch");
        }
        let keyAlgorithm;
        let publicKey;
        const paramsKey = params.publicKey;
        try {
            if (paramsKey instanceof X509Certificate) {
                keyAlgorithm = {
                    ...paramsKey.publicKey.algorithm,
                    ...paramsKey.signatureAlgorithm,
                };
                publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"]);
            }
            else if (paramsKey instanceof PublicKey) {
                keyAlgorithm = { ...paramsKey.algorithm, ...this.signature };
                publicKey = await paramsKey.export(keyAlgorithm, ["verify"]);
            }
            else {
                keyAlgorithm = { ...paramsKey.algorithm, ...this.signature };
                publicKey = paramsKey;
            }
        }
        catch (_e) {
            return false;
        }
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
            signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
            if (signature) {
                break;
            }
        }
        if (!signature) {
            throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        return await crypto.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
    }
    async getThumbprint(...args) {
        let crypto;
        let algorithm = "SHA-1";
        if (args[0]) {
            if (!args[0].subtle) {
                algorithm = args[0] || algorithm;
                crypto = args[1];
            }
            else {
                crypto = args[0];
            }
        }
        crypto !== null && crypto !== void 0 ? crypto : (crypto = cryptoProvider.get());
        return await crypto.subtle.digest(algorithm, this.rawData);
    }
    findRevoked(certOrSerialNumber) {
        const serialNumber = typeof certOrSerialNumber === "string" ? certOrSerialNumber : certOrSerialNumber.serialNumber;
        for (const entry of this.entries) {
            if (entry.serialNumber === serialNumber) {
                return entry;
            }
        }
        return null;
    }
}

class X509CrlGenerator {
    static async create(params, crypto = cryptoProvider.get()) {
        var _a;
        const name = params.issuer instanceof Name
            ? params.issuer
            : new Name(params.issuer);
        const asnX509Crl = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CertificateList({
            tbsCertList: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.TBSCertList({
                version: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Version.v2,
                issuer: _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(name.toArrayBuffer(), _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name),
                thisUpdate: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Time(params.thisUpdate || new Date()),
            }),
        });
        if (params.nextUpdate) {
            asnX509Crl.tbsCertList.nextUpdate = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Time(params.nextUpdate);
        }
        if (params.extensions && params.extensions.length) {
            asnX509Crl.tbsCertList.crlExtensions = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extensions(params.extensions.map(o => _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension)) || []);
        }
        if (params.entries && params.entries.length) {
            asnX509Crl.tbsCertList.revokedCertificates = [];
            for (const entry of params.entries) {
                const userCertificate = PemData.toArrayBuffer(entry.serialNumber);
                const index = asnX509Crl.tbsCertList.revokedCertificates.findIndex(cert => (0,pvtsutils__WEBPACK_IMPORTED_MODULE_3__.isEqual)(cert.userCertificate, userCertificate));
                if (index > -1) {
                    throw new Error(`Certificate serial number ${entry.serialNumber} already exists in tbsCertList`);
                }
                const revokedCert = new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.RevokedCertificate({
                    userCertificate: userCertificate,
                    revocationDate: new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Time(entry.revocationDate || new Date())
                });
                if ("extensions" in entry && ((_a = entry.extensions) === null || _a === void 0 ? void 0 : _a.length)) {
                    revokedCert.crlEntryExtensions = entry.extensions.map(o => _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(o.rawData, _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension));
                }
                else {
                    revokedCert.crlEntryExtensions = [];
                }
                if (!(entry instanceof X509CrlEntry)) {
                    if (entry.reason) {
                        revokedCert.crlEntryExtensions.push(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension({
                            extnID: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_cRLReasons,
                            critical: false,
                            extnValue: new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.CRLReason(entry.reason))),
                        }));
                    }
                    if (entry.invalidity) {
                        revokedCert.crlEntryExtensions.push(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension({
                            extnID: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_invalidityDate,
                            critical: false,
                            extnValue: new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.InvalidityDate(entry.invalidity))),
                        }));
                    }
                    if (entry.issuer) {
                        const name = params.issuer instanceof Name
                            ? params.issuer
                            : new Name(params.issuer);
                        revokedCert.crlEntryExtensions.push(new _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Extension({
                            extnID: _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_certificateIssuer,
                            critical: false,
                            extnValue: new _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.OctetString(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.parse(name.toArrayBuffer(), _peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.Name))),
                        }));
                    }
                }
                asnX509Crl.tbsCertList.revokedCertificates.push(revokedCert);
            }
        }
        const signingAlgorithm = { ...params.signingAlgorithm, ...params.signingKey.algorithm };
        const algProv = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolve(diAlgorithmProvider);
        asnX509Crl.tbsCertList.signature = asnX509Crl.signatureAlgorithm = algProv.toAsnAlgorithm(signingAlgorithm);
        const tbs = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnX509Crl.tbsCertList);
        const signature = await crypto.subtle.sign(signingAlgorithm, params.signingKey, tbs);
        const signatureFormatters = tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
            asnSignature = signatureFormatter.toAsnSignature(signingAlgorithm, signature);
            if (asnSignature) {
                break;
            }
        }
        if (!asnSignature) {
            throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        asnX509Crl.signature = asnSignature;
        return new X509Crl(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_1__.AsnConvert.serialize(asnX509Crl));
    }
}

ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_basicConstraints, BasicConstraintsExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_extKeyUsage, ExtendedKeyUsageExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_keyUsage, KeyUsagesExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectKeyIdentifier, SubjectKeyIdentifierExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_authorityKeyIdentifier, AuthorityKeyIdentifierExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_subjectAltName, SubjectAlternativeNameExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_ce_cRLDistributionPoints, CRLDistributionPointsExtension);
ExtensionFactory.register(_peculiar_asn1_x509__WEBPACK_IMPORTED_MODULE_2__.id_pe_authorityInfoAccess, AuthorityInfoAccessExtension);
AttributeFactory.register(_peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_challengePassword, ChallengePasswordAttribute);
AttributeFactory.register(_peculiar_asn1_pkcs9__WEBPACK_IMPORTED_MODULE_8__.id_pkcs9_at_extensionRequest, ExtensionsAttribute);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAsnSignatureFormatter, AsnDefaultSignatureFormatter);
tsyringe__WEBPACK_IMPORTED_MODULE_7__.container.registerSingleton(diAsnSignatureFormatter, AsnEcSignatureFormatter);
AsnEcSignatureFormatter.namedCurveSize.set("P-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("K-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("P-384", 48);
AsnEcSignatureFormatter.namedCurveSize.set("P-521", 66);




/***/ }),

/***/ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

Object.defineProperty(exports, "__esModule", { value: true });
exports.DearmorAndDesigncryptStream = exports.SigncryptAndArmorStream = exports.dearmorAndDesigncrypt = exports.signcryptAndArmor = exports.verifyDetachedArmored = exports.signDetachedAndArmor = exports.DearmorAndVerifyStream = exports.SignAndArmorStream = exports.verifyArmored = exports.signAndArmor = exports.DearmorAndDecryptStream = exports.EncryptAndArmorStream = exports.dearmorAndDecrypt = exports.encryptAndArmor = exports.SymmetricKeyRecipient = exports.DesigncryptStream = exports.designcrypt = exports.SigncryptStream = exports.signcrypt = exports.verifyDetached = exports.signDetached = exports.VerifyStream = exports.verify = exports.SignStream = exports.sign = exports.DecryptStream = exports.decrypt = exports.EncryptStream = exports.encrypt = exports.MessageType = exports.DearmorStream = exports.dearmor = exports.ArmorStream = exports.armor = void 0;
var armor_1 = require("./armor");
Object.defineProperty(exports, "armor", { enumerable: true, get: function () { return armor_1.armor; } });
Object.defineProperty(exports, "ArmorStream", { enumerable: true, get: function () { return armor_1.ArmorStream; } });
Object.defineProperty(exports, "dearmor", { enumerable: true, get: function () { return armor_1.dearmor; } });
Object.defineProperty(exports, "DearmorStream", { enumerable: true, get: function () { return armor_1.DearmorStream; } });
var message_header_1 = require("./message-header");
Object.defineProperty(exports, "MessageType", { enumerable: true, get: function () { return message_header_1.MessageType; } });
var encryption_1 = require("./encryption");
Object.defineProperty(exports, "encrypt", { enumerable: true, get: function () { return encryption_1.encrypt; } });
Object.defineProperty(exports, "EncryptStream", { enumerable: true, get: function () { return encryption_1.EncryptStream; } });
Object.defineProperty(exports, "decrypt", { enumerable: true, get: function () { return encryption_1.decrypt; } });
Object.defineProperty(exports, "DecryptStream", { enumerable: true, get: function () { return encryption_1.DecryptStream; } });
var signing_1 = require("./signing");
Object.defineProperty(exports, "sign", { enumerable: true, get: function () { return signing_1.sign; } });
Object.defineProperty(exports, "SignStream", { enumerable: true, get: function () { return signing_1.SignStream; } });
Object.defineProperty(exports, "verify", { enumerable: true, get: function () { return signing_1.verify; } });
Object.defineProperty(exports, "VerifyStream", { enumerable: true, get: function () { return signing_1.VerifyStream; } });
Object.defineProperty(exports, "signDetached", { enumerable: true, get: function () { return signing_1.signDetached; } });
Object.defineProperty(exports, "verifyDetached", { enumerable: true, get: function () { return signing_1.verifyDetached; } });
var signcryption_1 = require("./signcryption");
Object.defineProperty(exports, "signcrypt", { enumerable: true, get: function () { return signcryption_1.signcrypt; } });
Object.defineProperty(exports, "SigncryptStream", { enumerable: true, get: function () { return signcryption_1.SigncryptStream; } });
Object.defineProperty(exports, "designcrypt", { enumerable: true, get: function () { return signcryption_1.designcrypt; } });
Object.defineProperty(exports, "DesigncryptStream", { enumerable: true, get: function () { return signcryption_1.DesigncryptStream; } });
var recipient_1 = require("./signcryption/recipient");
Object.defineProperty(exports, "SymmetricKeyRecipient", { enumerable: true, get: function () { return recipient_1.SymmetricKeyRecipient; } });
var with_armor_1 = require("./with-armor");
Object.defineProperty(exports, "encryptAndArmor", { enumerable: true, get: function () { return with_armor_1.encryptAndArmor; } });
Object.defineProperty(exports, "dearmorAndDecrypt", { enumerable: true, get: function () { return with_armor_1.dearmorAndDecrypt; } });
Object.defineProperty(exports, "EncryptAndArmorStream", { enumerable: true, get: function () { return with_armor_1.EncryptAndArmorStream; } });
Object.defineProperty(exports, "DearmorAndDecryptStream", { enumerable: true, get: function () { return with_armor_1.DearmorAndDecryptStream; } });
Object.defineProperty(exports, "signAndArmor", { enumerable: true, get: function () { return with_armor_1.signAndArmor; } });
Object.defineProperty(exports, "verifyArmored", { enumerable: true, get: function () { return with_armor_1.verifyArmored; } });
Object.defineProperty(exports, "SignAndArmorStream", { enumerable: true, get: function () { return with_armor_1.SignAndArmorStream; } });
Object.defineProperty(exports, "DearmorAndVerifyStream", { enumerable: true, get: function () { return with_armor_1.DearmorAndVerifyStream; } });
Object.defineProperty(exports, "signDetachedAndArmor", { enumerable: true, get: function () { return with_armor_1.signDetachedAndArmor; } });
Object.defineProperty(exports, "verifyDetachedArmored", { enumerable: true, get: function () { return with_armor_1.verifyDetachedArmored; } });
Object.defineProperty(exports, "signcryptAndArmor", { enumerable: true, get: function () { return with_armor_1.signcryptAndArmor; } });
Object.defineProperty(exports, "dearmorAndDesigncrypt", { enumerable: true, get: function () { return with_armor_1.dearmorAndDesigncrypt; } });
Object.defineProperty(exports, "SigncryptAndArmorStream", { enumerable: true, get: function () { return with_armor_1.SigncryptAndArmorStream; } });
Object.defineProperty(exports, "DearmorAndDesigncryptStream", { enumerable: true, get: function () { return with_armor_1.DearmorAndDesigncryptStream; } });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");

asn1.define = (__webpack_require__(/*! ./asn1/api */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/api.js").define);
asn1.base = __webpack_require__(/*! ./asn1/base */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js");
asn1.constants = __webpack_require__(/*! ./asn1/constants */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js");
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/index.js");
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/index.js");


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/api.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/api.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var asn1 = __webpack_require__(/*! ../asn1 */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = (__webpack_require__(/*! vm */ "./node_modules/.pnpm/vm-browserify@1.1.2/node_modules/vm-browserify/index.js").runInThisContext)(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Reporter = (__webpack_require__(/*! ../base */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js").Reporter);
var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var base = exports;

base.Reporter = (__webpack_require__(/*! ./reporter */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/reporter.js").Reporter);
base.DecoderBuffer = (__webpack_require__(/*! ./buffer */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js").DecoderBuffer);
base.EncoderBuffer = (__webpack_require__(/*! ./buffer */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js").EncoderBuffer);
base.Node = __webpack_require__(/*! ./node */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/node.js");


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/node.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/node.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Reporter = (__webpack_require__(/*! ../base */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js").Reporter);
var EncoderBuffer = (__webpack_require__(/*! ../base */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js").EncoderBuffer);
var DecoderBuffer = (__webpack_require__(/*! ../base */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js").DecoderBuffer);
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/der.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var constants = __webpack_require__(/*! ../constants */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js");

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/der.js");


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js");
decoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/pem.js");


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);

var DERDecoder = __webpack_require__(/*! ./der */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js");
encoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/pem.js");


/***/ }),

/***/ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var DEREncoder = __webpack_require__(/*! ./der */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),

/***/ "./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/asn1js@3.0.6/node_modules/asn1js/build/index.es.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Any: () => (/* binding */ Any),
/* harmony export */   BaseBlock: () => (/* binding */ BaseBlock),
/* harmony export */   BaseStringBlock: () => (/* binding */ BaseStringBlock),
/* harmony export */   BitString: () => (/* binding */ BitString),
/* harmony export */   BmpString: () => (/* binding */ BmpString),
/* harmony export */   Boolean: () => (/* binding */ Boolean),
/* harmony export */   CharacterString: () => (/* binding */ CharacterString),
/* harmony export */   Choice: () => (/* binding */ Choice),
/* harmony export */   Constructed: () => (/* binding */ Constructed),
/* harmony export */   DATE: () => (/* binding */ DATE),
/* harmony export */   DateTime: () => (/* binding */ DateTime),
/* harmony export */   Duration: () => (/* binding */ Duration),
/* harmony export */   EndOfContent: () => (/* binding */ EndOfContent),
/* harmony export */   Enumerated: () => (/* binding */ Enumerated),
/* harmony export */   GeneralString: () => (/* binding */ GeneralString),
/* harmony export */   GeneralizedTime: () => (/* binding */ GeneralizedTime),
/* harmony export */   GraphicString: () => (/* binding */ GraphicString),
/* harmony export */   HexBlock: () => (/* binding */ HexBlock),
/* harmony export */   IA5String: () => (/* binding */ IA5String),
/* harmony export */   Integer: () => (/* binding */ Integer),
/* harmony export */   Null: () => (/* binding */ Null),
/* harmony export */   NumericString: () => (/* binding */ NumericString),
/* harmony export */   ObjectIdentifier: () => (/* binding */ ObjectIdentifier),
/* harmony export */   OctetString: () => (/* binding */ OctetString),
/* harmony export */   Primitive: () => (/* binding */ Primitive),
/* harmony export */   PrintableString: () => (/* binding */ PrintableString),
/* harmony export */   RawData: () => (/* binding */ RawData),
/* harmony export */   RelativeObjectIdentifier: () => (/* binding */ RelativeObjectIdentifier),
/* harmony export */   Repeated: () => (/* binding */ Repeated),
/* harmony export */   Sequence: () => (/* binding */ Sequence),
/* harmony export */   Set: () => (/* binding */ Set),
/* harmony export */   TIME: () => (/* binding */ TIME),
/* harmony export */   TeletexString: () => (/* binding */ TeletexString),
/* harmony export */   TimeOfDay: () => (/* binding */ TimeOfDay),
/* harmony export */   UTCTime: () => (/* binding */ UTCTime),
/* harmony export */   UniversalString: () => (/* binding */ UniversalString),
/* harmony export */   Utf8String: () => (/* binding */ Utf8String),
/* harmony export */   ValueBlock: () => (/* binding */ ValueBlock),
/* harmony export */   VideotexString: () => (/* binding */ VideotexString),
/* harmony export */   ViewWriter: () => (/* binding */ ViewWriter),
/* harmony export */   VisibleString: () => (/* binding */ VisibleString),
/* harmony export */   compareSchema: () => (/* binding */ compareSchema),
/* harmony export */   fromBER: () => (/* binding */ fromBER),
/* harmony export */   verifySchema: () => (/* binding */ verifySchema)
/* harmony export */ });
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pvtsutils */ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/.pnpm/pvutils@1.1.3/node_modules/pvutils/build/utils.es.js");
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */




function assertBigInt() {
    if (typeof BigInt === "undefined") {
        throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
}
function concat(buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        outputLength += buffer.byteLength;
    }
    const retView = new Uint8Array(outputLength);
    for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof Uint8Array)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}

class ViewWriter {
    constructor() {
        this.items = [];
    }
    write(buf) {
        this.items.push(buf);
    }
    final() {
        return concat(this.items);
    }
}

const powers2 = [new Uint8Array([1])];
const digitsString = "0123456789";
const NAME = "name";
const VALUE_HEX_VIEW = "valueHexView";
const IS_HEX_ONLY = "isHexOnly";
const ID_BLOCK = "idBlock";
const TAG_CLASS = "tagClass";
const TAG_NUMBER = "tagNumber";
const IS_CONSTRUCTED = "isConstructed";
const FROM_BER = "fromBER";
const TO_BER = "toBER";
const LOCAL = "local";
const EMPTY_STRING = "";
const EMPTY_BUFFER = new ArrayBuffer(0);
const EMPTY_VIEW = new Uint8Array(0);
const END_OF_CONTENT_NAME = "EndOfContent";
const OCTET_STRING_NAME = "OCTET STRING";
const BIT_STRING_NAME = "BIT STRING";

function HexBlock(BaseClass) {
    var _a;
    return _a = class Some extends BaseClass {
            get valueHex() {
                return this.valueHexView.slice().buffer;
            }
            set valueHex(value) {
                this.valueHexView = new Uint8Array(value);
            }
            constructor(...args) {
                var _b;
                super(...args);
                const params = args[0] || {};
                this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== void 0 ? _b : false;
                this.valueHexView = params.valueHex ? pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
            }
            fromBER(inputBuffer, inputOffset, inputLength) {
                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
                if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                    return -1;
                }
                const endLength = inputOffset + inputLength;
                this.valueHexView = view.subarray(inputOffset, endLength);
                if (!this.valueHexView.length) {
                    this.warnings.push("Zero buffer length");
                    return inputOffset;
                }
                this.blockLength = inputLength;
                return endLength;
            }
            toBER(sizeOnly = false) {
                if (!this.isHexOnly) {
                    this.error = "Flag 'isHexOnly' is not set, abort";
                    return EMPTY_BUFFER;
                }
                if (sizeOnly) {
                    return new ArrayBuffer(this.valueHexView.byteLength);
                }
                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)
                    ? this.valueHexView.buffer
                    : this.valueHexView.slice().buffer;
            }
            toJSON() {
                return {
                    ...super.toJSON(),
                    isHexOnly: this.isHexOnly,
                    valueHex: pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView),
                };
            }
        },
        _a.NAME = "hexBlock",
        _a;
}

class LocalBaseBlock {
    static blockName() {
        return this.NAME;
    }
    get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
    }
    set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
    }
    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {
        this.blockLength = blockLength;
        this.error = error;
        this.warnings = warnings;
        this.valueBeforeDecodeView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(valueBeforeDecode);
    }
    toJSON() {
        return {
            blockName: this.constructor.NAME,
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBeforeDecodeView),
        };
    }
}
LocalBaseBlock.NAME = "baseBlock";

class ValueBlock extends LocalBaseBlock {
    fromBER(_inputBuffer, _inputOffset, _inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
    toBER(_sizeOnly, _writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
}
ValueBlock.NAME = "valueBlock";

class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
    constructor({ idBlock = {} } = {}) {
        var _a, _b, _c, _d;
        super();
        if (idBlock) {
            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
            this.valueHexView = idBlock.valueHex
                ? pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(idBlock.valueHex)
                : EMPTY_VIEW;
            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        }
        else {
            this.tagClass = -1;
            this.tagNumber = -1;
            this.isConstructed = false;
        }
    }
    toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch (this.tagClass) {
            case 1:
                firstOctet |= 0x00;
                break;
            case 2:
                firstOctet |= 0x40;
                break;
            case 3:
                firstOctet |= 0x80;
                break;
            case 4:
                firstOctet |= 0xC0;
                break;
            default:
                this.error = "Unknown tag class";
                return EMPTY_BUFFER;
        }
        if (this.isConstructed)
            firstOctet |= 0x20;
        if (this.tagNumber < 31 && !this.isHexOnly) {
            const retView = new Uint8Array(1);
            if (!sizeOnly) {
                let number = this.tagNumber;
                number &= 0x1F;
                firstOctet |= number;
                retView[0] = firstOctet;
            }
            return retView.buffer;
        }
        if (!this.isHexOnly) {
            const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.tagNumber, 7);
            const encodedView = new Uint8Array(encodedBuf);
            const size = encodedBuf.byteLength;
            const retView = new Uint8Array(size + 1);
            retView[0] = (firstOctet | 0x1F);
            if (!sizeOnly) {
                for (let i = 0; i < (size - 1); i++)
                    retView[i + 1] = encodedView[i] | 0x80;
                retView[size] = encodedView[size - 1];
            }
            return retView.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = (firstOctet | 0x1F);
        if (!sizeOnly) {
            const curView = this.valueHexView;
            for (let i = 0; i < (curView.length - 1); i++)
                retView[i + 1] = curView[i] | 0x80;
            retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        const tagClassMask = intBuffer[0] & 0xC0;
        switch (tagClassMask) {
            case 0x00:
                this.tagClass = (1);
                break;
            case 0x40:
                this.tagClass = (2);
                break;
            case 0x80:
                this.tagClass = (3);
                break;
            case 0xC0:
                this.tagClass = (4);
                break;
            default:
                this.error = "Unknown tag class";
                return -1;
        }
        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 0x1F;
        if (tagNumberMask !== 0x1F) {
            this.tagNumber = (tagNumberMask);
            this.blockLength = 1;
        }
        else {
            let count = 1;
            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
            let tagNumberBufferMaxLength = 255;
            while (intBuffer[count] & 0x80) {
                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                count++;
                if (count >= intBuffer.length) {
                    this.error = "End of input reached before message was fully decoded";
                    return -1;
                }
                if (count === tagNumberBufferMaxLength) {
                    tagNumberBufferMaxLength += 255;
                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
                    for (let i = 0; i < intTagNumberBuffer.length; i++)
                        tempBufferView[i] = intTagNumberBuffer[i];
                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
                }
            }
            this.blockLength = (count + 1);
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            const tempBufferView = new Uint8Array(count);
            for (let i = 0; i < count; i++)
                tempBufferView[i] = intTagNumberBuffer[i];
            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
            intTagNumberBuffer.set(tempBufferView);
            if (this.blockLength <= 9)
                this.tagNumber = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(intTagNumberBuffer, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Tag too long, represented as hex-coded");
            }
        }
        if (((this.tagClass === 1))
            && (this.isConstructed)) {
            switch (this.tagNumber) {
                case 1:
                case 2:
                case 5:
                case 6:
                case 9:
                case 13:
                case 14:
                case 23:
                case 24:
                case 31:
                case 32:
                case 33:
                case 34:
                    this.error = "Constructed encoding used for primitive type";
                    return -1;
            }
        }
        return (inputOffset + this.blockLength);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            tagClass: this.tagClass,
            tagNumber: this.tagNumber,
            isConstructed: this.isConstructed,
        };
    }
}
LocalIdentificationBlock.NAME = "identificationBlock";

class LocalLengthBlock extends LocalBaseBlock {
    constructor({ lenBlock = {} } = {}) {
        var _a, _b, _c;
        super();
        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        if (intBuffer[0] === 0xFF) {
            this.error = "Length block 0xFF is reserved by standard";
            return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 0x80;
        if (this.isIndefiniteForm) {
            this.blockLength = 1;
            return (inputOffset + this.blockLength);
        }
        this.longFormUsed = !!(intBuffer[0] & 0x80);
        if (this.longFormUsed === false) {
            this.length = (intBuffer[0]);
            this.blockLength = 1;
            return (inputOffset + this.blockLength);
        }
        const count = intBuffer[0] & 0x7F;
        if (count > 8) {
            this.error = "Too big integer";
            return -1;
        }
        if ((count + 1) > intBuffer.length) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0x00)
            this.warnings.push("Needlessly long encoded length");
        this.length = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && (this.length <= 127))
            this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return (inputOffset + this.blockLength);
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127)
            this.longFormUsed = true;
        if (this.isIndefiniteForm) {
            retBuf = new ArrayBuffer(1);
            if (sizeOnly === false) {
                retView = new Uint8Array(retBuf);
                retView[0] = 0x80;
            }
            return retBuf;
        }
        if (this.longFormUsed) {
            const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.length, 8);
            if (encodedBuf.byteLength > 127) {
                this.error = "Too big length";
                return (EMPTY_BUFFER);
            }
            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
            if (sizeOnly)
                return retBuf;
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            retView[0] = encodedBuf.byteLength | 0x80;
            for (let i = 0; i < encodedBuf.byteLength; i++)
                retView[i + 1] = encodedView[i];
            return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = this.length;
        }
        return retBuf;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            longFormUsed: this.longFormUsed,
            length: this.length,
        };
    }
}
LocalLengthBlock.NAME = "lengthBlock";

const typeStore = {};

class BaseBlock extends LocalBaseBlock {
    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
        super(parameters);
        this.name = name;
        this.optional = optional;
        if (primitiveSchema) {
            this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm)
            ? inputLength
            : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length)
            this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
            this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
            this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
            prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
            _writer.write(new Uint8Array([0x80]).buffer);
            this.valueBlock.toBER(sizeOnly, _writer);
            _writer.write(new ArrayBuffer(2));
        }
        else {
            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
            this.lenBlock.length = valueBlockBuf.byteLength;
            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
            _writer.write(lenBlockBuf);
            _writer.write(valueBlockBuf);
        }
        if (!writer) {
            return _writer.final();
        }
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            idBlock: this.idBlock.toJSON(),
            lenBlock: this.lenBlock.toJSON(),
            valueBlock: this.valueBlock.toJSON(),
            name: this.name,
            optional: this.optional,
        };
        if (this.primitiveSchema)
            object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
    }
    toString(encoding = "ascii") {
        if (encoding === "ascii") {
            return this.onAsciiEncoding();
        }
        return pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.toBER());
    }
    onAsciiEncoding() {
        const name = this.constructor.NAME;
        const value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
        return `${name} : ${value}`;
    }
    isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof this.constructor)) {
            return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return pvutils__WEBPACK_IMPORTED_MODULE_1__.isEqualBuffer(thisRaw, otherRaw);
    }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
    var _a;
    if (baseBlock instanceof typeStore.Constructed) {
        for (const value of baseBlock.valueBlock.value) {
            if (prepareIndefiniteForm(value)) {
                baseBlock.lenBlock.isIndefiniteForm = true;
            }
        }
    }
    return !!((_a = baseBlock.lenBlock) === null || _a === void 0 ? void 0 : _a.isIndefiniteForm);
}

class BaseStringBlock extends BaseBlock {
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
        super(parameters, stringValueBlockType);
        if (value) {
            this.fromString(value);
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm)
            ? inputLength
            : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length)
            this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
            this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
            this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
    }
}
BaseStringBlock.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
    constructor({ isHexOnly = true, ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = isHexOnly;
    }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";

var _a$w;
class Primitive extends BaseBlock {
    constructor(parameters = {}) {
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
    }
}
_a$w = Primitive;
(() => {
    typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";

function localChangeType(inputObject, newType) {
    if (inputObject instanceof newType) {
        return inputObject;
    }
    const newObject = new newType();
    newObject.idBlock = inputObject.idBlock;
    newObject.lenBlock = inputObject.lenBlock;
    newObject.warnings = inputObject.warnings;
    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
    return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
    const incomingOffset = inputOffset;
    let returnObject = new BaseBlock({}, ValueBlock);
    const baseBlock = new LocalBaseBlock();
    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
        returnObject.error = baseBlock.error;
        return {
            offset: -1,
            result: returnObject,
        };
    }
    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
    if (!intBuffer.length) {
        returnObject.error = "Zero buffer length";
        return {
            offset: -1,
            result: returnObject,
        };
    }
    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.idBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.idBlock.warnings);
    }
    if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
            offset: -1,
            result: returnObject,
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.lenBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.lenBlock.warnings);
    }
    if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
            offset: -1,
            result: returnObject,
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (!returnObject.idBlock.isConstructed
        && returnObject.lenBlock.isIndefiniteForm) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
            offset: -1,
            result: returnObject,
        };
    }
    let newASN1Type = BaseBlock;
    switch (returnObject.idBlock.tagClass) {
        case 1:
            if ((returnObject.idBlock.tagNumber >= 37)
                && (returnObject.idBlock.isHexOnly === false)) {
                returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                return {
                    offset: -1,
                    result: returnObject,
                };
            }
            switch (returnObject.idBlock.tagNumber) {
                case 0:
                    if ((returnObject.idBlock.isConstructed)
                        && (returnObject.lenBlock.length > 0)) {
                        returnObject.error = "Type [UNIVERSAL 0] is reserved";
                        return {
                            offset: -1,
                            result: returnObject,
                        };
                    }
                    newASN1Type = typeStore.EndOfContent;
                    break;
                case 1:
                    newASN1Type = typeStore.Boolean;
                    break;
                case 2:
                    newASN1Type = typeStore.Integer;
                    break;
                case 3:
                    newASN1Type = typeStore.BitString;
                    break;
                case 4:
                    newASN1Type = typeStore.OctetString;
                    break;
                case 5:
                    newASN1Type = typeStore.Null;
                    break;
                case 6:
                    newASN1Type = typeStore.ObjectIdentifier;
                    break;
                case 10:
                    newASN1Type = typeStore.Enumerated;
                    break;
                case 12:
                    newASN1Type = typeStore.Utf8String;
                    break;
                case 13:
                    newASN1Type = typeStore.RelativeObjectIdentifier;
                    break;
                case 14:
                    newASN1Type = typeStore.TIME;
                    break;
                case 15:
                    returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                    return {
                        offset: -1,
                        result: returnObject,
                    };
                case 16:
                    newASN1Type = typeStore.Sequence;
                    break;
                case 17:
                    newASN1Type = typeStore.Set;
                    break;
                case 18:
                    newASN1Type = typeStore.NumericString;
                    break;
                case 19:
                    newASN1Type = typeStore.PrintableString;
                    break;
                case 20:
                    newASN1Type = typeStore.TeletexString;
                    break;
                case 21:
                    newASN1Type = typeStore.VideotexString;
                    break;
                case 22:
                    newASN1Type = typeStore.IA5String;
                    break;
                case 23:
                    newASN1Type = typeStore.UTCTime;
                    break;
                case 24:
                    newASN1Type = typeStore.GeneralizedTime;
                    break;
                case 25:
                    newASN1Type = typeStore.GraphicString;
                    break;
                case 26:
                    newASN1Type = typeStore.VisibleString;
                    break;
                case 27:
                    newASN1Type = typeStore.GeneralString;
                    break;
                case 28:
                    newASN1Type = typeStore.UniversalString;
                    break;
                case 29:
                    newASN1Type = typeStore.CharacterString;
                    break;
                case 30:
                    newASN1Type = typeStore.BmpString;
                    break;
                case 31:
                    newASN1Type = typeStore.DATE;
                    break;
                case 32:
                    newASN1Type = typeStore.TimeOfDay;
                    break;
                case 33:
                    newASN1Type = typeStore.DateTime;
                    break;
                case 34:
                    newASN1Type = typeStore.Duration;
                    break;
                default: {
                    const newObject = returnObject.idBlock.isConstructed
                        ? new typeStore.Constructed()
                        : new typeStore.Primitive();
                    newObject.idBlock = returnObject.idBlock;
                    newObject.lenBlock = returnObject.lenBlock;
                    newObject.warnings = returnObject.warnings;
                    returnObject = newObject;
                }
            }
            break;
        case 2:
        case 3:
        case 4:
        default: {
            newASN1Type = returnObject.idBlock.isConstructed
                ? typeStore.Constructed
                : typeStore.Primitive;
        }
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
        offset: resultOffset,
        result: returnObject,
    };
}
function fromBER(inputBuffer) {
    if (!inputBuffer.byteLength) {
        const result = new BaseBlock({}, ValueBlock);
        result.error = "Input buffer has zero length";
        return {
            offset: -1,
            result,
        };
    }
    return localFromBER(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}

function checkLen(indefiniteLength, length) {
    if (indefiniteLength) {
        return 1;
    }
    return length;
}
class LocalConstructedValueBlock extends ValueBlock {
    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
        }
        let currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
            const returnObject = localFromBER(view, currentOffset, inputLength);
            if (returnObject.offset === -1) {
                this.error = returnObject.result.error;
                this.warnings.concat(returnObject.result.warnings);
                return -1;
            }
            currentOffset = returnObject.offset;
            this.blockLength += returnObject.result.blockLength;
            inputLength -= returnObject.result.blockLength;
            this.value.push(returnObject.result);
            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
                break;
            }
        }
        if (this.isIndefiniteForm) {
            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
                this.value.pop();
            }
            else {
                this.warnings.push("No EndOfContent block encoded");
            }
        }
        return currentOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for (let i = 0; i < this.value.length; i++) {
            this.value[i].toBER(sizeOnly, _writer);
        }
        if (!writer) {
            return _writer.final();
        }
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            value: [],
        };
        for (const value of this.value) {
            object.value.push(value.toJSON());
        }
        return object;
    }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";

var _a$v;
class Constructed extends BaseBlock {
    constructor(parameters = {}) {
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length)
            this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
            this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
            this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value) {
            values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3
            ? `[${this.idBlock.tagNumber}]`
            : this.constructor.NAME;
        return values.length
            ? `${blockName} :\n${values.join("\n")}`
            : `${blockName} :`;
    }
}
_a$v = Constructed;
(() => {
    typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock extends ValueBlock {
    fromBER(inputBuffer, inputOffset, _inputLength) {
        return inputOffset;
    }
    toBER(_sizeOnly) {
        return EMPTY_BUFFER;
    }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";

var _a$u;
class EndOfContent extends BaseBlock {
    constructor(parameters = {}) {
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
    }
}
_a$u = EndOfContent;
(() => {
    typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;

var _a$t;
class Null extends BaseBlock {
    constructor(parameters = {}) {
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0)
            this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length)
            this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
            this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if ((inputOffset + inputLength) > inputBuffer.byteLength) {
            this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
            return -1;
        }
        return (inputOffset + inputLength);
    }
    toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
            const retView = new Uint8Array(retBuf);
            retView[0] = 0x05;
            retView[1] = 0x00;
        }
        if (writer) {
            writer.write(retBuf);
        }
        return retBuf;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME}`;
    }
}
_a$t = Null;
(() => {
    typeStore.Null = _a$t;
})();
Null.NAME = "NULL";

class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
    get value() {
        for (const octet of this.valueHexView) {
            if (octet > 0) {
                return true;
            }
        }
        return false;
    }
    set value(value) {
        this.valueHexView[0] = value ? 0xFF : 0x00;
    }
    constructor({ value, ...parameters } = {}) {
        super(parameters);
        if (parameters.valueHex) {
            this.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(parameters.valueHex);
        }
        else {
            this.valueHexView = new Uint8Array(1);
        }
        if (value) {
            this.value = value;
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1)
            this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        pvutils__WEBPACK_IMPORTED_MODULE_1__.utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return (inputOffset + inputLength);
    }
    toBER() {
        return this.valueHexView.slice();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value,
        };
    }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";

var _a$s;
class Boolean extends BaseBlock {
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    constructor(parameters = {}) {
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
    }
}
_a$s = Boolean;
(() => {
    typeStore.Boolean = _a$s;
})();
Boolean.NAME = "BOOLEAN";

class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.isConstructed = isConstructed;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
            this.isHexOnly = false;
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1)
                return resultOffset;
            for (let i = 0; i < this.value.length; i++) {
                const currentBlockName = this.value[i].constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm)
                        break;
                    else {
                        this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== OCTET_STRING_NAME) {
                    this.error = "OCTET STRING may consists of OCTET STRINGs only";
                    return -1;
                }
            }
        }
        else {
            this.isHexOnly = true;
            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
            this.blockLength = inputLength;
        }
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed)
            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly
            ? new ArrayBuffer(this.valueHexView.byteLength)
            : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isConstructed: this.isConstructed,
        };
    }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";

var _a$r;
class OctetString extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock,
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm,
            },
            ...parameters,
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
            if (this.idBlock.error.length === 0)
                this.blockLength += this.idBlock.blockLength;
            if (this.lenBlock.error.length === 0)
                this.blockLength += this.lenBlock.blockLength;
            return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
            const buf = view.subarray(inputOffset, inputOffset + inputLength);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === inputLength) {
                        this.valueBlock.value = [asn.result];
                    }
                }
            }
            catch {
            }
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
            return Constructed.prototype.onAsciiEncoding.call(this);
        }
        const name = this.constructor.NAME;
        const value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBlock.valueHexView);
        return `${name} : ${value}`;
    }
    getValue() {
        if (!this.idBlock.isConstructed) {
            return this.valueBlock.valueHexView.slice().buffer;
        }
        const array = [];
        for (const content of this.valueBlock.value) {
            if (content instanceof _a$r) {
                array.push(content.valueBlock.valueHexView);
            }
        }
        return pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.concat(array);
    }
}
_a$r = OctetString;
(() => {
    typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;

class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
            return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1)
                return resultOffset;
            for (const value of this.value) {
                const currentBlockName = value.constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm)
                        break;
                    else {
                        this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== BIT_STRING_NAME) {
                    this.error = "BIT STRING may consists of BIT STRINGs only";
                    return -1;
                }
                const valueBlock = value.valueBlock;
                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {
                    this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
                    return -1;
                }
                this.unusedBits = valueBlock.unusedBits;
            }
            return resultOffset;
        }
        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
            this.error = "Unused bits for BitString must be in range 0-7";
            return -1;
        }
        if (!this.unusedBits) {
            const buf = intBuffer.subarray(1);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {
                        this.value = [asn.result];
                    }
                }
            }
            catch {
            }
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return (inputOffset + inputLength);
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed) {
            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
            return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            unusedBits: this.unusedBits,
            isConstructed: this.isConstructed,
        };
    }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";

var _a$q;
class BitString extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock,
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm,
            },
            ...parameters,
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
            return Constructed.prototype.onAsciiEncoding.call(this);
        }
        else {
            const bits = [];
            const valueHex = this.valueBlock.valueHexView;
            for (const byte of valueHex) {
                bits.push(byte.toString(2).padStart(8, "0"));
            }
            const bitsStr = bits.join("");
            const name = this.constructor.NAME;
            const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
            return `${name} : ${value}`;
        }
    }
}
_a$q = BitString;
(() => {
    typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;

var _a$p;
function viewAdd(first, second) {
    const c = new Uint8Array([0]);
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    let firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value = 0;
    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
    let counter = 0;
    for (let i = max; i >= 0; i--, counter++) {
        switch (true) {
            case (counter < secondViewCopy.length):
                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                break;
            default:
                value = firstViewCopy[firstViewCopyLength - counter] + c[0];
        }
        c[0] = value / 10;
        switch (true) {
            case (counter >= firstViewCopy.length):
                firstViewCopy = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
                break;
            default:
                firstViewCopy[firstViewCopyLength - counter] = value % 10;
        }
    }
    if (c[0] > 0)
        firstViewCopy = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(c, firstViewCopy);
    return firstViewCopy;
}
function power2(n) {
    if (n >= powers2.length) {
        for (let p = powers2.length; p <= n; p++) {
            const c = new Uint8Array([0]);
            let digits = (powers2[p - 1]).slice(0);
            for (let i = (digits.length - 1); i >= 0; i--) {
                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
                c[0] = newValue[0] / 10;
                digits[i] = newValue[0] % 10;
            }
            if (c[0] > 0)
                digits = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(c, digits);
            powers2.push(digits);
        }
    }
    return powers2[n];
}
function viewSub(first, second) {
    let b = 0;
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    const firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value;
    let counter = 0;
    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
        switch (true) {
            case (value < 0):
                b = 1;
                firstViewCopy[firstViewCopyLength - counter] = value + 10;
                break;
            default:
                b = 0;
                firstViewCopy[firstViewCopyLength - counter] = value;
        }
    }
    if (b > 0) {
        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {
            value = firstViewCopy[firstViewCopyLength - counter] - b;
            if (value < 0) {
                b = 1;
                firstViewCopy[firstViewCopyLength - counter] = value + 10;
            }
            else {
                b = 0;
                firstViewCopy[firstViewCopyLength - counter] = value;
                break;
            }
        }
    }
    return firstViewCopy.slice();
}
class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
    setValueHex() {
        if (this.valueHexView.length >= 4) {
            this.warnings.push("Too big Integer for decoding, hex only");
            this.isHexOnly = true;
            this._valueDec = 0;
        }
        else {
            this.isHexOnly = false;
            if (this.valueHexView.length > 0) {
                this._valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilDecodeTC.call(this);
            }
        }
    }
    constructor({ value, ...parameters } = {}) {
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) {
            this.setValueHex();
        }
        if (value !== undefined) {
            this.valueDec = value;
        }
    }
    set valueDec(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(pvutils__WEBPACK_IMPORTED_MODULE_1__.utilEncodeTC(v));
    }
    get valueDec() {
        return this._valueDec;
    }
    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1)
            return offset;
        const view = this.valueHexView;
        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {
            this.valueHexView = view.subarray(1);
        }
        else {
            if (expectedLength !== 0) {
                if (view.length < expectedLength) {
                    if ((expectedLength - view.length) > 1)
                        expectedLength = view.length + 1;
                    this.valueHexView = view.subarray(expectedLength - view.length);
                }
            }
        }
        return offset;
    }
    toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch (true) {
            case ((view[0] & 0x80) !== 0):
                {
                    const updatedView = new Uint8Array(this.valueHexView.length + 1);
                    updatedView[0] = 0x00;
                    updatedView.set(view, 1);
                    this.valueHexView = updatedView;
                }
                break;
            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
                {
                    this.valueHexView = this.valueHexView.subarray(1);
                }
                break;
        }
        return this.toBER(sizeOnly);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
            return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
    }
    toBER(sizeOnly) {
        return sizeOnly
            ? new ArrayBuffer(this.valueHexView.length)
            : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec,
        };
    }
    toString() {
        const firstBit = (this.valueHexView.length * 8) - 1;
        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {
            currentByte = asn1View[byteNumber];
            for (let i = 0; i < 8; i++) {
                if ((currentByte & 1) === 1) {
                    switch (bitNumber) {
                        case firstBit:
                            digits = viewSub(power2(bitNumber), digits);
                            result = "-";
                            break;
                        default:
                            digits = viewAdd(digits, power2(bitNumber));
                    }
                }
                bitNumber++;
                currentByte >>= 1;
            }
        }
        for (let i = 0; i < digits.length; i++) {
            if (digits[i])
                flag = true;
            if (flag)
                result += digitsString.charAt(digits[i]);
        }
        if (flag === false)
            result += digitsString.charAt(0);
        return result;
    }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
    Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function (v) {
            this.valueHexView = new Uint8Array(v);
            this.setValueHex();
        },
        get: function () {
            return this.valueHexView.slice().buffer;
        },
    });
})();

var _a$o;
class Integer extends BaseBlock {
    constructor(parameters = {}) {
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
    }
    toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
    }
    static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromHex(hex));
        if (bigIntValue < 0) {
            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
            first[0] |= 0x80;
            const firstInt = BigInt(`0x${pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(first)}`);
            const secondInt = firstInt + bigIntValue;
            const second = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromHex(secondInt.toString(16)));
            second[0] |= 0x80;
            writer.write(second);
        }
        else {
            if (view[0] & 0x80) {
                writer.write(new Uint8Array([0]));
            }
            writer.write(view);
        }
        const res = new _a$o({ valueHex: writer.final() });
        return res;
    }
    convertToDER() {
        const integer = new _a$o({ valueHex: this.valueBlock.valueHexView });
        integer.valueBlock.toDER();
        return integer;
    }
    convertFromDER() {
        return new _a$o({
            valueHex: this.valueBlock.valueHexView[0] === 0
                ? this.valueBlock.valueHexView.subarray(1)
                : this.valueBlock.valueHexView,
        });
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
    }
}
_a$o = Integer;
(() => {
    typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";

var _a$n;
class Enumerated extends Integer {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
    }
}
_a$n = Enumerated;
(() => {
    typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";

class LocalSidValueBlock extends HexBlock(ValueBlock) {
    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
            return inputOffset;
        }
        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00)
                break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++) {
            tempView[i] = this.valueHexView[i];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00)
            this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
            this.valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return (inputOffset + this.blockLength);
    }
    set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while (bits.length % 7) {
            bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly)
                return (new ArrayBuffer(this.valueHexView.byteLength));
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for (let i = 0; i < (this.blockLength - 1); i++)
                retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for (let i = 0; i < len; i++)
                retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView;
    }
    toString() {
        let result = "";
        if (this.isHexOnly)
            result = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView);
        else {
            if (this.isFirstSid) {
                let sidValue = this.valueDec;
                if (this.valueDec <= 39)
                    result = "0.";
                else {
                    if (this.valueDec <= 79) {
                        result = "1.";
                        sidValue -= 40;
                    }
                    else {
                        result = "2.";
                        sidValue -= 80;
                    }
                }
                result += sidValue.toString();
            }
            else
                result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec,
            isFirstSid: this.isFirstSid,
        };
    }
}
LocalSidValueBlock.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
            this.fromString(value);
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
            const sidBlock = new LocalSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            if (this.value.length === 0)
                sidBlock.isFirstSid = true;
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1)
                sid = string.substring(pos1);
            else
                sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            if (flag) {
                const sidBlock = this.value[0];
                let plus = 0;
                switch (sidBlock.valueDec) {
                    case 0:
                        break;
                    case 1:
                        plus = 40;
                        break;
                    case 2:
                        plus = 80;
                        break;
                    default:
                        this.value = [];
                        return;
                }
                const parsedSID = parseInt(sid, 10);
                if (isNaN(parsedSID))
                    return;
                sidBlock.valueDec = parsedSID + plus;
                flag = false;
            }
            else {
                const sidBlock = new LocalSidValueBlock();
                if (sid > Number.MAX_SAFE_INTEGER) {
                    assertBigInt();
                    const sidValue = BigInt(sid);
                    sidBlock.valueBigInt = sidValue;
                }
                else {
                    sidBlock.valueDec = parseInt(sid, 10);
                    if (isNaN(sidBlock.valueDec))
                        return;
                }
                if (!this.value.length) {
                    sidBlock.isFirstSid = true;
                    flag = true;
                }
                this.value.push(sidBlock);
            }
        } while (pos2 !== -1);
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0)
                result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                if (this.value[i].isFirstSid)
                    result = `2.{${sidStr} - 80}`;
                else
                    result += sidStr;
            }
            else
                result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: [],
        };
        for (let i = 0; i < this.value.length; i++) {
            object.sidArray.push(this.value[i].toJSON());
        }
        return object;
    }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";

var _a$m;
class ObjectIdentifier extends BaseBlock {
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    constructor(parameters = {}) {
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue(),
        };
    }
}
_a$m = ObjectIdentifier;
(() => {
    typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
    constructor({ valueDec = 0, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0)
            return inputOffset;
        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength))
            return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00)
                break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++)
            tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00)
            this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
            this.valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return (inputOffset + this.blockLength);
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly)
                return (new ArrayBuffer(this.valueHexView.byteLength));
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for (let i = 0; i < (this.blockLength - 1); i++)
                retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for (let i = 0; i < len; i++)
                retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView.buffer;
    }
    toString() {
        let result = "";
        if (this.isHexOnly)
            result = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView);
        else {
            result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec,
        };
    }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
            this.fromString(value);
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
            const sidBlock = new LocalRelativeSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly, _writer) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1)
                sid = string.substring(pos1);
            else
                sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            const sidBlock = new LocalRelativeSidValueBlock();
            sidBlock.valueDec = parseInt(sid, 10);
            if (isNaN(sidBlock.valueDec))
                return true;
            this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0)
                result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                result += sidStr;
            }
            else
                result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: [],
        };
        for (let i = 0; i < this.value.length; i++)
            object.sidArray.push(this.value[i].toJSON());
        return object;
    }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";

var _a$l;
class RelativeObjectIdentifier extends BaseBlock {
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    constructor(parameters = {}) {
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue(),
        };
    }
}
_a$l = RelativeObjectIdentifier;
(() => {
    typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";

var _a$k;
class Sequence extends Constructed {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
    }
}
_a$k = Sequence;
(() => {
    typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";

var _a$j;
class Set extends Constructed {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
    }
}
_a$j = Set;
(() => {
    typeStore.Set = _a$j;
})();
Set.NAME = "SET";

class LocalStringValueBlock extends HexBlock(ValueBlock) {
    constructor({ ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value,
        };
    }
}
LocalStringValueBlock.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock extends BaseStringBlock {
    constructor({ ...parameters } = {}) {
        super(parameters, LocalSimpleStringValueBlock);
    }
    fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer));
    }
    fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (let i = 0; i < strLen; i++)
            view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
    }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
            this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUtf8String(inputBuffer);
        }
        catch (ex) {
            this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
            this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToBinary(inputBuffer);
        }
    }
    fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
    }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";

var _a$i;
class Utf8String extends LocalUtf8StringValueBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
    }
}
_a$i = Utf8String;
(() => {
    typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";

class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);
    }
    fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromUtf16String(inputString));
    }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";

var _a$h;
class BmpString extends LocalBmpStringValueBlock {
    constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
    }
}
_a$h = BmpString;
(() => {
    typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";

class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for (let i = 0; i < valueView.length; i += 4) {
            valueView[i] = valueView[i + 3];
            valueView[i + 1] = valueView[i + 2];
            valueView[i + 2] = 0x00;
            valueView[i + 3] = 0x00;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    }
    fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (let i = 0; i < strLength; i++) {
            const codeBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(inputString.charCodeAt(i), 8);
            const codeView = new Uint8Array(codeBuf);
            if (codeView.length > 4)
                continue;
            const dif = 4 - codeView.length;
            for (let j = (codeView.length - 1); j >= 0; j--)
                valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
    }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";

var _a$g;
class UniversalString extends LocalUniversalStringValueBlock {
    constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
    }
}
_a$g = UniversalString;
(() => {
    typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";

var _a$f;
class NumericString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
    }
}
_a$f = NumericString;
(() => {
    typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";

var _a$e;
class PrintableString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
    }
}
_a$e = PrintableString;
(() => {
    typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";

var _a$d;
class TeletexString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
    }
}
_a$d = TeletexString;
(() => {
    typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";

var _a$c;
class VideotexString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
    }
}
_a$c = VideotexString;
(() => {
    typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";

var _a$b;
class IA5String extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
    }
}
_a$b = IA5String;
(() => {
    typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";

var _a$a;
class GraphicString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
    }
}
_a$a = GraphicString;
(() => {
    typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";

var _a$9;
class VisibleString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
    }
}
_a$9 = VisibleString;
(() => {
    typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";

var _a$8;
class GeneralString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
    }
}
_a$8 = GeneralString;
(() => {
    typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";

var _a$7;
class CharacterString extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
    }
}
_a$7 = CharacterString;
(() => {
    typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";

var _a$6;
class UTCTime extends VisibleString {
    constructor({ value, valueDate, ...parameters } = {}) {
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
            this.fromString(value);
            this.valueBlock.valueHexView = new Uint8Array(value.length);
            for (let i = 0; i < value.length; i++)
                this.valueBlock.valueHexView[i] = value.charCodeAt(i);
        }
        if (valueDate) {
            this.fromDate(valueDate);
            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
    }
    fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer)));
    }
    toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for (let i = 0; i < str.length; i++)
            view[i] = str.charCodeAt(i);
        return buffer;
    }
    fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
    }
    toDate() {
        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
    }
    fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
            this.error = "Wrong input string for conversion";
            return;
        }
        const year = parseInt(parserArray[1], 10);
        if (year >= 50)
            this.year = 1900 + year;
        else
            this.year = 2000 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = new Array(7);
            outputArray[0] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
            outputArray[1] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.month, 2);
            outputArray[2] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.day, 2);
            outputArray[3] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.hour, 2);
            outputArray[4] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.minute, 2);
            outputArray[5] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.second, 2);
            outputArray[6] = "Z";
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
        };
    }
}
_a$6 = UTCTime;
(() => {
    typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";

var _a$5;
class GeneralizedTime extends UTCTime {
    constructor(parameters = {}) {
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
    }
    fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
    }
    toDate() {
        const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
        return (new Date(utcDate));
    }
    fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
            timeString = inputString.substring(0, inputString.length - 1);
            isUTC = true;
        }
        else {
            const number = new Number(inputString[inputString.length - 1]);
            if (isNaN(number.valueOf()))
                throw new Error("Wrong input string for conversion");
            timeString = inputString;
        }
        if (isUTC) {
            if (timeString.indexOf("+") !== -1)
                throw new Error("Wrong input string for conversion");
            if (timeString.indexOf("-") !== -1)
                throw new Error("Wrong input string for conversion");
        }
        else {
            let multiplier = 1;
            let differencePosition = timeString.indexOf("+");
            let differenceString = "";
            if (differencePosition === -1) {
                differencePosition = timeString.indexOf("-");
                multiplier = -1;
            }
            if (differencePosition !== -1) {
                differenceString = timeString.substring(differencePosition + 1);
                timeString = timeString.substring(0, differencePosition);
                if ((differenceString.length !== 2) && (differenceString.length !== 4))
                    throw new Error("Wrong input string for conversion");
                let number = parseInt(differenceString.substring(0, 2), 10);
                if (isNaN(number.valueOf()))
                    throw new Error("Wrong input string for conversion");
                hourDifference = multiplier * number;
                if (differenceString.length === 4) {
                    number = parseInt(differenceString.substring(2, 4), 10);
                    if (isNaN(number.valueOf()))
                        throw new Error("Wrong input string for conversion");
                    minuteDifference = multiplier * number;
                }
            }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1)
            fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
            if (isNaN(fractionPartCheck.valueOf()))
                throw new Error("Wrong input string for conversion");
            fractionPart = fractionPartCheck.valueOf();
            dateTimeString = timeString.substring(0, fractionPointPosition);
        }
        else
            dateTimeString = timeString;
        switch (true) {
            case (dateTimeString.length === 8):
                parser = /(\d{4})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1)
                    throw new Error("Wrong input string for conversion");
                break;
            case (dateTimeString.length === 10):
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.minute = Math.floor(fractionResult);
                    fractionResult = 60 * (fractionResult - this.minute);
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case (dateTimeString.length === 12):
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case (dateTimeString.length === 14):
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    const fractionResult = 1000 * fractionPart;
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            default:
                throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null)
            throw new Error("Wrong input string for conversion");
        for (let j = 1; j < parserArray.length; j++) {
            switch (j) {
                case 1:
                    this.year = parseInt(parserArray[j], 10);
                    break;
                case 2:
                    this.month = parseInt(parserArray[j], 10);
                    break;
                case 3:
                    this.day = parseInt(parserArray[j], 10);
                    break;
                case 4:
                    this.hour = parseInt(parserArray[j], 10) + hourDifference;
                    break;
                case 5:
                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                    break;
                case 6:
                    this.second = parseInt(parserArray[j], 10);
                    break;
                default:
                    throw new Error("Wrong input string for conversion");
            }
        }
        if (isUTC === false) {
            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
            this.year = tempDate.getUTCFullYear();
            this.month = tempDate.getUTCMonth();
            this.day = tempDate.getUTCDay();
            this.hour = tempDate.getUTCHours();
            this.minute = tempDate.getUTCMinutes();
            this.second = tempDate.getUTCSeconds();
            this.millisecond = tempDate.getUTCMilliseconds();
        }
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = [];
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.year, 4));
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.month, 2));
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.day, 2));
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.hour, 2));
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.minute, 2));
            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.second, 2));
            if (this.millisecond !== 0) {
                outputArray.push(".");
                outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.millisecond, 3));
            }
            outputArray.push("Z");
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            millisecond: this.millisecond,
        };
    }
}
_a$5 = GeneralizedTime;
(() => {
    typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";

var _a$4;
class DATE extends Utf8String {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
    }
}
_a$4 = DATE;
(() => {
    typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";

var _a$3;
class TimeOfDay extends Utf8String {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
    }
}
_a$3 = TimeOfDay;
(() => {
    typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";

var _a$2;
class DateTime extends Utf8String {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
    }
}
_a$2 = DateTime;
(() => {
    typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";

var _a$1;
class Duration extends Utf8String {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
    }
}
_a$1 = Duration;
(() => {
    typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";

var _a;
class TIME extends Utf8String {
    constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
    }
}
_a = TIME;
(() => {
    typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

class Any {
    constructor({ name = EMPTY_STRING, optional = false } = {}) {
        this.name = name;
        this.optional = optional;
    }
}

class Choice extends Any {
    constructor({ value = [], ...parameters } = {}) {
        super(parameters);
        this.value = value;
    }
}

class Repeated extends Any {
    constructor({ value = new Any(), local = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.local = local;
    }
}

class RawData {
    get data() {
        return this.dataView.slice().buffer;
    }
    set data(value) {
        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(value);
    }
    constructor({ data = EMPTY_VIEW } = {}) {
        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(data);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
    }
    toBER(_sizeOnly) {
        return this.dataView.slice().buffer;
    }
}

function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
        for (const element of inputSchema.value) {
            const result = compareSchema(root, inputData, element);
            if (result.verified) {
                return {
                    verified: true,
                    result: root,
                };
            }
        }
        {
            const _result = {
                verified: false,
                result: { error: "Wrong values for Choice type" },
            };
            if (inputSchema.hasOwnProperty(NAME))
                _result.name = inputSchema.name;
            return _result;
        }
    }
    if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty(NAME))
            root[inputSchema.name] = inputData;
        return {
            verified: true,
            result: root,
        };
    }
    if ((root instanceof Object) === false) {
        return {
            verified: false,
            result: { error: "Wrong root object" },
        };
    }
    if ((inputData instanceof Object) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 data" },
        };
    }
    if ((inputSchema instanceof Object) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if ((ID_BLOCK in inputSchema) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if ((FROM_BER in inputSchema.idBlock) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if ((TO_BER in inputSchema.idBlock) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    const encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) {
        return {
            verified: false,
            result: { error: "Error encoding idBlock for ASN.1 schema" },
        };
    }
    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) {
        return {
            verified: false,
            result: { error: "Error decoding idBlock for ASN.1 schema" },
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
        return {
            verified: false,
            result: root,
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
        return {
            verified: false,
            result: root,
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
        return {
            verified: false,
            result: root,
        };
    }
    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" },
        };
    }
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
        return {
            verified: false,
            result: root,
        };
    }
    if (inputSchema.idBlock.isHexOnly) {
        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" },
            };
        }
        const schemaView = inputSchema.idBlock.valueHexView;
        const asn1View = inputData.idBlock.valueHexView;
        if (schemaView.length !== asn1View.length) {
            return {
                verified: false,
                result: root,
            };
        }
        for (let i = 0; i < schemaView.length; i++) {
            if (schemaView[i] !== asn1View[1]) {
                return {
                    verified: false,
                    result: root,
                };
            }
        }
    }
    if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
            root[inputSchema.name] = inputData;
    }
    if (inputSchema instanceof typeStore.Constructed) {
        let admission = 0;
        let result = {
            verified: false,
            result: { error: "Unknown error" },
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                maxLength = inputData.valueBlock.value.length;
            }
        }
        if (maxLength === 0) {
            return {
                verified: true,
                result: root,
            };
        }
        if ((inputData.valueBlock.value.length === 0)
            && (inputSchema.valueBlock.value.length !== 0)) {
            let _optional = true;
            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)
                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
            if (_optional) {
                return {
                    verified: true,
                    result: root,
                };
            }
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                    delete root[inputSchema.name];
            }
            root.error = "Inconsistent object length";
            return {
                verified: false,
                result: root,
            };
        }
        for (let i = 0; i < maxLength; i++) {
            if ((i - admission) >= inputData.valueBlock.value.length) {
                if (inputSchema.valueBlock.value[i].optional === false) {
                    const _result = {
                        verified: false,
                        result: root,
                    };
                    root.error = "Inconsistent length between ASN.1 data and schema";
                    if (inputSchema.name) {
                        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                        if (inputSchema.name) {
                            delete root[inputSchema.name];
                            _result.name = inputSchema.name;
                        }
                    }
                    return _result;
                }
            }
            else {
                if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[0].optional)
                            admission++;
                        else {
                            if (inputSchema.name) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                                if (inputSchema.name)
                                    delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {
                        let arrayRoot = {};
                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))
                            arrayRoot = inputData;
                        else
                            arrayRoot = root;
                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
                    }
                }
                else {
                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[i].optional)
                            admission++;
                        else {
                            if (inputSchema.name) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                                if (inputSchema.name)
                                    delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                }
            }
        }
        if (result.verified === false) {
            const _result = {
                verified: false,
                result: root,
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return {
            verified: true,
            result: root,
        };
    }
    if (inputSchema.primitiveSchema
        && (VALUE_HEX_VIEW in inputData.valueBlock)) {
        const asn1 = localFromBER(inputData.valueBlock.valueHexView);
        if (asn1.offset === -1) {
            const _result = {
                verified: false,
                result: asn1.result,
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
        verified: true,
        result: root,
    };
}
function verifySchema(inputBuffer, inputSchema) {
    if ((inputSchema instanceof Object) === false) {
        return {
            verified: false,
            result: { error: "Wrong ASN.1 schema type" },
        };
    }
    const asn1 = localFromBER(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer));
    if (asn1.offset === -1) {
        return {
            verified: false,
            result: asn1.result,
        };
    }
    return compareSchema(asn1.result, asn1.result, inputSchema);
}




/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js");
var _require2 = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js").types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__(/*! object.assign/polyfill */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js")();
var objectIs = __webpack_require__(/*! object-is/polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js")();
var RegExpPrototypeTest = __webpack_require__(/*! call-bind/callBound */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js")('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js");
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require.inspect;
var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js");
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js").types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = __webpack_require__(/*! possible-typed-array-names */ "./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__webpack_require__(/*! buffer */ "?2534").Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    this.length = num === 0 ? 1 : this.length;

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ "./node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ "?718d");
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var GHASH = __webpack_require__(/*! ./ghash */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/ghash.js")
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js")
var incr32 = __webpack_require__(/*! ./incr32 */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js")

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ciphers = __webpack_require__(/*! ./encrypter */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/encrypter.js")
var deciphers = __webpack_require__(/*! ./decrypter */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/decrypter.js")
var modes = __webpack_require__(/*! ./modes/list.json */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json")

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/decrypter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/decrypter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var MODES = __webpack_require__(/*! ./modes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js")
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/encrypter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/encrypter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var MODES = __webpack_require__(/*! ./modes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js")
var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/ghash.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/ghash.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js ***!
  \***************************************************************************************/
/***/ ((module) => {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cbc.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cbc.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js")

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js")

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb1.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb1.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb8.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb8.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var incr32 = __webpack_require__(/*! ../incr32 */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js")

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ecb.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ecb.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ecb.js"),
  CBC: __webpack_require__(/*! ./cbc */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cbc.js"),
  CFB: __webpack_require__(/*! ./cfb */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb.js"),
  CFB8: __webpack_require__(/*! ./cfb8 */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb8.js"),
  CFB1: __webpack_require__(/*! ./cfb1 */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb1.js"),
  OFB: __webpack_require__(/*! ./ofb */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ofb.js"),
  CTR: __webpack_require__(/*! ./ctr */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js"),
  GCM: __webpack_require__(/*! ./ctr */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js")
}

var modes = __webpack_require__(/*! ./list.json */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json")

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}');

/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ofb.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ofb.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js")

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/.pnpm/browserify-cipher@1.0.1/node_modules/browserify-cipher/browser.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-cipher@1.0.1/node_modules/browserify-cipher/browser.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DES = __webpack_require__(/*! browserify-des */ "./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/index.js")
var aes = __webpack_require__(/*! browserify-aes/browser */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js")
var aesModes = __webpack_require__(/*! browserify-aes/modes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js")
var desModes = __webpack_require__(/*! browserify-des/modes */ "./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/modes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js")

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CipherBase = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var des = __webpack_require__(/*! des.js */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/modes.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/modes.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports["des-ecb"] = {
  key: 8,
  iv: 0
}
exports["des-cbc"] = exports.des = {
  key: 8,
  iv: 8
}
exports["des-ede3-cbc"] = exports.des3 = {
  key: 24,
  iv: 8
}
exports["des-ede3"] = {
  key: 24,
  iv: 0
}
exports["des-ede-cbc"] = {
  key: 16,
  iv: 8
}
exports["des-ede"] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ "./node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js");
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);

function getr(priv) {
	var len = priv.modulus.byteLength();
	var r;
	do {
		r = new BN(randomBytes(len));
	} while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
	return r;
}

function blind(priv) {
	var r = getr(priv);
	var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
	return { blinder: blinder, unblinder: r.invm(priv.modulus) };
}

function crt(msg, priv) {
	var blinds = blind(priv);
	var len = priv.modulus.byteLength();
	var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
	var c1 = blinded.toRed(BN.mont(priv.prime1));
	var c2 = blinded.toRed(BN.mont(priv.prime2));
	var qinv = priv.coefficient;
	var p = priv.prime1;
	var q = priv.prime2;
	var m1 = c1.redPow(priv.exponent1).fromRed();
	var m2 = c2.redPow(priv.exponent2).fromRed();
	var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
	return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len);
}
crt.getr = getr;

module.exports = crt;


/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/algos.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/algos.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./browser/algorithms.json */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/algorithms.json");


/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/algorithms.json":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/algorithms.json ***!
  \*******************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}');

/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/curves.json":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/curves.json ***!
  \***************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}');

/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/index.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js");
var stream = __webpack_require__(/*! readable-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var sign = __webpack_require__(/*! ./sign */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/sign.js");
var verify = __webpack_require__(/*! ./verify */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/verify.js");

var algorithms = __webpack_require__(/*! ./algorithms.json */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/algorithms.json");
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});

function Sign(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Sign, stream.Writable);

Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Sign.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
  this.end();
  var hash = this._hash.digest();
  var sig = sign(hash, key, this._hashType, this._signType, this._tag);

  return enc ? sig.toString(enc) : sig;
};

function Verify(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Verify, stream.Writable);

Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Verify.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;

  this.end();
  var hash = this._hash.digest();
  return verify(sigBuffer, hash, key, this._signType, this._tag);
};

function createSign(algorithm) {
  return new Sign(algorithm);
}

function createVerify(algorithm) {
  return new Verify(algorithm);
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};


/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/sign.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/sign.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
var createHmac = __webpack_require__(/*! create-hmac */ "./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js");
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js");
var EC = (__webpack_require__(/*! elliptic */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js").ec);
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js");
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/curves.json");

var RSA_PKCS1_PADDING = 1;

function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong private key type'); }
    return dsaSign(hash, priv, hashType);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) { throw new Error('illegal or unsupported padding mode'); }

  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];
  while (hash.length + pad.length + 1 < len) { pad.push(0xff); }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) { pad.push(hash[i]); }

  var out = crt(pad, priv);
  return out;
}

function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + priv.curve.join('.')); }

  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);

  return Buffer.from(out.toDER());
}

function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);
  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }
  return toDER(r, s);
}

function toDER(r, s) {
  r = r.toArray();
  s = s.toArray();

  // Pad values
  if (r[0] & 0x80) { r = [0].concat(r); }
  if (s[0] & 0x80) { s = [0].concat(s); }

  var total = r.length + s.length + 4;
  var res = [
    0x30, total, 0x02, r.length
  ];
  res = res.concat(r, [0x02, s.length], s);
  return Buffer.from(res);
}

function getKey(x, q, hash, algo) {
  x = Buffer.from(x.toArray());
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length);
    x = Buffer.concat([zeros, x]);
  }
  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = Buffer.alloc(hlen);
  v.fill(1);
  var k = Buffer.alloc(hlen);
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return { k: k, v: v };
}

function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) { bits.ishrn(shift); }
  return bits;
}

function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = Buffer.from(bits.toArray());
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length);
    out = Buffer.concat([zeros, out]);
  }
  return out;
}

function makeKey(q, kv, algo) {
  var t;
  var k;

  do {
    t = Buffer.alloc(0);

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }

    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);

  return k;
}

function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}

module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;


/***/ }),

/***/ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/verify.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/verify.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var EC = (__webpack_require__(/*! elliptic */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js").ec);
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js");
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/curves.json");

function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong public key type'); }
    return dsaVerify(sig, hash, pub);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }

  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum += 1;
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  pad = Buffer.from(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);

  sig = sig.redPow(new BN(pub.publicExponent));
  sig = Buffer.from(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) { out = 1; }

  i = -1;
  while (++i < len) { out |= sig[i] ^ pad[i]; }
  return out === 0;
}

function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')); }

  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;

  return curve.verify(hash, sig, pubkey);
}

function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q);
  return v.cmp(r) === 0;
}

function checkValue(b, q) {
  if (b.cmpn(0) <= 0) { throw new Error('invalid sig'); }
  if (b.cmp(q) >= 0) { throw new Error('invalid sig'); }
}

module.exports = verify;


/***/ }),

/***/ "./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}


/***/ }),

/***/ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__(/*! ./reflectApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js ***!
  \****************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js");

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var applyBind = __webpack_require__(/*! call-bind-apply-helpers/applyBind */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js");

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Commented = __webpack_require__(/*! ./commented */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js");
const Diagnose = __webpack_require__(/*! ./diagnose */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const Simple = __webpack_require__(/*! ./simple */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js");
const Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js");
const Map = __webpack_require__(/*! ./map */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js");
const SharedValueEncoder = __webpack_require__(/*! ./sharedValueEncoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js");

module.exports = {
  Commented,
  Diagnose,
  Decoder,
  Encoder,
  Simple,
  Tagged,
  Map,
  SharedValueEncoder,

  /**
   * Convenience name for {@linkcode Commented.comment}.
   */
  comment: Commented.comment,

  /**
   * Convenience name for {@linkcode Decoder.decodeAll}.
   */
  decodeAll: Decoder.decodeAll,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirst}.
   */
  decodeFirst: Decoder.decodeFirst,

  /**
   * Convenience name for {@linkcode Decoder.decodeAllSync}.
   */
  decodeAllSync: Decoder.decodeAllSync,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirstSync}.
   */
  decodeFirstSync: Decoder.decodeFirstSync,

  /**
   * Convenience name for {@linkcode Diagnose.diagnose}.
   */
  diagnose: Diagnose.diagnose,

  /**
   * Convenience name for {@linkcode Encoder.encode}.
   */
  encode: Encoder.encode,

  /**
   * Convenience name for {@linkcode Encoder.encodeCanonical}.
   */
  encodeCanonical: Encoder.encodeCanonical,

  /**
   * Convenience name for {@linkcode Encoder.encodeOne}.
   */
  encodeOne: Encoder.encodeOne,

  /**
   * Convenience name for {@linkcode Encoder.encodeAsync}.
   */
  encodeAsync: Encoder.encodeAsync,

  /**
   * Convenience name for {@linkcode Decoder.decodeFirstSync}.
   */
  decode: Decoder.decodeFirstSync,

  /**
   * The codec information for
   * {@link https://github.com/Level/encoding-down encoding-down}, which is a
   * codec framework for leveldb.  CBOR is a particularly convenient format for
   * both keys and values, as it can deal with a lot of types that JSON can't
   * handle without losing type information.
   *
   * @example
   * const level = require('level')
   * const cbor = require('cbor')
   *
   * async function putget() {
   *   const db = level('./db', {
   *     keyEncoding: cbor.leveldb,
   *     valueEncoding: cbor.leveldb,
   *   })
   *
   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)
   *   const val = await db.get({a: 1})
   * }
   */
  leveldb: {
    decode: Decoder.decodeFirstSync,
    encode: Encoder.encode,
    buffer: true,
    name: 'cbor',
  },

  /**
   * Reset everything that we can predict a plugin might have altered in good
   * faith.  For now that includes the default set of tags that decoding and
   * encoding will use.
   */
  reset() {
    Encoder.reset();
    Tagged.reset();
  },
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const {MT, NUMBYTES, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

function plural(c) {
  if (c > 1) {
    return 's';
  }
  return '';
}

/**
 * @typedef CommentOptions
 * @property {number} [max_depth=10] How many times to indent
 *   the dashes.
 * @property {number} [depth=1] Initial indentation depth.
 * @property {boolean} [no_summary=false] If true, omit the summary
 *   of the full bytes read at the end.
 * @property {object} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it
 *   is a string.
 */
/**
 * @callback commentCallback
 * @param {Error} [error] If one was generated.
 * @param {string} [commented] The comment string.
 * @returns {void}
 */
/**
 * Normalize inputs to the static functions.
 *
 * @param {CommentOptions|commentCallback|string|number} opts Encoding,
 *   max_depth, or callback.
 * @param {commentCallback} [cb] Called on completion.
 * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.
 * @throws {TypeError} Unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {commentCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'number':
      return {options: {max_depth: opts}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Generate the expanded format of RFC 8949, section 3.2.2.
 *
 * @extends stream.Transform
 */
class Commented extends stream.Transform {
  /**
   * Create a CBOR commenter.
   *
   * @param {CommentOptions} [options={}] Stream options.
   */
  constructor(options = {}) {
    const {
      depth = 1,
      max_depth = 10,
      no_summary = false,
      // Decoder options
      tags = {},
      preferWeb,
      encoding,
      // Stream.Transform options
      ...superOpts
    } = options;

    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: false,
    });

    this.depth = depth;
    this.max_depth = max_depth;
    this.all = new NoFilter();

    if (!tags[24]) {
      tags[24] = this._tag_24.bind(this);
    }
    this.parser = new Decoder({
      tags,
      max_depth,
      preferWeb,
      encoding,
    });
    this.parser.on('value', this._on_value.bind(this));
    this.parser.on('start', this._on_start.bind(this));
    this.parser.on('start-string', this._on_start_string.bind(this));
    this.parser.on('stop', this._on_stop.bind(this));
    this.parser.on('more-bytes', this._on_more.bind(this));
    this.parser.on('error', this._on_error.bind(this));
    if (!no_summary) {
      this.parser.on('data', this._on_data.bind(this));
    }
    this.parser.bs.on('read', this._on_read.bind(this));
  }

  /**
   * @param {Buffer} v Descend into embedded CBOR.
   * @private
   */
  _tag_24(v) {
    const c = new Commented({depth: this.depth + 1, no_summary: true});

    c.on('data', b => this.push(b));
    c.on('error', er => this.emit('error', er));
    c.end(v);
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    // TODO: find the test that covers this, and look at the return value
    return this.parser._flush(cb);
  }

  /**
   * Comment on an input Buffer or string, creating a string passed to the
   * callback.  If callback not specified, a promise is returned.
   *
   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray
   *   |DataView|stream.Readable} input Something to parse.
   * @param {CommentOptions|commentCallback|string|number} [options={}]
   *   Encoding, max_depth, or callback.
   * @param {commentCallback} [cb] If specified, called on completion.
   * @returns {Promise} If cb not specified.
   * @throws {Error} Input required.
   */
  static comment(input, options = {}, cb = null) {
    if (input == null) {
      throw new Error('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const bs = new NoFilter();
    const {encoding = 'hex', ...opts} = options;
    const d = new Commented(opts);
    let p = null;

    if (typeof cb === 'function') {
      d.on('end', () => {
        cb(null, bs.toString('utf8'));
      });
      d.on('error', cb);
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => {
          resolve(bs.toString('utf8'));
        });
        d.on('error', reject);
      });
    }
    d.pipe(bs);
    utils.guessEncoding(input, encoding).pipe(d);
    return p;
  }

  /**
   * @ignore
   */
  _on_error(er) {
    this.push('ERROR: ');
    this.push(er.toString());
    this.push('\n');
  }

  /**
   * @ignore
   */
  _on_read(buf) {
    this.all.write(buf);
    const hex = buf.toString('hex');

    this.push(new Array(this.depth + 1).join('  '));
    this.push(hex);

    let ind = ((this.max_depth - this.depth) * 2) - hex.length;
    if (ind < 1) {
      ind = 1;
    }
    this.push(new Array(ind + 1).join(' '));
    this.push('-- ');
  }

  /**
   * @ignore
   */
  _on_more(mt, len, _parent_mt, _pos) {
    let desc = '';

    this.depth++;
    switch (mt) {
      case MT.POS_INT:
        desc = 'Positive number,';
        break;
      case MT.NEG_INT:
        desc = 'Negative number,';
        break;
      case MT.ARRAY:
        desc = 'Array, length';
        break;
      case MT.MAP:
        desc = 'Map, count';
        break;
      case MT.BYTE_STRING:
        desc = 'Bytes, length';
        break;
      case MT.UTF8_STRING:
        desc = 'String, length';
        break;
      case MT.SIMPLE_FLOAT:
        if (len === 1) {
          desc = 'Simple value,';
        } else {
          desc = 'Float,';
        }
        break;
    }
    this.push(`${desc} next ${len} byte${plural(len)}\n`);
  }

  /**
   * @ignore
   */
  _on_start_string(mt, len, _parent_mt, _pos) {
    let desc = '';

    this.depth++;
    switch (mt) {
      case MT.BYTE_STRING:
        desc = `Bytes, length: ${len}`;
        break;
      case MT.UTF8_STRING:
        desc = `String, length: ${len.toString()}`;
        break;
    }
    this.push(`${desc}\n`);
  }

  /**
   * @ignore
   */
  _on_start(mt, tag, parent_mt, pos) {
    this.depth++;
    switch (parent_mt) {
      case MT.ARRAY:
        this.push(`[${pos}], `);
        break;
      case MT.MAP:
        if (pos % 2) {
          this.push(`{Val:${Math.floor(pos / 2)}}, `);
        } else {
          this.push(`{Key:${Math.floor(pos / 2)}}, `);
        }
        break;
    }
    switch (mt) {
      case MT.TAG:
        this.push(`Tag #${tag}`);
        if (tag === 24) {
          this.push(' Encoded CBOR data item');
        }
        break;
      case MT.ARRAY:
        if (tag === SYMS.STREAM) {
          this.push('Array (streaming)');
        } else {
          this.push(`Array, ${tag} item${plural(tag)}`);
        }
        break;
      case MT.MAP:
        if (tag === SYMS.STREAM) {
          this.push('Map (streaming)');
        } else {
          this.push(`Map, ${tag} pair${plural(tag)}`);
        }
        break;
      case MT.BYTE_STRING:
        this.push('Bytes (streaming)');
        break;
      case MT.UTF8_STRING:
        this.push('String (streaming)');
        break;
    }
    this.push('\n');
  }

  /**
   * @ignore
   */
  _on_stop(_mt) {
    this.depth--;
  }

  /**
   * @private
   */
  _on_value(val, parent_mt, pos, ai) {
    if (val !== SYMS.BREAK) {
      switch (parent_mt) {
        case MT.ARRAY:
          this.push(`[${pos}], `);
          break;
        case MT.MAP:
          if (pos % 2) {
            this.push(`{Val:${Math.floor(pos / 2)}}, `);
          } else {
            this.push(`{Key:${Math.floor(pos / 2)}}, `);
          }
          break;
      }
    }
    const str = utils.cborValueToString(val, -Infinity);

    if ((typeof val === 'string') ||
        (Buffer.isBuffer(val))) {
      if (val.length > 0) {
        this.push(str);
        this.push('\n');
      }
      this.depth--;
    } else {
      this.push(str);
      this.push('\n');
    }

    switch (ai) {
      case NUMBYTES.ONE:
      case NUMBYTES.TWO:
      case NUMBYTES.FOUR:
      case NUMBYTES.EIGHT:
        this.depth--;
    }
  }

  /**
   * @ignore
   */
  _on_data() {
    this.push('0x');
    this.push(this.all.read().toString('hex'));
    this.push('\n');
  }
}

module.exports = Commented;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @enum {number}
 */
exports.MT = {
  POS_INT: 0,
  NEG_INT: 1,
  BYTE_STRING: 2,
  UTF8_STRING: 3,
  ARRAY: 4,
  MAP: 5,
  TAG: 6,
  SIMPLE_FLOAT: 7,
};

/**
 * @enum {number}
 */
exports.TAG = {
  DATE_STRING: 0,
  DATE_EPOCH: 1,
  POS_BIGINT: 2,
  NEG_BIGINT: 3,
  DECIMAL_FRAC: 4,
  BIGFLOAT: 5,
  BASE64URL_EXPECTED: 21,
  BASE64_EXPECTED: 22,
  BASE16_EXPECTED: 23,
  CBOR: 24,
  URI: 32,
  BASE64URL: 33,
  BASE64: 34,
  REGEXP: 35,
  MIME: 36,
  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  SET: 258,
};

/**
 * @enum {number}
 */
exports.NUMBYTES = {
  ZERO: 0,
  ONE: 24,
  TWO: 25,
  FOUR: 26,
  EIGHT: 27,
  INDEFINITE: 31,
};

/**
 * @enum {number}
 */
exports.SIMPLE = {
  FALSE: 20,
  TRUE: 21,
  NULL: 22,
  UNDEFINED: 23,
};

exports.SYMS = {
  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),
  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),
  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),
  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),
  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),
};

exports.SHIFT32 = 0x100000000;

exports.BI = {
  MINUS_ONE: BigInt(-1),
  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),
  MAXINT32: BigInt('0xffffffff'),
  MAXINT64: BigInt('0xffffffffffffffff'),
  SHIFT32: BigInt(exports.SHIFT32),
};



/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BinaryParseStream = __webpack_require__(/*! ../vendor/binary-parse-stream */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js");
const Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js");
const Simple = __webpack_require__(/*! ./simple */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {MT, NUMBYTES, SYMS, BI} = constants;
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

const COUNT = Symbol('count');
const MAJOR = Symbol('major type');
const ERROR = Symbol('error');
const NOT_FOUND = Symbol('not found');

function parentArray(parent, typ, count) {
  const a = [];

  a[COUNT] = count;
  a[SYMS.PARENT] = parent;
  a[MAJOR] = typ;
  return a;
}

function parentBufferStream(parent, typ) {
  const b = new NoFilter();

  b[COUNT] = -1;
  b[SYMS.PARENT] = parent;
  b[MAJOR] = typ;
  return b;
}

class UnexpectedDataError extends Error {
  constructor(byte, value) {
    super(`Unexpected data: 0x${byte.toString(16)}`);
    this.name = 'UnexpectedDataError';
    this.byte = byte;
    this.value = value;
  }
}

/**
 * Things that can act as inputs, from which a NoFilter can be created.
 *
 * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView
 *   |DataView|import('stream').Readable} BufferLike
 */
/**
 * @typedef ExtendedResults
 * @property {any} value The value that was found.
 * @property {number} length The number of bytes of the original input that
 *   were read.
 * @property {Buffer} bytes The bytes of the original input that were used
 *   to produce the value.
 * @property {Buffer} [unused] The bytes that were left over from the original
 *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or
 *   {@linkcode Decoder.decodeFirstSync} was called.
 */
/**
 * @typedef DecoderOptions
 * @property {number} [max_depth=-1] The maximum depth to parse.
 *   Use -1 for "until you run out of memory".  Set this to a finite
 *   positive number for un-trusted inputs.  Most standard inputs won't nest
 *   more than 100 or so levels; I've tested into the millions before
 *   running out of memory.
 * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferMap=false] If true, prefer to generate Map
 *   instances to plain objects, even if there are no entries in the map
 *   or if all of the keys are strings.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] The encoding of the input.
 *   Ignored if input is a Buffer.
 * @property {boolean} [required=false] Should an error be thrown when no
 *   data is in the input?
 * @property {boolean} [extendedResults=false] If true, emit extended
 *   results, which will be an object with shape {@link ExtendedResults}.
 *   The value will already have been null-checked.
 * @property {boolean} [preventDuplicateKeys=false] If true, error is
 *   thrown if a map has duplicate keys.
 */
/**
 * @callback decodeCallback
 * @param {Error} [error] If one was generated.
 * @param {any} [value] The decoded value.
 * @returns {void}
 */
/**
 * @param {DecoderOptions|decodeCallback|string} opts Options,
 *   the callback, or input incoding.
 * @param {decodeCallback} [cb] Called on completion.
 * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.
 * @throws {TypeError} On unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {decodeCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends BinaryParseStream
 */
class Decoder extends BinaryParseStream {
  /**
   * Create a parsing stream.
   *
   * @param {DecoderOptions} [options={}] Options.
   */
  constructor(options = {}) {
    const {
      tags = {},
      max_depth = -1,
      preferMap = false,
      preferWeb = false,
      required = false,
      encoding = 'hex',
      extendedResults = false,
      preventDuplicateKeys = false,
      ...superOpts
    } = options;

    super({defaultEncoding: encoding, ...superOpts});

    this.running = true;
    this.max_depth = max_depth;
    this.tags = tags;
    this.preferMap = preferMap;
    this.preferWeb = preferWeb;
    this.extendedResults = extendedResults;
    this.required = required;
    this.preventDuplicateKeys = preventDuplicateKeys;

    if (extendedResults) {
      this.bs.on('read', this._onRead.bind(this));
      this.valueBytes = /** @type {NoFilter} */ (new NoFilter());
    }
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @param {any} val The value to check.
   * @returns {any} The corrected value.
   * @throws {Error} Nothing was found.
   * @static
   * @example
   * myDecoder.on('data', val => {
   *   val = Decoder.nullcheck(val)
   *   // ...
   * })
   */
  static nullcheck(val) {
    switch (val) {
      case SYMS.NULL:
        return null;
      case SYMS.UNDEFINED:
        return undefined;
      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure
      // it can't happen.
      /* istanbul ignore next */
      case NOT_FOUND:
        /* istanbul ignore next */
        throw new Error('Value not found');
      default:
        return val;
    }
  }

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw
   * an exception if the input is not valid CBOR, or if there are more bytes
   * left over at the end (if options.extendedResults is not true).
   *
   * @param {BufferLike} input If a Readable stream, must have
   *   received the `readable` event already, or you will get an error
   *   claiming "Insufficient data".
   * @param {DecoderOptions|string} [options={}] Options or encoding for input.
   * @returns {ExtendedResults|any} The decoded value.
   * @throws {UnexpectedDataError} Data is left over after decoding.
   * @throws {Error} Insufficient data.
   */
  static decodeFirstSync(input, options = {}) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options} = normalizeOptions(options));
    const {encoding = 'hex', ...opts} = options;
    const c = new Decoder(opts);
    const s = utils.guessEncoding(input, encoding);

    // For/of doesn't work when you need to call next() with a value
    // generator created by parser will be "done" after each CBOR entity
    // parser will yield numbers of bytes that it wants
    const parser = c._parse();
    let state = parser.next();

    while (!state.done) {
      const b = s.read(state.value);

      if ((b == null) || (b.length !== state.value)) {
        throw new Error('Insufficient data');
      }
      if (c.extendedResults) {
        c.valueBytes.write(b);
      }
      state = parser.next(b);
    }

    let val = null;
    if (c.extendedResults) {
      val = state.value;
      val.unused = s.read();
    } else {
      val = Decoder.nullcheck(state.value);
      if (s.length > 0) {
        const nextByte = s.read(1);

        s.unshift(nextByte);
        throw new UnexpectedDataError(nextByte[0], val);
      }
    }
    return val;
  }

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|string} [options={}] Options or encoding
   *   for input.
   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.
   * @throws {TypeError} No input provided.
   * @throws {Error} Insufficient data provided.
   */
  static decodeAllSync(input, options = {}) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options} = normalizeOptions(options));
    const {encoding = 'hex', ...opts} = options;
    const c = new Decoder(opts);
    const s = utils.guessEncoding(input, encoding);
    const res = [];

    while (s.length > 0) {
      const parser = c._parse();
      let state = parser.next();

      while (!state.done) {
        const b = s.read(state.value);

        if ((b == null) || (b.length !== state.value)) {
          throw new Error('Insufficient data');
        }
        if (c.extendedResults) {
          c.valueBytes.write(b);
        }
        state = parser.next(b);
      }
      res.push(Decoder.nullcheck(state.value));
    }
    return res;
  }

  /**
   * Decode the first CBOR item in the input.  This will error if there are
   * more bytes left over at the end (if options.extendedResults is not true),
   * and optionally if there were no valid CBOR bytes in the input.  Emits the
   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the
   * `required` option is false.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the
   *   callback, or input encoding.
   * @param {decodeCallback} [cb] Callback.
   * @returns {Promise<ExtendedResults|any>} Returned even if callback is
   *   specified.
   * @throws {TypeError} No input provided.
   */
  static decodeFirst(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', required = false, ...opts} = options;

    const c = new Decoder(opts);
    let v = /** @type {any} */ (NOT_FOUND);
    const s = utils.guessEncoding(input, encoding);
    const p = new Promise((resolve, reject) => {
      c.on('data', val => {
        v = Decoder.nullcheck(val);
        c.close();
      });
      c.once('error', er => {
        if (c.extendedResults && (er instanceof UnexpectedDataError)) {
          v.unused = c.bs.slice();
          return resolve(v);
        }
        if (v !== NOT_FOUND) {
          // Typescript work-around
          // eslint-disable-next-line dot-notation
          er['value'] = v;
        }
        v = ERROR;
        c.close();
        return reject(er);
      });
      c.once('end', () => {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return reject(new Error('No CBOR found'));
            }
            return resolve(v);
          // Pretty sure this can't happen, but not *certain*.
          /* istanbul ignore next */
          case ERROR:
            /* istanbul ignore next */
            return undefined;
          default:
            return resolve(v);
        }
      });
    });

    if (typeof cb === 'function') {
      p.then(val => cb(null, val), cb);
    }
    s.pipe(c);
    return p;
  }

  /**
   * @callback decodeAllCallback
   * @param {Error} error If one was generated.
   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded
   *   values, wrapped in an Array.
   */

  /**
   * Decode all of the CBOR items in the input.  This will error if there are
   * more bytes left over at the end.
   *
   * @param {BufferLike} input What to parse?
   * @param {DecoderOptions|decodeAllCallback|string} [options={}]
   *   Decoding options, the callback, or the input encoding.
   * @param {decodeAllCallback} [cb] Callback.
   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback
   *   is specified.
   * @throws {TypeError} No input specified.
   */
  static decodeAll(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', ...opts} = options;

    const c = new Decoder(opts);
    const vals = [];

    c.on('data', val => vals.push(Decoder.nullcheck(val)));

    const p = new Promise((resolve, reject) => {
      c.on('error', reject);
      c.on('end', () => resolve(vals));
    });

    if (typeof cb === 'function') {
      p.then(v => cb(undefined, v), er => cb(er, undefined));
    }
    utils.guessEncoding(input, encoding).pipe(c);
    return p;
  }

  /**
   * Stop processing.
   */
  close() {
    this.running = false;
    this.__fresh = true;
  }

  /**
   * Only called if extendedResults is true.
   *
   * @ignore
   */
  _onRead(data) {
    this.valueBytes.write(data);
  }

  /**
   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,
   *   returns anything, next returns a Buffer.
   * @throws {Error} Maximum depth exceeded.
   * @yields {number} Number of bytes to read.
   * @ignore
   */
  *_parse() {
    let parent = null;
    let depth = 0;
    let val = null;

    while (true) {
      if ((this.max_depth >= 0) && (depth > this.max_depth)) {
        throw new Error(`Maximum depth ${this.max_depth} exceeded`);
      }

      const [octet] = yield 1;
      if (!this.running) {
        this.bs.unshift(Buffer.from([octet]));
        throw new UnexpectedDataError(octet);
      }
      const mt = octet >> 5;
      const ai = octet & 0x1f;
      const parent_major = (parent == null) ? undefined : parent[MAJOR];
      const parent_length = (parent == null) ? undefined : parent.length;

      switch (ai) {
        case NUMBYTES.ONE:
          this.emit('more-bytes', mt, 1, parent_major, parent_length);
          [val] = yield 1;
          break;
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT: {
          const numbytes = 1 << (ai - 24);

          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);
          const buf = yield numbytes;
          val = (mt === MT.SIMPLE_FLOAT) ?
            buf :
            utils.parseCBORint(ai, buf);
          break;
        }
        case 28:
        case 29:
        case 30:
          this.running = false;
          throw new Error(`Additional info not implemented: ${ai}`);
        case NUMBYTES.INDEFINITE:
          switch (mt) {
            case MT.POS_INT:
            case MT.NEG_INT:
            case MT.TAG:
              throw new Error(`Invalid indefinite encoding for MT ${mt}`);
          }
          val = -1;
          break;
        default:
          val = ai;
      }
      switch (mt) {
        case MT.POS_INT:
          // Val already decoded
          break;
        case MT.NEG_INT:
          if (val === Number.MAX_SAFE_INTEGER) {
            val = BI.NEG_MAX;
          } else {
            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val;
          }
          break;
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          switch (val) {
            case 0:
              this.emit('start-string', mt, val, parent_major, parent_length);
              if (mt === MT.UTF8_STRING) {
                val = '';
              } else {
                val = this.preferWeb ?
                  new Uint8Array(0) :
                  Buffer.allocUnsafe(0);
              }
              break;
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentBufferStream(parent, mt);
              depth++;
              continue;
            default:
              this.emit('start-string', mt, val, parent_major, parent_length);
              val = yield val;
              if (mt === MT.UTF8_STRING) {
                val = utils.utf8(val);
              } else if (this.preferWeb) {
                val = new Uint8Array(val.buffer, val.byteOffset, val.length);
              }
          }
          break;
        case MT.ARRAY:
        case MT.MAP:
          switch (val) {
            case 0:
              if (mt === MT.MAP) {
                val = (this.preferMap) ? new Map() : {};
              } else {
                val = [];
              }
              break;
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentArray(parent, mt, -1);
              depth++;
              continue;
            default:
              this.emit('start', mt, val, parent_major, parent_length);
              parent = parentArray(parent, mt, val * (mt - 3));
              depth++;
              continue;
          }
          break;
        case MT.TAG:
          this.emit('start', mt, val, parent_major, parent_length);
          parent = parentArray(parent, mt, 1);
          parent.push(val);
          depth++;
          continue;
        case MT.SIMPLE_FLOAT:
          if (typeof val === 'number') {
            if ((ai === NUMBYTES.ONE) && (val < 32)) {
              throw new Error(
                `Invalid two-byte encoding of simple value ${val}`
              );
            }
            const hasParent = (parent != null);
            val = Simple.decode(
              val,
              hasParent,
              hasParent && (parent[COUNT] < 0)
            );
          } else {
            val = utils.parseCBORfloat(val);
          }
      }
      this.emit('value', val, parent_major, parent_length, ai);
      let again = false;
      while (parent != null) {
        if (val === SYMS.BREAK) {
          parent[COUNT] = 1;
        } else if (Array.isArray(parent)) {
          parent.push(val);
        } else {
          // Assert: parent instanceof NoFilter
          const pm = parent[MAJOR];

          if ((pm != null) && (pm !== mt)) {
            this.running = false;
            throw new Error('Invalid major type in indefinite encoding');
          }
          parent.write(val);
        }

        if ((--parent[COUNT]) !== 0) {
          again = true;
          break;
        }
        --depth;
        delete parent[COUNT];

        if (Array.isArray(parent)) {
          switch (parent[MAJOR]) {
            case MT.ARRAY:
              val = parent;
              break;
            case MT.MAP: {
              let allstrings = !this.preferMap;

              if ((parent.length % 2) !== 0) {
                throw new Error(`Invalid map length: ${parent.length}`);
              }
              for (
                let i = 0, len = parent.length;
                allstrings && (i < len);
                i += 2
              ) {
                if ((typeof parent[i] !== 'string') ||
                    (parent[i] === '__proto__')) {
                  allstrings = false;
                  break;
                }
              }
              if (allstrings) {
                val = {};
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  if (this.preventDuplicateKeys &&
                    Object.prototype.hasOwnProperty.call(val, parent[i])) {
                    throw new Error('Duplicate keys in a map');
                  }
                  val[parent[i]] = parent[i + 1];
                }
              } else {
                val = new Map();
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  if (this.preventDuplicateKeys && val.has(parent[i])) {
                    throw new Error('Duplicate keys in a map');
                  }
                  val.set(parent[i], parent[i + 1]);
                }
              }
              break;
            }
            case MT.TAG: {
              const t = new Tagged(parent[0], parent[1]);

              val = t.convert(this.tags);
              break;
            }
          }
        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {
          // Only parent types are Array and NoFilter for (Array/Map) and
          // (bytes/string) respectively.
          switch (parent[MAJOR]) {
            case MT.BYTE_STRING:
              val = parent.slice();
              if (this.preferWeb) {
                val = new Uint8Array(
                  /** @type {Buffer} */ (val).buffer,
                  /** @type {Buffer} */ (val).byteOffset,
                  /** @type {Buffer} */ (val).length
                );
              }
              break;
            case MT.UTF8_STRING:
              val = parent.toString('utf-8');
              break;
          }
        }
        this.emit('stop', parent[MAJOR]);

        const old = parent;
        parent = parent[SYMS.PARENT];
        delete old[SYMS.PARENT];
        delete old[MAJOR];
      }
      if (!again) {
        if (this.extendedResults) {
          const bytes = this.valueBytes.slice();
          const ret = {
            value: Decoder.nullcheck(val),
            bytes,
            length: bytes.length,
          };

          this.valueBytes = new NoFilter();
          return ret;
        }
        return val;
      }
    }
  }
}

Decoder.NOT_FOUND = NOT_FOUND;
module.exports = Decoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const {MT, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * Things that can act as inputs, from which a NoFilter can be created.
 *
 * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView
 *   |DataView|stream.Readable} BufferLike
 */

/**
 * @typedef DiagnoseOptions
 * @property {string} [separator='\n'] Output between detected objects.
 * @property {boolean} [stream_errors=false] Put error info into the
 *   output stream.
 * @property {number} [max_depth=-1] The maximum depth to parse.
 *   Use -1 for "until you run out of memory".  Set this to a finite
 *   positive number for un-trusted inputs.  Most standard inputs won't nest
 *   more than 100 or so levels; I've tested into the millions before
 *   running out of memory.
 * @property {object} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if
 *   input is not string.
 */
/**
 * @callback diagnoseCallback
 * @param {Error} [error] If one was generated.
 * @param {string} [value] The diagnostic value.
 * @returns {void}
 */
/**
 * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,
 *   the callback, or input incoding.
 * @param {diagnoseCallback} [cb] Called on completion.
 * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.
 * @throws {TypeError} Unknown option type.
 * @private
 */
function normalizeOptions(opts, cb) {
  switch (typeof opts) {
    case 'function':
      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)};
    case 'string':
      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};
    case 'object':
      return {options: opts || {}, cb};
    default:
      throw new TypeError('Unknown option type');
  }
}

/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 * @extends stream.Transform
 */
class Diagnose extends stream.Transform {
  /**
   * Creates an instance of Diagnose.
   *
   * @param {DiagnoseOptions} [options={}] Options for creation.
   */
  constructor(options = {}) {
    const {
      separator = '\n',
      stream_errors = false,
      // Decoder options
      tags,
      max_depth,
      preferWeb,
      encoding,
      // Stream.Transform options
      ...superOpts
    } = options;
    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: false,
    });

    this.float_bytes = -1;
    this.separator = separator;
    this.stream_errors = stream_errors;
    this.parser = new Decoder({
      tags,
      max_depth,
      preferWeb,
      encoding,
    });
    this.parser.on('more-bytes', this._on_more.bind(this));
    this.parser.on('value', this._on_value.bind(this));
    this.parser.on('start', this._on_start.bind(this));
    this.parser.on('stop', this._on_stop.bind(this));
    this.parser.on('data', this._on_data.bind(this));
    this.parser.on('error', this._on_error.bind(this));
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    this.parser._flush(er => {
      if (this.stream_errors) {
        if (er) {
          this._on_error(er);
        }
        return cb();
      }
      return cb(er);
    });
  }

  /**
   * Convenience function to return a string in diagnostic format.
   *
   * @param {BufferLike} input The CBOR bytes to format.
   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]
   *   Options, the callback, or the input encoding.
   * @param {diagnoseCallback} [cb] Callback.
   * @returns {Promise} If callback not specified.
   * @throws {TypeError} Input not provided.
   */
  static diagnose(input, options = {}, cb = null) {
    if (input == null) {
      throw new TypeError('input required');
    }
    ({options, cb} = normalizeOptions(options, cb));
    const {encoding = 'hex', ...opts} = options;

    const bs = new NoFilter();
    const d = new Diagnose(opts);
    let p = null;
    if (typeof cb === 'function') {
      d.on('end', () => cb(null, bs.toString('utf8')));
      d.on('error', cb);
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => resolve(bs.toString('utf8')));
        d.on('error', reject);
      });
    }
    d.pipe(bs);
    utils.guessEncoding(input, encoding).pipe(d);
    return p;
  }

  /**
   * @ignore
   */
  _on_error(er) {
    if (this.stream_errors) {
      this.push(er.toString());
    } else {
      this.emit('error', er);
    }
  }

  /** @private */
  _on_more(mt, len, _parent_mt, _pos) {
    if (mt === MT.SIMPLE_FLOAT) {
      this.float_bytes = {
        2: 1,
        4: 2,
        8: 3,
      }[len];
    }
  }

  /** @private */
  _fore(parent_mt, pos) {
    switch (parent_mt) {
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
      case MT.ARRAY:
        if (pos > 0) {
          this.push(', ');
        }
        break;
      case MT.MAP:
        if (pos > 0) {
          if (pos % 2) {
            this.push(': ');
          } else {
            this.push(', ');
          }
        }
    }
  }

  /** @private */
  _on_value(val, parent_mt, pos) {
    if (val === SYMS.BREAK) {
      return;
    }
    this._fore(parent_mt, pos);
    const fb = this.float_bytes;
    this.float_bytes = -1;
    this.push(utils.cborValueToString(val, fb));
  }

  /** @private */
  _on_start(mt, tag, parent_mt, pos) {
    this._fore(parent_mt, pos);
    switch (mt) {
      case MT.TAG:
        this.push(`${tag}(`);
        break;
      case MT.ARRAY:
        this.push('[');
        break;
      case MT.MAP:
        this.push('{');
        break;
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        this.push('(');
        break;
    }
    if (tag === SYMS.STREAM) {
      this.push('_ ');
    }
  }

  /** @private */
  _on_stop(mt) {
    switch (mt) {
      case MT.TAG:
        this.push(')');
        break;
      case MT.ARRAY:
        this.push(']');
        break;
      case MT.MAP:
        this.push('}');
        break;
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        this.push(')');
        break;
    }
  }

  /** @private */
  _on_data() {
    this.push(this.separator);
  }
}

module.exports = Diagnose;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {
  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,
} = constants;
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

const HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO;
const FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR;
const DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT;
const TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE;
const FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE;
const UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED;
const NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL;

const BREAK = Buffer.from([0xff]);
const BUF_NAN = Buffer.from('f97e00', 'hex');
const BUF_INF_NEG = Buffer.from('f9fc00', 'hex');
const BUF_INF_POS = Buffer.from('f97c00', 'hex');
const BUF_NEG_ZERO = Buffer.from('f98000', 'hex');

/**
 * Generate the CBOR for a value.  If you are using this, you'll either need
 * to call {@link Encoder.write} with a Buffer, or look into the internals of
 * Encoder to reuse existing non-documented behavior.
 *
 * @callback EncodeFunction
 * @param {Encoder} enc The encoder to use.
 * @param {any} val The value to encode.
 * @returns {boolean} True on success.
 */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, EncodeFunction>} SemanticMap
 */

/**
 * @type {SemanticMap}
 * @private
 */
const SEMANTIC_TYPES = {};

/**
 * @type {SemanticMap}
 * @private
 */
let current_SEMANTIC_TYPES = {};

/**
 * @param {string} str String to normalize.
 * @returns {"number"|"float"|"int"|"string"} Normalized.
 * @throws {TypeError} Invalid input.
 * @private
 */
function parseDateType(str) {
  if (!str) {
    return 'number';
  }
  switch (str.toLowerCase()) {
    case 'number':
      return 'number';
    case 'float':
      return 'float';
    case 'int':
    case 'integer':
      return 'int';
    case 'string':
      return 'string';
  }
  throw new TypeError(`dateType invalid, got "${str}"`);
}

/**
 * @typedef ObjectOptions
 * @property {boolean} [indefinite = false] Force indefinite encoding for this
 *   object.
 * @property {boolean} [skipTypes = false] Do not use available type mappings
 *   for this object, but encode it as a "normal" JS object would be.
 */

/**
 * @typedef EncodingOptions
 * @property {any[]|object} [genTypes=[]] Array of pairs of
 *   `type`, `function(Encoder)` for semantic types to be encoded.  Not
 *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.
 *   If an object, the keys are the constructor names for the types.
 * @property {boolean} [canonical=false] Should the output be
 *   canonicalized.
 * @property {boolean|WeakSet} [detectLoops=false] Should object loops
 *   be detected?  This will currently add memory to track every part of the
 *   object being encoded in a WeakSet.  Do not encode
 *   the same object twice on the same encoder, without calling
 *   `removeLoopDetectors` in between, which will clear the WeakSet.
 *   You may pass in your own WeakSet to be used; this is useful in some
 *   recursive scenarios.
 * @property {("number"|"float"|"int"|"string")} [dateType="number"] -
 *   how should dates be encoded?  "number" means float or int, if no
 *   fractional seconds.
 * @property {any} [encodeUndefined=undefined] How should an
 *   "undefined" in the input be encoded.  By default, just encode a CBOR
 *   undefined.  If this is a buffer, use those bytes without re-encoding
 *   them.  If this is a function, the function will be called (which is a
 *   good time to throw an exception, if that's what you want), and the
 *   return value will be used according to these rules.  Anything else will
 *   be encoded as CBOR.
 * @property {boolean} [disallowUndefinedKeys=false] Should
 *   "undefined" be disallowed as a key in a Map that is serialized?  If
 *   this is true, encode(new Map([[undefined, 1]])) will throw an
 *   exception.  Note that it is impossible to get a key of undefined in a
 *   normal JS object.
 * @property {boolean} [collapseBigIntegers=false] Should integers
 *   that come in as ECMAscript bigint's be encoded
 *   as normal CBOR integers if they fit, discarding type information?
 * @property {number} [chunkSize=4096] Number of characters or bytes
 *   for each chunk, if obj is a string or Buffer, when indefinite encoding.
 * @property {boolean} [omitUndefinedProperties=false] When encoding
 *   objects or Maps, do not include a key if its corresponding value is
 *   `undefined`.
 */

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends stream.Transform
 */
class Encoder extends stream.Transform {
  /**
   * Creates an instance of Encoder.
   *
   * @param {EncodingOptions} [options={}] Options for the encoder.
   */
  constructor(options = {}) {
    const {
      canonical = false,
      encodeUndefined,
      disallowUndefinedKeys = false,
      dateType = 'number',
      collapseBigIntegers = false,
      detectLoops = false,
      omitUndefinedProperties = false,
      genTypes = [],
      ...superOpts
    } = options;

    super({
      ...superOpts,
      readableObjectMode: false,
      writableObjectMode: true,
    });

    this.canonical = canonical;
    this.encodeUndefined = encodeUndefined;
    this.disallowUndefinedKeys = disallowUndefinedKeys;
    this.dateType = parseDateType(dateType);
    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;

    /** @type {WeakSet?} */
    this.detectLoops = undefined;
    if (typeof detectLoops === 'boolean') {
      if (detectLoops) {
        this.detectLoops = new WeakSet();
      }
    } else if (detectLoops instanceof WeakSet) {
      this.detectLoops = detectLoops;
    } else {
      throw new TypeError('detectLoops must be boolean or WeakSet');
    }
    this.omitUndefinedProperties = omitUndefinedProperties;

    this.semanticTypes = {...Encoder.SEMANTIC_TYPES};

    if (Array.isArray(genTypes)) {
      for (let i = 0, len = genTypes.length; i < len; i += 2) {
        this.addSemanticType(genTypes[i], genTypes[i + 1]);
      }
    } else {
      for (const [k, v] of Object.entries(genTypes)) {
        this.addSemanticType(k, v);
      }
    }
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} _encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, _encoding, cb) {
    const ret = this.pushAny(fresh);
    // Old transformers might not return bool.  undefined !== false
    cb((ret === false) ? new Error('Push Error') : undefined);
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  // eslint-disable-next-line class-methods-use-this
  _flush(cb) {
    cb();
  }

  /**
   * @param {number} val Number(0-255) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt8(val) {
    const b = Buffer.allocUnsafe(1);
    b.writeUInt8(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number(0-65535) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt16BE(val) {
    const b = Buffer.allocUnsafe(2);
    b.writeUInt16BE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number(0..2**32-1) to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUInt32BE(val) {
    const b = Buffer.allocUnsafe(4);
    b.writeUInt32BE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number to encode as 4-byte float.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushFloatBE(val) {
    const b = Buffer.allocUnsafe(4);
    b.writeFloatBE(val, 0);
    return this.push(b);
  }

  /**
   * @param {number} val Number to encode as 8-byte double.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushDoubleBE(val) {
    const b = Buffer.allocUnsafe(8);
    b.writeDoubleBE(val, 0);
    return this.push(b);
  }

  /**
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNaN() {
    return this.push(BUF_NAN);
  }

  /**
   * @param {number} obj Positive or negative infinity.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushInfinity(obj) {
    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS;
    return this.push(half);
  }

  /**
   * Choose the best float representation for a number and encode it.
   *
   * @param {number} obj A number that is known to be not-integer, but not
   *   how many bytes of precision it needs.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushFloat(obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It's certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      const b2 = Buffer.allocUnsafe(2);
      if (utils.writeHalf(b2, obj)) {
        // I have convinced myself that there are no cases where writeHalf
        // will return true but `utils.parseHalf(b2) !== obj)`
        return this._pushUInt8(HALF) && this.push(b2);
      }
    }
    if (Math.fround(obj) === obj) {
      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
    }

    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
  }

  /**
   * Choose the best integer representation for a postive number and encode
   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I
   * don't remember why).
   *
   * @param {number} obj A positive number that is known to be an integer,
   *   but not how many bytes of precision it needs.
   * @param {number} mt The Major Type number to combine with the integer.
   *   Not yet shifted.
   * @param {number} [orig] The number before it was transformed to positive.
   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,
   *   then we'll encode this as a float rather than making the number
   *   negative again and losing precision.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushInt(obj, mt, orig) {
    const m = mt << 5;

    if (obj < 24) {
      return this._pushUInt8(m | obj);
    }
    if (obj <= 0xff) {
      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
    }
    if (obj <= 0xffff) {
      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
    }
    if (obj <= 0xffffffff) {
      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
    }
    let max = Number.MAX_SAFE_INTEGER;
    if (mt === MT.NEG_INT) {
      // Special case for Number.MIN_SAFE_INTEGER - 1
      max--;
    }
    if (obj <= max) {
      return this._pushUInt8(m | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&
        this._pushUInt32BE(obj % SHIFT32);
    }
    if (mt === MT.NEG_INT) {
      return this._pushFloat(orig);
    }
    return this._pushFloat(obj);
  }

  /**
   * Choose the best integer representation for a number and encode it.
   *
   * @param {number} obj A number that is known to be an integer,
   *   but not how many bytes of precision it needs.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushIntNum(obj) {
    if (Object.is(obj, -0)) {
      return this.push(BUF_NEG_ZERO);
    }

    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj);
    }
    return this._pushInt(obj, MT.POS_INT);
  }

  /**
   * @param {number} obj Plain JS number to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNumber(obj) {
    if (isNaN(obj)) {
      return this._pushNaN();
    }
    if (!isFinite(obj)) {
      return this._pushInfinity(obj);
    }
    if (Math.round(obj) === obj) {
      return this._pushIntNum(obj);
    }
    return this._pushFloat(obj);
  }

  /**
   * @param {string} obj String to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushString(obj) {
    const len = Buffer.byteLength(obj, 'utf8');
    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');
  }

  /**
   * @param {boolean} obj Bool to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE);
  }

  /**
   * @param {undefined} obj Ignored.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushUndefined(obj) {
    switch (typeof this.encodeUndefined) {
      case 'undefined':
        return this._pushUInt8(UNDEFINED);
      case 'function':
        return this.pushAny(this.encodeUndefined(obj));
      case 'object': {
        const buf = utils.bufferishToBuffer(this.encodeUndefined);
        if (buf) {
          return this.push(buf);
        }
      }
    }
    return this.pushAny(this.encodeUndefined);
  }

  /**
   * @param {null} _obj Ignored.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushNull(_obj) {
    return this._pushUInt8(NULL);
  }

  /**
   * @param {number} tag Tag number to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushTag(tag) {
    return this._pushInt(tag, MT.TAG);
  }

  /**
   * @param {bigint} obj BigInt to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  _pushJSBigint(obj) {
    let m = MT.POS_INT;
    let tag = TAG.POS_BIGINT;
    // BigInt doesn't have -0
    if (obj < 0) {
      obj = -obj + BI.MINUS_ONE;
      m = MT.NEG_INT;
      tag = TAG.NEG_BIGINT;
    }

    if (this.collapseBigIntegers &&
        (obj <= BI.MAXINT64)) {
      // Special handiling for 64bits
      if (obj <= 0xffffffff) {
        return this._pushInt(Number(obj), m);
      }
      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&
        this._pushUInt32BE(Number(obj % BI.SHIFT32));
    }

    let str = obj.toString(16);
    if (str.length % 2) {
      str = `0${str}`;
    }
    const buf = Buffer.from(str, 'hex');
    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);
  }

  /**
   * @param {object} obj Object to encode.
   * @param {ObjectOptions} [opts] Options for encoding this object.
   * @returns {boolean} True on success.
   * @throws {Error} Loop detected.
   * @ignore
   */
  _pushObject(obj, opts) {
    if (!obj) {
      return this._pushNull(obj);
    }
    opts = {
      indefinite: false,
      skipTypes: false,
      ...opts,
    };
    if (!opts.indefinite) {
      // This will only happen the first time through for indefinite encoding
      if (this.detectLoops) {
        if (this.detectLoops.has(obj)) {
          throw new Error(`\
Loop detected while CBOR encoding.
Call removeLoopDetectors before resuming.`);
        } else {
          this.detectLoops.add(obj);
        }
      }
    }
    if (!opts.skipTypes) {
      const f = obj.encodeCBOR;
      if (typeof f === 'function') {
        return f.call(obj, this);
      }
      const converter = this.semanticTypes[obj.constructor.name];
      if (converter) {
        return converter.call(obj, this, obj);
      }
    }
    const keys = Object.keys(obj).filter(k => {
      const tv = typeof obj[k];
      return (tv !== 'function') &&
        (!this.omitUndefinedProperties || (tv !== 'undefined'));
    });
    const cbor_keys = {};
    if (this.canonical) {
      // Note: this can't be a normal sort, because 'b' needs to sort before
      // 'aa'
      keys.sort((a, b) => {
        // Always strings, so don't bother to pass options.
        // hold on to the cbor versions, since there's no need
        // to encode more than once
        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));

        return a_cbor.compare(b_cbor);
      });
    }
    if (opts.indefinite) {
      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!this._pushInt(keys.length, MT.MAP)) {
      return false;
    }
    let ck = null;
    for (let j = 0, len2 = keys.length; j < len2; j++) {
      const k = keys[j];
      if (this.canonical && ((ck = cbor_keys[k]))) {
        if (!this.push(ck)) { // Already a Buffer
          return false;
        }
      } else if (!this._pushString(k)) {
        return false;
      }
      if (!this.pushAny(obj[k])) {
        return false;
      }
    }
    if (opts.indefinite) {
      if (!this.push(BREAK)) {
        return false;
      }
    } else if (this.detectLoops) {
      this.detectLoops.delete(obj);
    }
    return true;
  }

  /**
   * @param {any[]} objs Array of supported things.
   * @returns {Buffer} Concatenation of encodings for the supported things.
   * @ignore
   */
  _encodeAll(objs) {
    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});
    this.pipe(bs);
    for (const o of objs) {
      this.pushAny(o);
    }
    this.end();
    return bs.read();
  }

  /**
   * Add an encoding function to the list of supported semantic types.  This
   * is useful for objects for which you can't add an encodeCBOR method.
   *
   * @param {string|Function} type The type to encode.
   * @param {EncodeFunction} fun The encoder to use.
   * @returns {EncodeFunction?} The previous encoder or undefined if there
   *   wasn't one.
   * @throws {TypeError} Invalid function.
   */
  addSemanticType(type, fun) {
    const typeName = (typeof type === 'string') ? type : type.name;
    const old = this.semanticTypes[typeName];

    if (fun) {
      if (typeof fun !== 'function') {
        throw new TypeError('fun must be of type function');
      }
      this.semanticTypes[typeName] = fun;
    } else if (old) {
      delete this.semanticTypes[typeName];
    }
    return old;
  }

  /**
   * Push any supported type onto the encoded stream.
   *
   * @param {any} obj The thing to encode.
   * @returns {boolean} True on success.
   * @throws {TypeError} Unknown type for obj.
   */
  pushAny(obj) {
    switch (typeof obj) {
      case 'number':
        return this._pushNumber(obj);
      case 'bigint':
        return this._pushJSBigint(obj);
      case 'string':
        return this._pushString(obj);
      case 'boolean':
        return this._pushBoolean(obj);
      case 'undefined':
        return this._pushUndefined(obj);
      case 'object':
        return this._pushObject(obj);
      case 'symbol':
        switch (obj) {
          case SYMS.NULL:
            return this._pushNull(null);
          case SYMS.UNDEFINED:
            return this._pushUndefined(undefined);
          // TODO: Add pluggable support for other symbols
          default:
            throw new TypeError(`Unknown symbol: ${obj.toString()}`);
        }
      default:
        throw new TypeError(
          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`
        );
    }
  }

  /**
   * Encode an array and all of its elements.
   *
   * @param {Encoder} gen Encoder to use.
   * @param {any[]} obj Array to encode.
   * @param {object} [opts] Options.
   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?
   * @returns {boolean} True on success.
   */
  static pushArray(gen, obj, opts) {
    opts = {
      indefinite: false,
      ...opts,
    };
    const len = obj.length;
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!gen._pushInt(len, MT.ARRAY)) {
      return false;
    }
    for (let j = 0; j < len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false;
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Remove the loop detector WeakSet for this Encoder.
   *
   * @returns {boolean} True when the Encoder was reset, else false.
   */
  removeLoopDetectors() {
    if (!this.detectLoops) {
      return false;
    }
    this.detectLoops = new WeakSet();
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Date} obj Date to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushDate(gen, obj) {
    switch (gen.dateType) {
      case 'string':
        return gen._pushTag(TAG.DATE_STRING) &&
          gen._pushString(obj.toISOString());
      case 'int':
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushIntNum(Math.round(obj.getTime() / 1000));
      case 'float':
        // Force float
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushFloat(obj.getTime() / 1000);
      case 'number':
      default:
        // If we happen to have an integral number of seconds,
        // use integer.  Otherwise, use float.
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen.pushAny(obj.getTime() / 1000);
    }
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Buffer} obj Buffer to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {NoFilter} obj Buffer to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushNoFilter(gen, obj) {
    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()));
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {RegExp} obj RegExp to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Set} obj Set to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushSet(gen, obj) {
    if (!gen._pushTag(TAG.SET)) {
      return false;
    }
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false;
    }
    for (const x of obj) {
      if (!gen.pushAny(x)) {
        return false;
      }
    }
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {URL} obj URL to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushURL(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {object} obj Boxed String, Number, or Boolean object to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushBoxed(gen, obj) {
    return gen.pushAny(obj.valueOf());
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {Map} obj Map to encode.
   * @returns {boolean} True on success.
   * @throws {Error} Map key that is undefined.
   * @ignore
   */
  static _pushMap(gen, obj, opts) {
    opts = {
      indefinite: false,
      ...opts,
    };
    let entries = [...obj.entries()];
    if (gen.omitUndefinedProperties) {
      entries = entries.filter(([_k, v]) => v !== undefined);
    }
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false;
      }
    } else if (!gen._pushInt(entries.length, MT.MAP)) {
      return false;
    }
    // Memoizing the cbor only helps in certain cases, and hurts in most
    // others.  Just avoid it.
    if (gen.canonical) {
      // Keep the key/value pairs together, so we don't have to do odd
      // gets with object keys later
      const enc = new Encoder({
        genTypes: gen.semanticTypes,
        canonical: gen.canonical,
        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector
        dateType: gen.dateType,
        disallowUndefinedKeys: gen.disallowUndefinedKeys,
        collapseBigIntegers: gen.collapseBigIntegers,
      });
      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark});
      enc.pipe(bs);
      entries.sort(([a], [b]) => {
        // Both a and b are the keys
        enc.pushAny(a);
        const a_cbor = bs.read();
        enc.pushAny(b);
        const b_cbor = bs.read();
        return a_cbor.compare(b_cbor);
      });
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined');
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false;
        }
      }
    } else {
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined');
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false;
        }
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false;
      }
    }
    return true;
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param {NodeJS.TypedArray} obj Array to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushTypedArray(gen, obj) {
    // See https://tools.ietf.org/html/rfc8746

    let typ = 0b01000000;
    let sz = obj.BYTES_PER_ELEMENT;
    const {name} = obj.constructor;

    if (name.startsWith('Float')) {
      typ |= 0b00010000;
      sz /= 2;
    } else if (!name.includes('U')) {
      typ |= 0b00001000;
    }
    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {
      typ |= 0b00000100;
    }
    typ |= {
      1: 0b00,
      2: 0b01,
      4: 0b10,
      8: 0b11,
    }[sz];
    if (!gen._pushTag(typ)) {
      return false;
    }
    return Encoder._pushBuffer(
      gen,
      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)
    );
  }

  /**
   * @param {Encoder} gen Encoder.
   * @param { ArrayBuffer } obj Array to encode.
   * @returns {boolean} True on success.
   * @ignore
   */
  static _pushArrayBuffer(gen, obj) {
    return Encoder._pushBuffer(gen, Buffer.from(obj));
  }

  /**
   * Encode the given object with indefinite length.  There are apparently
   * some (IMO) broken implementations of poorly-specified protocols that
   * REQUIRE indefinite-encoding.  See the example for how to add this as an
   * `encodeCBOR` function to an object or class to get indefinite encoding.
   *
   * @param {Encoder} gen The encoder to use.
   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If
   *   null, use "this" instead.
   * @param {EncodingOptions} [options={}] Options for encoding.
   * @returns {boolean} True on success.
   * @throws {Error} No object to encode or invalid indefinite encoding.
   * @example <caption>Force indefinite encoding:</caption>
   * const o = {
   *   a: true,
   *   encodeCBOR: cbor.Encoder.encodeIndefinite,
   * }
   * const m = []
   * m.encodeCBOR = cbor.Encoder.encodeIndefinite
   * cbor.encodeOne([o, m])
   */
  static encodeIndefinite(gen, obj, options = {}) {
    if (obj == null) {
      if (this == null) {
        throw new Error('No object to encode');
      }
      obj = this;
    }

    // TODO: consider other options
    const {chunkSize = 4096} = options;

    let ret = true;
    const objType = typeof obj;
    let buf = null;
    if (objType === 'string') {
      // TODO: make sure not to split surrogate pairs at the edges of chunks,
      // since such half-surrogates cannot be legally encoded as UTF-8.
      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE);
      let offset = 0;
      while (offset < obj.length) {
        const endIndex = offset + chunkSize;
        ret = ret && gen._pushString(obj.slice(offset, endIndex));
        offset = endIndex;
      }
      ret = ret && gen.push(BREAK);
    } else if ((buf = utils.bufferishToBuffer(obj))) {
      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE);
      let offset = 0;
      while (offset < buf.length) {
        const endIndex = offset + chunkSize;
        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));
        offset = endIndex;
      }
      ret = ret && gen.push(BREAK);
    } else if (Array.isArray(obj)) {
      ret = ret && Encoder.pushArray(gen, obj, {
        indefinite: true,
      });
    } else if (obj instanceof Map) {
      ret = ret && Encoder._pushMap(gen, obj, {
        indefinite: true,
      });
    } else {
      if (objType !== 'object') {
        throw new Error('Invalid indefinite encoding');
      }
      ret = ret && gen._pushObject(obj, {
        indefinite: true,
        skipTypes: true,
      });
    }
    return ret;
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encode(...objs) {
    return new Encoder()._encodeAll(objs);
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encodeCanonical(...objs) {
    return new Encoder({
      canonical: true,
    })._encodeAll(objs);
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @param {any} obj The object to encode.
   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
   * @returns {Buffer} The encoded objects.
   */
  static encodeOne(obj, options) {
    return new Encoder(options)._encodeAll([obj]);
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj The object to encode.
   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
   * @returns {Promise<Buffer>} A promise for the encoded buffer.
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) => {
      const bufs = [];
      const enc = new Encoder(options);
      enc.on('data', buf => bufs.push(buf));
      enc.on('error', reject);
      enc.on('finish', () => resolve(Buffer.concat(bufs)));
      enc.pushAny(obj);
      enc.end();
    });
  }

  /**
   * The currently supported set of semantic types.  May be modified by plugins.
   *
   * @type {SemanticMap}
   */
  static get SEMANTIC_TYPES() {
    return current_SEMANTIC_TYPES;
  }

  static set SEMANTIC_TYPES(val) {
    current_SEMANTIC_TYPES = val;
  }

  /**
   * Reset the supported semantic types to the original set, before any
   * plugins modified the list.
   */
  static reset() {
    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES};
  }
}

Object.assign(SEMANTIC_TYPES, {
  Array: Encoder.pushArray,
  Date: Encoder._pushDate,
  Buffer: Encoder._pushBuffer,
  [Buffer.name]: Encoder._pushBuffer, // Might be mangled
  Map: Encoder._pushMap,
  NoFilter: Encoder._pushNoFilter,
  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled
  RegExp: Encoder._pushRegexp,
  Set: Encoder._pushSet,
  ArrayBuffer: Encoder._pushArrayBuffer,
  Uint8ClampedArray: Encoder._pushTypedArray,
  Uint8Array: Encoder._pushTypedArray,
  Uint16Array: Encoder._pushTypedArray,
  Uint32Array: Encoder._pushTypedArray,
  Int8Array: Encoder._pushTypedArray,
  Int16Array: Encoder._pushTypedArray,
  Int32Array: Encoder._pushTypedArray,
  Float32Array: Encoder._pushTypedArray,
  Float64Array: Encoder._pushTypedArray,
  URL: Encoder._pushURL,
  Boolean: Encoder._pushBoxed,
  Number: Encoder._pushBoxed,
  String: Encoder._pushBoxed,
});

// Safari needs to get better.
if (typeof BigUint64Array !== 'undefined') {
  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;
}
if (typeof BigInt64Array !== 'undefined') {
  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;
}

Encoder.reset();
module.exports = Encoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const decoder = __webpack_require__(/*! ./decoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js");
const {MT} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * Wrapper around a JavaScript Map object that allows the keys to be
 * any complex type.  The base Map object allows this, but will only
 * compare the keys by identity, not by value.  CborMap translates keys
 * to CBOR first (and base64's them to ensure by-value comparison).
 *
 * This is not a subclass of Object, because it would be tough to get
 * the semantics to be an exact match.
 *
 * @extends Map
 */
class CborMap extends Map {
  /**
   * Creates an instance of CborMap.
   *
   * @param {Iterable<any>} [iterable] An Array or other iterable
   *   object whose elements are key-value pairs (arrays with two elements, e.g.
   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added
   *   to the new CborMap; null values are treated as undefined.
   */
  constructor(iterable) {
    super(iterable);
  }

  /**
   * @ignore
   * @param {unknown} key
   * @returns {string}
   */
  static _encode(key) {
    return encoder.encodeCanonical(key).toString('base64');
  }

  /**
   * @ignore
   * @param {string} key
   * @returns {unknown}
   */
  static _decode(key) {
    return decoder.decodeFirstSync(key, 'base64');
  }

  /**
   * Retrieve a specified element.
   *
   * @param {any} key The key identifying the element to retrieve.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {any} The element if it exists, or <code>undefined</code>.
   */
  get(key) {
    return super.get(CborMap._encode(key));
  }

  /**
   * Adds or updates an element with a specified key and value.
   *
   * @param {any} key The key identifying the element to store.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @param {any} val The element to store.
   * @returns {this} This object.
   */
  set(key, val) {
    return super.set(CborMap._encode(key), val);
  }

  /**
   * Removes the specified element.
   *
   * @param {any} key The key identifying the element to delete. Can be any
   *   type, which will be serialized into CBOR and compared by value.
   * @returns {boolean} True if an element in the Map object existed and has
   *   been removed, or false if the element does not exist.
   */
  delete(key) {
    return super.delete(CborMap._encode(key));
  }

  /**
   * Does an element with the specified key exist?
   *
   * @param {any} key The key identifying the element to check.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean} True if an element with the specified key exists in
   *   the Map object; otherwise false.
   */
  has(key) {
    return super.has(CborMap._encode(key));
  }

  /**
   * Returns a new Iterator object that contains the keys for each element
   * in the Map object in insertion order.  The keys are decoded into their
   * original format.
   *
   * @returns {MapIterator<any>}
   */
  *keys() {
    for (const k of super.keys()) {
      yield CborMap._decode(k);
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator<any>} Key value pairs.
   * @yields {any[]} Key value pairs.
   */
  *entries() {
    for (const kv of super.entries()) {
      yield [CborMap._decode(kv[0]), kv[1]];
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator<any>} Key value pairs.
   */
  [Symbol.iterator]() {
    return this.entries();
  }

  /**
   * Executes a provided function once per each key/value pair in the Map
   * object, in insertion order.
   *
   * @param {function(any, any, Map<any,any>): undefined} fun Function to
   *   execute for each element, which takes a value, a key, and the Map
   *   being traversed.
   * @param {any} thisArg Value to use as this when executing callback.
   * @throws {TypeError} Invalid function.
   */
  forEach(fun, thisArg = this) {
    if (typeof fun !== 'function') {
      throw new TypeError('Must be function');
    }
    for (const kv of super.entries()) {
      fun.call(thisArg, kv[1], CborMap._decode(kv[0]), this);
    }
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {import('./encoder.js')} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    if (!gen._pushInt(this.size, MT.MAP)) {
      return false;
    }
    if (gen.canonical) {
      const entries = Array.from(super.entries())
        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);
      entries.sort((a, b) => a[0].compare(b[0]));
      for (const kv of entries) {
        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    } else {
      for (const kv of super.entries()) {
        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    }
    return true;
  }
}

module.exports = CborMap;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Record objects that pass by in a stream.  If the same object is used more
 * than once, it can be value-shared using shared values.
 *
 * @see {@link http://cbor.schmorp.de/value-sharing}
 */
class ObjectRecorder {
  constructor() {
    this.clear();
  }

  /**
   * Clear all of the objects that have been seen.  Revert to recording mode.
   */
  clear() {
    this.map = new WeakMap();
    this.count = 0;
    this.recording = true;
  }

  /**
   * Stop recording.
   */
  stop() {
    this.recording = false;
  }

  /**
   * Determine if wrapping a tag 28 or 29 around an object that has been
   * reused is appropriate.  This method stores state for which objects have
   * been seen.
   *
   * @param {object} obj Any object about to be serialized.
   * @returns {number} If recording: -1 for first use, index for second use.
   *   If not recording, -1 for never-duplicated, -2 for first use, index for
   *   subsequent uses.
   * @throws {Error} Recording does not match playback.
   */
  check(obj) {
    const val = this.map.get(obj);
    if (val) {
      if (val.length > 1) {
        if (val[0] || this.recording) {
          return val[1];
        }

        val[0] = true;
        return ObjectRecorder.FIRST;
      }
      if (!this.recording) {
        return ObjectRecorder.NEVER;
      }
      val.push(this.count++);
      // Second use while recording
      return val[1];
    }
    if (!this.recording) {
      throw new Error('New object detected when not recording');
    }
    this.map.set(obj, [false]);
    // First use while recording
    return ObjectRecorder.NEVER;
  }
}

ObjectRecorder.NEVER = -1;
ObjectRecorder.FIRST = -2;

module.exports = ObjectRecorder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js");
const ObjectRecorder = __webpack_require__(/*! ./objectRecorder */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js");
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");

/**
 * Implement value sharing.
 *
 * @see {@link cbor.schmorp.de/value-sharing}
 */
class SharedValueEncoder extends Encoder {
  constructor(opts) {
    super(opts);
    this.valueSharing = new ObjectRecorder();
  }

  /**
   * @param {object} obj Object to encode.
   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding
   *   this object.
   * @returns {boolean} True on success.
   * @throws {Error} Loop detected.
   * @ignore
   */
  _pushObject(obj, opts) {
    if (obj !== null) {
      const shared = this.valueSharing.check(obj);
      switch (shared) {
        case ObjectRecorder.FIRST:
          // Prefix with tag 28
          this._pushTag(28);
          break;
        case ObjectRecorder.NEVER:
          // Do nothing
          break;
        default:
          return this._pushTag(29) && this._pushIntNum(shared);
      }
    }
    return super._pushObject(obj, opts);
  }

  /**
   * Between encoding runs, stop recording, and start outputing correct tags.
   */
  stopRecording() {
    this.valueSharing.stop();
  }

  /**
   * Remove the existing recording and start over.  Do this between encoding
   * pairs.
   */
  clearRecording() {
    this.valueSharing.clear();
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs The objects to encode.
   * @returns {Buffer} The encoded objects.
   */
  static encode(...objs) {
    const enc = new SharedValueEncoder();
    // eslint-disable-next-line no-empty-function
    enc.on('data', () => {}); // Sink all writes

    for (const o of objs) {
      enc.pushAny(o);
    }
    enc.stopRecording();
    enc.removeAllListeners('data');
    return enc._encodeAll(objs);
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} _objs The objects to encode.
   * @returns {Buffer} Never.
   * @throws {Error} Always.  This combination doesn't work at the moment.
   */
  static encodeCanonical(..._objs) {
    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @param {any} obj The object to encode.
   * @param {import('./encoder').EncodingOptions} [options={}]
   *   Passed to the Encoder constructor.
   * @returns {Buffer} The encoded objects.
   * @static
   */
  static encodeOne(obj, options) {
    const enc = new SharedValueEncoder(options);
    // eslint-disable-next-line no-empty-function
    enc.on('data', () => {}); // Sink all writes
    enc.pushAny(obj);
    enc.stopRecording();
    enc.removeAllListeners('data');
    return enc._encodeAll([obj]);
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj The object to encode.
   * @param {import('./encoder').EncodingOptions} [options={}]
   *   Passed to the Encoder constructor.
   * @returns {Promise<Buffer>} A promise for the encoded buffer.
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) => {
      /** @type {Buffer[]} */
      const bufs = [];
      const enc = new SharedValueEncoder(options);
      // eslint-disable-next-line no-empty-function
      enc.on('data', () => {});
      enc.on('error', reject);
      enc.on('finish', () => resolve(Buffer.concat(bufs)));
      enc.pushAny(obj);
      enc.stopRecording();
      enc.removeAllListeners('data');
      enc.on('data', buf => bufs.push(buf));
      enc.pushAny(obj);
      enc.end();
    });
  }
}

module.exports = SharedValueEncoder;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {MT, SIMPLE, SYMS} = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");

/**
 * A CBOR Simple Value that does not map onto a known constant.
 */
class Simple {
  /**
   * Creates an instance of Simple.
   *
   * @param {number} value The simple value's integer value.
   */
  constructor(value) {
    if (typeof value !== 'number') {
      throw new Error(`Invalid Simple type: ${typeof value}`);
    }
    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {
      throw new Error(`value must be a small positive integer: ${value}`);
    }
    this.value = value;
  }

  /**
   * Debug string for simple value.
   *
   * @returns {string} Formated string of `simple(value)`.
   */
  toString() {
    return `simple(${this.value})`;
  }

  /**
   * Debug string for simple value.
   *
   * @param {number} _depth How deep are we?
   * @param {object} _opts Options.
   * @returns {string} Formatted string of `simple(value)`.
   */
  [Symbol.for('nodejs.util.inspect.custom')](_depth, _opts) {
    return `simple(${this.value})`;
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {object} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
  }

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj Object to test.
   * @returns {boolean} Is it Simple?
   */
  static isSimple(obj) {
    return obj instanceof Simple;
  }

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a "safe" symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {number} val The CBOR additional info to convert.
   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?
   * @param {boolean} [parent_indefinite=false] Is the parent element
   *   indefinitely encoded?
   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.
   * @throws {Error} Invalid BREAK.
   */
  static decode(val, has_parent = true, parent_indefinite = false) {
    switch (val) {
      case SIMPLE.FALSE:
        return false;
      case SIMPLE.TRUE:
        return true;
      case SIMPLE.NULL:
        if (has_parent) {
          return null;
        }
        return SYMS.NULL;
      case SIMPLE.UNDEFINED:
        if (has_parent) {
          return undefined;
        }
        return SYMS.UNDEFINED;
      case -1:
        if (!has_parent || !parent_indefinite) {
          throw new Error('Invalid BREAK');
        }
        return SYMS.BREAK;
      default:
        return new Simple(val);
    }
  }
}

module.exports = Simple;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js");
const INTERNAL_JSON = Symbol('INTERNAL_JSON');

function setBuffersToJSON(obj, fn) {
  // The data item tagged can be a byte string or any other data item.  In the
  // latter case, the tag applies to all of the byte string data items
  // contained in the data item, except for those contained in a nested data
  // item tagged with an expected conversion.
  if (utils.isBufferish(obj)) {
    obj.toJSON = fn;
  } else if (Array.isArray(obj)) {
    for (const v of obj) {
      setBuffersToJSON(v, fn);
    }
  } else if (obj && (typeof obj === 'object')) {
    // FFS, complexity in the protocol.

    // There's some circular dependency in here.
    // eslint-disable-next-line no-use-before-define
    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {
      for (const v of Object.values(obj)) {
        setBuffersToJSON(v, fn);
      }
    }
  }
}

function b64this() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64(this);
}

function b64urlThis() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64url(this);
}

function hexThis() {
  // eslint-disable-next-line no-invalid-this
  return this.toString('hex');
}

function swapEndian(ab, size, byteOffset, byteLength) {
  const dv = new DataView(ab);
  const [getter, setter] = {
    2: [dv.getUint16, dv.setUint16],
    4: [dv.getUint32, dv.setUint32],
    8: [dv.getBigUint64, dv.setBigUint64],
  }[size];

  const end = byteOffset + byteLength;
  for (let offset = byteOffset; offset < end; offset += size) {
    setter.call(dv, offset, getter.call(dv, offset, true));
  }
}

/**
 * Convert a tagged value to a more interesting JavaScript type.  Errors
 * thrown in this function will be captured into the "err" property of the
 * original Tagged instance.
 *
 * @callback TagFunction
 * @param {any} value The value inside the tag.
 * @param {Tagged} tag The enclosing Tagged instance; useful if you want to
 *   modify it and return it.  Also available as "this".
 * @returns {any} The transformed value.
 */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, TagFunction>} TagMap
 */

/**
 * @type {TagMap}
 * @private
 */
const TAGS = {
  // Standard date/time string; see Section 3.4.1
  0: v => new Date(v),
  // Epoch-based date/time; see Section 3.4.2
  1: v => new Date(v * 1000),
  // Positive bignum; see Section 3.4.3
  2: v => utils.bufferToBigInt(v),
  // Negative bignum; see Section 3.4.3
  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),
  // Expected conversion to base64url encoding; see Section 3.4.5.2
  21: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64urlThis;
    } else {
      setBuffersToJSON(v, b64urlThis);
    }
    return tag;
  },
  // Expected conversion to base64 encoding; see Section 3.4.5.2
  22: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64this;
    } else {
      setBuffersToJSON(v, b64this);
    }
    return tag;
  },
  // Expected conversion to base16 encoding; see Section Section 3.4.5.2
  23: (v, tag) => {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = hexThis;
    } else {
      setBuffersToJSON(v, hexThis);
    }
    return tag;
  },
  // URI; see Section 3.4.5.3
  32: v => new URL(v),
  // Base64url; see Section 3.4.5.3
  33: (v, tag) => {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {
      throw new Error('Invalid base64url characters');
    }
    const last = v.length % 4;
    if (last === 1) {
      throw new Error('Invalid base64url length');
    }
    // -  the padding bits in a 2- or 3-character block are not 0, or
    if (last === 2) {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (last === 3) {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    }

    //    Or
    // -  the base64url encoding has padding characters,
    // (caught above)

    // the string is invalid.
    return tag;
  },
  // Base64; see Section 3.4.5.3
  34: (v, tag) => {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);
    if (!m) {
      throw new Error('Invalid base64 characters');
    }
    if ((v.length % 4) !== 0) {
      throw new Error('Invalid base64 length');
    }
    // -  the padding bits in a 2- or 3-character block are not 0, or
    if (m.groups.padding === '=') {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (m.groups.padding === '==') {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    }

    // -  the base64 encoding has the wrong number of padding characters,
    // (caught above)
    // the string is invalid.
    return tag;
  },
  // Regular expression; see Section 2.4.4.3
  35: v => new RegExp(v),
  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  258: v => new Set(v),
};

const TYPED_ARRAY_TAGS = {
  64: Uint8Array,
  65: Uint16Array,
  66: Uint32Array,
  // 67: BigUint64Array,  Safari doesn't implement
  68: Uint8ClampedArray,
  69: Uint16Array,
  70: Uint32Array,
  // 71: BigUint64Array,  Safari doesn't implement
  72: Int8Array,
  73: Int16Array,
  74: Int32Array,
  // 75: BigInt64Array,  Safari doesn't implement
  // 76: reserved
  77: Int16Array,
  78: Int32Array,
  // 79: BigInt64Array,  Safari doesn't implement
  // 80: not implemented, float16 array
  81: Float32Array,
  82: Float64Array,
  // 83: not implemented, float128 array
  // 84: not implemented, float16 array
  85: Float32Array,
  86: Float64Array,
  // 87: not implemented, float128 array
};

// Safari
if (typeof BigUint64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[67] = BigUint64Array;
  TYPED_ARRAY_TAGS[71] = BigUint64Array;
}
if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[75] = BigInt64Array;
  TYPED_ARRAY_TAGS[79] = BigInt64Array;
}

function toTypedArray(val, tagged) {
  if (!utils.isBufferish(val)) {
    throw new TypeError('val not a buffer');
  }
  const {tag} = tagged;
  // See https://tools.ietf.org/html/rfc8746
  const TypedClass = TYPED_ARRAY_TAGS[tag];
  if (!TypedClass) {
    throw new Error(`Invalid typed array tag: ${tag}`);
  }
  const little = tag & 0b00000100;
  const float = (tag & 0b00010000) >> 4;
  const sz = 2 ** (float + (tag & 0b00000011));

  if ((!little !== utils.isBigEndian()) && (sz > 1)) {
    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);
  }

  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
  return new TypedClass(ab);
}

for (const n of Object.keys(TYPED_ARRAY_TAGS)) {
  TAGS[n] = toTypedArray;
}

/**
 * @type {TagMap}
 * @private
 */
let current_TAGS = {};

/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */
class Tagged {
  /**
   * Creates an instance of Tagged.
   *
   * @param {number} tag The number of the tag.
   * @param {any} value The value inside the tag.
   * @param {Error} [err] The error that was thrown parsing the tag, or null.
   */
  constructor(tag, value, err) {
    this.tag = tag;
    this.value = value;
    this.err = err;
    if (typeof this.tag !== 'number') {
      throw new Error(`Invalid tag type (${typeof this.tag})`);
    }
    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {
      throw new Error(`Tag must be a positive integer: ${this.tag}`);
    }
  }

  toJSON() {
    if (this[INTERNAL_JSON]) {
      return this[INTERNAL_JSON].call(this.value);
    }
    const ret = {
      tag: this.tag,
      value: this.value,
    };
    if (this.err) {
      ret.err = this.err;
    }
    return ret;
  }

  /**
   * Convert to a String.
   *
   * @returns {string} String of the form '1(2)'.
   */
  toString() {
    return `${this.tag}(${JSON.stringify(this.value)})`;
  }

  /**
   * Push the simple value onto the CBOR stream.
   *
   * @param {object} gen The generator to push onto.
   * @returns {boolean} True on success.
   */
  encodeCBOR(gen) {
    gen._pushTag(this.tag);
    return gen.pushAny(this.value);
  }

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is 'null' instead
   * of a function.
   *
   * @param {object} converters Keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} The converted item.
   */
  convert(converters) {
    let f = (converters == null) ? undefined : converters[this.tag];
    if (f === null) { // === is intentional. null has semantic meaning as above
      return this;
    }
    if (typeof f !== 'function') {
      f = Tagged.TAGS[this.tag];
      if (typeof f !== 'function') {
        return this;
      }
    }
    try {
      return f.call(this, this.value, this);
    } catch (error) {
      if (error && error.message && (error.message.length > 0)) {
        this.err = error.message;
      } else {
        this.err = error;
      }
      return this;
    }
  }

  /**
   * The current set of supported tags.  May be modified by plugins.
   *
   * @type {TagMap}
   * @static
   */
  static get TAGS() {
    return current_TAGS;
  }

  static set TAGS(val) {
    current_TAGS = val;
  }

  /**
   * Reset the supported tags to the original set, before any plugins modified
   * the list.
   */
  static reset() {
    Tagged.TAGS = {...TAGS};
  }
}
Tagged.INTERNAL_JSON = INTERNAL_JSON;
Tagged.reset();
module.exports = Tagged;


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");
const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js");
const {NUMBYTES, SHIFT32, BI, SYMS} = constants;
const MAX_SAFE_HIGH = 0x1fffff;

/**
 * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error
 * on invalid UTF8.  Byte Order Marks are not looked at or stripped.
 *
 * @private
 */
const td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true});
exports.utf8 = buf => td.decode(buf);
exports.utf8.checksUTF8 = true;

function isReadable(s) {
  // Is this a readable stream?  In the webpack version, instanceof isn't
  // working correctly.
  if (s instanceof stream.Readable) {
    return true;
  }
  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function');
}

exports.isBufferish = function isBufferish(b) {
  return b &&
    (typeof b === 'object') &&
    ((Buffer.isBuffer(b)) ||
      (b instanceof Uint8Array) ||
      (b instanceof Uint8ClampedArray) ||
      (b instanceof ArrayBuffer) ||
      (b instanceof DataView));
};

exports.bufferishToBuffer = function bufferishToBuffer(b) {
  if (Buffer.isBuffer(b)) {
    return b;
  } else if (ArrayBuffer.isView(b)) {
    return Buffer.from(b.buffer, b.byteOffset, b.byteLength);
  } else if (b instanceof ArrayBuffer) {
    return Buffer.from(b);
  }
  return null;
};

exports.parseCBORint = function parseCBORint(ai, buf) {
  switch (ai) {
    case NUMBYTES.ONE:
      return buf.readUInt8(0);
    case NUMBYTES.TWO:
      return buf.readUInt16BE(0);
    case NUMBYTES.FOUR:
      return buf.readUInt32BE(0);
    case NUMBYTES.EIGHT: {
      const f = buf.readUInt32BE(0);
      const g = buf.readUInt32BE(4);
      if (f > MAX_SAFE_HIGH) {
        return (BigInt(f) * BI.SHIFT32) + BigInt(g);
      }
      return (f * SHIFT32) + g;
    }
    default:
      throw new Error(`Invalid additional info for int: ${ai}`);
  }
};

exports.writeHalf = function writeHalf(buf, half) {
  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught

  // HACK: everyone settle in.  This isn't going to be pretty.
  // Translate cn-cbor's C code (from Carsten Borman):

  // uint32_t be32;
  // uint16_t be16, u16;
  // union {
  //   float f;
  //   uint32_t u;
  // } u32;
  // u32.f = float_val;

  const u32 = Buffer.allocUnsafe(4);
  u32.writeFloatBE(half, 0);
  const u = u32.readUInt32BE(0);

  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */

  // hildjj: If the lower 13 bits aren't 0,
  // we will lose precision in the conversion.
  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13
  if ((u & 0x1FFF) !== 0) {
    return false;
  }

  // Sign, exponent, mantissa
  //   int s16 = (u32.u >> 16) & 0x8000;
  //   int exp = (u32.u >> 23) & 0xff;
  //   int mant = u32.u & 0x7fffff;

  let s16 = (u >> 16) & 0x8000; // Top bit is sign
  const exp = (u >> 23) & 0xff; // Then 5 bits of exponent
  const mant = u & 0x7fffff;

  // Hildjj: zeros already handled.  Assert if you don't believe me.
  //   if (exp == 0 && mant == 0)
  //     ;              /* 0.0, -0.0 */

  //   else if (exp >= 113 && exp <= 142) /* normalized */
  //     s16 += ((exp - 112) << 10) + (mant >> 13);

  if ((exp >= 113) && (exp <= 142)) {
    s16 += ((exp - 112) << 10) + (mant >> 13);
  } else if ((exp >= 103) && (exp < 113)) {
    // Denormalized numbers
    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */
    //     if (mant & ((1 << (126 - exp)) - 1))
    //       goto float32;         /* loss of precision */
    //     s16 += ((mant + 0x800000) >> (126 - exp));

    if (mant & ((1 << (126 - exp)) - 1)) {
      return false;
    }
    s16 += ((mant + 0x800000) >> (126 - exp));
  } else {
  //   } else if (exp == 255 && mant == 0) { /* Inf */
  //     s16 += 0x7c00;

    // hildjj: Infinity already handled

    //   } else
    //     goto float32;           /* loss of range */

    return false;
  }

  // Done
  //   ensure_writable(3);
  //   u16 = s16;
  //   be16 = hton16p((const uint8_t*)&u16);
  buf.writeUInt16BE(s16);
  return true;
};

exports.parseHalf = function parseHalf(buf) {
  const sign = buf[0] & 0x80 ? -1 : 1;
  const exp = (buf[0] & 0x7C) >> 2;
  const mant = ((buf[0] & 0x03) << 8) | buf[1];
  if (!exp) {
    return sign * 5.9604644775390625e-8 * mant;
  } else if (exp === 0x1f) {
    return sign * (mant ? NaN : Infinity);
  }
  return sign * (2 ** (exp - 25)) * (1024 + mant);
};

exports.parseCBORfloat = function parseCBORfloat(buf) {
  switch (buf.length) {
    case 2:
      return exports.parseHalf(buf);
    case 4:
      return buf.readFloatBE(0);
    case 8:
      return buf.readDoubleBE(0);
    default:
      throw new Error(`Invalid float size: ${buf.length}`);
  }
};

exports.hex = function hex(s) {
  return Buffer.from(s.replace(/^0x/, ''), 'hex');
};

exports.bin = function bin(s) {
  s = s.replace(/\s/g, '');
  let start = 0;
  let end = (s.length % 8) || 8;
  const chunks = [];
  while (end <= s.length) {
    chunks.push(parseInt(s.slice(start, end), 2));
    start = end;
    end += 8;
  }
  return Buffer.from(chunks);
};

exports.arrayEqual = function arrayEqual(a, b) {
  if ((a == null) && (b == null)) {
    return true;
  }
  if ((a == null) || (b == null)) {
    return false;
  }
  return (a.length === b.length) && a.every((elem, i) => elem === b[i]);
};

exports.bufferToBigInt = function bufferToBigInt(buf) {
  return BigInt(`0x${buf.toString('hex')}`);
};

exports.cborValueToString = function cborValueToString(val, float_bytes = -1) {
  switch (typeof val) {
    case 'symbol': {
      switch (val) {
        case SYMS.NULL:
          return 'null';
        case SYMS.UNDEFINED:
          return 'undefined';
        case SYMS.BREAK:
          return 'BREAK';
      }
      // Impossible in node 10
      /* istanbul ignore if */
      if (val.description) {
        return val.description;
      }
      // On node10, Symbol doesn't have description.  Parse it out of the
      // toString value, which looks like `Symbol(foo)`.
      const s = val.toString();
      const m = s.match(/^Symbol\((?<name>.*)\)/);
      /* istanbul ignore if */
      if (m && m.groups.name) {
        // Impossible in node 12+
        /* istanbul ignore next */
        return m.groups.name;
      }
      return 'Symbol';
    }
    case 'string':
      return JSON.stringify(val);
    case 'bigint':
      return val.toString();
    case 'number': {
      const s = Object.is(val, -0) ? '-0' : String(val);
      return (float_bytes > 0) ? `${s}_${float_bytes}` : s;
    }
    case 'object': {
      if (!val) {
        return 'null';
      }
      const buf = exports.bufferishToBuffer(val);
      if (buf) {
        const hex = buf.toString('hex');
        return (float_bytes === -Infinity) ? hex : `h'${hex}'`;
      }
      if (val && typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {
        return val[Symbol.for('nodejs.util.inspect.custom')]();
      }
      // Shouldn't get non-empty arrays here
      if (Array.isArray(val)) {
        return '[]';
      }
      // This should be all that is left
      return '{}';
    }
  }
  return String(val);
};

exports.guessEncoding = function guessEncoding(input, encoding) {
  if (typeof input === 'string') {
    return new NoFilter(input, (encoding == null) ? 'hex' : encoding);
  }
  const buf = exports.bufferishToBuffer(input);
  if (buf) {
    return new NoFilter(buf);
  }
  if (isReadable(input)) {
    return input;
  }
  throw new Error('Unknown input type');
};

const B64URL_SWAPS = {
  '=': '',
  '+': '-',
  '/': '_',
};

/**
 * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf
 *   Buffer to convert.
 * @returns {string} Base64url string.
 * @private
 */
exports.base64url = function base64url(buf) {
  return exports.bufferishToBuffer(buf)
    .toString('base64')
    .replace(/[=+/]/g, c => B64URL_SWAPS[c]);
};

/**
 * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf
 *   Buffer to convert.
 * @returns {string} Base64 string.
 * @private
 */
exports.base64 = function base64(buf) {
  return exports.bufferishToBuffer(buf).toString('base64');
};

exports.isBigEndian = function isBigEndian() {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !((view[0] = 1) & array[0]);
};


/***/ }),

/***/ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Tweaked version of nathan7's binary-parse-stream
// (see https://github.com/nathan7/binary-parse-stream)
// Uses NoFilter instead of the readable in the original.  Removes
// the ability to read -1, which was odd and un-needed.
// License for binary-parse-stream: MIT

// binary-parse-stream is now unmaintained, so I have rewritten it as
// more modern JS so I can get tsc to help check types.


// eslint-disable-next-line n/prefer-node-protocol
const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const NoFilter = __webpack_require__(/*! nofilter */ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js");

/**
 * BinaryParseStream is a TransformStream that consumes buffers and outputs
 * objects on the other end.  It expects your subclass to implement a `_parse`
 * method that is a generator.  When your generator yields a number, it'll be
 * fed a buffer of that length from the input.  When your generator returns,
 * the return value will be pushed to the output side.
 *
 * @extends stream.Transform
 */
class BinaryParseStream extends stream.Transform {
  /**
   * Creates an instance of BinaryParseStream.
   *
   * @memberof BinaryParseStream
   * @param {stream.TransformOptions} options Stream options.
   */
  constructor(options) {
    super(options);
    // Doesn't work to pass these in as opts, for some reason
    // also, work around typescript not knowing TransformStream internals
    // eslint-disable-next-line dot-notation
    this['_writableState'].objectMode = false;
    // eslint-disable-next-line dot-notation
    this['_readableState'].objectMode = true;

    this.bs = new NoFilter();
    this.__restart();
  }

  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} _encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _transform(fresh, _encoding, cb) {
    this.bs.write(fresh);

    while (this.bs.length >= this.__needed) {
      let ret = null;
      const chunk = (this.__needed === null) ?
        undefined :
        this.bs.read(this.__needed);

      try {
        ret = this.__parser.next(chunk);
      } catch (e) {
        return cb(e);
      }

      if (this.__needed) {
        this.__fresh = false;
      }

      if (ret.done) {
        this.push(ret.value);
        this.__restart();
      } else {
        this.__needed = ret.value || Infinity;
      }
    }

    return cb();
  }

  /**
   * Subclasses must override this to set their parsing behavior.  Yield a
   * number to receive a Buffer of that many bytes.
   *
   * @abstract
   * @returns {Generator<number, any, Buffer>}
   */
  /* istanbul ignore next */
  *_parse() { // eslint-disable-line class-methods-use-this, require-yield
    throw new Error('Must be implemented in subclass');
  }

  __restart() {
    this.__needed = null;
    this.__parser = this._parse();
    this.__fresh = true;
  }

  /**
   * Flushing.
   *
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */
  _flush(cb) {
    cb(this.__fresh ? null : new Error('unexpected end of input'));
  }
}

module.exports = BinaryParseStream;


/***/ }),

/***/ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
var Transform = (__webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js").Transform);
var StringDecoder = (__webpack_require__(/*! string_decoder */ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

function CipherBase(hashMode) {
	Transform.call(this);
	this.hashMode = typeof hashMode === 'string';
	if (this.hashMode) {
		this[hashMode] = this._finalOrDigest;
	} else {
		this['final'] = this._finalOrDigest;
	}
	if (this._final) {
		this.__final = this._final;
		this._final = null;
	}
	this._decoder = null;
	this._encoding = null;
}
inherits(CipherBase, Transform);

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
	&& typeof Uint8Array !== 'undefined'
	&& ArrayBuffer.isView
	&& (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

function toBuffer(data, encoding) {
	/*
	 * No need to do anything for exact instance
	 * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed
	 */
	if (data instanceof Buffer) {
		return data;
	}

	// Convert strings to Buffer
	if (typeof data === 'string') {
		return Buffer.from(data, encoding);
	}

	/*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */
	if (useArrayBuffer && ArrayBuffer.isView(data)) {
		// Bug in Node.js <6.3.1, which treats this as out-of-bounds
		if (data.byteLength === 0) {
			return Buffer.alloc(0);
		}

		var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
		/*
		 * Recheck result size, as offset/length doesn't work on Node.js <5.10
		 * We just go to Uint8Array case if this fails
		 */
		if (res.byteLength === data.byteLength) {
			return res;
		}
	}

	/*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */
	if (useUint8Array && data instanceof Uint8Array) {
		return Buffer.from(data);
	}

	/*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */
	if (
		Buffer.isBuffer(data)
			&& data.constructor
			&& typeof data.constructor.isBuffer === 'function'
			&& data.constructor.isBuffer(data)
	) {
		return Buffer.from(data);
	}

	throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	var bufferData = toBuffer(data, inputEnc); // asserts correct input type
	var outData = this._update(bufferData);
	if (this.hashMode) {
		return this;
	}

	if (outputEnc) {
		outData = this._toString(outData, outputEnc);
	}

	return outData;
};

CipherBase.prototype.setAutoPadding = function () {};
CipherBase.prototype.getAuthTag = function () {
	throw new Error('trying to get auth tag in unsupported state');
};

CipherBase.prototype.setAuthTag = function () {
	throw new Error('trying to set auth tag in unsupported state');
};

CipherBase.prototype.setAAD = function () {
	throw new Error('trying to set aad in unsupported state');
};

CipherBase.prototype._transform = function (data, _, next) {
	var err;
	try {
		if (this.hashMode) {
			this._update(data);
		} else {
			this.push(this._update(data));
		}
	} catch (e) {
		err = e;
	} finally {
		next(err);
	}
};
CipherBase.prototype._flush = function (done) {
	var err;
	try {
		this.push(this.__final());
	} catch (e) {
		err = e;
	}

	done(err);
};
CipherBase.prototype._finalOrDigest = function (outputEnc) {
	var outData = this.__final() || Buffer.alloc(0);
	if (outputEnc) {
		outData = this._toString(outData, outputEnc, true);
	}
	return outData;
};

CipherBase.prototype._toString = function (value, enc, fin) {
	if (!this._decoder) {
		this._decoder = new StringDecoder(enc);
		this._encoding = enc;
	}

	if (this._encoding !== enc) {
		throw new Error('cant switch encodings');
	}

	var out = this._decoder.write(value);
	if (fin) {
		out += this._decoder.end();
	}

	return out;
};

module.exports = CipherBase;


/***/ }),

/***/ "./node_modules/.pnpm/create-ecdh@4.0.4/node_modules/create-ecdh/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/create-ecdh@4.0.4/node_modules/create-ecdh/browser.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
var elliptic = __webpack_require__(/*! elliptic */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js")

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js")

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ "./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Legacy = __webpack_require__(/*! ./legacy */ "./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js")

var sha = __webpack_require__(/*! sha.js */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js")

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ "./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var Base = __webpack_require__(/*! cipher-base */ "./node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js")

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// eslint-disable-next-line no-multi-assign
exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js");

// eslint-disable-next-line no-multi-assign
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js");

// eslint-disable-next-line no-multi-assign
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ "./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js");

var algos = __webpack_require__(/*! browserify-sign/algos */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/algos.js");
var algoKeys = Object.keys(algos);
var hashes = [
	'sha1',
	'sha224',
	'sha256',
	'sha384',
	'sha512',
	'md5',
	'rmd160'
].concat(algoKeys);

exports.getHashes = function () {
	return hashes;
};

var p = __webpack_require__(/*! pbkdf2 */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/browser.js");
exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;

var aes = __webpack_require__(/*! browserify-cipher */ "./node_modules/.pnpm/browserify-cipher@1.0.1/node_modules/browserify-cipher/browser.js");

exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;

var dh = __webpack_require__(/*! diffie-hellman */ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/browser.js");

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;

var sign = __webpack_require__(/*! browserify-sign */ "./node_modules/.pnpm/browserify-sign@4.2.3/node_modules/browserify-sign/browser/index.js");

exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;

exports.createECDH = __webpack_require__(/*! create-ecdh */ "./node_modules/.pnpm/create-ecdh@4.0.4/node_modules/create-ecdh/browser.js");

var publicEncrypt = __webpack_require__(/*! public-encrypt */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/browser.js");

exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt;

// the least I can do is make error messages for the rest of the node.js/crypto api.
// [
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error('sorry, ' + name + ' is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
//   };
// });

var rf = __webpack_require__(/*! randomfill */ "./node_modules/.pnpm/randomfill@1.0.4/node_modules/randomfill/browser.js");

exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;

exports.createCredentials = function () {
	throw new Error('sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
};

exports.constants = {
	DH_CHECK_P_NOT_SAFE_PRIME: 2,
	DH_CHECK_P_NOT_PRIME: 1,
	DH_UNABLE_TO_CHECK_GENERATOR: 4,
	DH_NOT_SUITABLE_GENERATOR: 8,
	NPN_ENABLED: 1,
	ALPN_ENABLED: 1,
	RSA_PKCS1_PADDING: 1,
	RSA_SSLV23_PADDING: 2,
	RSA_NO_PADDING: 3,
	RSA_PKCS1_OAEP_PADDING: 4,
	RSA_X931_PADDING: 5,
	RSA_PKCS1_PSS_PADDING: 6,
	POINT_CONVERSION_COMPRESSED: 2,
	POINT_CONVERSION_UNCOMPRESSED: 4,
	POINT_CONVERSION_HYBRID: 6
};


/***/ }),

/***/ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js");
exports.Cipher = __webpack_require__(/*! ./des/cipher */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js");
exports.DES = __webpack_require__(/*! ./des/des */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js");
exports.CBC = __webpack_require__(/*! ./des/cbc */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cbc.js");
exports.EDE = __webpack_require__(/*! ./des/ede */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/ede.js");


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cbc.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cbc.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
  this.padding = options.padding !== false
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js");
var Cipher = __webpack_require__(/*! ./cipher */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js");

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  if (this.padding === false) {
    return false;
  }

  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  if (this.padding === false) {
    return buffer;
  }

  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/ede.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/ede.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

var Cipher = __webpack_require__(/*! ./cipher */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js");
var DES = __webpack_require__(/*! ./des */ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js");

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ "./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/browser.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js")
var primes = __webpack_require__(/*! ./lib/primes.json */ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/primes.json")

var DH = __webpack_require__(/*! ./lib/dh */ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/dh.js")

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman


/***/ }),

/***/ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/dh.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/dh.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js");
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ "./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/primes.json":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/primes.json ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}');

/***/ }),

/***/ "./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var elliptic = exports;

elliptic.version = (__webpack_require__(/*! ../package.json */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json").version);
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js");
var curve = __webpack_require__(/*! ./curve */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var curves = __webpack_require__(/*! ../curves */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js");
var rand = __webpack_require__(/*! brorand */ "./node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js");
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
  var byteLength;
  if (BN.isBN(msg) || typeof msg === 'number') {
    msg = new BN(msg, 16);
    byteLength = msg.byteLength();
  } else if (typeof msg === 'object') {
    // BN assumes an array-like input and asserts length
    byteLength = msg.length;
    msg = new BN(msg, 16);
  } else {
    // BN converts the value to string
    var str = msg.toString();
    // HEX encoding
    byteLength = (str.length + 1) >>> 1;
    msg = new BN(str, 16);
  }
  // Allow overriding
  if (typeof bitLength !== 'number') {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  if (typeof msg !== 'string' && typeof msg !== 'number' && !BN.isBN(msg)) {
    assert(typeof msg === 'object' && msg && typeof msg.length === 'number',
      'Expected message to be an array-like, a hex string, or a BN instance');
    assert((msg.length >>> 0) === msg.length); // non-negative 32-bit integer
    for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
  }

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(msg, false, options.msgBitLength);

  // Would fail further checks, but let's make the error message clear
  assert(!msg.isNeg(), 'Can not sign a negative message');

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Recheck nonce to be bijective to msg
  assert((new BN(nonce)).eq(msg), 'Can not sign message');

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc, options) {
  if (!options)
    options = {};

  msg = this._truncateToN(msg, false, options.msgBitLength);
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature, options) {
  return this.ec.verify(msg, signature, this, undefined, options);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  if(buf[p.place] === 0x00) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js");
var curves = __webpack_require__(/*! ../curves */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    assert(sig.length === eddsa.encodingLength * 2, 'Signature has invalid size');
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*******************************************************************************************************/
/***/ ((module) => {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  var i;
  for (i = 0; i < naf.length; i += 1) {
    naf[i] = 0;
  }

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"elliptic","version":"6.6.1","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

/***/ }),

/***/ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js")

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ "./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};


/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");

var abs = __webpack_require__(/*! math-intrinsics/abs */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__(/*! math-intrinsics/floor */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
var max = __webpack_require__(/*! math-intrinsics/max */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
var min = __webpack_require__(/*! math-intrinsics/min */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
var pow = __webpack_require__(/*! math-intrinsics/pow */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
var round = __webpack_require__(/*! math-intrinsics/round */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
var sign = __webpack_require__(/*! math-intrinsics/sign */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();

var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__(/*! dunder-proto/get */ "./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js":
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(/*! ./gOPD */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/.pnpm/hash-base@3.0.5/node_modules/hash-base/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/hash-base@3.0.5/node_modules/hash-base/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var Transform = (__webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js").Transform)
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

var useUint8Array = typeof Uint8Array !== 'undefined'
var useArrayBuffer = typeof ArrayBuffer !== 'undefined' &&
  typeof Uint8Array !== 'undefined' &&
  ArrayBuffer.isView &&
  (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT)

function toBuffer (data, encoding) {
  // No need to do anything for exact instance
  // This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed
  if (data instanceof Buffer) return data

  // Convert strings to Buffer
  if (typeof data === 'string') return Buffer.from(data, encoding)

  /*
   * Wrap any TypedArray instances and DataViews
   * Makes sense only on engines with full TypedArray support -- let Buffer detect that
   */
  if (useArrayBuffer && ArrayBuffer.isView(data)) {
    if (data.byteLength === 0) return Buffer.alloc(0) // Bug in Node.js <6.3.1, which treats this as out-of-bounds
    var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength)
    // Recheck result size, as offset/length doesn't work on Node.js <5.10
    // We just go to Uint8Array case if this fails
    if (res.byteLength === data.byteLength) return res
  }

  /*
   * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
   * Doesn't make sense with other TypedArray instances
   */
  if (useUint8Array && data instanceof Uint8Array) return Buffer.from(data)

  /*
   * Old Buffer polyfill on an engine that doesn't have TypedArray support
   * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
   * Convert to our current Buffer implementation
   */
  if (
    Buffer.isBuffer(data) &&
    data.constructor &&
    typeof data.constructor.isBuffer === 'function' &&
    data.constructor.isBuffer(data)
  ) {
    return Buffer.from(data)
  }

  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.')
}

HashBase.prototype.update = function (data, encoding) {
  if (this._finalized) throw new Error('Digest already called')

  data = toBuffer(data, encoding) // asserts correct input type

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js ***!
  \*************************************************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");

var $toString = callBound('Object.prototype.toString');

/** @type {import('.')} */
var isStandardArguments = function isArguments(value) {
	if (
		hasToStringTag
		&& value
		&& typeof value === 'object'
		&& Symbol.toStringTag in value
	) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

/** @type {import('.')} */
var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null
		&& typeof value === 'object'
		&& 'length' in value
		&& typeof value.length === 'number'
		&& value.length >= 0
		&& $toString(value) !== '[object Array]'
		&& 'callee' in value
		&& $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

/** @type {import('.')} */
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var safeRegexTest = __webpack_require__(/*! safe-regex-test */ "./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js");
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');

var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
/** @type {undefined | false | null | GeneratorFunctionConstructor} */
var GeneratorFunction;

/** @type {import('.')} */
module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex(fnToStr(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc
			// eslint-disable-next-line no-extra-parens
			? /** @type {GeneratorFunctionConstructor} */ (getProto(generatorFunc))
			: false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
var fn;

if (hasToStringTag) {
	/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
	var $exec = callBound('RegExp.prototype.exec');
	/** @type {object} */
	var isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
	var badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}

	/** @type {import('.')} */
	// @ts-expect-error TS can't figure out that the $exec call always throws
	// eslint-disable-next-line consistent-return
	fn = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			// eslint-disable-next-line no-extra-parens
			$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
		} catch (e) {
			return e === isRegexMarker;
		}
	};
} else {
	/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
	var $toString = callBound('Object.prototype.toString');
	/** @const @type {'[object RegExp]'} */
	var regexClass = '[object RegExp]';

	/** @type {import('.')} */
	fn = function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};
}

module.exports = fn;


/***/ }),

/***/ "./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ./isNaN */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ "./node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/.pnpm/hash-base@3.0.5/node_modules/hash-base/index.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bn = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js");
var brorand = __webpack_require__(/*! brorand */ "./node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js");

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js")
const {Buffer} = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")
const td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})

/**
 * @typedef {object} NoFilterOptions
 * @property {string|Buffer} [input=null] Input source data.
 * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,
 *   ignored if input is not a String.
 * @property {number} [highWaterMark=16384] The maximum number of bytes to
 *   store in the internal buffer before ceasing to read from the underlying
 *   resource. Default=16kb, or 16 for objectMode streams.
 * @property {BufferEncoding} [encoding=null] If specified, then buffers
 *   will be decoded to strings using the specified encoding.
 * @property {boolean} [objectMode=false] Whether this stream should behave
 *   as a stream of objects. Meaning that stream.read(n) returns a single
 *   value instead of a Buffer of size n.
 * @property {boolean} [decodeStrings=true] Whether or not to decode
 *   strings into Buffers before passing them to _write().
 * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,
 *   setting this stream's objectMode based on the objectMode of the input
 *   stream.
 * @property {boolean} [readError=false] If true, when a read() underflows,
 *   throw an error.
 * @property {boolean} [allowHalfOpen=true] If set to false, then the
 *   stream will automatically end the writable side when the readable side
 *   ends.
 * @property {boolean} [autoDestroy=true] Whether this stream should
 *   automatically call .destroy() on itself after ending.
 * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding
 *   that is used when no encoding is specified as an argument to
 *   stream.write().
 * @property {boolean} [emitClose=true] Whether or not the stream should
 *   emit 'close' after it has been destroyed.
 * @property {number} [readableHighWaterMark] Sets highWaterMark for the
 *   readable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [readableObjectMode=false] Sets objectMode for
 *   readable side of the stream. Has no effect if objectMode is true.
 * @property {number} [writableHighWaterMark] Sets highWaterMark for the
 *   writable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [writableObjectMode=false] Sets objectMode for
 *   writable side of the stream. Has no effect if objectMode is true.
 */

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source and sink</caption>
 * const source = new NoFilter('Zm9v', 'base64')
 * source.pipe(process.stdout)
 * const sink = new Nofilter()
 * // NOTE: 'finish' fires when the input is done writing
 * sink.on('finish', () => console.log(n.toString('base64')))
 * process.stdin.pipe(sink)
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.
   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding
   *   name for input, ignored if input is not a String.
   * @param {NoFilterOptions} [options] Other options.
   */
  constructor(input, inputEncoding, options = {}) {
    let inp = null
    let inpE = /** @type {BufferEncoding?} */ (null)
    switch (typeof input) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
        } else if (input) {
          options = input
        }
        break
      case 'string':
        inp = input
        break
      case 'undefined':
        break
      default:
        throw new TypeError('Invalid input')
    }
    switch (typeof inputEncoding) {
      case 'object':
        if (inputEncoding) {
          options = inputEncoding
        }
        break
      case 'string':
        inpE = /** @type {BufferEncoding} */ (inputEncoding)
        break
      case 'undefined':
        break
      default:
        throw new TypeError('Invalid inputEncoding')
    }
    if (!options || typeof options !== 'object') {
      throw new TypeError('Invalid options')
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe == null ? true : options.watchPipe
    delete options.watchPipe
    const readError = Boolean(options.readError)
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        // @ts-ignore: TS2339 (using internal interface)
        const om = readable._readableState.objectMode
        // @ts-ignore: TS2339 (using internal interface)
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream'
          )
        }

        // @ts-ignore: TS2339 (using internal interface)
        this._readableState.objectMode = om
        // @ts-ignore: TS2339 (using internal interface)
        this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {object} obj The object to test.
   * @returns {boolean} True if obj is a NoFilter.
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 The first object to compare.
   * @param {NoFilter} nf2 The second object to compare.
   * @returns {number} -1, 0, 1 for less, equal, greater.
   * @throws {TypeError} Arguments not NoFilter instances.
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')]
   * arr.sort(NoFilter.compare)
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    }
    return nf1.compare(nf2)
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read.
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer.
   * @throws {TypeError} List not array of NoFilters.
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      // @ts-ignore: TS2322, tsc can't see the type checking above
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @ignore
   */
  _transform(chunk, encoding, callback) {
    // @ts-ignore: TS2339 (using internal interface)
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @returns {Buffer[]} The current internal buffers.  They are layed out
   *   end to end.
   * @ignore
   */
  _bufArray() {
    // @ts-ignore: TS2339 (using internal interface)
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer.
   * @throws Error If readError is true and there was underflow.
   * @fires NoFilter#read When read from.
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /**
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @param {Buffer|string|object} buf What was read.
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Read the full number of bytes asked for, no matter how long it takes.
   * Fail if an error occurs in the meantime, or if the stream finishes before
   * enough data is available.
   *
   * Note: This function won't work fully correctly if you are using
   * stream-browserify (for example, on the Web).
   *
   * @param {number} size The number of bytes to read.
   * @returns {Promise<string|Buffer>} A promise for the data read.
   */
  readFull(size) {
    let onReadable = null
    let onFinish = null
    let onError = null
    return new Promise((resolve, reject) => {
      if (this.length >= size) {
        resolve(this.read(size))
        return
      }

      // Added in Node 12.19.  This won't work with stream-browserify yet.
      // If it's needed, file a bug, and I'll do a work-around.
      if (this.writableFinished) {
        // Already finished writing, so no more coming.
        reject(new Error(`Stream finished before ${size} bytes were available`))
        return
      }

      onReadable = chunk => {
        if (this.length >= size) {
          resolve(this.read(size))
        }
      }
      onFinish = () => {
        reject(new Error(`Stream finished before ${size} bytes were available`))
      }
      onError = reject
      this.on('readable', onReadable)
      this.on('error', onError)
      this.on('finish', onFinish)
    }).finally(() => {
      if (onReadable) {
        this.removeListener('readable', onReadable)
        this.removeListener('error', onError)
        this.removeListener('finish', onFinish)
      }
    })
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {Function} [cb=null] Finished/error callback used in *addition*
   *   to the promise.
   * @returns {Promise<Buffer|string>} Fulfilled when complete.
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', er => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other The other object to compare.
   * @returns {number} -1, 0, 1 for less, equal, greater.
   * @throws {TypeError} Arguments must be NoFilters.
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    }

    const buf1 = this.slice()
    const buf2 = other.slice()
    // These will both be buffers because of the check above.
    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
      return buf1.compare(buf2)
    }
    throw new Error('Cannot compare streams in object mode')
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other Other NoFilter to compare against.
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {number} [start=0] Beginning offset.
   * @param {number} [end=length] Ending offset.
   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    // @ts-ignore: TS2339 (using internal interface)
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default: {
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
      }
    }
  }

  /**
   * Get a byte by offset.  I didn't want to get into metaprogramming
   * to give you the `NoFilter[0]` syntax.
   *
   * @param {number} index The byte to retrieve.
   * @returns {number} 0-255.
   */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so that
   * round-tripping will produce a Buffer.
   *
   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,
   *   the objects.  Otherwise, JSON text.
   * @example <caption>output for 'foo', not in object mode</caption>
   * ({
   *   type: 'Buffer',
   *   data: [102, 111, 111],
   * })
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    }
    return b
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?
   * @param {number} [start=0] Start offset.
   * @param {number} [end=length] End offset.
   * @returns {string} String version of the contents.
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if (!encoding || (encoding === 'utf8')) {
      return td.decode(buf)
    }
    return buf.toString(encoding)
  }

  /**
   * @ignore
   */
  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map(b => {
      if (Buffer.isBuffer(b)) {
        return options.stylize(b.toString('hex'), 'string')
      }
      return JSON.stringify(b)
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @returns {number} Length of the contents.
   */
  get length() {
    // @ts-ignore: TS2339 (using internal interface)
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val The value to write.
   * @returns {boolean} True on success.
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // Two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = `0${str}`
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number} [len=null] Number of bytes to read or all remaining
   *   if null.
   * @returns {bigint} A BigInt.
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt(`0x${b.toString('hex')}`)
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] Number of bytes to read or all remaining
   *   if null.
   * @returns {bigint} A BigInt.
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt(`0x${b.toString('hex')}`)
    // Negative?
    if (b[0] & 0x80) {
      // Two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret -= mask
    }
    return ret
  }

  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @param {number} value 0..255.
   * @returns {boolean} True on success.
   */
  writeUInt8(value) {
    const b = Buffer.from([value])
    return this.push(b)
  }

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @param {number} value 0..65535.
   * @returns {boolean} True on success.
   */
  writeUInt16LE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16LE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @param {number} value 0..65535.
   * @returns {boolean} True on success.
   */
  writeUInt16BE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16BE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @param {number} value 0..2**32-1.
   * @returns {boolean} True on success.
   */
  writeUInt32LE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32LE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @param {number} value 0..2**32-1.
   * @returns {boolean} True on success.
   */
  writeUInt32BE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32BE(value)
    return this.push(b)
  }

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @param {number} value (-128)..127.
   * @returns {boolean} True on success.
   */
  writeInt8(value) {
    const b = Buffer.from([value])
    return this.push(b)
  }

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @param {number} value (-32768)..32767.
   * @returns {boolean} True on success.
   */
  writeInt16LE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @param {number} value (-32768)..32767.
   * @returns {boolean} True on success.
   */
  writeInt16BE(value) {
    const b = Buffer.alloc(2)
    b.writeUInt16BE(value)
    return this.push(b)
  }

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @param {number} value (-2**31)..(2**31-1).
   * @returns {boolean} True on success.
   */
  writeInt32LE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @param {number} value (-2**31)..(2**31-1).
   * @returns {boolean} True on success.
   */
  writeInt32BE(value) {
    const b = Buffer.alloc(4)
    b.writeUInt32BE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @param {number} value 32-bit float.
   * @returns {boolean} True on success.
   */
  writeFloatLE(value) {
    const b = Buffer.alloc(4)
    b.writeFloatLE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @param {number} value 32-bit float.
   * @returns {boolean} True on success.
   */
  writeFloatBE(value) {
    const b = Buffer.alloc(4)
    b.writeFloatBE(value)
    return this.push(b)
  }

  /**
   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.
   *
   * @param {number} value 64-bit float.
   * @returns {boolean} True on success.
   */
  writeDoubleLE(value) {
    const b = Buffer.alloc(8)
    b.writeDoubleLE(value)
    return this.push(b)
  }

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @param {number} value 64-bit float.
   * @returns {boolean} True on success.
   */
  writeDoubleBE(value) {
    const b = Buffer.alloc(8)
    b.writeDoubleBE(value)
    return this.push(b)
  }

  /**
   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value BigInt.
   * @returns {boolean} True on success.
   */
  writeBigInt64LE(value) {
    const b = Buffer.alloc(8)
    b.writeBigInt64LE(value)
    return this.push(b)
  }

  /**
   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value BigInt.
   * @returns {boolean} True on success.
   */
  writeBigInt64BE(value) {
    const b = Buffer.alloc(8)
    b.writeBigInt64BE(value)
    return this.push(b)
  }

  /**
   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value Non-negative BigInt.
   * @returns {boolean} True on success.
   */
  writeBigUInt64LE(value) {
    const b = Buffer.alloc(8)
    b.writeBigUInt64LE(value)
    return this.push(b)
  }

  /**
   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
   *
   * @param {bigint} value Non-negative BigInt.
   * @returns {boolean} True on success.
   */
  writeBigUInt64BE(value) {
    const b = Buffer.alloc(8)
    b.writeBigUInt64BE(value)
    return this.push(b)
  }

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @returns {number} Value read.
   */
  readUInt8() {
    const b = this.read(1)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt8()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt16LE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt16LE()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt16BE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt16BE()
  }

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt32LE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt32LE()
  }

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readUInt32BE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readUInt32BE()
  }

  /**
   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @returns {number} Value read.
   */
  readInt8() {
    const b = this.read(1)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt8()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readInt16LE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt16LE()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @returns {number} Value read.
   */
  readInt16BE() {
    const b = this.read(2)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt16BE()
  }

  /**
   * Read a little-endian signed 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readInt32LE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt32LE()
  }

  /**
   * Read a little-endian signed 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readInt32BE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readInt32BE()
  }

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readFloatLE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readFloatLE()
  }

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @returns {number} Value read.
   */
  readFloatBE() {
    const b = this.read(4)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readFloatBE()
  }

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @returns {number} Value read.
   */
  readDoubleLE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readDoubleLE()
  }

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @returns {number} Value read.
   */
  readDoubleBE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readDoubleBE()
  }

  /**
   * Read a signed 64-bit little-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigInt64LE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigInt64LE()
  }

  /**
   * Read a signed 64-bit big-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigInt64BE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigInt64BE()
  }

  /**
   * Read an unsigned 64-bit little-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigUInt64LE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigUInt64LE()
  }

  /**
   * Read an unsigned 64-bit big-endian BigInt from the stream.
   * Consumes 8 bytes.
   *
   * @returns {bigint} Value read.
   */
  readBigUInt64BE() {
    const b = this.read(8)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b.readBigUInt64BE()
  }
}

module.exports = NoFilter


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = $Object(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = $Object(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


/***/ }),

/***/ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js");

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/aesid.json":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/aesid.json ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}');

/***/ }),

/***/ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/asn1.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/asn1.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.



var asn1 = __webpack_require__(/*! asn1.js */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js");

exports.certificate = __webpack_require__(/*! ./certificate */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/certificate.js");

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('modulus')['int'](),
		this.key('publicExponent')['int'](),
		this.key('privateExponent')['int'](),
		this.key('prime1')['int'](),
		this.key('prime2')['int'](),
		this.key('exponent1')['int'](),
		this.key('exponent2')['int'](),
		this.key('coefficient')['int']()
	);
});
exports.RSAPrivateKey = RSAPrivateKey;

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
	this.seq().obj(
		this.key('modulus')['int'](),
		this.key('publicExponent')['int']()
	);
});
exports.RSAPublicKey = RSAPublicKey;

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('none').null_().optional(),
		this.key('curve').objid().optional(),
		this.key('params').seq().obj(
			this.key('p')['int'](),
			this.key('q')['int'](),
			this.key('g')['int']()
		).optional()
	);
});

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});
exports.PublicKey = PublicKey;

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPrivateKey').octstr()
	);
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').seq().obj(
			this.key('id').objid(),
			this.key('decrypt').seq().obj(
				this.key('kde').seq().obj(
					this.key('id').objid(),
					this.key('kdeparams').seq().obj(
						this.key('salt').octstr(),
						this.key('iters')['int']()
					)
				),
				this.key('cipher').seq().obj(
					this.key('algo').objid(),
					this.key('iv').octstr()
				)
			)
		),
		this.key('subjectPrivateKey').octstr()
	);
});

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('p')['int'](),
		this.key('q')['int'](),
		this.key('g')['int'](),
		this.key('pub_key')['int'](),
		this.key('priv_key')['int']()
	);
});
exports.DSAPrivateKey = DSAPrivateKey;

exports.DSAparam = asn1.define('DSAparam', function () {
	this['int']();
});

var ECParameters = asn1.define('ECParameters', function () {
	this.choice({
		namedCurve: this.objid()
	});
});

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('privateKey').octstr(),
		this.key('parameters').optional().explicit(0).use(ECParameters),
		this.key('publicKey').optional().explicit(1).bitstr()
	);
});
exports.ECPrivateKey = ECPrivateKey;

exports.signature = asn1.define('signature', function () {
	this.seq().obj(
		this.key('r')['int'](),
		this.key('s')['int']()
	);
});


/***/ }),

/***/ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/certificate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/certificate.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ "./node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js");

var Time = asn.define('Time', function () {
	this.choice({
		utcTime: this.utctime(),
		generalTime: this.gentime()
	});
});

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
	this.seq().obj(
		this.key('type').objid(),
		this.key('value').any()
	);
});

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('parameters').optional(),
		this.key('curve').objid().optional()
	);
});

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
	this.setof(AttributeTypeValue);
});

var RDNSequence = asn.define('RDNSequence', function () {
	this.seqof(RelativeDistinguishedName);
});

var Name = asn.define('Name', function () {
	this.choice({
		rdnSequence: this.use(RDNSequence)
	});
});

var Validity = asn.define('Validity', function () {
	this.seq().obj(
		this.key('notBefore').use(Time),
		this.key('notAfter').use(Time)
	);
});

var Extension = asn.define('Extension', function () {
	this.seq().obj(
		this.key('extnID').objid(),
		this.key('critical').bool().def(false),
		this.key('extnValue').octstr()
	);
});

var TBSCertificate = asn.define('TBSCertificate', function () {
	this.seq().obj(
		this.key('version').explicit(0)['int']().optional(),
		this.key('serialNumber')['int'](),
		this.key('signature').use(AlgorithmIdentifier),
		this.key('issuer').use(Name),
		this.key('validity').use(Validity),
		this.key('subject').use(Name),
		this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
		this.key('issuerUniqueID').implicit(1).bitstr().optional(),
		this.key('subjectUniqueID').implicit(2).bitstr().optional(),
		this.key('extensions').explicit(3).seqof(Extension).optional()
	);
});

var X509Certificate = asn.define('X509Certificate', function () {
	this.seq().obj(
		this.key('tbsCertificate').use(TBSCertificate),
		this.key('signatureAlgorithm').use(AlgorithmIdentifier),
		this.key('signatureValue').bitstr()
	);
});

module.exports = X509Certificate;


/***/ }),

/***/ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/fixProc.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/fixProc.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = __webpack_require__(/*! evp_bytestokey */ "./node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js");
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js");
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
module.exports = function (okey, password) {
	var key = okey.toString();
	var match = key.match(findProc);
	var decrypted;
	if (!match) {
		var match2 = key.match(fullRegex);
		decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
	} else {
		var suite = 'aes' + match[1];
		var iv = Buffer.from(match[2], 'hex');
		var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
		var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
		var out = [];
		var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
		out.push(cipher.update(cipherText));
		out.push(cipher['final']());
		decrypted = Buffer.concat(out);
	}
	var tag = key.match(startRegex)[1];
	return {
		tag: tag,
		data: decrypted
	};
};


/***/ }),

/***/ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asn1 = __webpack_require__(/*! ./asn1 */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/asn1.js");
var aesid = __webpack_require__(/*! ./aesid.json */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/aesid.json");
var fixProc = __webpack_require__(/*! ./fixProc */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/fixProc.js");
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js");
var compat = __webpack_require__(/*! pbkdf2 */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/browser.js");
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);

function decrypt(data, password) {
	var salt = data.algorithm.decrypt.kde.kdeparams.salt;
	var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
	var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
	var iv = data.algorithm.decrypt.cipher.iv;
	var cipherText = data.subjectPrivateKey;
	var keylen = parseInt(algo.split('-')[1], 10) / 8;
	var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
	var cipher = ciphers.createDecipheriv(algo, key, iv);
	var out = [];
	out.push(cipher.update(cipherText));
	out.push(cipher['final']());
	return Buffer.concat(out);
}

function parseKeys(buffer) {
	var password;
	if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
		password = buffer.passphrase;
		buffer = buffer.key;
	}
	if (typeof buffer === 'string') {
		buffer = Buffer.from(buffer);
	}

	var stripped = fixProc(buffer, password);

	var type = stripped.tag;
	var data = stripped.data;
	var subtype, ndata;
	switch (type) {
		case 'CERTIFICATE':
			ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
			// falls through
		case 'PUBLIC KEY':
			if (!ndata) {
				ndata = asn1.PublicKey.decode(data, 'der');
			}
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
				case '1.2.840.10045.2.1':
					ndata.subjectPrivateKey = ndata.subjectPublicKey;
					return {
						type: 'ec',
						data: ndata
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
					return {
						type: 'dsa',
						data: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'ENCRYPTED PRIVATE KEY':
			data = asn1.EncryptedPrivateKey.decode(data, 'der');
			data = decrypt(data, password);
			// falls through
		case 'PRIVATE KEY':
			ndata = asn1.PrivateKey.decode(data, 'der');
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
				case '1.2.840.10045.2.1':
					return {
						curve: ndata.algorithm.curve,
						privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
					return {
						type: 'dsa',
						params: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'RSA PUBLIC KEY':
			return asn1.RSAPublicKey.decode(data, 'der');
		case 'RSA PRIVATE KEY':
			return asn1.RSAPrivateKey.decode(data, 'der');
		case 'DSA PRIVATE KEY':
			return {
				type: 'dsa',
				params: asn1.DSAPrivateKey.decode(data, 'der')
			};
		case 'EC PRIVATE KEY':
			data = asn1.ECPrivateKey.decode(data, 'der');
			return {
				curve: data.parameters.value,
				privateKey: data.privateKey
			};
		default: throw new Error('unknown key type ' + type);
	}
}
parseKeys.signature = asn1.signature;

module.exports = parseKeys;


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/async.js")
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/async.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/async.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/sync-browser.js")
var toBuffer = __webpack_require__(/*! ./to-buffer */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/to-buffer.js")

var ZERO_BUF
var subtle = __webpack_require__.g.crypto && __webpack_require__.g.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (__webpack_require__.g.process && !__webpack_require__.g.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (__webpack_require__.g.process && __webpack_require__.g.process.nextTick) {
    nextTick = __webpack_require__.g.process.nextTick
  } else if (__webpack_require__.g.queueMicrotask) {
    nextTick = __webpack_require__.g.queueMicrotask
  } else if (__webpack_require__.g.setImmediate) {
    nextTick = __webpack_require__.g.setImmediate
  } else {
    nextTick = __webpack_require__.g.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof __webpack_require__.g.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/default-encoding.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/default-encoding.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
var defaultEncoding
/* istanbul ignore next */
if (__webpack_require__.g.process && __webpack_require__.g.process.browser) {
  defaultEncoding = 'utf-8'
} else if (__webpack_require__.g.process && __webpack_require__.g.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/precondition.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/precondition.js ***!
  \*********************************************************************************/
/***/ ((module) => {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/sync-browser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/sync-browser.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/default-encoding.js")
var toBuffer = __webpack_require__(/*! ./to-buffer */ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/to-buffer.js")

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/to-buffer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/pbkdf2@3.1.2/node_modules/pbkdf2/lib/to-buffer.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}


/***/ }),

/***/ "./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js ***!
  \**************************************************************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];


/***/ }),

/***/ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js ***!
  \****************************************************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/browser.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/publicEncrypt.js")
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/privateDecrypt.js")

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createHash = __webpack_require__(/*! create-hash */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/privateDecrypt.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/privateDecrypt.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/publicEncrypt.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/publicEncrypt.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/.pnpm/parse-asn1@5.1.7/node_modules/parse-asn1/index.js")
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BN = __webpack_require__(/*! bn.js */ "./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ "./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ "./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */



const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
class BufferSourceConverter {
    static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
    }
    static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
            return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        return this.toUint8Array(data.buffer)
            .slice(data.byteOffset, data.byteOffset + data.byteLength)
            .buffer;
    }
    static toUint8Array(data) {
        return this.toView(data, Uint8Array);
    }
    static toView(data, type) {
        if (data.constructor === type) {
            return data;
        }
        if (this.isArrayBuffer(data)) {
            return new type(data);
        }
        if (this.isArrayBufferView(data)) {
            return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
    }
    static isBufferSource(data) {
        return this.isArrayBufferView(data)
            || this.isArrayBuffer(data);
    }
    static isArrayBufferView(data) {
        return ArrayBuffer.isView(data)
            || (data && this.isArrayBuffer(data.buffer));
    }
    static isEqual(a, b) {
        const aView = BufferSourceConverter.toUint8Array(a);
        const bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
            return false;
        }
        for (let i = 0; i < aView.length; i++) {
            if (aView[i] !== bView[i]) {
                return false;
            }
        }
        return true;
    }
    static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
            buffers = args[0];
        }
        else if (Array.isArray(args[0]) && args[1] instanceof Function) {
            buffers = args[0];
        }
        else {
            if (args[args.length - 1] instanceof Function) {
                buffers = args.slice(0, args.length - 1);
            }
            else {
                buffers = args;
            }
        }
        let size = 0;
        for (const buffer of buffers) {
            size += buffer.byteLength;
        }
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer of buffers) {
            const view = this.toUint8Array(buffer);
            res.set(view, offset);
            offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) {
            return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
    }
}

const STRING_TYPE = "string";
const HEX_REGEX = /^[0-9a-f\s]+$/i;
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
class Utf8Converter {
    static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
    }
    static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for (let i = 0; i < buf.length; i++) {
            encodedString += String.fromCharCode(buf[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
}
class Utf16Converter {
    static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
            const code = dataView.getUint16(i, littleEndian);
            res += String.fromCharCode(code);
        }
        return res;
    }
    static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView = new DataView(res);
        for (let i = 0; i < text.length; i++) {
            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
    }
}
class Convert {
    static isHex(data) {
        return typeof data === STRING_TYPE
            && HEX_REGEX.test(data);
    }
    static isBase64(data) {
        return typeof data === STRING_TYPE
            && BASE64_REGEX.test(data);
    }
    static isBase64Url(data) {
        return typeof data === STRING_TYPE
            && BASE64URL_REGEX.test(data);
    }
    static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            case "utf16le":
                return Utf16Converter.toString(buf, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buf);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static FromString(str, enc = "utf8") {
        if (!str) {
            return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            case "utf16le":
                return Utf16Converter.fromString(str, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(str);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf, "binary");
            return btoa(binary);
        }
        else {
            return Buffer.from(buf).toString("base64");
        }
    }
    static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64(formatted)) {
            throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
            return this.FromBinary(atob(formatted));
        }
        else {
            return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
    }
    static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64Url(formatted)) {
            throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    }
    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
            case "ascii":
                return this.FromBinary(text);
            case "utf8":
                return Utf8Converter.fromString(text);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(text);
            case "utf16le":
            case "usc2":
                return Utf16Converter.fromString(text, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
            case "ascii":
                return this.ToBinary(buffer);
            case "utf8":
                return Utf8Converter.toString(buffer);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buffer);
            case "utf16le":
            case "usc2":
                return Utf16Converter.toString(buffer, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
            resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
    }
    static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for (let i = 0; i < buf.length; i++) {
            res += String.fromCharCode(buf[i]);
        }
        return res;
    }
    static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let result = "";
        const len = buf.length;
        for (let i = 0; i < len; i++) {
            const byte = buf[i];
            if (byte < 16) {
                result += "0";
            }
            result += byte.toString(16);
        }
        return result;
    }
    static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isHex(formatted)) {
            throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
            formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i = 0; i < formatted.length; i = i + 2) {
            const c = formatted.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
    }
    static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
    }
    static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
    }
    static Base64Padding(base64) {
        const padCount = 4 - (base64.length % 4);
        if (padCount < 4) {
            for (let i = 0; i < padCount; i++) {
                base64 += "=";
            }
        }
        return base64;
    }
    static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
    }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";

function assign(target, ...sources) {
    const res = arguments[0];
    for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
            res[prop] = obj[prop];
        }
    }
    return res;
}
function combine(...buf) {
    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
    const res = new Uint8Array(totalByteLength);
    let currentPos = 0;
    buf.map((item) => new Uint8Array(item)).forEach((arr) => {
        for (const item2 of arr) {
            res[currentPos++] = item2;
        }
    });
    return res.buffer;
}
function isEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
        return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}

exports.BufferSourceConverter = BufferSourceConverter;
exports.Convert = Convert;
exports.assign = assign;
exports.combine = combine;
exports.isEqual = isEqual;


/***/ }),

/***/ "./node_modules/.pnpm/pvutils@1.1.3/node_modules/pvutils/build/utils.es.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/pvutils@1.1.3/node_modules/pvutils/build/utils.es.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayBufferToString: () => (/* binding */ arrayBufferToString),
/* harmony export */   bufferToHexCodes: () => (/* binding */ bufferToHexCodes),
/* harmony export */   checkBufferParams: () => (/* binding */ checkBufferParams),
/* harmony export */   clearProps: () => (/* binding */ clearProps),
/* harmony export */   fromBase64: () => (/* binding */ fromBase64),
/* harmony export */   getParametersValue: () => (/* binding */ getParametersValue),
/* harmony export */   getUTCDate: () => (/* binding */ getUTCDate),
/* harmony export */   isEqualBuffer: () => (/* binding */ isEqualBuffer),
/* harmony export */   nearestPowerOf2: () => (/* binding */ nearestPowerOf2),
/* harmony export */   padNumber: () => (/* binding */ padNumber),
/* harmony export */   stringToArrayBuffer: () => (/* binding */ stringToArrayBuffer),
/* harmony export */   toBase64: () => (/* binding */ toBase64),
/* harmony export */   utilConcatBuf: () => (/* binding */ utilConcatBuf),
/* harmony export */   utilConcatView: () => (/* binding */ utilConcatView),
/* harmony export */   utilDecodeTC: () => (/* binding */ utilDecodeTC),
/* harmony export */   utilEncodeTC: () => (/* binding */ utilEncodeTC),
/* harmony export */   utilFromBase: () => (/* binding */ utilFromBase),
/* harmony export */   utilToBase: () => (/* binding */ utilToBase)
/* harmony export */ });
/*!
 Copyright (c) Peculiar Ventures, LLC
*/

function getUTCDate(date) {
    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if ((parameters instanceof Object) === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {
    let result = "";
    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for (let i = (inputBuffer.length - 1); i >= 0; i--) {
        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
    }
    return result;
}
function utilToBase(value, base, reserved = (-1)) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for (let i = 1; i < 8; i++) {
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            }
            else {
                if (internalReserved < i) {
                    return (new ArrayBuffer(0));
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for (let j = (i - 1); j >= 0; j--) {
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= (retView[result - j - 1]) * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers) {
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views) {
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
    }
    bigIntView[0] = (buf[0] & 0x80);
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return (smallInt - bigInt);
}
function utilEncodeTC(value) {
    const modValue = (value < 0) ? (value * (-1)) : value;
    let bigInt = 128;
    for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for (let k = 0; k < tempBuf.byteLength; k++) {
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return (new ArrayBuffer(0));
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for (let i = 0; i < dif; i++) {
        padding[i] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i = 0; i < input.length; i++) {
            if (input.charCodeAt(i) !== 0) {
                nonZeroPosition = i;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        }
        else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            }
            else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                }
                else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        }
        else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for (let i = 0; i < 64; i++) {
            if (template.charAt(i) === toSearch)
                return i;
        }
        return 64;
    }
    function test(incoming) {
        return ((incoming === 64) ? 0x00 : incoming);
    }
    let i = 0;
    let output = "";
    while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = (-1);
        for (let i = (outputLength - 1); i >= 0; i--) {
            if (output.charCodeAt(i) !== 0) {
                nonZeroStart = i;
                break;
            }
        }
        if (nonZeroStart !== (-1)) {
            output = output.slice(0, nonZeroStart + 1);
        }
        else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view) {
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = (Math.log(length) / log2);
    const floor = Math.floor(base);
    const round = Math.round(base);
    return ((floor === round) ? floor : round);
}
function clearProps(object, propsArray) {
    for (const prop of propsArray) {
        delete object[prop];
    }
}




/***/ }),

/***/ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ "./node_modules/.pnpm/randomfill@1.0.4/node_modules/randomfill/browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/randomfill@1.0.4/node_modules/randomfill/browser.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js")
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof __webpack_require__.g.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof __webpack_require__.g.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ "?9bba");
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __webpack_require__(/*! ./end-of-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"),
  Buffer = _require.Buffer;
var _require2 = __webpack_require__(/*! util */ "?b231"),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes).ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \********************************************************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js").codes).ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js");
exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js");


/***/ }),

/***/ "./node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof globalThis === "object" ? globalThis :
            typeof __webpack_require__.g === "object" ? __webpack_require__.g :
                typeof self === "object" ? self :
                    typeof this === "object" ? this :
                        sloppyModeThis();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        function makeExporter(target, previous) {
            return function (key, value) {
                Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                if (previous)
                    previous(key, value);
            };
        }
        function functionThis() {
            try {
                return Function("return this;")();
            }
            catch (_) { }
        }
        function indirectEvalThis() {
            try {
                return (void 0, eval)("(function() { return this; })()");
            }
            catch (_) { }
        }
        function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
        }
    })(function (exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(target, propertyKey, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ true);
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var provider = GetMetadataProvider(O, P, /*create*/ false);
            if (!provider) {
                return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        // 6 ECMAScript Data Types and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        function SameValueZero(x, y) {
            return x === y || x !== x && y !== y;
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // Global metadata registry
        // - Allows `import "reflect-metadata"` and `import "reflect-metadata/no-conflict"` to interoperate.
        // - Uses isolated metadata if `Reflect` is frozen before the registry can be installed.
        /**
         * Creates a registry used to allow multiple `reflect-metadata` providers.
         */
        function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) &&
                typeof root.Reflect !== "undefined" &&
                !(registrySymbol in root.Reflect) &&
                typeof root.Reflect.defineMetadata === "function") {
                // interoperate with older version of `reflect-metadata` that did not support a registry.
                fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
                registerProvider: registerProvider,
                getProvider: getProvider,
                setProvider: setProvider,
            };
            return registry;
            function registerProvider(provider) {
                if (!Object.isExtensible(registry)) {
                    throw new Error("Cannot add provider to a frozen registry.");
                }
                switch (true) {
                    case fallback === provider: break;
                    case IsUndefined(first):
                        first = provider;
                        break;
                    case first === provider: break;
                    case IsUndefined(second):
                        second = provider;
                        break;
                    case second === provider: break;
                    default:
                        if (rest === undefined)
                            rest = new _Set();
                        rest.add(provider);
                        break;
                }
            }
            function getProviderNoCache(O, P) {
                if (!IsUndefined(first)) {
                    if (first.isProviderFor(O, P))
                        return first;
                    if (!IsUndefined(second)) {
                        if (second.isProviderFor(O, P))
                            return first;
                        if (!IsUndefined(rest)) {
                            var iterator = GetIterator(rest);
                            while (true) {
                                var next = IteratorStep(iterator);
                                if (!next) {
                                    return undefined;
                                }
                                var provider = IteratorValue(next);
                                if (provider.isProviderFor(O, P)) {
                                    IteratorClose(iterator);
                                    return provider;
                                }
                            }
                        }
                    }
                }
                if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
                    return fallback;
                }
                return undefined;
            }
            function getProvider(O, P) {
                var providerMap = targetProviderMap.get(O);
                var provider;
                if (!IsUndefined(providerMap)) {
                    provider = providerMap.get(P);
                }
                if (!IsUndefined(provider)) {
                    return provider;
                }
                provider = getProviderNoCache(O, P);
                if (!IsUndefined(provider)) {
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return provider;
            }
            function hasProvider(provider) {
                if (IsUndefined(provider))
                    throw new TypeError();
                return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O, P, provider) {
                if (!hasProvider(provider)) {
                    throw new Error("Metadata provider not registered.");
                }
                var existingProvider = getProvider(O, P);
                if (existingProvider !== provider) {
                    if (!IsUndefined(existingProvider)) {
                        return false;
                    }
                    var providerMap = targetProviderMap.get(O);
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return true;
            }
        }
        /**
         * Gets or creates the shared registry of metadata providers.
         */
        function GetOrCreateMetadataRegistry() {
            var metadataRegistry;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                metadataRegistry = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry)) {
                metadataRegistry = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                Object.defineProperty(root.Reflect, registrySymbol, {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: metadataRegistry
                });
            }
            return metadataRegistry;
        }
        function CreateMetadataProvider(registry) {
            // [[Metadata]] internal slot
            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
            var metadata = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var targetMetadata = metadata.get(O);
                    if (IsUndefined(targetMetadata))
                        return false;
                    return targetMetadata.has(P);
                },
                OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata,
                OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata,
                OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata,
                OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys,
                OrdinaryDeleteMetadata: OrdinaryDeleteMetadata,
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = metadata.get(O);
                var createdTargetMetadata = false;
                if (IsUndefined(targetMetadata)) {
                    if (!Create)
                        return undefined;
                    targetMetadata = new _Map();
                    metadata.set(O, targetMetadata);
                    createdTargetMetadata = true;
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                    if (!Create)
                        return undefined;
                    metadataMap = new _Map();
                    targetMetadata.set(P, metadataMap);
                    if (!registry.setProvider(O, P, provider)) {
                        targetMetadata.delete(P);
                        if (createdTargetMetadata) {
                            metadata.delete(O);
                        }
                        throw new Error("Wrong provider for target.");
                    }
                }
                return metadataMap;
            }
            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                return ToBoolean(metadataMap.has(MetadataKey));
            }
            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return undefined;
                return metadataMap.get(MetadataKey);
            }
            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
                metadataMap.set(MetadataKey, MetadataValue);
            }
            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
            function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                        keys.length = k;
                        return keys;
                    }
                    var nextValue = IteratorValue(next);
                    try {
                        keys[k] = nextValue;
                    }
                    catch (e) {
                        try {
                            IteratorClose(iterator);
                        }
                        finally {
                            throw e;
                        }
                    }
                    k++;
                }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                if (!metadataMap.delete(MetadataKey))
                    return false;
                if (metadataMap.size === 0) {
                    var targetMetadata = metadata.get(O);
                    if (!IsUndefined(targetMetadata)) {
                        targetMetadata.delete(P);
                        if (targetMetadata.size === 0) {
                            metadata.delete(targetMetadata);
                        }
                    }
                }
                return true;
            }
        }
        function CreateFallbackProvider(reflect) {
            var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var metadataPropertySet = metadataOwner.get(O);
                    if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                        return true;
                    }
                    if (getOwnMetadataKeys(O, P).length) {
                        if (IsUndefined(metadataPropertySet)) {
                            metadataPropertySet = new _Set();
                            metadataOwner.set(O, metadataPropertySet);
                        }
                        metadataPropertySet.add(P);
                        return true;
                    }
                    return false;
                },
                OrdinaryDefineOwnMetadata: defineMetadata,
                OrdinaryHasOwnMetadata: hasOwnMetadata,
                OrdinaryGetOwnMetadata: getOwnMetadata,
                OrdinaryOwnMetadataKeys: getOwnMetadataKeys,
                OrdinaryDeleteMetadata: deleteMetadata,
            };
            return provider;
        }
        /**
         * Gets the metadata provider for an object. If the object has no metadata provider and this is for a create operation,
         * then this module's metadata provider is assigned to the object.
         */
        function GetMetadataProvider(O, P, Create) {
            var registeredProvider = metadataRegistry.getProvider(O, P);
            if (!IsUndefined(registeredProvider)) {
                return registeredProvider;
            }
            if (Create) {
                if (metadataRegistry.setProvider(O, P, metadataProvider)) {
                    return metadataProvider;
                }
                throw new Error("Illegal state.");
            }
            return undefined;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            var Map = /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (SameValueZero(key, this._cacheKey)) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (!SameValueZero(this._cacheKey, key)) {
                        this._cacheIndex = -1;
                        for (var i = 0; i < this._keys.length; i++) {
                            if (SameValueZero(this._keys[i], key)) {
                                this._cacheIndex = i;
                                break;
                            }
                        }
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            return Map;
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            var Set = /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.keys(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
            return Set;
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    var array = new Uint8Array(size);
                    if (typeof crypto !== "undefined") {
                        crypto.getRandomValues(array);
                    }
                    else if (typeof msCrypto !== "undefined") {
                        msCrypto.getRandomValues(array);
                    }
                    else {
                        FillRandomBytes(array, size);
                    }
                    return array;
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js").Buffer)
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/.pnpm/hash-base@3.0.5/node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var isRegex = __webpack_require__(/*! is-regex */ "./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js");

var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

/** @type {import('.')} */
module.exports = function regexTester(regex) {
	if (!isRegex(regex)) {
		throw new $TypeError('`regex` must be a RegExp');
	}
	return function test(s) {
		return $exec(regex, s) !== null;
	};
};


/***/ }),

/***/ "./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha224.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha224.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha384.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha384.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(/*! events */ "./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js").EventEmitter);
var inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/lib/_stream_readable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js");
Stream.Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/lib/_stream_duplex.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js");
Stream.Transform = __webpack_require__(/*! readable-stream/lib/_stream_transform.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/lib/_stream_passthrough.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js");
Stream.finished = __webpack_require__(/*! readable-stream/lib/internal/streams/end-of-stream.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
Stream.pipeline = __webpack_require__(/*! readable-stream/lib/internal/streams/pipeline.js */ "./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js")

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");
/* harmony import */ var _providers_injection_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../providers/injection-token */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js");
/* harmony import */ var _error_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../error-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/error-helpers.js");





function autoInjectable() {
    return function (target) {
        var paramInfo = (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.getParamInfo)(target);
        return (function (_super) {
            (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__extends)(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spread)(args.concat(paramInfo.slice(args.length).map(function (type, index) {
                    var _a, _b, _c;
                    try {
                        if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTokenDescriptor)(type)) {
                            if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTransformDescriptor)(type)) {
                                return type.multiple
                                    ? (_a = _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance
                                        .resolve(type.transform)).transform.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spread)([_dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolveAll(type.token)], type.transformArgs)) : (_b = _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance
                                    .resolve(type.transform)).transform.apply(_b, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spread)([_dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolve(type.token)], type.transformArgs));
                            }
                            else {
                                return type.multiple
                                    ? _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolveAll(type.token)
                                    : _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolve(type.token);
                            }
                        }
                        else if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTransformDescriptor)(type)) {
                            return (_c = _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance
                                .resolve(type.transform)).transform.apply(_c, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spread)([_dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolve(type.token)], type.transformArgs));
                        }
                        return _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.resolve(type);
                    }
                    catch (e) {
                        var argIndex = index + args.length;
                        throw new Error((0,_error_helpers__WEBPACK_IMPORTED_MODULE_3__.formatErrorCtor)(target, argIndex, e));
                    }
                })))) || this;
            }
            return class_1;
        }(target));
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (autoInjectable);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoInjectable: () => (/* reexport safe */ _auto_injectable__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   inject: () => (/* reexport safe */ _inject__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   injectAll: () => (/* reexport safe */ _inject_all__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   injectAllWithTransform: () => (/* reexport safe */ _inject_all_with_transform__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   injectWithTransform: () => (/* reexport safe */ _inject_with_transform__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   injectable: () => (/* reexport safe */ _injectable__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   registry: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   scoped: () => (/* reexport safe */ _scoped__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   singleton: () => (/* reexport safe */ _singleton__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _auto_injectable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auto-injectable */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js");
/* harmony import */ var _inject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inject */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject.js");
/* harmony import */ var _injectable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./injectable */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/registry.js");
/* harmony import */ var _singleton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singleton */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/singleton.js");
/* harmony import */ var _inject_all__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./inject-all */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all.js");
/* harmony import */ var _inject_all_with_transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./inject-all-with-transform */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js");
/* harmony import */ var _inject_with_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./inject-with-transform */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js");
/* harmony import */ var _scoped__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scoped */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/scoped.js");











/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");

function injectAllWithTransform(token, transformer) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var data = {
        token: token,
        multiple: true,
        transform: transformer,
        transformArgs: args
    };
    return (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.defineInjectionTokenMetadata)(data);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (injectAllWithTransform);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");

function injectAll(token, options) {
    var data = {
        token: token,
        multiple: true,
        isOptional: options && options.isOptional
    };
    return (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.defineInjectionTokenMetadata)(data);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (injectAll);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");

function injectWithTransform(token, transformer) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.defineInjectionTokenMetadata)(token, {
        transformToken: transformer,
        args: args
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (injectWithTransform);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");

function inject(token, options) {
    var data = {
        token: token,
        multiple: false,
        isOptional: options && options.isOptional
    };
    return (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.defineInjectionTokenMetadata)(data);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (inject);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _reflection_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reflection-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");



function injectable(options) {
    return function (target) {
        _dependency_container__WEBPACK_IMPORTED_MODULE_1__.typeInfo.set(target, (0,_reflection_helpers__WEBPACK_IMPORTED_MODULE_0__.getParamInfo)(target));
        if (options && options.token) {
            if (!Array.isArray(options.token)) {
                _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.register(options.token, target);
            }
            else {
                options.token.forEach(function (token) {
                    _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.register(token, target);
                });
            }
        }
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (injectable);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/registry.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/registry.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");


function registry(registrations) {
    if (registrations === void 0) { registrations = []; }
    return function (target) {
        registrations.forEach(function (_a) {
            var token = _a.token, options = _a.options, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["token", "options"]);
            return _dependency_container__WEBPACK_IMPORTED_MODULE_0__.instance.register(token, provider, options);
        });
        return target;
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registry);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/scoped.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/scoped.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ scoped)
/* harmony export */ });
/* harmony import */ var _injectable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injectable */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");


function scoped(lifecycle, token) {
    return function (target) {
        (0,_injectable__WEBPACK_IMPORTED_MODULE_0__["default"])()(target);
        _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.register(token || target, target, {
            lifecycle: lifecycle
        });
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/singleton.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/singleton.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _injectable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injectable */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");


function singleton() {
    return function (target) {
        (0,_injectable__WEBPACK_IMPORTED_MODULE_0__["default"])()(target);
        _dependency_container__WEBPACK_IMPORTED_MODULE_1__.instance.registerSingleton(target);
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (singleton);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   typeInfo: () => (/* binding */ typeInfo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _providers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./providers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/index.js");
/* harmony import */ var _providers_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./providers/provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/provider.js");
/* harmony import */ var _providers_injection_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./providers/injection-token */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry.js");
/* harmony import */ var _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/lifecycle */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/lifecycle.js");
/* harmony import */ var _resolution_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolution-context */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/resolution-context.js");
/* harmony import */ var _error_helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./error-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/error-helpers.js");
/* harmony import */ var _lazy_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lazy-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js");
/* harmony import */ var _types_disposable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types/disposable */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/disposable.js");
/* harmony import */ var _interceptors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interceptors */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/interceptors.js");











var typeInfo = new Map();
var InternalDependencyContainer = (function () {
    function InternalDependencyContainer(parent) {
        this.parent = parent;
        this._registry = new _registry__WEBPACK_IMPORTED_MODULE_3__["default"]();
        this.interceptors = new _interceptors__WEBPACK_IMPORTED_MODULE_9__["default"]();
        this.disposed = false;
        this.disposables = new Set();
    }
    InternalDependencyContainer.prototype.register = function (token, providerOrConstructor, options) {
        if (options === void 0) { options = { lifecycle: _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Transient }; }
        this.ensureNotDisposed();
        var provider;
        if (!(0,_providers_provider__WEBPACK_IMPORTED_MODULE_1__.isProvider)(providerOrConstructor)) {
            provider = { useClass: providerOrConstructor };
        }
        else {
            provider = providerOrConstructor;
        }
        if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isTokenProvider)(provider)) {
            var path = [token];
            var tokenProvider = provider;
            while (tokenProvider != null) {
                var currentToken = tokenProvider.useToken;
                if (path.includes(currentToken)) {
                    throw new Error("Token registration cycle detected! " + (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__spread)(path, [currentToken]).join(" -> "));
                }
                path.push(currentToken);
                var registration = this._registry.get(currentToken);
                if (registration && (0,_providers__WEBPACK_IMPORTED_MODULE_0__.isTokenProvider)(registration.provider)) {
                    tokenProvider = registration.provider;
                }
                else {
                    tokenProvider = null;
                }
            }
        }
        if (options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Singleton ||
            options.lifecycle == _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ContainerScoped ||
            options.lifecycle == _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ResolutionScoped) {
            if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isValueProvider)(provider) || (0,_providers__WEBPACK_IMPORTED_MODULE_0__.isFactoryProvider)(provider)) {
                throw new Error("Cannot use lifecycle \"" + _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"][options.lifecycle] + "\" with ValueProviders or FactoryProviders");
            }
        }
        this._registry.set(token, { provider: provider, options: options });
        return this;
    };
    InternalDependencyContainer.prototype.registerType = function (from, to) {
        this.ensureNotDisposed();
        if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(to)) {
            return this.register(from, {
                useToken: to
            });
        }
        return this.register(from, {
            useClass: to
        });
    };
    InternalDependencyContainer.prototype.registerInstance = function (token, instance) {
        this.ensureNotDisposed();
        return this.register(token, {
            useValue: instance
        });
    };
    InternalDependencyContainer.prototype.registerSingleton = function (from, to) {
        this.ensureNotDisposed();
        if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(from)) {
            if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(to)) {
                return this.register(from, {
                    useToken: to
                }, { lifecycle: _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Singleton });
            }
            else if (to) {
                return this.register(from, {
                    useClass: to
                }, { lifecycle: _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Singleton });
            }
            throw new Error('Cannot register a type name as a singleton without a "to" token');
        }
        var useClass = from;
        if (to && !(0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(to)) {
            useClass = to;
        }
        return this.register(from, {
            useClass: useClass
        }, { lifecycle: _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Singleton });
    };
    InternalDependencyContainer.prototype.resolve = function (token, context, isOptional) {
        if (context === void 0) { context = new _resolution_context__WEBPACK_IMPORTED_MODULE_5__["default"](); }
        if (isOptional === void 0) { isOptional = false; }
        this.ensureNotDisposed();
        var registration = this.getRegistration(token);
        if (!registration && (0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(token)) {
            if (isOptional) {
                return undefined;
            }
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "Single");
        if (registration) {
            var result = this.resolveRegistration(registration, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isConstructorToken)(token)) {
            var result = this.construct(token, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    };
    InternalDependencyContainer.prototype.executePreResolutionInterceptor = function (token, resolutionType) {
        var e_1, _a;
        if (this.interceptors.preResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__values)(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, resolutionType);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.interceptors.preResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.executePostResolutionInterceptor = function (token, result, resolutionType) {
        var e_2, _a;
        if (this.interceptors.postResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__values)(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, result, resolutionType);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.interceptors.postResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.resolveRegistration = function (registration, context) {
        this.ensureNotDisposed();
        if (registration.options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ResolutionScoped &&
            context.scopedResolutions.has(registration)) {
            return context.scopedResolutions.get(registration);
        }
        var isSingleton = registration.options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].Singleton;
        var isContainerScoped = registration.options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ContainerScoped;
        var returnInstance = isSingleton || isContainerScoped;
        var resolved;
        if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isValueProvider)(registration.provider)) {
            resolved = registration.provider.useValue;
        }
        else if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isTokenProvider)(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.resolve(registration.provider.useToken, context))
                : this.resolve(registration.provider.useToken, context);
        }
        else if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isClassProvider)(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.construct(registration.provider.useClass, context))
                : this.construct(registration.provider.useClass, context);
        }
        else if ((0,_providers__WEBPACK_IMPORTED_MODULE_0__.isFactoryProvider)(registration.provider)) {
            resolved = registration.provider.useFactory(this);
        }
        else {
            resolved = this.construct(registration.provider, context);
        }
        if (registration.options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ResolutionScoped) {
            context.scopedResolutions.set(registration, resolved);
        }
        return resolved;
    };
    InternalDependencyContainer.prototype.resolveAll = function (token, context, isOptional) {
        var _this = this;
        if (context === void 0) { context = new _resolution_context__WEBPACK_IMPORTED_MODULE_5__["default"](); }
        if (isOptional === void 0) { isOptional = false; }
        this.ensureNotDisposed();
        var registrations = this.getAllRegistrations(token);
        if (!registrations && (0,_providers__WEBPACK_IMPORTED_MODULE_0__.isNormalToken)(token)) {
            if (isOptional) {
                return [];
            }
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "All");
        if (registrations) {
            var result_1 = registrations.map(function (item) {
                return _this.resolveRegistration(item, context);
            });
            this.executePostResolutionInterceptor(token, result_1, "All");
            return result_1;
        }
        var result = [this.construct(token, context)];
        this.executePostResolutionInterceptor(token, result, "All");
        return result;
    };
    InternalDependencyContainer.prototype.isRegistered = function (token, recursive) {
        if (recursive === void 0) { recursive = false; }
        this.ensureNotDisposed();
        return (this._registry.has(token) ||
            (recursive &&
                (this.parent || false) &&
                this.parent.isRegistered(token, true)));
    };
    InternalDependencyContainer.prototype.reset = function () {
        this.ensureNotDisposed();
        this._registry.clear();
        this.interceptors.preResolution.clear();
        this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer.prototype.clearInstances = function () {
        var e_3, _a;
        this.ensureNotDisposed();
        try {
            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__values)(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__read)(_c.value, 2), token = _d[0], registrations = _d[1];
                this._registry.setAll(token, registrations
                    .filter(function (registration) { return !(0,_providers__WEBPACK_IMPORTED_MODULE_0__.isValueProvider)(registration.provider); })
                    .map(function (registration) {
                    registration.instance = undefined;
                    return registration;
                }));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    InternalDependencyContainer.prototype.createChildContainer = function () {
        var e_4, _a;
        this.ensureNotDisposed();
        var childContainer = new InternalDependencyContainer(this);
        try {
            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__values)(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__read)(_c.value, 2), token = _d[0], registrations = _d[1];
                if (registrations.some(function (_a) {
                    var options = _a.options;
                    return options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ContainerScoped;
                })) {
                    childContainer._registry.setAll(token, registrations.map(function (registration) {
                        if (registration.options.lifecycle === _types_lifecycle__WEBPACK_IMPORTED_MODULE_4__["default"].ContainerScoped) {
                            return {
                                provider: registration.provider,
                                options: registration.options
                            };
                        }
                        return registration;
                    }));
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return childContainer;
    };
    InternalDependencyContainer.prototype.beforeResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.preResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.afterResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.postResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.dispose = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__awaiter)(this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.disposed = true;
                        promises = [];
                        this.disposables.forEach(function (disposable) {
                            var maybePromise = disposable.dispose();
                            if (maybePromise) {
                                promises.push(maybePromise);
                            }
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    InternalDependencyContainer.prototype.getRegistration = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.get(token);
        }
        if (this.parent) {
            return this.parent.getRegistration(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.getAllRegistrations = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.getAll(token);
        }
        if (this.parent) {
            return this.parent.getAllRegistrations(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.construct = function (ctor, context) {
        var _this = this;
        if (ctor instanceof _lazy_helpers__WEBPACK_IMPORTED_MODULE_7__.DelayedConstructor) {
            return ctor.createProxy(function (target) {
                return _this.resolve(target, context);
            });
        }
        var instance = (function () {
            var paramInfo = typeInfo.get(ctor);
            if (!paramInfo || paramInfo.length === 0) {
                if (ctor.length === 0) {
                    return new ctor();
                }
                else {
                    throw new Error("TypeInfo not known for \"" + ctor.name + "\"");
                }
            }
            var params = paramInfo.map(_this.resolveParams(context, ctor));
            return new (ctor.bind.apply(ctor, (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__spread)([void 0], params)))();
        })();
        if ((0,_types_disposable__WEBPACK_IMPORTED_MODULE_8__.isDisposable)(instance)) {
            this.disposables.add(instance);
        }
        return instance;
    };
    InternalDependencyContainer.prototype.resolveParams = function (context, ctor) {
        var _this = this;
        return function (param, idx) {
            var _a, _b, _c;
            try {
                if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTokenDescriptor)(param)) {
                    if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTransformDescriptor)(param)) {
                        return param.multiple
                            ? (_a = _this.resolve(param.transform)).transform.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__spread)([_this.resolveAll(param.token, new _resolution_context__WEBPACK_IMPORTED_MODULE_5__["default"](), param.isOptional)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__spread)([_this.resolve(param.token, context, param.isOptional)], param.transformArgs));
                    }
                    else {
                        return param.multiple
                            ? _this.resolveAll(param.token, new _resolution_context__WEBPACK_IMPORTED_MODULE_5__["default"](), param.isOptional)
                            : _this.resolve(param.token, context, param.isOptional);
                    }
                }
                else if ((0,_providers_injection_token__WEBPACK_IMPORTED_MODULE_2__.isTransformDescriptor)(param)) {
                    return (_c = _this.resolve(param.transform, context)).transform.apply(_c, (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__spread)([_this.resolve(param.token, context)], param.transformArgs));
                }
                return _this.resolve(param, context);
            }
            catch (e) {
                throw new Error((0,_error_helpers__WEBPACK_IMPORTED_MODULE_6__.formatErrorCtor)(ctor, idx, e));
            }
        };
    };
    InternalDependencyContainer.prototype.ensureNotDisposed = function () {
        if (this.disposed) {
            throw new Error("This container has been disposed, you cannot interact with a disposed container");
        }
    };
    return InternalDependencyContainer;
}());
var instance = new InternalDependencyContainer();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/error-helpers.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/error-helpers.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatErrorCtor: () => (/* binding */ formatErrorCtor)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");

function formatDependency(params, idx) {
    if (params === null) {
        return "at position #" + idx;
    }
    var argName = params.split(",")[idx].trim();
    return "\"" + argName + "\" at position #" + idx;
}
function composeErrorMessage(msg, e, indent) {
    if (indent === void 0) { indent = "    "; }
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spread)([msg], e.message.split("\n").map(function (l) { return indent + l; })).join("\n");
}
function formatErrorCtor(ctor, paramIdx, error) {
    var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a[1], params = _b === void 0 ? null : _b;
    var dep = formatDependency(params, paramIdx);
    return composeErrorMessage("Cannot inject the dependency " + dep + " of \"" + ctor.name + "\" constructor. Reason:", error);
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instanceCachingFactory: () => (/* reexport safe */ _instance_caching_factory__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   instancePerContainerCachingFactory: () => (/* reexport safe */ _instance_per_container_caching_factory__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   predicateAwareClassFactory: () => (/* reexport safe */ _predicate_aware_class_factory__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _instance_caching_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instance-caching-factory */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js");
/* harmony import */ var _instance_per_container_caching_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instance-per-container-caching-factory */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js");
/* harmony import */ var _predicate_aware_class_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./predicate-aware-class-factory */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js");





/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ instanceCachingFactory)
/* harmony export */ });
function instanceCachingFactory(factoryFunc) {
    var instance;
    return function (dependencyContainer) {
        if (instance == undefined) {
            instance = factoryFunc(dependencyContainer);
        }
        return instance;
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ instancePerContainerCachingFactory)
/* harmony export */ });
function instancePerContainerCachingFactory(factoryFunc) {
    var cache = new WeakMap();
    return function (dependencyContainer) {
        var instance = cache.get(dependencyContainer);
        if (instance == undefined) {
            instance = factoryFunc(dependencyContainer);
            cache.set(dependencyContainer, instance);
        }
        return instance;
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ predicateAwareClassFactory)
/* harmony export */ });
function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching) {
    if (useCaching === void 0) { useCaching = true; }
    var instance;
    var previousPredicate;
    return function (dependencyContainer) {
        var currentPredicate = predicate(dependencyContainer);
        if (!useCaching || previousPredicate !== currentPredicate) {
            if ((previousPredicate = currentPredicate)) {
                instance = dependencyContainer.resolve(trueConstructor);
            }
            else {
                instance = dependencyContainer.resolve(falseConstructor);
            }
        }
        return instance;
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lifecycle: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.Lifecycle),
/* harmony export */   autoInjectable: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.autoInjectable),
/* harmony export */   container: () => (/* reexport safe */ _dependency_container__WEBPACK_IMPORTED_MODULE_5__.instance),
/* harmony export */   delay: () => (/* reexport safe */ _lazy_helpers__WEBPACK_IMPORTED_MODULE_4__.delay),
/* harmony export */   inject: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.inject),
/* harmony export */   injectAll: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.injectAll),
/* harmony export */   injectAllWithTransform: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.injectAllWithTransform),
/* harmony export */   injectWithTransform: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.injectWithTransform),
/* harmony export */   injectable: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.injectable),
/* harmony export */   instanceCachingFactory: () => (/* reexport safe */ _factories__WEBPACK_IMPORTED_MODULE_2__.instanceCachingFactory),
/* harmony export */   instancePerContainerCachingFactory: () => (/* reexport safe */ _factories__WEBPACK_IMPORTED_MODULE_2__.instancePerContainerCachingFactory),
/* harmony export */   isClassProvider: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_3__.isClassProvider),
/* harmony export */   isFactoryProvider: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_3__.isFactoryProvider),
/* harmony export */   isNormalToken: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_3__.isNormalToken),
/* harmony export */   isTokenProvider: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_3__.isTokenProvider),
/* harmony export */   isValueProvider: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_3__.isValueProvider),
/* harmony export */   predicateAwareClassFactory: () => (/* reexport safe */ _factories__WEBPACK_IMPORTED_MODULE_2__.predicateAwareClassFactory),
/* harmony export */   registry: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.registry),
/* harmony export */   scoped: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.scoped),
/* harmony export */   singleton: () => (/* reexport safe */ _decorators__WEBPACK_IMPORTED_MODULE_1__.singleton)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/index.js");
/* harmony import */ var _decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorators */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/index.js");
/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factories */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/index.js");
/* harmony import */ var _providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./providers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/index.js");
/* harmony import */ var _lazy_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lazy-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js");
/* harmony import */ var _dependency_container__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dependency-container */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js");
if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error("tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point.");
}








/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/interceptors.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/interceptors.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostResolutionInterceptors: () => (/* binding */ PostResolutionInterceptors),
/* harmony export */   PreResolutionInterceptors: () => (/* binding */ PreResolutionInterceptors),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _registry_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registry-base */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry-base.js");


var PreResolutionInterceptors = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PreResolutionInterceptors, _super);
    function PreResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PreResolutionInterceptors;
}(_registry_base__WEBPACK_IMPORTED_MODULE_0__["default"]));

var PostResolutionInterceptors = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PostResolutionInterceptors, _super);
    function PostResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PostResolutionInterceptors;
}(_registry_base__WEBPACK_IMPORTED_MODULE_0__["default"]));

var Interceptors = (function () {
    function Interceptors() {
        this.preResolution = new PreResolutionInterceptors();
        this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interceptors);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DelayedConstructor: () => (/* binding */ DelayedConstructor),
/* harmony export */   delay: () => (/* binding */ delay)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");

var DelayedConstructor = (function () {
    function DelayedConstructor(wrap) {
        this.wrap = wrap;
        this.reflectMethods = [
            "get",
            "getPrototypeOf",
            "setPrototypeOf",
            "getOwnPropertyDescriptor",
            "defineProperty",
            "has",
            "set",
            "deleteProperty",
            "apply",
            "construct",
            "ownKeys"
        ];
    }
    DelayedConstructor.prototype.createProxy = function (createObject) {
        var _this = this;
        var target = {};
        var init = false;
        var value;
        var delayedObject = function () {
            if (!init) {
                value = createObject(_this.wrap());
                init = true;
            }
            return value;
        };
        return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor.prototype.createHandler = function (delayedObject) {
        var handler = {};
        var install = function (name) {
            handler[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                args[0] = delayedObject();
                var method = Reflect[name];
                return method.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spread)(args));
            };
        };
        this.reflectMethods.forEach(install);
        return handler;
    };
    return DelayedConstructor;
}());

function delay(wrappedConstructor) {
    if (typeof wrappedConstructor === "undefined") {
        throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
    }
    return new DelayedConstructor(wrappedConstructor);
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/class-provider.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/class-provider.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isClassProvider: () => (/* binding */ isClassProvider)
/* harmony export */ });
function isClassProvider(provider) {
    return !!provider.useClass;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/factory-provider.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/factory-provider.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFactoryProvider: () => (/* binding */ isFactoryProvider)
/* harmony export */ });
function isFactoryProvider(provider) {
    return !!provider.useFactory;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isClassProvider: () => (/* reexport safe */ _class_provider__WEBPACK_IMPORTED_MODULE_0__.isClassProvider),
/* harmony export */   isFactoryProvider: () => (/* reexport safe */ _factory_provider__WEBPACK_IMPORTED_MODULE_1__.isFactoryProvider),
/* harmony export */   isNormalToken: () => (/* reexport safe */ _injection_token__WEBPACK_IMPORTED_MODULE_2__.isNormalToken),
/* harmony export */   isTokenProvider: () => (/* reexport safe */ _token_provider__WEBPACK_IMPORTED_MODULE_3__.isTokenProvider),
/* harmony export */   isValueProvider: () => (/* reexport safe */ _value_provider__WEBPACK_IMPORTED_MODULE_4__.isValueProvider)
/* harmony export */ });
/* harmony import */ var _class_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/class-provider.js");
/* harmony import */ var _factory_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factory-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/factory-provider.js");
/* harmony import */ var _injection_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./injection-token */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js");
/* harmony import */ var _token_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./token-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/token-provider.js");
/* harmony import */ var _value_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./value-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/value-provider.js");







/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isConstructorToken: () => (/* binding */ isConstructorToken),
/* harmony export */   isNormalToken: () => (/* binding */ isNormalToken),
/* harmony export */   isTokenDescriptor: () => (/* binding */ isTokenDescriptor),
/* harmony export */   isTransformDescriptor: () => (/* binding */ isTransformDescriptor)
/* harmony export */ });
/* harmony import */ var _lazy_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lazy-helpers */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js");

function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "multiple" in descriptor);
}
function isTransformDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "transform" in descriptor);
}
function isConstructorToken(token) {
    return typeof token === "function" || token instanceof _lazy_helpers__WEBPACK_IMPORTED_MODULE_0__.DelayedConstructor;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/provider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/provider.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isProvider: () => (/* binding */ isProvider)
/* harmony export */ });
/* harmony import */ var _class_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/class-provider.js");
/* harmony import */ var _value_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/value-provider.js");
/* harmony import */ var _token_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/token-provider.js");
/* harmony import */ var _factory_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factory-provider */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/factory-provider.js");




function isProvider(provider) {
    return ((0,_class_provider__WEBPACK_IMPORTED_MODULE_0__.isClassProvider)(provider) ||
        (0,_value_provider__WEBPACK_IMPORTED_MODULE_1__.isValueProvider)(provider) ||
        (0,_token_provider__WEBPACK_IMPORTED_MODULE_2__.isTokenProvider)(provider) ||
        (0,_factory_provider__WEBPACK_IMPORTED_MODULE_3__.isFactoryProvider)(provider));
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/token-provider.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/token-provider.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isTokenProvider: () => (/* binding */ isTokenProvider)
/* harmony export */ });
function isTokenProvider(provider) {
    return !!provider.useToken;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/value-provider.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/value-provider.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isValueProvider: () => (/* binding */ isValueProvider)
/* harmony export */ });
function isValueProvider(provider) {
    return provider.useValue != undefined;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INJECTION_TOKEN_METADATA_KEY: () => (/* binding */ INJECTION_TOKEN_METADATA_KEY),
/* harmony export */   defineInjectionTokenMetadata: () => (/* binding */ defineInjectionTokenMetadata),
/* harmony export */   getParamInfo: () => (/* binding */ getParamInfo)
/* harmony export */ });
var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
function getParamInfo(target) {
    var params = Reflect.getMetadata("design:paramtypes", target) || [];
    var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach(function (key) {
        params[+key] = injectionTokens[key];
    });
    return params;
}
function defineInjectionTokenMetadata(data, transform) {
    return function (target, _propertyKey, parameterIndex) {
        var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
        descriptors[parameterIndex] = transform
            ? {
                token: data,
                transform: transform.transformToken,
                transformArgs: transform.args || []
            }
            : data;
        Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry-base.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry-base.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var RegistryBase = (function () {
    function RegistryBase() {
        this._registryMap = new Map();
    }
    RegistryBase.prototype.entries = function () {
        return this._registryMap.entries();
    };
    RegistryBase.prototype.getAll = function (key) {
        this.ensure(key);
        return this._registryMap.get(key);
    };
    RegistryBase.prototype.get = function (key) {
        this.ensure(key);
        var value = this._registryMap.get(key);
        return value[value.length - 1] || null;
    };
    RegistryBase.prototype.set = function (key, value) {
        this.ensure(key);
        this._registryMap.get(key).push(value);
    };
    RegistryBase.prototype.setAll = function (key, value) {
        this._registryMap.set(key, value);
    };
    RegistryBase.prototype.has = function (key) {
        this.ensure(key);
        return this._registryMap.get(key).length > 0;
    };
    RegistryBase.prototype.clear = function () {
        this._registryMap.clear();
    };
    RegistryBase.prototype.ensure = function (key) {
        if (!this._registryMap.has(key)) {
            this._registryMap.set(key, []);
        }
    };
    return RegistryBase;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegistryBase);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _registry_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registry-base */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry-base.js");


var Registry = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Registry, _super);
    function Registry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry;
}(_registry_base__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Registry);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/resolution-context.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/resolution-context.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ResolutionContext = (function () {
    function ResolutionContext() {
        this.scopedResolutions = new Map();
    }
    return ResolutionContext;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ResolutionContext);


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/disposable.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/disposable.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isDisposable: () => (/* binding */ isDisposable)
/* harmony export */ });
function isDisposable(value) {
    if (typeof value.dispose !== "function")
        return false;
    var disposeFun = value.dispose;
    if (disposeFun.length > 0) {
        return false;
    }
    return true;
}


/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lifecycle: () => (/* reexport safe */ _lifecycle__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lifecycle */ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/lifecycle.js");



/***/ }),

/***/ "./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/lifecycle.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/lifecycle.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Lifecycle;
(function (Lifecycle) {
    Lifecycle[Lifecycle["Transient"] = 0] = "Transient";
    Lifecycle[Lifecycle["Singleton"] = 1] = "Singleton";
    Lifecycle[Lifecycle["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle[Lifecycle["ContainerScoped"] = 3] = "ContainerScoped";
})(Lifecycle || (Lifecycle = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Lifecycle);


/***/ }),

/***/ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "?78b1");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (false) // removed by dead control flow
{ var debugEnv; }
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/.pnpm/vm-browserify@1.1.2/node_modules/vm-browserify/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/vm-browserify@1.1.2/node_modules/vm-browserify/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),

/***/ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./src/Fido2Manager.ts":
/*!*****************************!*\
  !*** ./src/Fido2Manager.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./src/platform/webauthn.ts");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./src/KeyManager.ts"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./src/pqCrypto.ts");
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const encodeBinary = (data) => {
    if (data.length <= 65535) {
        // bin16: binary data whose length is upto (2^16)-1 bytes
        return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
    }
    else {
        // bin32: binary data whose length is upto (2^32)-1 bytes
        return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
    }
};
const serializeID_v0 = (km) => {
    const version = buffer_1.Buffer.from([0x83, 0xa1, 0x76, km.version]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    const ckey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x63]), encodeBinary(km.ckey)]);
    return buffer_1.Buffer.concat([version, ckey, cypher]);
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const type = cbor_1.default.decode(ckey).get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2Manager extends KeyManager_1.default {
    constructor() {
        super();
        this._transports = 0;
        this.level = 1; // ROOT, no Proof Management
        this.encType = "X25519KeyAgreementKey2019";
        this.webAuthn = (0, webauthn_1.getWebAuthnProvider)();
    }
    get transports() {
        return getTransports(this._transports);
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2Manager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        //encrypting
        const entropy = (0, crypto_1.randomBytes)(32);
        const seed = sha512(entropy);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed.slice(0, 32));
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        f2m.entropy = entropy;
        return f2m;
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                c: this.ckey,
                e: this.cypher.publicKey,
            }));
    }
    get id_v0() {
        return serializeID_v0(this);
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        f2m.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return f2m;
    }
    static instantiate(obj) {
        const f2m = new Fido2Manager();
        f2m.version = obj.version ?? 0;
        f2m.level = obj.level;
        f2m.fid = typeof obj.fid === "string" ? buffer_1.Buffer.from(obj.fid, "base64") : obj.fid;
        f2m._transports = obj.t ? obj.t : 15;
        f2m.ckey = obj.ckey.data ? buffer_1.Buffer.from(obj.ckey.data) : buffer_1.Buffer.from(obj.ckey);
        f2m.signer = getSignerFromCkey(f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return f2m;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const f2m = new Fido2Manager();
        f2m.version = data.v ?? 0;
        f2m.capability = "public";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m.ckey = data.c;
        f2m.signer = getSignerFromCkey(data.c);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.cypher = {
            publicKey: data.e,
        };
        return f2m;
    }
    async getSigner() {
        return {
            sign: async (data) => {
                if (!navigator.credentials)
                    return null;
                // ugly request userinteraction (needed for Safari and iOS)
                try {
                    await window?.CredentialUserInteractionRequest();
                }
                catch (error) { }
                const challenge = (0, crypto_1.hash)("sha256", data);
                const publicKey = {
                    challenge,
                    userVerification: "preferred",
                    allowCredentials: [
                        {
                            type: "public-key",
                            id: this.fid,
                            transports: getTransports(this._transports),
                        },
                    ],
                };
                const { response } = (await this.webAuthn.get(publicKey));
                const publicKeyResponse = response;
                const output = {
                    s: buffer_1.Buffer.from(publicKeyResponse.signature),
                    c: buffer_1.Buffer.from(publicKeyResponse.clientDataJSON),
                    a: buffer_1.Buffer.from(publicKeyResponse.authenticatorData),
                };
                return buffer_1.Buffer.from((0, msgpack_1.encode)(output));
            },
        };
    }
    verify(data, signature, userVerification = false) {
        const signatureBuffer = buffer_1.Buffer.from(signature);
        const decoded = (0, msgpack_1.decode)(signatureBuffer);
        const response = {
            signature: decoded.s,
            clientDataJSON: decoded.c,
            authenticatorData: decoded.a,
            userHandle: buffer_1.Buffer.from([]).buffer,
        };
        const challenge = (0, crypto_1.hash)("sha256", data).toString("base64");
        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);
        if (challenge !== extractedChallenge) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    verifyCredentials(credentials, userVerification = false) {
        if (credentials.id !== this.fid.toString("base64")) {
            return false;
        }
        const response = credentials.response;
        const rpIdHash = buffer_1.Buffer.from(response.authenticatorData.slice(0, 32)).toString("hex");
        const myIdHash = sha256(buffer_1.Buffer.from(credentials.id, "base64")).toString("hex");
        if (rpIdHash !== myIdHash) {
            return false;
        }
        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);
    }
    async createRevocationCertificate() {
        // TODO use an external id
        return null;
    }
}
exports["default"] = Fido2Manager;


/***/ }),

/***/ "./src/Fido2PRFManager.ts":
/*!********************************!*\
  !*** ./src/Fido2PRFManager.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./src/Fido2Manager.ts"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./src/pqCrypto.ts");
const lookup = {
    usb: 1,
    nfc: 2,
    ble: 4,
    internal: 8,
    hybrid: 16,
    "smart-card": 32,
};
const getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);
const fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);
const getAuthTypeFromCkey = (ckey) => {
    const decoded = cbor_1.default.decode(ckey, { extendedResults: true });
    const type = decoded.value.get(1);
    if (type === 1) {
        return "Ed25519VerificationKey2020";
    }
    else if (type === 2) {
        return "P256VerificationKey2020";
    }
    else
        return "Unknown";
};
const getSignerFromCkey = (ckey) => {
    const k = cbor_1.default.decode(ckey, { extendedResults: true }).value;
    //console.log("getSignerFromCkey", k);
    let publicKey = buffer_1.Buffer.from([]);
    if (k.get(3) == -7)
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), k.get(-2), k.get(-3)]);
    else if (k.get(3) == -8)
        publicKey = k.get(-2);
    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)
        publicKey = k.get(-101);
    return { publicKey };
};
class Fido2PRFManager extends Fido2Manager_1.default {
    constructor() {
        super();
        this.prfsalt = buffer_1.Buffer.from("VaultysID salt");
    }
    static async createFromAttestation(attestation) {
        const f2m = new Fido2PRFManager();
        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);
        //console.log(attestation, f2m.ckey);
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.fid = buffer_1.Buffer.from(attestation.id, "base64");
        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports
        const response = attestation.response;
        const transports = response.getTransports ? response.getTransports() : ["usb"];
        f2m._transports = fromTransports(transports);
        // signing
        f2m.signer = getSignerFromCkey(f2m.ckey);
        await f2m.getCypher();
        delete f2m.cypher.secretKey;
        return f2m;
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            f: this.fid,
            t: this._transports,
            c: this.ckey,
            e: this.cypher.publicKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const f2m = new Fido2PRFManager();
        f2m.version = data.v ?? 0;
        f2m.capability = "private";
        f2m.fid = typeof data.f === "string" ? buffer_1.Buffer.from(data.f, "base64") : data.f;
        f2m._transports = data.t ? data.t : 15;
        f2m.ckey = data.c;
        f2m.authType = getAuthTypeFromCkey(f2m.ckey);
        f2m.signer = getSignerFromCkey(data.c);
        f2m.cypher = { publicKey: data.e };
        return f2m;
    }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
    }
    async getCypher() {
        if (!this.cypher?.secretKey) {
            const publicKey = {
                challenge: buffer_1.Buffer.from([]),
                userVerification: "preferred",
                allowCredentials: [
                    {
                        type: "public-key",
                        id: this.fid,
                        transports: getTransports(this._transports),
                    },
                ],
                extensions: {
                    prf: {
                        eval: {
                            // Input the contextual information
                            first: this.prfsalt,
                            // There is a "second" optional field too
                            // Though it is intended for key rotation.
                        },
                    },
                },
            };
            const result = await this.webAuthn.get(publicKey);
            const { prf } = result.getClientExtensionResults();
            const first = prf?.results?.first;
            if (!first)
                throw new Error("PRF failed");
            const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(first));
            this.cypher = {
                publicKey: buffer_1.Buffer.from(cypher.publicKey),
                secretKey: buffer_1.Buffer.from(cypher.secretKey),
            };
        }
        return super.getCypher();
    }
    async createRevocationCertificate() {
        // impossible
        return null;
    }
}
exports["default"] = Fido2PRFManager;


/***/ }),

/***/ "./src/KeyManager.ts":
/*!***************************!*\
  !*** ./src/KeyManager.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DHIES = void 0;
const saltpack_1 = __webpack_require__(/*! @vaultys/saltpack */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_2 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
ed25519_1.ed25519.CURVE = { ...ed25519_1.ed25519.CURVE };
// @ts-ignore hack to get compatibility with former @stricahq/bip32ed25519 lib
ed25519_1.ed25519.CURVE.adjustScalarBytes = (bytes) => {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 63; // 0b0001_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
};
////@ts-expect-error fix for wrong way of exporting bip32ed25519
//const bip32 = bip32fix.default ?? bip32fix;
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
const serializeID_v0 = (km) => {
    const encodeBinary = (data) => {
        if (data.length <= 65535) {
            // bin16: binary data whose length is upto (2^16)-1 bytes
            return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);
        }
        else {
            // bin32: binary data whose length is upto (2^32)-1 bytes
            return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);
        }
    };
    const version = buffer_1.Buffer.from([0x84, 0xa1, 0x76, 0]);
    const proof = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x70]), encodeBinary(km.proof)]);
    const sign = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x78]), encodeBinary(km.signer.publicKey)]);
    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);
    return buffer_1.Buffer.concat([version, proof, sign, cypher]);
};
/**
 * DHIES (Diffie-Hellman Integrated Encryption Scheme) for KeyManager
 * Provides authenticated encryption using Diffie-Hellman key exchange
 */
class DHIES {
    constructor(keyManager) {
        this.keyManager = keyManager;
    }
    /**
     * Encrypts a message for a recipient using DHIES
     *
     * @param message The plaintext message to encrypt
     * @param recipientPublicKey The recipient's public key
     * @returns Encrypted message with ephemeral public key and authentication tag, or null if encryption fails
     */
    async encrypt(message, recipientPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot encrypt with DHIES using a public KeyManager");
            return null;
        }
        const cypher = await this.keyManager.getCypher();
        // Convert message to Buffer if it's a string
        const messageBuffer = typeof message === "string" ? buffer_1.Buffer.from(message, "utf8") : message;
        try {
            const ephemeralKey = (0, crypto_1.randomBytes)(32); // Generate a random 32-byte key for ephemeral key
            // Derive shared secret using recipient's public key and sender secret key
            const dh = await cypher.diffieHellman(recipientPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys from shared secret
            const kdfOutput = this.kdf(sharedSecret, this.keyManager.cypher.publicKey, recipientPublicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Encrypt the message using XChaCha20-Poly1305
            const nonce = (0, crypto_1.randomBytes)(24); // 24 bytes nonce for XChaCha20-Poly1305
            const ciphertext = buffer_1.Buffer.from(tweetnacl_1.default.secretbox(messageBuffer, nonce, encryptionKey));
            // Compute MAC (Message Authentication Code)
            const dataToAuthenticate = buffer_1.Buffer.concat([this.keyManager.cypher.publicKey, nonce, ciphertext]);
            const mac = this.computeMAC(macKey, dataToAuthenticate);
            // Construct the final encrypted message: nonce + ephemeralKey + ciphertext + MAC
            const encryptedMessage = buffer_1.Buffer.concat([nonce, ephemeralKey, ciphertext, mac]);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(dh);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return encryptedMessage;
        }
        catch (error) {
            console.error("DHIES encryption failed:", error);
            return null;
        }
    }
    /**
     * Decrypts a message encrypted with DHIES
     *
     * @param encryptedMessage The complete encrypted message from the encrypt method
     * @returns Decrypted message as a Buffer, or null if decryption fails
     */
    async decrypt(encryptedMessage, senderPublicKey) {
        if (this.keyManager.capability === "public") {
            console.error("Cannot decrypt with DHIES using a public KeyManager");
            return null;
        }
        try {
            // Extract components from the encrypted message
            // Format: nonce (24 bytes) + ephemeralKey (32 bytes) + ciphertext + MAC (32 bytes)
            const nonce = encryptedMessage.slice(0, 24);
            const ephemeralKey = encryptedMessage.slice(24, 56);
            const mac = encryptedMessage.slice(encryptedMessage.length - 32);
            const ciphertext = encryptedMessage.slice(56, encryptedMessage.length - 32);
            const cypher = await this.keyManager.getCypher();
            // Derive shared secret using sender public key and recipient secret key
            const dh = await cypher.diffieHellman(senderPublicKey);
            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));
            // Key derivation: derive encryption and MAC keys
            const kdfOutput = this.kdf(sharedSecret, senderPublicKey, this.keyManager.cypher.publicKey);
            const encryptionKey = kdfOutput.encryptionKey;
            const macKey = kdfOutput.macKey;
            // Verify MAC
            const dataToAuthenticate = buffer_1.Buffer.concat([senderPublicKey, nonce, ciphertext]);
            const computedMac = this.computeMAC(macKey, dataToAuthenticate);
            if (!this.constantTimeEqual(mac, computedMac)) {
                //console.log(mac, computedMac);
                console.error("DHIES: MAC verification failed");
                return null;
            }
            // Decrypt the ciphertext
            const plaintext = tweetnacl_1.default.secretbox.open(ciphertext, nonce, encryptionKey);
            if (!plaintext) {
                console.error("DHIES: Decryption failed");
                return null;
            }
            const result = buffer_1.Buffer.from(plaintext);
            // Securely erase sensitive data
            (0, crypto_1.secureErase)(sharedSecret);
            (0, crypto_1.secureErase)(encryptionKey);
            (0, crypto_1.secureErase)(macKey);
            return result;
        }
        catch (error) {
            console.error("DHIES decryption failed:", error);
            return null;
        }
    }
    /**
     * Key Derivation Function: Derives encryption and MAC keys from the shared secret
     */
    kdf(sharedSecret, ephemeralPublicKey, staticPublicKey) {
        // Create a context for the KDF to ensure different keys for different uses
        const context = buffer_1.Buffer.concat([buffer_1.Buffer.from("DHIES-KDF"), ephemeralPublicKey, staticPublicKey]);
        // Derive encryption key: HKDF-like construction
        const encryptionKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x01]), // Domain separation byte
        ]));
        // Derive MAC key (using a different domain separation byte)
        const macKeyMaterial = (0, crypto_1.hash)("sha512", buffer_1.Buffer.concat([
            sharedSecret,
            context,
            buffer_1.Buffer.from([0x02]), // Domain separation byte
        ]));
        // Use first 32 bytes of each as the actual keys (for NaCl's secretbox)
        return {
            encryptionKey: encryptionKeyMaterial.slice(0, 32),
            macKey: macKeyMaterial.slice(0, 32),
        };
    }
    /**
     * Computes MAC for authenticated encryption
     */
    computeMAC(macKey, data) {
        return (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([macKey, data]));
    }
    /**
     * Constant-time comparison of two buffers to prevent timing attacks
     */
    constantTimeEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        let result = 0;
        for (let i = 0; i < a.length; i++) {
            result |= a[i] ^ b[i];
        }
        return result === 0;
    }
}
exports.DHIES = DHIES;
class KeyManager {
    constructor() {
        this.level = 1;
        this.version = 1;
        this.capability = "private";
        this.authType = "Ed25519VerificationKey2020";
        this.encType = "X25519KeyAgreementKey2019";
    }
    static async create_Id25519_fromEntropy(entropy, swapIndex = 0) {
        const km = new KeyManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        const seed = sha512(entropy);
        // const derivedKey = privateDerivePath(await bip32.Bip32PrivateKey.fromEntropy(seed.slice(0, 32)), `m/1'/0'/${swapIndex}'`);
        km.proofKey = {
            publicKey: buffer_1.Buffer.from([]), //deprecated
            //secretKey: derivedKey.toBytes(),
        };
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", km.proofKey.publicKey);
        // const privateKey = privateDerivePath(derivedKey, "/0'");
        km.signer = {
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(seed.slice(0, 32))),
            secretKey: seed.slice(0, 32),
        };
        const swapIndexBuffer = buffer_1.Buffer.alloc(8);
        swapIndexBuffer.writeBigInt64LE(BigInt(swapIndex), 0);
        const seed2 = sha256(buffer_1.Buffer.concat([seed.slice(32, 64), swapIndexBuffer]));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_Id25519() {
        return KeyManager.create_Id25519_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    get id() {
        if (this.version == 0)
            return serializeID_v0(this);
        else
            return buffer_1.Buffer.from((0, msgpack_1.encode)({
                v: this.version,
                p: this.proof,
                x: this.signer.publicKey,
                e: this.cypher.publicKey,
            }));
    }
    async getCypher() {
        // todo fetch secretKey here
        const cypher = this.cypher;
        return {
            hmac: (message) => cypher.secretKey
                ? buffer_1.Buffer.from((0, crypto_2.createHmac)("sha256", buffer_1.Buffer.from(cypher.secretKey).toString("hex"))
                    .update("VaultysID/" + message + "/end")
                    .digest())
                : undefined,
            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),
            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),
            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),
        };
    }
    getSigner() {
        // todo fetch secretKey here
        const secretKey = this.signer.secretKey;
        const sign = (data) => Promise.resolve(buffer_1.Buffer.from(ed25519_1.ed25519.sign(data, secretKey)));
        //console.log(secretKey.toString("hex"), new bip32.PrivateKey(secretKey).toPublicKey().toBytes().toString("hex"), Buffer.from(ed25519.getPublicKey(secretKey)).toString("hex"));
        return Promise.resolve({ sign });
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            x: this.signer.secretKey,
            e: this.cypher.secretKey,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.signer = {
            secretKey: data.x.slice(0, 32),
            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(data.x.slice(0, 32))),
        };
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new KeyManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new KeyManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        const signer = await this.getSigner();
        return signer.sign(data);
    }
    verify(data, signature, userVerificationIgnored) {
        return ed25519_1.ed25519.verify(signature, data, this.signer.publicKey);
    }
    // async createRevocationCertificate(newId) {
    //   if (this.level == LEVEL_ROOT) {
    //     const seed = sha512(this.entropy);
    //     let node = derivePath(
    //       await Bip32PrivateKey.fromEntropy(seed.slice(0, 32)),
    //       "m/1'/0'/1'",
    //     );
    //     const proof = hash("sha256", node.toBip32PublicKey().toBytes());
    //     if (this.proof.toString("hex") == proof.toString("hex")) {
    //       const revocationCertificate = {
    //         xpub: node.toBytes(),
    //         id: this.id,
    //         newId,
    //       };
    //       revocationCertificate.signature = node.toPrivateKey().sign(revocationCertificate);
    //       return revocationCertificate;
    //     } else return null;
    //   } else return null;
    // }
    // async createSwapingCertificate() {
    //   if (this.level === LEVEL_ROOT && this.entropy) {
    //     const newKey = await KeyManager.create_Id25519_fromEntropy(this.entropy, this.swapIndex + 1);
    //     const hiscp: HISCP = {
    //       newId: newKey.id,
    //       proofKey: this.proofKey.publicKey,
    //       timestamp: Date.now(),
    //       signature: Buffer.from([]),
    //     };
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     hiscp.signature = new bip32.Bip32PrivateKey(this.proofKey.secretKey!).toPrivateKey().sign(hiscpBuffer);
    //     return hiscp;
    //   }
    //   return null;
    // }
    // async verifySwapingCertificate(hiscp: HISCP) {
    //   const proof = hash("sha256", hiscp.proofKey).toString("hex");
    //   if (proof === this.proof.toString("hex")) {
    //     const timestampBuffer = Buffer.alloc(8);
    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);
    //     const newKey = KeyManager.fromId(hiscp.newId);
    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);
    //     const proofVerifier = bip32.Bip32PublicKey.fromBytes(hiscp.proofKey);
    //     return proofVerifier.toPublicKey().verify(hiscpBuffer, hiscp.signature);
    //   } else {
    //     return false;
    //   }
    // }
    cleanSecureData() {
        if (this.cypher?.secretKey) {
            (0, crypto_1.secureErase)(this.cypher.secretKey);
            delete this.cypher.secretKey;
        }
        if (this.signer?.secretKey) {
            (0, crypto_1.secureErase)(this.signer.secretKey);
            delete this.signer.secretKey;
        }
        if (this.entropy) {
            (0, crypto_1.secureErase)(this.entropy);
            delete this.entropy;
        }
    }
    /**
     * Performs a Diffie-Hellman key exchange with another KeyManager instance
     * @param otherKeyManager The other party's KeyManager instance
     * @returns A shared secret that can be used for symmetric encryption
     */
    async performDiffieHellman(otherKeyManager) {
        if (this.capability === "public") {
            console.error("Cannot perform DH key exchange with a public key capability");
            return null;
        }
        const cypher = await this.getCypher();
        const otherKey = otherKeyManager.cypher.publicKey;
        // Perform the X25519 scalar multiplication to derive the shared secret
        const sharedSecret = await cypher.diffieHellman(otherKey);
        // Hash the shared secret for better security (to derive a symmetric key)
        const derivedKey = sha256(sharedSecret);
        // Securely erase the shared secret from memory
        (0, crypto_1.secureErase)(sharedSecret);
        return derivedKey;
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two KeyManager instances
     * @param keyManager1 First KeyManager instance
     * @param keyManager2 Second KeyManager instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(keyManager1, keyManager2) {
        return keyManager1.performDiffieHellman(keyManager2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's KeyManager ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        const recipientKM = KeyManager.fromId(recipientId);
        //console.log(recipientKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.encrypt(message, recipientKM.cypher.publicKey);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        const senderKM = KeyManager.fromId(senderId);
        //console.log(senderKM.cypher.publicKey, this.cypher.publicKey);
        const dhies = new DHIES(this);
        return dhies.decrypt(encryptedMessage, senderKM.cypher.publicKey);
    }
    static async encrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        return await (0, saltpack_1.encryptAndArmor)(plaintext, null, publicKeys);
    }
    async signcrypt(plaintext, recipientIds) {
        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);
        const cypher = await this.getCypher();
        return await cypher.signcrypt(plaintext, publicKeys);
    }
    async decrypt(encryptedMessage, senderId = null) {
        const cypher = await this.getCypher();
        const senderKey = senderId ? KeyManager.fromId(senderId).cypher.publicKey : null;
        const message = await cypher.decrypt(encryptedMessage, senderKey);
        return message.toString();
    }
    // use better hash to prevent attack
    getSecretHash(data) {
        const toHash = buffer_1.Buffer.concat([data, buffer_1.Buffer.from("secrethash"), this.cypher.secretKey]);
        return (0, crypto_1.hash)("sha256", toHash);
    }
}
exports["default"] = KeyManager;


/***/ }),

/***/ "./src/MemoryChannel.ts":
/*!******************************!*\
  !*** ./src/MemoryChannel.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryChannel = void 0;
exports.pipeChannels = pipeChannels;
exports.unpipeChannels = unpipeChannels;
exports.StreamChannel = StreamChannel;
exports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;
exports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;
const cryptoChannel_1 = __importDefault(__webpack_require__(/*! ./cryptoChannel */ "./src/cryptoChannel.ts"));
const stream_1 = __webpack_require__(/*! stream */ "./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Pipes two channels together, creating a bidirectional flow where
 * messages sent to one channel are automatically forwarded to the other.
 * @param channel1 The first channel to connect
 * @param channel2 The second channel to connect
 * @returns A Promise that resolves when both channels close
 */
function pipeChannels(channel1, channel2) {
    let running = true;
    // Start both piping directions
    const pipe1to2 = async () => {
        try {
            await channel1.start();
            await channel2.start();
            console.log("pipe1to2");
            while (running) {
                try {
                    const data = await channel1.receive();
                    console.log("pipe1to2", data);
                    if (!running || data.length === 0)
                        break;
                    channel2.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe1to2:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe1to2:", error);
        }
    };
    const pipe2to1 = async () => {
        try {
            while (running) {
                console.log("pipe2to1");
                try {
                    const data = await channel2.receive();
                    console.log("pipe2to1", data);
                    if (!running || data.length === 0)
                        break;
                    channel1.send(data);
                }
                catch (error) {
                    if (running)
                        console.error("Error in pipe2to1:", error);
                    break;
                }
            }
        }
        catch (error) {
            console.error("Fatal error in pipe2to1:", error);
        }
    };
    // Start the pipes
    pipe1to2();
    pipe2to1();
    // Return function to stop piping
    return async () => {
        running = false;
        await Promise.all([channel1.close(), channel2.close()]);
    };
}
/**
 * Utility function that stops an active channel pipe
 * @param channel1 The first channel in the pipe
 * @param channel2 The second channel in the pipe
 */
async function unpipeChannels(channel1, channel2) {
    await Promise.all([channel1.close(), channel2.close()]);
}
function StreamChannel(channel) {
    const onData = async (callback) => {
        let message = await channel.receive();
        while (message) {
            callback(message);
            if (message.toString("utf-8") === "EOF") {
                return;
            }
            message = await channel.receive();
        }
    };
    const getWriteStream = () => {
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                channel.send(chunk);
                done();
            },
        });
        return stream;
    };
    const upload = async (stream) => {
        return new Promise((resolve) => {
            const writeStream = getWriteStream();
            stream.pipe(writeStream).once("finish", () => {
                channel.send(buffer_1.Buffer.from("EOF", "utf-8"));
                writeStream.end();
                resolve();
            });
        });
    };
    const uploadData = async (data) => {
        const stream = stream_1.Readable.from(data);
        await upload(stream);
    };
    const download = async (stream) => {
        const readStream = getReadStream();
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve();
        }));
        readStream.pipe(stream);
        await result;
    };
    const downloadData = async () => {
        const readStream = getReadStream();
        const chunks = [];
        const result = new Promise((resolve) => readStream.on("end", () => {
            resolve(buffer_1.Buffer.concat(chunks));
        }));
        const stream = new stream_1.Stream.Writable({
            write: (chunk, encoding, done) => {
                chunks.push(chunk);
                done();
            },
        });
        readStream.pipe(stream);
        return result;
    };
    const getReadStream = () => {
        let push;
        let temp;
        const stream = new stream_1.Stream.Readable({
            read() {
                push = (data) => this.push(data);
            },
        });
        onData((buf) => {
            if (buf.length === 3 && buf.toString("utf-8") === "EOF" && push) {
                temp && push(temp);
                push(null);
                stream.destroy();
            }
            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;
            if (push) {
                !push(temp) && (push = null);
                temp = null;
            }
        });
        return stream;
    };
    return {
        getReadStream,
        getWriteStream,
        upload,
        uploadData,
        download,
        downloadData,
    };
}
function convertWebWritableStreamToNodeWritable(webWritableStream) {
    const writer = webWritableStream.getWriter();
    return new stream_1.Writable({
        async write(chunk, encoding, callback) {
            try {
                // Get a writer from the Web WritableStream
                await writer.write(chunk);
                writer.releaseLock(); // Release the lock on the writer after writing
                callback(); // Signal that the chunk has been processed
            }
            catch (error) {
                callback(); // Signal an error if it occurred
            }
        },
        async final(callback) {
            try {
                // Close the Web WritableStream
                const writer = webWritableStream.getWriter();
                await writer.close();
                writer.releaseLock(); // Release the lock on the writer after closing
                callback(); // Signal that the stream is finished
            }
            catch (error) {
                callback(); // Signal an error if it occurred during close
            }
        },
        async destroy(error, callback) {
            try {
                // Abort the Web WritableStream in case of an error
                const writer = webWritableStream.getWriter();
                await writer.abort(error);
                writer.releaseLock(); // Release the lock on the writer after aborting
                callback(error); // Signal that the stream is destroyed
            }
            catch (abortError) {
                callback(null); // Signal an error if it occurred during abort
            }
        },
    });
}
function convertWebReadableStreamToNodeReadable(webReadableStream) {
    const reader = webReadableStream.getReader();
    return new stream_1.Readable({
        async read() {
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    //console.log(value);
                    if (done) {
                        this.push(null); // Signal the end of the stream
                        break;
                    }
                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer
                }
            }
            catch (error) {
                this.destroy();
            }
        },
    });
}
class MemoryChannel {
    constructor() {
        this.messageQueue = [];
        this.waitingResolvers = [];
        this.connected = false;
        this.connectedCallbacks = [];
        this.closed = false;
    }
    setChannel(chan, name) {
        this.name = name;
        this.otherend = chan;
    }
    static createBidirectionnal() {
        const input = new MemoryChannel();
        const output = new MemoryChannel();
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    onConnected(callback) {
        if (this.connected) {
            callback();
        }
        else {
            this.connectedCallbacks.push(callback);
        }
    }
    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {
        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);
        input.setChannel(output);
        output.setChannel(input);
        return input;
    }
    getConnectionString() {
        return "vaultys://memory";
    }
    fromConnectionString(string) {
        return string === "vaultys://memory" ? new MemoryChannel() : null;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setInjector(injector) {
        this.injector = injector;
    }
    async start() {
        this.connected = true;
        this.connectedCallbacks.forEach((callback) => callback());
        this.connectedCallbacks = []; // Clear callbacks after calling them
    }
    async send(data) {
        if (this.closed) {
            throw new Error("Cannot send on closed channel");
        }
        if (!this.otherend) {
            throw new Error("No other end connected to this channel");
        }
        // Log the data if a logger is set
        if (this.logger) {
            this.logger(data);
        }
        // Process data through injector if present
        let processedData = data;
        if (this.injector) {
            processedData = await this.injector(data);
        }
        // // Signal that this end is connected
        if (!this.connected) {
            await this.start();
        }
        // Deliver the message to the other end
        this.otherend.deliverMessage(processedData);
    }
    deliverMessage(data) {
        // If there are waiting receivers, deliver directly to the first one
        if (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            resolver(data);
        }
        else {
            // Otherwise queue the message
            this.messageQueue.push(data);
        }
    }
    async receive() {
        if (this.closed) {
            throw new Error("Cannot receive on closed channel");
        }
        //console.log(this);
        // If there are queued messages, return the first one
        if (this.messageQueue.length > 0) {
            return this.messageQueue.shift();
        }
        // Otherwise, wait for a message to arrive
        return new Promise((resolve) => {
            this.waitingResolvers.push(resolve);
        });
    }
    async close() {
        this.closed = true;
        // Clear any waiting receivers with an error
        while (this.waitingResolvers.length > 0) {
            const resolver = this.waitingResolvers.shift();
            // Resolve with empty buffer to indicate channel closed
            resolver(buffer_1.Buffer.alloc(0));
        }
        // Clear the message queue
        this.messageQueue = [];
    }
}
exports.MemoryChannel = MemoryChannel;


/***/ }),

/***/ "./src/MemoryStorage.ts":
/*!******************************!*\
  !*** ./src/MemoryStorage.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const replacer = (key, value) => {
    //if(key=="1686045792046") console.log(value);
    if (!value)
        return value;
    if (key === "certificate")
        return "__C__" + buffer_1.Buffer.from(value).toString("base64");
    if (value.type === "Buffer") {
        return "_bx_" + buffer_1.Buffer.from(value.data).toString("base64");
    }
    if (value.constructor.name === "Array") {
        return "_bx_" + buffer_1.Buffer.from(value).toString("base64");
    }
    return value;
};
const reviver = (key, value) => {
    if (value && key === "certificate") {
        if (typeof value === "string" && value.startsWith("__C__")) {
            return buffer_1.Buffer.from(value.slice(5), "base64");
        }
        else
            return buffer_1.Buffer.from(value);
    }
    if (typeof value === "string" && value.startsWith("_bx_")) {
        return buffer_1.Buffer.from(value.slice(4), "base64");
    }
    return value;
};
const serialize = (data) => JSON.stringify(data, replacer);
exports.serialize = serialize;
const deserialize = (string) => JSON.parse(string, reviver);
exports.deserialize = deserialize;
const MemoryStorage = (save) => {
    let data = {};
    if (!save)
        save = () => (0, exports.serialize)(data);
    return storagify(data, save, () => "");
};
exports.MemoryStorage = MemoryStorage;
const LocalStorage = (key = "vaultysStorage") => {
    let data = {};
    const _id = Math.random();
    //console.log(key);
    if (!localStorage[key])
        localStorage[key] = "{}";
    else
        data = (0, exports.deserialize)(localStorage[key]);
    return storagify(data, () => {
        //console.log("save !!!!!", key, _id);
        localStorage.setItem(key, (0, exports.serialize)(data));
    }, () => localStorage.removeItem(key));
};
exports.LocalStorage = LocalStorage;
const storagify = (object, save, destroy) => {
    return {
        destroy,
        save,
        toString: () => (0, exports.serialize)(object),
        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),
        _raw: object,
        set: (key, value) => (object[key] = value),
        delete: (key) => delete object[key],
        get: (key) => object[key],
        list: () => Object.keys(object).filter((k) => !k.startsWith("!")),
        listSubstores: () => Object.keys(object)
            .filter((k) => k.startsWith("!"))
            .map((k) => k.slice(1)),
        deleteSubstore: (key) => delete object["!" + key],
        renameSubstore: (oldname, newname) => {
            if (oldname === newname || !!object["!" + newname])
                return;
            object["!" + newname] = object["!" + oldname];
            delete object["!" + oldname];
        },
        substore: (key) => {
            if (!object["!" + key])
                object["!" + key] = {};
            return storagify(object["!" + key], save, destroy);
        },
    };
};


/***/ }),

/***/ "./src/PQManager.ts":
/*!**************************!*\
  !*** ./src/PQManager.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const saltpack_1 = __webpack_require__(/*! @vaultys/saltpack */ "./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta/node_modules/@vaultys/saltpack/dist/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ "./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs");
const crypto_2 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./src/pqCrypto.ts");
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./src/KeyManager.ts"));
const LEVEL_ROOT = 1;
const LEVEL_DERIVED = 2;
const sha512 = (data) => (0, crypto_1.hash)("sha512", data);
const sha256 = (data) => (0, crypto_1.hash)("sha256", data);
class PQManager extends KeyManager_1.default {
    constructor() {
        super();
        this.authType = "DilithiumVerificationKey2025";
    }
    static async create_PQ_fromEntropy(entropy, swapIndex = 0) {
        const km = new PQManager();
        km.entropy = entropy;
        km.level = LEVEL_ROOT;
        km.capability = "private";
        km.seed = sha512(entropy);
        km.swapIndex = swapIndex;
        km.proof = (0, crypto_1.hash)("sha256", buffer_1.Buffer.from([]));
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static generate_PQ() {
        return PQManager.create_PQ_fromEntropy((0, crypto_1.randomBytes)(32));
    }
    async getCypher() {
        // todo fetch secretKey here
        const cypher = this.cypher;
        return {
            hmac: (message) => cypher.secretKey
                ? buffer_1.Buffer.from((0, crypto_2.createHmac)("sha256", buffer_1.Buffer.from(cypher.secretKey).toString("hex"))
                    .update("VaultysID/" + message + "/end")
                    .digest())
                : undefined,
            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),
            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),
            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),
        };
    }
    getSecret() {
        return buffer_1.Buffer.from((0, msgpack_1.encode)({
            v: this.version,
            p: this.proof,
            s: this.seed,
        }));
    }
    static fromSecret(secret) {
        const data = (0, msgpack_1.decode)(secret);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "private";
        km.proof = data.p;
        km.seed = buffer_1.Buffer.from(data.s);
        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));
        const seed2 = sha256(km.seed.slice(32, 64));
        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);
        km.cypher = {
            publicKey: buffer_1.Buffer.from(cypher.publicKey),
            secretKey: buffer_1.Buffer.from(cypher.secretKey),
        };
        return km;
    }
    static instantiate(obj) {
        const km = new PQManager();
        km.version = obj.version ?? 0;
        km.level = obj.level;
        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);
        km.signer = {
            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),
        };
        km.cypher = {
            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),
        };
        return km;
    }
    static fromId(id) {
        const data = (0, msgpack_1.decode)(id);
        const km = new PQManager();
        km.version = data.v ?? 0;
        km.level = LEVEL_DERIVED;
        km.capability = "public";
        km.proof = data.p;
        km.signer = {
            publicKey: data.x,
        };
        km.cypher = {
            publicKey: data.e,
        };
        // console.log(km)
        return km;
    }
    async sign(data) {
        if (this.capability == "public")
            return null;
        return (0, pqCrypto_1.signDilithium)(data, this.signer.secretKey);
    }
    verify(data, signature, userVerificationIgnored) {
        return (0, pqCrypto_1.verifyDilithium)(data, signature, this.signer.publicKey);
    }
}
exports["default"] = PQManager;


/***/ }),

/***/ "./src/VaultysId.ts":
/*!**************************!*\
  !*** ./src/VaultysId.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const Fido2Manager_1 = __importDefault(__webpack_require__(/*! ./Fido2Manager */ "./src/Fido2Manager.ts"));
const Fido2PRFManager_1 = __importDefault(__webpack_require__(/*! ./Fido2PRFManager */ "./src/Fido2PRFManager.ts"));
const KeyManager_1 = __importDefault(__webpack_require__(/*! ./KeyManager */ "./src/KeyManager.ts"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const webauthn_1 = __webpack_require__(/*! ./platform/webauthn */ "./src/platform/webauthn.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const PQManager_1 = __importDefault(__webpack_require__(/*! ./PQManager */ "./src/PQManager.ts"));
const pqCrypto_1 = __webpack_require__(/*! ./pqCrypto */ "./src/pqCrypto.ts");
const TYPE_MACHINE = 0;
const TYPE_PERSON = 1;
const TYPE_ORGANIZATION = 2;
const TYPE_FIDO2 = 3;
const TYPE_FIDO2PRF = 4;
class VaultysId {
    constructor(keyManager, certificate, type = TYPE_MACHINE) {
        this.encrypt = VaultysId.encrypt;
        this.type = type;
        this.keyManager = keyManager;
        this.certificate = certificate;
    }
    // // Set the index of the proof in case of previous key for this protocol/service have been compromised
    // setProofIndex(protocol, service, index) {
    //   this.proofIndices[`${protocol}-${service}`] = index;
    // }
    // createSwapingCertificate(protocol, service) {
    //   let proofIndex = this.proofIndices[`${protocol}-${service}`]
    //     ? this.proofIndices[`${protocol}-${service}`]
    //     : 0;
    //   const pk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex,
    //   });
    //   const newPk = this.getKey({
    //     protocol,
    //     service,
    //     proofIndex: proofIndex + 1,
    //   });
    //   const xPub = this.device.getProofXPub({
    //     protocol,
    //     service,
    //     index,
    //   });
    //   const derivation = PDM.getProofDerivation(protocol, service, index);
    //   const revocationCertificate = `vaultys://p2p/revocation?pk=${pk}&npk=${newPk}&xpub=${xpub}&index=${derivation}`;
    // }
    static fromId(id, certificate, encoding = "hex") {
        let cleanId = id;
        if (id.data) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id.data);
        }
        if (id instanceof Uint8Array) {
            // Buffer thing
            cleanId = buffer_1.Buffer.from(id);
        }
        if (typeof id === "string") {
            cleanId = buffer_1.Buffer.from(id, encoding);
        }
        const type = cleanId[0];
        if (type === TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else if (type === TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromId(cleanId.slice(1));
            return new VaultysId(f2m, certificate, type);
        }
        else {
            if (cleanId.length > 1952) {
                const pqm = PQManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(pqm, certificate, type);
            }
            else {
                const km = KeyManager_1.default.fromId(cleanId.slice(1));
                return new VaultysId(km, certificate, type);
            }
        }
    }
    static async fromEntropy(entropy, type, pqc = false) {
        const cleanedEntropy = entropy;
        if (pqc) {
            const km = await PQManager_1.default.create_PQ_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
        else {
            const km = await KeyManager_1.default.create_Id25519_fromEntropy(cleanedEntropy);
            return new VaultysId(km, undefined, type);
        }
    }
    static async createWebauthn(passkey = true, onPRFEnabled) {
        const options = VaultysId.createPublicKeyCredentialCreationOptions(passkey);
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation, onPRFEnabled);
    }
    static async createPQC() {
        const options = VaultysId.createPublicKeyCredentialOptionsPQC();
        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();
        const attestation = await webAuthn.create(options);
        //console.log(attestation);
        if (!attestation)
            return null;
        else
            return VaultysId.fido2FromAttestation(attestation);
    }
    static async fido2FromAttestation(attestation, onPRFEnabled) {
        // should be somehow valid.
        SoftCredentials_1.default.verifyPackedAttestation(attestation.response, true);
        //console.log(SoftCredentials.verifyPackedAttestation(attestation.response as AuthenticatorAttestationResponse, true));
        if (attestation.getClientExtensionResults().prf?.enabled && (!onPRFEnabled || (await onPRFEnabled()))) {
            const f2m = await Fido2PRFManager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2PRF);
        }
        else {
            const f2m = await Fido2Manager_1.default.createFromAttestation(attestation);
            return new VaultysId(f2m, undefined, TYPE_FIDO2);
        }
    }
    static async machineFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_MACHINE);
    }
    static async organizationFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_ORGANIZATION);
    }
    static async personFromEntropy(entropy) {
        return VaultysId.fromEntropy(entropy, TYPE_PERSON);
    }
    static fromSecret(secret, encoding = "hex") {
        const secretBuffer = buffer_1.Buffer.from(secret, encoding);
        const type = secretBuffer[0];
        if (type == TYPE_FIDO2) {
            const f2m = Fido2Manager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else if (type == TYPE_FIDO2PRF) {
            const f2m = Fido2PRFManager_1.default.fromSecret(secretBuffer.slice(1));
            return new VaultysId(f2m, undefined, type);
        }
        else {
            //console.log(secretBuffer.length);
            if (secretBuffer.length === 109) {
                const pqm = PQManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(pqm, undefined, type);
            }
            else {
                const km = KeyManager_1.default.fromSecret(secretBuffer.slice(1));
                return new VaultysId(km, undefined, type);
            }
        }
    }
    static async generatePerson(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_PERSON);
        }
    }
    static async generateOrganization(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_ORGANIZATION);
        }
    }
    static async generateMachine(pqc = false) {
        if (pqc) {
            const km = await PQManager_1.default.generate_PQ();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
        else {
            const km = await KeyManager_1.default.generate_Id25519();
            return new VaultysId(km, undefined, TYPE_MACHINE);
        }
    }
    get relationshipCertificate() {
        return this.certificate;
    }
    getSecret(encoding = "hex") {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.getSecret()]).toString(encoding);
    }
    get fingerprint() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return fp
            .slice(0, 40)
            .toUpperCase()
            .match(/.{1,4}/g)
            .join(" ");
    }
    get did() {
        const t = buffer_1.Buffer.from([this.type]).toString("hex");
        const fp = t + (0, crypto_1.hash)("SHA224", this.keyManager.id).toString("hex");
        return `did:vaultys:${fp.slice(0, 40)}`;
    }
    get didDocument() {
        return {
            "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2020/v1"],
            id: this.did,
            authentication: [
                {
                    id: `${this.did}#keys-1`,
                    type: this.keyManager.authType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.signer.publicKey).toString("base64"),
                },
            ],
            keyAgreement: [
                {
                    id: `${this.did}#keys-2`,
                    type: this.keyManager.encType,
                    controller: this.did,
                    publicKeyMultibase: "m" + buffer_1.Buffer.from(this.keyManager.cypher.publicKey).toString("base64"),
                },
            ],
        };
    }
    get id() {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.id]);
    }
    toVersion(v) {
        this.keyManager.version = v;
        return this;
    }
    get version() {
        return this.keyManager.version;
    }
    isHardware() {
        return this.type === TYPE_FIDO2 || this.type === TYPE_FIDO2PRF;
    }
    isMachine() {
        return this.type === TYPE_MACHINE;
    }
    isPerson() {
        return this.type === TYPE_PERSON;
    }
    getOTPHmac(timelock = 1 * 3600000) {
        const otp = Math.floor(new Date().getTime() / timelock);
        return this.keyManager.getSecretHash(buffer_1.Buffer.from(`OTP-${otp}`)).toString("hex");
    }
    // Need to think about insecure use of this function
    getOTP(prefix = "password", timelock = 24 * 3600000) {
        if (this.certificate) {
            const otp = Math.floor(new Date().getTime() / timelock);
            const toHash = buffer_1.Buffer.concat([buffer_1.Buffer.from(prefix, "utf-8"), buffer_1.Buffer.from(this.certificate), buffer_1.Buffer.from([otp])]);
            return (0, crypto_1.hash)("SHA256", toHash).toString("hex");
        }
        throw new Error("no certificate, cannot derive OTP");
    }
    async performDiffieHellman(otherVaultysId) {
        return this.keyManager.performDiffieHellman(otherVaultysId.keyManager);
    }
    /**
     * Static method to perform a Diffie-Hellman key exchange between two VaultysId instances
     * @param vaultysId1 First VaultysId instance
     * @param vaultysId2 Second VaultysId instance
     * @returns A shared secret that both parties can derive
     */
    static async diffieHellman(vaultysId1, vaultysId2) {
        return vaultysId1.performDiffieHellman(vaultysId2);
    }
    /**
     * Encrypt a message using DHIES for a recipient
     * @param message Message to encrypt
     * @param recipientId Recipient's VaultysId ID
     * @returns Encrypted message or null if encryption fails
     */
    async dhiesEncrypt(message, recipientId) {
        let cleanId;
        if (typeof recipientId === "string") {
            cleanId = buffer_1.Buffer.from(recipientId.slice(2), "hex");
        }
        else {
            cleanId = recipientId.slice(1);
        }
        return this.keyManager.dhiesEncrypt(message, cleanId);
    }
    /**
     * Decrypt a message encrypted with DHIES
     * @param encryptedMessage Encrypted message from dhiesEncrypt
     * @returns Decrypted message as Buffer or null if decryption fails
     */
    async dhiesDecrypt(encryptedMessage, senderId) {
        let cleanId;
        if (typeof senderId === "string") {
            cleanId = buffer_1.Buffer.from(senderId.slice(2), "hex");
        }
        else {
            cleanId = senderId.slice(1);
        }
        return this.keyManager.dhiesDecrypt(encryptedMessage, cleanId);
    }
    async signChallenge(challenge) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        const signature = await this.keyManager.sign(result);
        if (!signature)
            throw new Error("Could not sign challenge");
        else
            return signature;
    }
    verifyChallenge(challenge, signature, userVerification) {
        if (typeof challenge == "string") {
            challenge = buffer_1.Buffer.from(challenge, "hex");
        }
        if (typeof signature == "string") {
            signature = buffer_1.Buffer.from(signature, "hex");
        }
        const result = (0, crypto_1.hash)("sha256", buffer_1.Buffer.concat([this.id, challenge]));
        return this.keyManager.verify(result, signature, userVerification);
    }
    async signcrypt(plaintext, recipientIds) {
        return this.keyManager.signcrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    static async encrypt(plaintext, recipientIds) {
        return KeyManager_1.default.encrypt(plaintext, recipientIds.map((id) => {
            if (typeof id === "string")
                return buffer_1.Buffer.from(id.slice(2), "hex");
            else
                return id.slice(1);
        }));
    }
    async decrypt(encryptedMessage, senderId) {
        let cleanId;
        if (senderId) {
            if (typeof senderId === "string")
                cleanId = buffer_1.Buffer.from(senderId.slice(2));
            // @ts-ignore
            else
                cleanId = senderId.subarray(1);
        }
        return this.keyManager.decrypt(encryptedMessage, cleanId);
    }
    async hmac(message) {
        const cypher = await this.keyManager.getCypher();
        return cypher.hmac(message);
    }
}
VaultysId.createPublicKeyCredentialOptionsPQC = () => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: "cross-platform",
            residentKey: "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [{ type: "public-key", alg: pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 }],
    };
    return options;
};
VaultysId.createPublicKeyCredentialCreationOptions = (passkey) => {
    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);
    const hint = passkey ? "client-device" : "security-key";
    const options = {
        challenge: (0, crypto_1.randomBytes)(32),
        rp: {
            name: "Vaultys ID",
        },
        user: {
            id: (0, crypto_1.randomBytes)(16),
            name: "Vaultys ID",
            displayName: "Vaultys Wallet ID",
        },
        attestation: safari ? "none" : "direct", // SAFARI Dead, they removed direct attestation
        authenticatorSelection: {
            authenticatorAttachment: passkey ? "platform" : "cross-platform",
            residentKey: passkey ? "required" : "discouraged",
            userVerification: "preferred",
        },
        // @ts-ignore not yet in dom types
        hints: [hint],
        extensions: {
            prf: {
                eval: {
                    first: buffer_1.Buffer.from("VaultysID salt", "utf-8"),
                },
            },
        },
        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7, // SECP256/ECDSA, Ed25519/EdDSA (-8) not supported natively on mobile or yubikey (crying)
            },
            {
                type: "public-key",
                alg: -8, // Ed25519/EdDSA prefered
            },
            {
                type: "public-key",
                alg: -257, // RS256
            },
            // {
            //   "type": "public-key",
            //   "alg": -36
            // },
            // {
            //   "type": "public-key",
            //   "alg": -37
            // },
            // {
            //   "type": "public-key",
            //   "alg": -38
            // },
            // {
            //   "type": "public-key",
            //   "alg": -39
            // },
            // {
            //   "type": "public-key",
            //   "alg": -258
            // },
            // {
            //   "type": "public-key",
            //   "alg": -259
            // }
        ],
    };
    return options;
};
exports["default"] = VaultysId;


/***/ }),

/***/ "./src/crypto.ts":
/*!***********************!*\
  !*** ./src/crypto.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hash = exports.Buffer = void 0;
const crypto_1 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
Object.defineProperty(exports, "Buffer", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js");
const sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ "./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js");
const getAlgorithm = (alg) => {
    const cleanAlg = alg.replaceAll("-", "").toLowerCase();
    if (cleanAlg === "sha256")
        return sha256_1.sha256.create();
    if (cleanAlg === "sha512")
        return sha512_1.sha512.create();
    if (cleanAlg === "sha224")
        return sha256_1.sha224.create();
    return sha256_1.sha256.create();
};
const _randomBytes = (size) => buffer_1.Buffer.from(crypto_1.randomBytes ? (0, crypto_1.randomBytes)(size) : crypto.getRandomValues(new Uint8Array(size)));
exports.randomBytes = _randomBytes;
const hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).update(buffer).digest());
exports.hash = hash;
const secretbox = tweetnacl_1.default.secretbox;
exports.secretbox = secretbox;
const toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("base64");
exports.toBase64 = toBase64;
const toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("hex");
exports.toHex = toHex;
const toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString("utf-8");
exports.toUTF8 = toUTF8;
const fromBase64 = (string) => buffer_1.Buffer.from(string, "base64");
exports.fromBase64 = fromBase64;
const fromHex = (string) => buffer_1.Buffer.from(string, "hex");
exports.fromHex = fromHex;
const fromUTF8 = (string) => buffer_1.Buffer.from(string, "utf-8");
exports.fromUTF8 = fromUTF8;
const secureErase = (buffer) => {
    for (let i = 0; i < buffer.length; i++) {
        buffer[i] = 0;
    }
};
exports.secureErase = secureErase;


/***/ }),

/***/ "./src/cryptoChannel.ts":
/*!******************************!*\
  !*** ./src/cryptoChannel.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);
const encrypt = (buffer, key) => {
    //console.log("encrypting: ", buffer, key)
    const keyUint8Array = key;
    const nonce = newNonce();
    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return buffer_1.Buffer.from(fullMessage);
};
exports.encrypt = encrypt;
const decrypt = (messageWithNonce, key) => {
    //console.log("decrypting: ", messageWithNonce, key)
    const keyUint8Array = key;
    const messageWithNonceAsUint8Array = messageWithNonce;
    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);
    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);
    if (!decrypted) {
        throw new Error("Could not decrypt message");
    }
    return buffer_1.Buffer.from(decrypted);
};
exports.decrypt = decrypt;
// upgrading a channel api with an encrypting layer. The API shoud be
// - send(Buffer):null
// - async receive():Buffer
const encryptChannel = (channel, key) => {
    const sendHandler = {
        apply(target, that, args) {
            return target.call(that, (0, exports.encrypt)(args[0], key));
        },
    };
    const receiveHandler = {
        async apply(target, that, args) {
            const result = await target.call(that);
            return (0, exports.decrypt)(result, key);
        },
    };
    channel.send = new Proxy(channel.send, sendHandler);
    channel.receive = new Proxy(channel.receive, receiveHandler);
    return channel;
};
const generateKey = () => (0, crypto_1.randomBytes)(32);
exports["default"] = {
    decrypt: exports.decrypt,
    encrypt: exports.encrypt,
    encryptChannel,
    generateKey,
};


/***/ }),

/***/ "./src/platform/SoftCredentials.ts":
/*!*****************************************!*\
  !*** ./src/platform/SoftCredentials.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: to revamp and optimize
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_2 = __webpack_require__(/*! ../crypto */ "./src/crypto.ts");
const cbor_1 = __importDefault(__webpack_require__(/*! cbor */ "./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js"));
const ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js");
const p256_1 = __webpack_require__(/*! @noble/curves/p256 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js");
const p384_1 = __webpack_require__(/*! @noble/curves/p384 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js");
const p521_1 = __webpack_require__(/*! @noble/curves/p521 */ "./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js");
const x509_1 = __webpack_require__(/*! @peculiar/x509 */ "./node_modules/.pnpm/@peculiar+x509@1.12.4/node_modules/@peculiar/x509/build/x509.es.js");
const pqCrypto_1 = __webpack_require__(/*! ../pqCrypto */ "./src/pqCrypto.ts");
const credentials = {};
//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;
const COSEKEYS = {
    kty: 1,
    alg: 3,
    crv: -1,
    x: -2,
    y: -3,
    n: -1,
    e: -2,
};
const COSEKTY = {
    OKP: 1,
    EC2: 2,
    RSA: 3,
    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,
};
const COSERSASCHEME = {
    "-3": "pss-sha256",
    "-39": "pss-sha512",
    "-38": "pss-sha384",
    "-65535": "pkcs1-sha1",
    "-257": "pkcs1-sha256",
    "-258": "pkcs1-sha384",
    "-259": "pkcs1-sha512",
};
const COSECRV = {
    1: p256_1.p256,
    2: p384_1.p384,
    3: p521_1.p521,
};
const COSEALGHASH = {
    "-257": "SHA-256",
    "-258": "SHA-384",
    "-259": "SHA-512",
    "-65535": "SHA-1",
    "-39": "SHA-512",
    "-38": "SHA-384",
    "-37": "SHA-256",
    "-260": "SHA-256",
    "-261": "SHA-512",
    "-7": "SHA-256",
    "-36": "SHA-512",
    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: "SHA-256", // DILITHIUM2 uses SHA-256 for hashing
};
const hash = (alg, message) => (0, crypto_2.hash)(alg.replace("-", ""), message);
const base64ToPem = (b64cert) => {
    let pemcert = "";
    for (let i = 0; i < b64cert.length; i += 64)
        pemcert += b64cert.slice(i, i + 64) + "\n";
    return "-----BEGIN CERTIFICATE-----\n" + pemcert + "-----END CERTIFICATE-----";
};
const getCertificateInfo = (certificate) => {
    const x509 = new x509_1.X509Certificate(certificate);
    const subjectString = x509.subject;
    const issuer = x509.issuer;
    const issuerName = x509.issuerName.toString();
    const subjectParts = subjectString.split(",");
    const subject = {};
    for (const field of subjectParts) {
        const kv = field.split("=");
        subject[kv[0].trim()] = kv[1];
    }
    // console.log(subject);
    const { Version } = x509.toTextObject().Data;
    const bc = x509.getExtension(x509_1.BasicConstraintsExtension);
    const basicConstraintsCA = bc ? bc.ca : false;
    return {
        issuer,
        issuerName,
        subject,
        version: Version,
        basicConstraintsCA,
    };
};
const parseAuthData = (buffer) => {
    const rpIdHash = buffer.slice(0, 32);
    buffer = buffer.slice(32);
    const flagsBuf = buffer.slice(0, 1);
    buffer = buffer.slice(1);
    const flagsInt = flagsBuf[0];
    const flags = {
        up: !!(flagsInt & 0x01),
        uv: !!(flagsInt & 0x04),
        at: !!(flagsInt & 0x40),
        ed: !!(flagsInt & 0x80),
        flagsInt,
    };
    const counterBuf = buffer.slice(0, 4);
    buffer = buffer.slice(4);
    const counter = counterBuf.readUInt32BE(0);
    let aaguid = undefined;
    let credID = undefined;
    let COSEPublicKey = undefined;
    if (flags.at) {
        aaguid = buffer.slice(0, 16);
        buffer = buffer.slice(16);
        const credIDLenBuf = buffer.slice(0, 2);
        buffer = buffer.slice(2);
        const credIDLen = credIDLenBuf.readUInt16BE(0);
        credID = buffer.slice(0, credIDLen);
        buffer = buffer.slice(credIDLen);
        COSEPublicKey = buffer;
    }
    //console.log(aaguid);
    return {
        rpIdHash,
        flagsBuf,
        flags,
        counter,
        counterBuf,
        aaguid,
        credID,
        COSEPublicKey,
    };
};
const verifyPackedAttestation = (response, userVerification = false) => {
    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
    if (attestationStruct.fmt == "none")
        return false;
    const authDataStruct = parseAuthData(attestationStruct.authData);
    // check if user has actually touched the device
    if (!authDataStruct.flags.up)
        return false;
    // check if did enter PIN code
    if (userVerification && !authDataStruct.flags.uv)
        return false;
    const clientDataHashBuf = hash("sha256", buffer_1.Buffer.from(response.clientDataJSON));
    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);
    const signature = attestationStruct.attStmt.sig;
    let signatureIsValid = false;
    /* ----- Verify FULL attestation ----- */
    if (attestationStruct.attStmt.x5c) {
        const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString("base64"));
        const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);
        const subject = certInfo.subject;
        // console.log(certInfo);
        if (subject.OU !== "Authenticator Attestation")
            throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');
        if (!subject.CN)
            throw new Error("Batch certificate CN MUST no be empty!");
        if (!subject.O)
            throw new Error("Batch certificate O MUST no be empty!");
        if (!subject.C || subject.C.length !== 2)
            throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");
        if (certInfo.basicConstraintsCA)
            throw new Error("Batch certificate basic constraints CA MUST be false!");
        if (certInfo.version !== "v3 (2)")
            throw new Error("Batch certificate version MUST be 3(ASN1 2)!");
        signatureIsValid = crypto_1.default.createVerify("sha256").update(dataBuffer).verify(leafCert, signature);
        /* ----- Verify FULL attestation ENDS ----- */
    }
    else if (attestationStruct.attStmt.ecdaaKeyId) {
        throw new Error("ECDAA IS NOT SUPPORTED!");
    }
    else {
        /* ----- Verify SURROGATE attestation ----- */
        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];
        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];
        const data = hash(hashAlg, dataBuffer);
        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {
            // ECDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            const y = pubKeyCose.get(COSEKEYS.y);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);
            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];
            const sig = ec.Signature.fromDER(signature);
            signatureIsValid = ec.verify(sig, data, pubKey);
        }
        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {
            // EdDSA
            const x = pubKeyCose.get(COSEKEYS.x);
            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);
        }
        else {
            return false;
        }
        /* ----- Verify SURROGATE attestation ENDS ----- */
    }
    if (!signatureIsValid)
        throw new Error("Failed to verify the signature!");
    return true;
};
class MyPublicKeyCredential {
    constructor(creds) {
        this.type = "public-key";
        this.clientExtensionResults = {};
        const keys = ["id", "rawId", "response"];
        this.id = creds.id;
        this.rawId = buffer_1.Buffer.from(creds.rawId);
        this.response = creds.response;
    }
    getClientExtensionResults() {
        return {};
    }
}
const verifyECDSA = (data, publicKey, signature) => {
    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);
};
const verifyEdDSA = (data, publicKey, signature) => {
    return ed25519_1.ed25519.verify(signature, data, publicKey);
};
// Webauthn Partial Implementation for testing
class SoftCredentials {
    constructor() {
        this.signCount = 0;
        this.rawId = (0, crypto_2.randomBytes)(32);
        this.aaguid = buffer_1.Buffer.alloc(16);
    }
    // credentials request payload
    static createRequest(alg, prf = false) {
        const challenge = buffer_1.Buffer.from((0, crypto_2.randomBytes)(32).toString("base64"));
        const result = {
            publicKey: {
                challenge,
                rp: {
                    name: "Vaultys ID",
                    id: "Vaultys ID",
                },
                user: {
                    id: buffer_1.Buffer.from("Vaultys Wallet ID", "utf8"),
                    name: "Vaultys Wallet ID",
                    displayName: "Vaultys Wallet ID",
                },
                pubKeyCredParams: [
                    {
                        type: "public-key",
                        alg,
                    },
                ],
            },
        };
        if (prf) {
            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_2.randomBytes)(32) } } };
        }
        return result;
    }
    static getCertificateInfo(response) {
        const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);
        const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];
        if (attestationStruct.attStmt.x5c) {
            return getCertificateInfo(attestationStruct.attStmt.x5c[0]);
        }
        else {
            return null;
        }
    }
    static async create(options, origin = "test") {
        const credential = new SoftCredentials();
        const publicKey = options.publicKey;
        credential.options = publicKey;
        credential.rpId = publicKey.rp.id || publicKey.rp.name;
        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), "base64");
        credentials[credential.rawId.toString("base64")] = credential; // erase previous instance
        // Get the algorithm from pubKeyCredParams
        const pubKeyCredParams = publicKey.pubKeyCredParams;
        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)
        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
        // Set algorithm, prioritizing DILITHIUM if it's supported
        if (supportsDilithium) {
            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;
        }
        else {
            credential.alg = publicKey.pubKeyCredParams[0].alg;
        }
        if (credential.alg === -8) {
            const random = ed25519_1.ed25519.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: ed25519_1.ed25519.getPublicKey(random),
                algorithm: "EdDSA",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 1);
            credential.coseKey.set(3, -8);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(0, 32);
            credential.coseKey.set(-2, x);
        }
        else if (credential.alg === -7) {
            const random = p256_1.p256.utils.randomPrivateKey();
            credential.keyPair = {
                privateKey: random,
                publicKey: p256_1.p256.getPublicKey(random, false),
                algorithm: "ES256",
            };
            credential.coseKey = new Map();
            credential.coseKey.set(1, 2);
            credential.coseKey.set(3, -7);
            credential.coseKey.set(-1, 6);
            const x = credential.keyPair.publicKey.slice(1, 33);
            const y = credential.keyPair.publicKey.slice(33);
            credential.coseKey.set(-2, x);
            credential.coseKey.set(-3, y);
            // console.log(extpk,x,y)
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // Generate DILITHIUM key pair
            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();
            //console.log("PQC", dilithiumPk, dilithiumSk);
            credential.keyPair = {
                privateKey: dilithiumSk,
                publicKey: dilithiumPk,
                algorithm: "DILITHIUM2",
                isDILITHIUM: true,
            };
            // Create COSE key representation
            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);
            //console.log("PQC", credential);
        }
        const clientData = {
            type: "webauthn.create",
            challenge: publicKey.challenge,
            origin,
        };
        const rpIdHash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "ascii"));
        const flags = buffer_1.Buffer.from("41", "hex"); // attested_data + user_present
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);
        rawIdLength.writeUInt16BE(credential.rawId.length, 0);
        const coseKey = cbor_1.default.encode(credential.coseKey);
        const attestationObject = {
            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),
            fmt: "none",
            attStmt: {},
        };
        const pkCredentials = {
            id: credential.rawId.toString("base64"),
            rawId: credential.rawId,
            authenticatorAttachment: null,
            type: "public-key",
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    return { prf: { enabled: true } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                attestationObject: cbor_1.default.encode(attestationObject),
                getTransports: () => ["usb", "hybrid"],
                getAuthenticatorData: () => attestationObject.authData,
                getPublicKey: () => coseKey,
                getPublicKeyAlgorithm: () => -7,
            },
        };
        return pkCredentials;
    }
    static simpleVerify(COSEPublicKey, response, userVerification = false) {
        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;
        const rpIdHash = response.authenticatorData.slice(0, 32);
        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];
        const counter = response.authenticatorData.slice(33, 37);
        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);
        if (!goodflags)
            return false;
        const hash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(response.clientDataJSON));
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);
        if (ckey.get(3) == -7) {
            data = (0, crypto_2.hash)("sha256", data);
        }
        if (ckey.get(1) == 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) == 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));
        }
        else if (ckey.get(1) === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(response.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);
        }
        return false;
    }
    static getCOSEPublicKey(attestation) {
        const response = attestation.response;
        const ato = cbor_1.default.decode(response.attestationObject);
        //console.log("getCOSEPublicKey", ato, parseAuthData(ato.authData));
        return parseAuthData(ato.authData).COSEPublicKey;
    }
    static verifyPackedAttestation(attestation, userVerification = false) {
        return verifyPackedAttestation(attestation, userVerification);
    }
    static async verify(attestation, assertion, userVerifiation = false) {
        //if (assertion.id !== attestation.id) return false;
        const hash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(assertion.response.clientDataJSON));
        const ass = assertion.response;
        const att = attestation.response;
        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);
        const ato = cbor_1.default.decode(att.attestationObject);
        const authData = parseAuthData(ato.authData);
        // check if user has actually touched the device
        if (!authData.flags.up)
            return false;
        // check if the user has entered his PIN code or used biometric sensor
        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)
            return false;
        const ckey = cbor_1.default.decode(authData.COSEPublicKey);
        // Hash data for ES256
        if (ckey.get(3) == -7) {
            data = (0, crypto_2.hash)("sha256", data);
        }
        // Get key type
        const keyType = ckey.get(1);
        if (keyType === 1) {
            // EdDSA
            const x = ckey.get(-2);
            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === 2) {
            // ECDSA
            const x = ckey.get(-2);
            const y = ckey.get(-3);
            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from("04", "hex"), x, y]);
            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));
        }
        else if (keyType === COSEKTY.DILITHIUM) {
            // DILITHIUM
            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);
            // Verify DILITHIUM signature asynchronously
            //console.log(data, publicKey, Buffer.from(ass.signature));
            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);
        }
        return false;
    }
    static extractChallenge(clientDataJSON) {
        const clientData = JSON.parse(clientDataJSON.toString());
        const m = clientData.challenge.length % 4;
        return clientData.challenge
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), "=");
    }
    static async get({ publicKey }, origin = "test") {
        if (!publicKey.allowCredentials)
            throw new Error();
        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString("base64");
        const credential = credentials[id];
        credential.signCount += 1;
        // prepare signature
        const clientData = {
            type: "webauthn.get",
            challenge: buffer_1.Buffer.from(publicKey.challenge).toString("base64"),
            origin,
        };
        const clientDataHash = (0, crypto_2.hash)("sha256", (0, crypto_2.fromUTF8)(JSON.stringify(clientData)));
        const rpIdHash = (0, crypto_2.hash)("sha256", buffer_1.Buffer.from(credential.rpId, "utf-8"));
        const flags = buffer_1.Buffer.from("05", "hex"); // user verification
        const signCount = buffer_1.Buffer.allocUnsafe(4);
        signCount.writeUInt32BE(credential.signCount, 0);
        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);
        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);
        let signature = new Uint8Array();
        if (credential.alg === -7) {
            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();
        }
        else if (credential.alg === -8) {
            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);
        }
        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {
            // DILITHIUM signing - this returns a Promise so we need to await it
            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);
        }
        const pkCredentials = {
            id,
            rawId: buffer_1.Buffer.from(id, "base64").buffer,
            type: "public-key",
            authenticatorAttachment: null,
            getClientExtensionResults: () => {
                if (publicKey.extensions?.prf?.eval?.first) {
                    // unsafe and not following w3c recommendation. for testing purpose only
                    return { prf: { results: { first: hash("sha256", publicKey.extensions?.prf?.eval?.first) } } };
                }
                else {
                    return {};
                }
            },
            toJSON() { },
            response: {
                authenticatorData,
                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), "utf-8"),
                signature: signature,
                userHandle: credential.userHandle,
            },
        };
        return pkCredentials;
    }
}
exports["default"] = SoftCredentials;


/***/ }),

/***/ "./src/platform/webauthn.ts":
/*!**********************************!*\
  !*** ./src/platform/webauthn.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeWebAuthn = exports.BrowserWebAuthn = void 0;
exports.getWebAuthnProvider = getWebAuthnProvider;
exports.createCredentialRequest = createCredentialRequest;
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ./SoftCredentials */ "./src/platform/SoftCredentials.ts"));
// Browser implementation
class BrowserWebAuthn {
    isAvailable() {
        return typeof window !== "undefined" && typeof window.PublicKeyCredential !== "undefined";
    }
    async create(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.create({ publicKey: options }));
    }
    async get(options) {
        if (!this.isAvailable()) {
            throw new Error("WebAuthn is not available in this environment");
        }
        return (await navigator.credentials.get({ publicKey: options }));
    }
}
exports.BrowserWebAuthn = BrowserWebAuthn;
// Node.js implementation using SoftCredentials
class NodeWebAuthn {
    constructor(origin = "test") {
        this.origin = origin;
    }
    isAvailable() {
        return true; // Always available in mock mode
    }
    async create(options) {
        return await SoftCredentials_1.default.create({
            publicKey: options,
        }, this.origin);
    }
    async get(options) {
        return await SoftCredentials_1.default.get({
            publicKey: options,
        }, this.origin);
    }
}
exports.NodeWebAuthn = NodeWebAuthn;
// Factory function
function getWebAuthnProvider(options) {
    if (typeof window !== "undefined") {
        return new BrowserWebAuthn();
    }
    return new NodeWebAuthn(options?.origin);
}
// Helper to create credential request
function createCredentialRequest(alg, prf = false) {
    return SoftCredentials_1.default.createRequest(alg, prf);
}


/***/ }),

/***/ "./src/pqCrypto.ts":
/*!*************************!*\
  !*** ./src/pqCrypto.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Post-Quantum Cryptography Operations
 *
 * This file contains implementations for post-quantum cryptographic algorithms
 * starting with DILITHIUM for digital signatures.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;
exports.generateDilithiumKeyPair = generateDilithiumKeyPair;
exports.signDilithium = signDilithium;
exports.verifyDilithium = verifyDilithium;
exports.createDilithiumCoseKey = createDilithiumCoseKey;
exports.getDilithiumKeyInfo = getDilithiumKeyInfo;
const ml_dsa_js_1 = __webpack_require__(/*! @noble/post-quantum/ml-dsa.js */ "./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./src/crypto.ts");
/**
 * COSE algorithm identifiers for post-quantum algorithms
 * Note: These values are provisional and may need to be updated as standards evolve
 */
exports.PQ_COSE_ALG = {
    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)
    DILITHIUM2: -46, // Level 2 (128-bit security)
    DILITHIUM3: -47, // Level 3 (192-bit security)
    DILITHIUM5: -48, // Level 5 (256-bit security)
};
/**
 * COSE key type for DILITHIUM
 */
exports.PQ_COSE_KEY_TYPE = {
    DILITHIUM: 4, // Custom key type for DILITHIUM
};
/**
 * COSE key parameter identifiers for DILITHIUM
 */
exports.PQ_COSE_KEY_PARAMS = {
    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)
    DILITHIUM_PK: -101, // Public key
    DILITHIUM_SK: -102, // Secret key
};
/**
 * Generate a DILITHIUM Level 2 key pair
 * @returns Promise resolving to an object containing the key pair
 */
function generateDilithiumKeyPair(seed) {
    if (!seed)
        seed = (0, crypto_1.randomBytes)(32);
    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);
    return {
        publicKey: buffer_1.Buffer.from(keyPair.publicKey),
        secretKey: buffer_1.Buffer.from(keyPair.secretKey),
    };
}
/**
 * Sign a message using DILITHIUM Level 2
 * @param message - The message to sign
 * @param privateKey - The DILITHIUM private key
 * @returns Promise resolving to signature as Uint8Array
 */
function signDilithium(message, secretKey) {
    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));
}
/**
 * Verify a DILITHIUM Level 2 signature
 * @param message - The original message
 * @param signature - The signature to verify
 * @param publicKey - The DILITHIUM public key
 * @returns Promise resolving to boolean indicating if signature is valid
 */
function verifyDilithium(message, signature, publicKey) {
    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);
}
/**
 * Create a COSE key representation for a DILITHIUM public key
 * @param publicKey - The DILITHIUM public key
 * @returns Map representing the COSE key
 */
function createDilithiumCoseKey(publicKey) {
    const coseKey = new Map();
    // Standard COSE key parameters
    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type
    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm
    // DILITHIUM-specific parameters
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2
    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);
    return coseKey;
}
/**
 * Get key size information for DILITHIUM
 * @returns Object with key size information
 */
function getDilithiumKeyInfo() {
    return {
        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key
        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key
        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature
    };
}


/***/ }),

/***/ "./test/challenger.test.ts":
/*!*********************************!*\
  !*** ./test/challenger.test.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const testCertificate = (rogueCert) => {
    try {
        const result = __1.Challenger.deserializeCertificate(rogueCert);
        return result;
    }
    catch (error) {
        return {
            state: -2,
        };
    }
};
const delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));
const challengeNext = async (vaultysId, newCertificate, oldCertificate) => {
    //console.log(newCertificate, oldCertificate);
    const challenger = new __1.Challenger(vaultysId);
    challenger.version = 1;
    if (oldCertificate) {
        await challenger.init(oldCertificate);
    }
    else if (!newCertificate) {
        challenger.createChallenge("p2p", "test", 1);
    }
    if (newCertificate)
        await challenger.update(newCertificate);
    return challenger.getCertificate();
};
describe("Symetric Proof of Relationship - SRG - v1", () => {
    it("Perform Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Protocol downgrading to v0", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 0);
        //console.log(challenger1.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Stateless Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const init = await challengeNext(vaultysId1);
        // console.log("init", Challenger.deserializeCertificate(init));
        const step1 = await challengeNext(vaultysId2, init);
        // console.log("step1", Challenger.deserializeCertificate(step1));
        const complete = await challengeNext(vaultysId1, step1);
        // console.log("complete", Challenger.deserializeCertificate(complete));
        const finalise = await challengeNext(vaultysId2, complete, step1);
        assert_1.default.equal(complete.toString("base64"), finalise.toString("base64"));
    });
    it("Perform Protocol attacking protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.protocol = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking service", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.service = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking nonce", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        // console.log(challengerattack.challenge);
        // console.log("boom");
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking timestamp", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.challenge.timestamp = Date.now();
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Timestamp has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered timestamp should have failed");
    });
    it("Perform Protocol attacking with legit but different certificate", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
        const challenger3 = new __1.Challenger(vaultysId1);
        const challenger4 = new __1.Challenger(vaultysId2);
        challenger3.createChallenge("p2p", "auth", 1);
        await challenger4.update(challenger3.getCertificate());
        await challenger3.update(challenger4.getCertificate());
        try {
            await challenger4.update(challenger1.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered legit certificate should have failed");
    });
    it("Fail for liveliness at first round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await delay(100);
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail for liveliness at second round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await delay(100);
        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Pass for liveliness at third round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 500);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 500);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await delay(200);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Fail with time deviation of 60s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail with time deviation of 60s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    /*
    it("Fail with tampered certificate (FIDO2)", async () => {
      const attestation1 = await navigator.credentials.create(
        SoftCredentials.createRequest(-7),
      );
      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);
      const challenger1 = new Challenger(vaultysId1);
  
      const attestation2 = await navigator.credentials.create(
        SoftCredentials.createRequest(-8),
      );
      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate all possibilities (FIDO2)", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        // TODO fix this malleability for
        // timestampDS_ a974696d657374616d70cf000001884453195fa3
        // timestampDS_ a974696d657374616d70d3000001884453195fa3
        // or use another serialisation for identifying certificate.
        if(i != 46 && i != rogueCert.length - 1) {
          for(let j = 0; j < 256; j++){
            if(j != back) {
              rogueCert[i] = j;
              const t = testCertificate(rogueCert);
              if(t.state == 2) {
                console.log(i, j, t);
                console.log(
                  Buffer.from(rogueCert).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(rogueCert).toString("hex").slice(i*2-20, i*2+20),
                  Buffer.from(challenger2.getCertificate()).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(challenger2.getCertificate()).toString("hex").slice(i*2-20, i*2+20)
                );
              }
              assert.notEqual(t.state, 2);
            }
          }
        }
        console.log(i, rogueCert.length);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("random", "test");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
    */
});


/***/ }),

/***/ "./test/challenger_v0.test.ts":
/*!************************************!*\
  !*** ./test/challenger_v0.test.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const cryptoChannel_1 = __webpack_require__(/*! ../src/cryptoChannel */ "./src/cryptoChannel.ts");
const delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));
const challengeNext = async (vaultysId, newCertificate, oldCertificate) => {
    //console.log(newCertificate, oldCertificate);
    const challenger = new __1.Challenger(vaultysId);
    challenger.version = 0;
    if (oldCertificate) {
        await challenger.init(oldCertificate);
    }
    else if (!newCertificate) {
        challenger.createChallenge("p2p", "test", 0);
    }
    if (newCertificate)
        await challenger.update(newCertificate);
    return challenger.getCertificate();
};
describe("Symetric Proof of Relationship - SRG - v0", () => {
    it("Perform Protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 1);
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.equal(challenger1.state, 2);
        assert_1.default.equal(challenger2.state, 2);
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Perform Stateless Protocol", async () => {
        for (let i = 0; i < 10; i++) {
            const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
            const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
            const init = await challengeNext(vaultysId1);
            // console.log("init", Challenger.deserializeCertificate(init));
            const step1 = await challengeNext(vaultysId2, init);
            // console.log("step1", Challenger.deserializeCertificate(step1));
            const complete = await challengeNext(vaultysId1, step1);
            // console.log("complete", Challenger.deserializeCertificate(complete));
            const finalise = await challengeNext(vaultysId2, complete, step1);
            assert_1.default.equal(complete.toString("base64"), finalise.toString("base64"));
        }
    });
    it("Perform Protocol attacking protocol", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.protocol = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking service", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.service = "hack";
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        // console.log(challengerattack.challenge);
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking nonce", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        // console.log(challengerattack.challenge);
        // console.log("boom");
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered nonce should have failed");
    });
    it("Perform Protocol attacking timestamp", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.challenge.timestamp = Date.now();
        delete challengerattack.challenge?.pk2;
        delete challengerattack.challenge?.sign2;
        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));
        await challenger2.update(challengerattack.getCertificate());
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, 1);
        try {
            await challenger1.update(challenger2.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Timestamp has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered timestamp should have failed");
    });
    it("Perform Protocol attacking version", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        const challengerattack = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth");
        assert_1.default.equal(challenger1.state, 0);
        assert_1.default.equal(challenger2.state, -1);
        await challengerattack.setChallenge(challenger1.getCertificate());
        await delay(2); //new timestamp might be the same!
        challengerattack.version = challengerattack.version ? 1 : 0;
        challengerattack.challenge.version = challengerattack.challenge.version ? 1 : 0;
        try {
            await challenger2.update(challengerattack.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "challenge is not corresponding to the right id");
            return;
        }
        assert_1.default.fail("The protocol with tampered version should have failed");
    });
    it("Perform Protocol attacking with legit but different certificate", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
        const challenger3 = new __1.Challenger(vaultysId1);
        const challenger4 = new __1.Challenger(vaultysId2);
        challenger3.createChallenge("p2p", "auth");
        await challenger4.update(challenger3.getCertificate());
        await challenger3.update(challenger4.getCertificate());
        try {
            await challenger4.update(challenger1.getCertificate());
        }
        catch (err) {
            assert_1.default.equal(err?.message, "Nonce has been tampered with");
            return;
        }
        assert_1.default.fail("The protocol with tampered legit certificate should have failed");
    });
    it("Fail for liveliness at first round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await delay(100);
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail for liveliness at second round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 50);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 50);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await delay(100);
        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Pass for liveliness at third round", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1, 500);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2, 500);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await delay(20);
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Pass with time deviation of 59s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        if (!challenger1.challenge)
            assert_1.default.fail();
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await new Promise((resolve) => setTimeout(resolve, 100));
        await challenger2.update(challenger1.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Fail with time deviation of 60s in the future", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Fail with time deviation of 60s in the past", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth");
        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;
        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {
            name: "Error",
            message: "challenge timestamp failed the liveliness",
        });
    });
    it("Should deserialize a succesful v0 certificate", async () => {
        const cert = "iahwcm90b2NvbKNwMnCnc2VydmljZahyZWdpc3Rlcql0aW1lc3RhbXDPAAABko9gLwijcGsxxHQBhKF2AKFwxQAgthOolbL2HWtbnAkuAyLHAjfbnS8njgLhHlxWlosbC6uheMUAIBXMRt4jV1gxWK5/TF1jNx0kD+v2qKTWFnfEDQsrOeIvoWXFACCwkdnz8o6yhL86amqfB4/nUoznXnmSs9wAIIT30iGhaaNwazLEdACEoXYAoXDFACARZg0feo56ckkSEU8xc0G/xCH5vjeLeQjP9/KtRC4X76F4xQAg9qbrfdWleMqBsN8y7qPmZ1/ObCqFxeQmIopZBwJGfa2hZcUAIHKiC8fHbhLl902mhMbl/h04JvVnWLBCyAGb22orn5dVpW5vbmNlxCAofLkkt7f/YFen3ve05OcpDl8AFJRnejfZbMC6q37gOqVzaWduMcRAby4aZAta/aZL/8NxtqX8NnDUMTfXZ44qEdW5QVl3Gp/nh7sNDtdJfpF3XdJ1bJ7FtinGDDtTkRCzW5Hm9S+EAqVzaWduMsRA0xyketeALY1yA/KbPo7gTWTGdBVyxmG4u60kQJ2WtTDdjhVnCVzlb56xZtWhtGX/DJxw43yEehPyPxI/HvgwB6htZXRhZGF0YYA=";
        const result = __1.Challenger.deserializeCertificate(buffer_1.Buffer.from(cert, "base64"));
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 2);
    });
    it("Should deserialize a succesful v0 certificate 2", async () => {
        const message = "QNGwy7yyIskbWees8qH39YHp6QpODl4Gsp970YFp3j+VjWbU2j1wAw7qLMWk0Ra0YeE6mVcENvohrXRfGdcM763qrYTgpFj72+jznW6szC+XxvDFkwCm9tba/qj6H+wpoDKphscI7UzJ8J1RoKytcLl3yg5BF6ikoJW0DMG58jE/T44tyEVhS0XVD5buSF6nGgam0Hge/rOMIh4Z0G6W5XQzEjMlobk7HYEV4nQAxRV8qaSLPtspF1ZcPgke2Q278n/KTwd65Nq+YYkr6cFPkxkmz9jZx9Zv0jKGiOw48MuirweOnD2AtvkpWq5fg6vi+pNZ/tymfIxwQ9LTnYbyKOwMR6/OzTulrbOBNftwDb2+PXLLT9Y=";
        const key = "9ee1d044677cac34984b2da0acbc66d238e884a5e944cde54b96be77e3fc1e8e";
        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, "base64"), buffer_1.Buffer.from(key, "hex"));
        // console.log(dearmorAndDecrypt(cert));
        // console.log(decode(cert));
        const result = __1.Challenger.deserializeCertificate(cert);
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 0);
    });
    it("Should deserialize a succesful v0 certificate 3", async () => {
        const message = "Cf+KnycFC0odoGv9Yxjc2JvUgZSYBNmzBN1UomUz/3VzXds3K/Fr2odh9ZI4q86ZmFsKu/bIxsXhDNg2sM7PhESvgpAJte+3QfVD8e1pzSG4+mqQs2HSkXm5xo6gcPfoN7OyJfzUbaDW5ts1Cy9dIWxJpr8JcT6BUofVgoQk4loi8LPsDdsA4Kxk6FaAE05CeqvuglYayaOnOk/u+cQFHN9rBHe2cpHCrgQAr4Qa+MeLMo4GU7pB4Qd4nA7AQxDBXJqR+tVvPIA2GZWb/EW2OGDFU7YzRJJLP7RdXnjcsSYRkUzuCPpI7l7vfaVy8nxNqy9PkEIPlzyO3TCHOHqHWlEy2YN8O1Mx";
        const key = "cc4dfd01327a30e10d9286344d485f2e4807ddb4c3e007f8b7fba20bb6c16985";
        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, "base64"), buffer_1.Buffer.from(key, "hex"));
        //console.log(dearmorAndDecrypt(cert));
        // console.log(decode(cert));
        const result = __1.Challenger.deserializeCertificate(cert);
        assert_1.default.equal(result.error, "");
        assert_1.default.equal(result.state, 0);
    });
    /*
    it("Fail with tampered certificate (FIDO2)", async () => {
      const attestation1 = await navigator.credentials.create(
        SoftCredentials.createRequest(-7),
      );
      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);
      const challenger1 = new Challenger(vaultysId1);
  
      const attestation2 = await navigator.credentials.create(
        SoftCredentials.createRequest(-8),
      );
      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate all possibilities (FIDO2)", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("interesting", "stuff");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        // TODO fix this malleability for
        // timestampDS_ a974696d657374616d70cf000001884453195fa3
        // timestampDS_ a974696d657374616d70d3000001884453195fa3
        // or use another serialisation for identifying certificate.
        if(i != 46 && i != rogueCert.length - 1) {
          for(let j = 0; j < 256; j++){
            if(j != back) {
              rogueCert[i] = j;
              const t = testCertificate(rogueCert);
              if(t.state == 2) {
                console.log(i, j, t);
                console.log(
                  Buffer.from(rogueCert).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(rogueCert).toString("hex").slice(i*2-20, i*2+20),
                  Buffer.from(challenger2.getCertificate()).toString("utf-8").slice(i-10, i+10),
                  Buffer.from(challenger2.getCertificate()).toString("hex").slice(i*2-20, i*2+20)
                );
              }
              assert.notEqual(t.state, 2);
            }
          }
        }
        console.log(i, rogueCert.length);
        rogueCert[i] = back;
      }
    }).timeout(10000);
  
    it("Fail with tampered certificate", async () => {
      const vaultysId1 = await VaultysId.generateMachine();
      const challenger1 = new Challenger(vaultysId1);
      const vaultysId2 = await VaultysId.generateMachine();
      const challenger2 = new Challenger(vaultysId2);
  
      challenger1.createChallenge("random", "test");
      await challenger2.update(challenger1.getCertificate());
      await challenger1.update(challenger2.getCertificate());
      await challenger2.update(challenger1.getCertificate());
      assert.ok(challenger1.isComplete());
      assert.ok(challenger2.isComplete());
      const rogueCert = challenger2.getCertificate();
      for(let i = 0; i < rogueCert.length; i++) {
        const back = rogueCert[i];
        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1
        const t = testCertificate(rogueCert);
        assert.notEqual(t.state, 2);
        rogueCert[i] = back;
      }
    }).timeout(10000);
    */
});


/***/ }),

/***/ "./test/channel.test.ts":
/*!******************************!*\
  !*** ./test/channel.test.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const MemoryChannel_1 = __webpack_require__(/*! ../src/MemoryChannel */ "./src/MemoryChannel.ts");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
describe("Channel tests", () => {
    it("send/receive", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
        channel.send(buffer_1.Buffer.from("hello world", "utf-8"));
        const message = await channel.otherend?.receive();
        assert_1.default.equal("hello world", message?.toString("utf-8"));
    });
});
// describe("Channel pipe tests", () => {
//   it("should pipe data between two memory channels", async () => {
//     // Create endpoints for A and B
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     console.log("started");
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     channelA.setLogger(console.log);
//     channelB.setLogger(console.log);
//     // Start piping between the two channels
//     const unpipe = pipeChannels(channelA, channelB);
//     await delay(10);
//     const messageAtB = receiverB.receive();
//     // Send data from A to B
//     channelA.send(Buffer.from("hello from A", "utf-8"));
//     // Receive on B's side
//     console.log(await messageAtB);
//     console.log("Data sent from A to B");
//     // Send data from B to A
//     await channelB.send(Buffer.from("hello from B", "utf-8"));
//     // Receive on A's side
//     const messageAtA = await receiverA.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(messageAtB.toString("utf-8"), "hello from A");
//     assert.equal(messageAtA.toString("utf-8"), "hello from B");
//   });
//   it("should pipe data between encrypted memory channels", async () => {
//     // Create encrypted endpoints
//     const channelA = MemoryChannel.createEncryptedBidirectionnal();
//     const channelB = MemoryChannel.createEncryptedBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Send multiple messages from A to B
//     await channelA.send(Buffer.from("message 1", "utf-8"));
//     await channelA.send(Buffer.from("message 2", "utf-8"));
//     // Receive on B
//     const message1AtB = await receiverB.receive();
//     const message2AtB = await receiverB.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(message1AtB.toString("utf-8"), "message 1");
//     assert.equal(message2AtB.toString("utf-8"), "message 2");
//   });
//   it("should handle large data transfers", async () => {
//     // Create endpoints
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Create a large buffer (1MB)
//     const largeData = Buffer.alloc(1024 * 1024);
//     largeData.fill(42);
//     // Send large data from A to B
//     await channelA.send(largeData);
//     // Receive on B
//     const receivedData = await receiverB.receive();
//     // Clean up
//     await unpipe();
//     // Verify the data was correctly transmitted
//     assert.equal(receivedData.length, largeData.length);
//     assert.ok(receivedData.equals(largeData));
//   });
//   it("should handle bidirectional communication simultaneously", async () => {
//     // Create endpoints
//     const channelA = MemoryChannel.createBidirectionnal();
//     const channelB = MemoryChannel.createBidirectionnal();
//     // Connect channels to receive endpoints
//     const receiverA = channelA.otherend!;
//     const receiverB = channelB.otherend!;
//     // Start piping
//     const unpipe = pipeChannels(channelA, channelB);
//     // Send messages in both directions
//     await Promise.all([channelA.send(Buffer.from("from A to B", "utf-8")), channelB.send(Buffer.from("from B to A", "utf-8"))]);
//     // Receive in both directions
//     const [messageAtB, messageAtA] = await Promise.all([receiverB.receive(), receiverA.receive()]);
//     // Clean up
//     await unpipe();
//     // Verify bidirectional data transmission
//     assert.equal(messageAtB.toString("utf-8"), "from A to B");
//     assert.equal(messageAtA.toString("utf-8"), "from B to A");
//   });
// });


/***/ }),

/***/ "./test/file.browser_test.ts":
/*!***********************************!*\
  !*** ./test/file.browser_test.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
const crypto_1 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const MemoryChannel_1 = __webpack_require__(/*! ../src/MemoryChannel */ "./src/MemoryChannel.ts");
const MemoryStorage_1 = __webpack_require__(/*! ../src/MemoryStorage */ "./src/MemoryStorage.ts");
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const hashBuffer = (buffer) => {
    const hashSum = (0, crypto_1.createHash)("sha256");
    hashSum.update(buffer_1.Buffer.from(buffer));
    return hashSum.digest("hex");
};
const fetchFile = async (url) => {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch file: ${response.statusText}`);
    }
    return await response.arrayBuffer();
};
describe("IdManager with files in browser", () => {
    it("Transfer data over encrypted Channel", async () => {
        for (let i = 0; i < 10; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const manager1 = new __1.IdManager(id1, s1);
            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            const inputBuffer = await fetchFile("assets/testfile.png");
            const input = new Blob([inputBuffer], { type: "image/png" });
            const outputChunks = [];
            const outputStream = new WritableStream({
                write(chunk) {
                    outputChunks.push(new Uint8Array(chunk));
                },
            });
            const promise = manager2.download(channel, (0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
            await manager1.upload(channel.otherend, (0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
            await promise;
            const outputBuffer = buffer_1.Buffer.concat(outputChunks);
            const hash1 = hashBuffer(inputBuffer);
            const hash2 = hashBuffer(outputBuffer.buffer);
            assert_1.default.equal(hash1, hash2);
        }
    });
    it("sign a File over Channel", async () => {
        for (let i = 0; i < 10; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => "");
            const manager1 = new __1.IdManager(id1, s1);
            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            const inputBuffer = await fetchFile("assets/testfile.png");
            const file = { arrayBuffer: buffer_1.Buffer.from(inputBuffer), type: "image/png" };
            manager1.acceptSignFile(channel);
            const result = await manager2.requestSignFile(channel.otherend, file);
            if (!result)
                return assert_1.default.fail("no result of the sign file request");
            const challenge = new URL(result.challenge.toString("utf8"));
            assert_1.default.equal(challenge.protocol, "vaultys:");
            assert_1.default.equal(challenge.host, "signfile");
            assert_1.default.equal(challenge.searchParams.get("hash"), "a73d53246950a93ee956e413f50ed326e36f9a052dcd6fc5388ae19290931f32");
            assert_1.default.notEqual(challenge.searchParams.get("timestamp"), null);
            assert_1.default.ok(manager2.verifyFile(file, result, manager1.vaultysId));
        }
    });
});
describe("Channel tests for browser", () => {
    it("stream file", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createBidirectionnal();
        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);
        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
        const inputBuffer = await fetchFile("assets/testfile.png");
        const input = new Blob([inputBuffer], { type: "image/png" });
        const outputChunks = [];
        const outputStream = new WritableStream({
            write(chunk) {
                outputChunks.push(new Uint8Array(chunk));
            },
        });
        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
        await promise;
        const outputBuffer = buffer_1.Buffer.concat(outputChunks);
        const hash1 = hashBuffer(inputBuffer);
        const hash2 = hashBuffer(outputBuffer.buffer);
        assert_1.default.equal(hash1, hash2);
    });
    it("stream file over encrypted channel", async () => {
        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();
        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);
        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);
        const inputBuffer = await fetchFile("assets/testfile.png");
        const input = new Blob([inputBuffer], { type: "image/png" });
        const outputChunks = [];
        const outputStream = new WritableStream({
            write(chunk) {
                outputChunks.push(new buffer_1.Buffer(chunk));
            },
        });
        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));
        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));
        await promise;
        const outputBuffer = buffer_1.Buffer.concat(outputChunks);
        const hash1 = hashBuffer(inputBuffer);
        const hash2 = hashBuffer(outputBuffer.buffer);
        assert_1.default.equal(hash1, hash2);
    });
});


/***/ }),

/***/ "./test/idManager.test.ts":
/*!********************************!*\
  !*** ./test/idManager.test.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const __1 = __webpack_require__(/*! .. */ "./dist/node/index.js");
const __2 = __webpack_require__(/*! .. */ "./dist/node/index.js");
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const crypto_2 = __webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js");
describe("IdManager", () => {
    it("serder a vaultys secret", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const secret = id1.getSecret();
            const id2 = __2.VaultysId.fromSecret(secret);
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac1?.toString("base64"), hmac2?.toString("base64"));
        }
    });
    it("serder a vaultys secret in base64", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const secret = id1.getSecret("base64");
            const id2 = __2.VaultysId.fromSecret(secret, "base64");
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac1?.toString("base64"), hmac2?.toString("base64"));
        }
    });
    it("serder to public Idmanager", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id);
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
            const hmac1 = await id1.hmac("test message");
            const hmac2 = await id2.hmac("test message");
            assert_1.default.notEqual(hmac1, undefined);
            assert_1.default.equal(hmac2, undefined);
        }
    });
    it("serder to public Idmanager stringified", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id = JSON.stringify(id1.id);
            const id2 = __2.VaultysId.fromId(JSON.parse(id));
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
        }
    });
    it("serder to public Idmanager as hex string", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id.toString("hex"));
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
        }
    });
    it("serder to public Idmanager as base64 string", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const id2 = __2.VaultysId.fromId(id1.id.toString("base64"), undefined, "base64");
            assert_1.default.equal(id2.fingerprint, id1.fingerprint);
            assert_1.default.equal(id2.id.toString("base64"), id1.id.toString("base64"));
            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);
        }
    });
    it("sign unspecified data and log it in the store", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const s = (0, __2.MemoryStorage)(() => "");
            const manager = new __2.IdManager(id1, s);
            const signature = await manager.signChallenge(manager.vaultysId.id);
            if (signature == null)
                assert_1.default.fail();
            const signatures = manager.getSignatures();
            assert_1.default.equal(signatures.length, 1);
            assert_1.default.equal(signatures[0].payload.challenge.toString("hex"), manager.vaultysId.id.toString("hex"));
            assert_1.default.equal(signatures[0].payload.signature.toString("hex"), signature.toString("hex"));
            assert_1.default.equal(signatures[0].type, "UNKNOWN");
        }
    });
    it("sign random document hash and log it in the store", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const s = (0, __2.MemoryStorage)(() => "");
            const file = { arrayBuffer: __1.Buffer.from((0, crypto_2.randomBytes)(1024)), type: "random" };
            const h = (0, crypto_1.hash)("sha256", file.arrayBuffer);
            const manager = new __2.IdManager(id1, s);
            const payload = await manager.signFile(file);
            const signatures = manager.getSignatures();
            assert_1.default.equal(signatures.length, 1);
            const challenge = new URL(signatures[0].challenge);
            assert_1.default.equal(challenge.searchParams.get("hash"), h.toString("hex"));
            assert_1.default.ok(manager.verifyFile(file, signatures[0].payload, id1));
            if (payload.signature == null)
                assert_1.default.fail();
            assert_1.default.equal(signatures[0].payload.signature.toString("hex"), payload.signature.toString("hex"));
            //console.log(signatures[0]);
            assert_1.default.equal(signatures[0].type, "DOCUMENT");
        }
    });
    // it("sign login and log it in the store", async () => {
    //   const s = MemoryStorage(() => "");
    //   const loginMock = 'vaultys://login?host=https://sso.vaultys.net/interaction/1UfGEF9HDQiIreFPS3wlI&nonce=9c0c7621a790c6e697032093aeca614d183319d663aa5cc1a085e052c7f904d5&timestamp=1665498137687&challenge=dummy'
    //   const manager = new IdManager(await VaultysId.generatePerson(), s);
    //   const payload = await manager.signLogin(loginMock);
    //   const signatures = manager.getSignatures();
    //   assert.equal(signatures.length, 1);
    //   const challenge = new URL(signatures[0].challenge)
    //   assert.equal(challenge.searchParams.get('hash'), fileHashMock.toString("hex"));
    //   assert.ok(manager.verifyFile(signatures[0].payload.challenge.toString("hex"), signatures[0].payload.signature));
    //   assert.equal(signatures[0].payload.signature.toString("hex"), payload.signature.toString("hex"));
    //   //console.log(signatures[0]);
    //   assert.equal(signatures[0].type, 'LOGIN');
    // });
});
describe("SRG v0 challenge with IdManager", () => {
    it("pass a challenge", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // console.log(s2.substore("contacts"))
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            if (manager1.vaultysId.type === 0) {
                assert_1.default.equal(manager2.apps.length, 1);
                assert_1.default.equal(manager2.getApp(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            }
            else {
                assert_1.default.equal(manager2.contacts.length, 1);
                assert_1.default.equal(manager2.getContact(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
                manager2.setContactMetadata(manager1.vaultysId.did, "name", "salut");
                manager2.setContactMetadata(manager1.vaultysId.did, "group", "pro");
                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, "name"), "salut");
                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, "group"), "pro");
                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            }
        }
    });
    it("fail a challenge if user1 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("fail a challenge if user2 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("pass a challenge over encrypted Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
            };
            const metadata2 = {
                name: "d",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            manager1.setContactMetadata(manager2.vaultysId.did, "name", "salut");
            manager1.setContactMetadata(manager2.vaultysId.did, "group", "pro");
            // assert.deepStrictEqual(
            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),
            //   metadata2
            // );
            // assert.deepStrictEqual(
            //   manager1.getAllMetadata(manager2.vaultysId.did),
            //   {
            //     group: 'pro',
            //     name: 'salut',
            //     phone: 'f'
            //   }
            // );
            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
        }
    });
    it("perform PRF over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            manager1.acceptPRF(channel);
            const result = await manager2.requestPRF(channel.otherend, "nostr");
            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac("prf|nostr|prf"));
        }
    });
    it("perform decrypt over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const message = "test decrypt on demand";
            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);
            manager1.acceptDecrypt(channel);
            //console.log(toDecrypt);
            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, "utf-8"));
            assert_1.default.deepEqual(result?.toString("utf-8"), message);
        }
    });
    describe("IdManager File Encryption/Decryption", () => {
        it("should encrypt and decrypt a file between two IdManagers", async () => {
            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Create a sample file
            const fileContent = (0, crypto_2.randomBytes)(1024);
            const originalFile = {
                arrayBuffer: __2.crypto.Buffer.from(fileContent),
                type: "application/octet-stream",
                name: "test.bin",
            };
            // Set up the decryption handler on manager2
            manager2.acceptDecryptFile(channel.otherend);
            // Request encryption from manager1 to manager2
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption failed");
            assert_1.default.equal(encryptedFile.type, originalFile.type, "File type should be preserved");
            assert_1.default.equal(encryptedFile.name, originalFile.name, "File name should be preserved");
            assert_1.default.ok(encryptedFile.arrayBuffer, "Encrypted data should be present");
            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, "Encrypted data should be different from original");
            // Now decrypt the file
            channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption failed");
            assert_1.default.equal(decryptedFile.type, originalFile.type, "File type should be preserved after decryption");
            assert_1.default.equal(decryptedFile.name, originalFile.name, "File name should be preserved after decryption");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted file should match the original");
        });
        it("should work with different file types and sizes", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Test with different file types and sizes
            const testCases = [
                { size: 10, type: "text/plain", name: "small.txt" },
                { size: 1024, type: "application/pdf", name: "medium.pdf" },
                { size: 4096, type: "image/jpeg", name: "large.jpg" },
            ];
            for (const testCase of testCases) {
                const fileContent = (0, crypto_2.randomBytes)(testCase.size);
                const originalFile = {
                    arrayBuffer: __1.Buffer.from(fileContent),
                    type: testCase.type,
                    name: testCase.name,
                };
                manager2.acceptEncryptFile(channel.otherend);
                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);
                manager2.acceptDecryptFile(channel.otherend);
                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);
                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);
            }
        });
        it("should handle acceptDecryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create a sample file
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_2.randomBytes)(512)),
                type: "text/plain",
                name: "test.txt",
            };
            // Test with accepting function that returns true
            let acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Test with accepting function that returns false
            acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async () => {
                acceptCalled = true;
                return false;
            });
            const failedResult = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(acceptCalled, "Accept function should be called even when rejecting");
            assert_1.default.equal(failedResult, null, "Encryption should fail when accept returns false");
        });
        it("should handle acceptEncryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create an encrypted file
            let acceptCalled = false;
            manager2.acceptEncryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            // Create a sample file and encrypt it
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_2.randomBytes)(256)),
                type: "application/json",
                name: "data.json",
            };
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Verify we can decrypt it back
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption should succeed");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted content should match original");
        });
        it("should verify that acceptEncryptFile and acceptDecryptFile are the same function", async () => {
            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => ""));
            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, "acceptEncryptFile should be an alias of acceptDecryptFile");
        });
    });
    it("perform migration from version 0 to 1", async () => {
        const ids = [];
        for (let i = 0; i < 2; i++) {
            for (let i = 0; i < 4; i++) {
                const vid = await (0, utils_1.createRandomVaultysId)();
                const s1 = (0, __2.MemoryStorage)(() => "");
                const id1 = new __2.IdManager(vid, s1);
                for (let j = 0; j < 2; j++) {
                    for (let i = 0; i < 4; i++) {
                        const vid2 = await (0, utils_1.createRandomVaultysId)();
                        const s2 = (0, __2.MemoryStorage)(() => "");
                        const id2 = new __2.IdManager(vid2, s2);
                        id1.saveContact(id2.vaultysId);
                        id1.setContactMetadata(id2.vaultysId.did, "test", id2.vaultysId.did);
                    }
                }
                ids.push(id1);
            }
        }
        for (const id of ids) {
            id.migrate(0);
            assert_1.default.equal(id.contacts.length + id.apps.length, 8);
            id.migrate(1);
            assert_1.default.equal(id.contacts.length + id.apps.length, 8);
        }
    }).timeout(20000);
});
describe("SRG v1 challenge with IdManager", () => {
    it("pass a challenge", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            const challengers = await Promise.all([manager1.startSRP(channel, "p2p", "auth", metadata1), manager2.acceptSRP(channel.otherend, "p2p", "auth", metadata2)]);
            //console.log(challengers);
            // assert.equal(contacts[0].did, manager2.vaultysId.did);
            // assert.equal(contacts[1].did, manager1.vaultysId.did);
            ///console.log(s2, s1);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            // assert.equal(s1.substore("wot").list().length, 1);
            // assert.equal(s2.substore("wot").list().length, 1);
            // console.log(Challenger.deserializeCertificate(s2.substore("wot").get(s2.substore("wot").list()[0])));
            // if (manager1.vaultysId.type === 0) {
            //   assert.equal(manager2.apps.length, 1);
            //   assert.equal(manager2.getApp(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            // } else {
            //   assert.equal(manager2.contacts.length, 1);
            //   assert.equal(manager2.getContact(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);
            //   manager2.setContactMetadata(manager1.vaultysId.did, "name", "salut");
            //   manager2.setContactMetadata(manager1.vaultysId.did, "group", "pro");
            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, "name"), "salut");
            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, "group"), "pro");
            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
            // }
        }
    });
    it("fail a challenge if user1 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("fail a challenge if user2 refuse", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
                phone: "c",
            };
            const metadata2 = {
                name: "d",
                email: "e",
                phone: "f",
            };
            try {
                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);
            }
            catch (e) {
                assert_1.default.equal(e.message, "Error: Contact refused");
            }
        }
    });
    it("pass a challenge over encrypted Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const metadata1 = {
                name: "a",
                email: "b",
            };
            const metadata2 = {
                name: "d",
                phone: "f",
            };
            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);
            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);
            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);
            // assert.deepStrictEqual(s2.substore("contacts").get(manager1.vaultysId.did).metadata, metadata1);
            // assert.deepStrictEqual(s1.substore("contacts").get(manager2.vaultysId.did).metadata, metadata2);
            assert_1.default.equal(s1.substore("wot").list().length, 1);
            assert_1.default.equal(s2.substore("wot").list().length, 1);
            manager1.setContactMetadata(manager2.vaultysId.did, "name", "salut");
            manager1.setContactMetadata(manager2.vaultysId.did, "group", "pro");
            // assert.deepStrictEqual(
            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),
            //   metadata2
            // );
            // assert.deepStrictEqual(
            //   manager1.getAllMetadata(manager2.vaultysId.did),
            //   {
            //     group: 'pro',
            //     name: 'salut',
            //     phone: 'f'
            //   }
            // );
            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));
            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));
        }
    });
    it("perform PRF over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            manager1.acceptPRF(channel);
            const result = await manager2.requestPRF(channel.otherend, "nostr");
            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac("prf|nostr|prf"));
        }
    });
    it("perform decrypt over Channel", async () => {
        for (let i = 0; i < 5; i++) {
            const id1 = await (0, utils_1.createRandomVaultysId)();
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            // channel.setLogger((data) => console.log(data.toString("utf-8")));
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(id1, s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);
            const message = "test decrypt on demand";
            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);
            manager1.acceptDecrypt(channel);
            //console.log(toDecrypt);
            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, "utf-8"));
            assert_1.default.deepEqual(result?.toString("utf-8"), message);
        }
    });
    describe("IdManager File Encryption/Decryption", () => {
        it("should encrypt and decrypt a file between two IdManagers", async () => {
            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Create a sample file
            const fileContent = (0, crypto_2.randomBytes)(1024);
            const originalFile = {
                arrayBuffer: __2.crypto.Buffer.from(fileContent),
                type: "application/octet-stream",
                name: "test.bin",
            };
            // Set up the decryption handler on manager2
            manager2.acceptDecryptFile(channel.otherend);
            // Request encryption from manager1 to manager2
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption failed");
            assert_1.default.equal(encryptedFile.type, originalFile.type, "File type should be preserved");
            assert_1.default.equal(encryptedFile.name, originalFile.name, "File name should be preserved");
            assert_1.default.ok(encryptedFile.arrayBuffer, "Encrypted data should be present");
            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, "Encrypted data should be different from original");
            // Now decrypt the file
            channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption failed");
            assert_1.default.equal(decryptedFile.type, originalFile.type, "File type should be preserved after decryption");
            assert_1.default.equal(decryptedFile.name, originalFile.name, "File name should be preserved after decryption");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted file should match the original");
        });
        it("should work with different file types and sizes", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // Test with different file types and sizes
            const testCases = [
                { size: 10, type: "text/plain", name: "small.txt" },
                { size: 1024, type: "application/pdf", name: "medium.pdf" },
                { size: 4096, type: "image/jpeg", name: "large.jpg" },
            ];
            for (const testCase of testCases) {
                const fileContent = (0, crypto_2.randomBytes)(testCase.size);
                const originalFile = {
                    arrayBuffer: __1.Buffer.from(fileContent),
                    type: testCase.type,
                    name: testCase.name,
                };
                manager2.acceptEncryptFile(channel.otherend);
                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);
                manager2.acceptDecryptFile(channel.otherend);
                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);
                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);
                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);
            }
        });
        it("should handle acceptDecryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create a sample file
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_2.randomBytes)(512)),
                type: "text/plain",
                name: "test.txt",
            };
            // Test with accepting function that returns true
            let acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Test with accepting function that returns false
            acceptCalled = false;
            manager2.acceptDecryptFile(channel.otherend, async () => {
                acceptCalled = true;
                return false;
            });
            const failedResult = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(acceptCalled, "Accept function should be called even when rejecting");
            assert_1.default.equal(failedResult, null, "Encryption should fail when accept returns false");
        });
        it("should handle acceptEncryptFile with custom acceptance function", async () => {
            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail("Channel creation failed");
            const s1 = (0, __2.MemoryStorage)(() => "");
            const s2 = (0, __2.MemoryStorage)(() => "");
            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);
            manager1.setProtocolVersion(1);
            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);
            // First establish contact between the managers
            const contactChannel = __2.MemoryChannel.createBidirectionnal();
            if (!contactChannel.otherend)
                assert_1.default.fail("Contact channel creation failed");
            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);
            // Create an encrypted file
            let acceptCalled = false;
            manager2.acceptEncryptFile(channel.otherend, async (contact) => {
                acceptCalled = true;
                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);
                return true;
            });
            // Create a sample file and encrypt it
            const originalFile = {
                arrayBuffer: __1.Buffer.from((0, crypto_2.randomBytes)(256)),
                type: "application/json",
                name: "data.json",
            };
            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);
            assert_1.default.ok(encryptedFile, "Encryption should succeed when accept returns true");
            assert_1.default.ok(acceptCalled, "Accept function should be called");
            // Verify we can decrypt it back
            manager2.acceptDecryptFile(channel.otherend);
            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);
            assert_1.default.ok(decryptedFile, "Decryption should succeed");
            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, "Decrypted content should match original");
        });
        it("should verify that acceptEncryptFile and acceptDecryptFile are the same function", async () => {
            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => ""));
            manager.setProtocolVersion(1);
            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, "acceptEncryptFile should be an alias of acceptDecryptFile");
        });
    });
});


/***/ }),

/***/ "./test/keymanager.test.ts":
/*!*********************************!*\
  !*** ./test/keymanager.test.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
// import { publicDerivePath, privateDerivePath, HISCP } from "../src/KeyManager";
// import * as bip32 from "@stricahq/bip32ed25519";
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const tweetnacl_1 = __importDefault(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
//// @ts-expect-error weird import for @stricahq/bip32ed25519
// const bip32fix = bip32.default ?? bip32;
// const writeVector = (km: KeyManager) => {
//   return;
//   console.log("## NOT Published");
//   console.log("### proof sk:\n", new bip32fix.Bip32PrivateKey(km.proofKey.secretKey!).toPrivateKey().toBytes().toString("hex"));
//   console.log("### proof pk:\n", new bip32fix.Bip32PrivateKey(km.proofKey.publicKey).toBip32PublicKey().toPublicKey().toBytes().toString("hex"));
//   console.log("### sk = derive(proof sk, m/0'):\n", new bip32fix.Bip32PrivateKey(km.signer.secretKey!).toPrivateKey().toBytes().toString("hex"));
//   console.log("## Published");
//   console.log("### proof = sha256(proof pk):\n", km.proof.toString("hex"));
//   console.log("### pk:", km.signer.publicKey.toString("hex"));
// };
// const writeCertificate = (hiscp: HISCP) => {
//   return;
//   const hiscpDisplay = {
//     newId: hiscp.newId.toString("hex"),
//     proofKey: hiscp.proofKey.toString("hex"),
//     timestamp: hiscp.timestamp,
//   };
//   console.log("## HISCP Certificate");
//   console.log("### hiscp data:\n", JSON.stringify(hiscpDisplay, null, 2));
//   console.log("### Signature of hiscp = [newID || proofKey || timestamp] by proof sk\n", hiscp.signature.toString("hex"));
// };
describe("KeyManager tests", () => {
    // it("derive correctly keys (strica)", async () => {
    //   const node = await bip32fix.Bip32PrivateKey.fromEntropy(randomBytes(32));
    //   const publicNode = node.toBip32PublicKey();
    //   const derivedNode = privateDerivePath(node, "m/1/2/3");
    //   const publicDerivedNode = publicDerivePath(publicNode, "m/1/2/3");
    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString("hex"), publicDerivedNode.toBytes().toString("hex"));
    // });
    // it("derive correctly keys (noble)", async () => {
    //   const privateKey = ed.utils.randomPrivateKey();
    //   const node = await Bip32PrivateKey.fromEntropy(randomBytes(32));
    //   const publicNode = node.toBip32PublicKey();
    //   const derivedNode = derivePath(node, "1/2/3");
    //   const publicDerivedNode = derivePath(publicNode, "m/1/2/3");
    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString("hex"), publicDerivedNode.toBytes().toString("hex"));
    // });
    it("serder a KeyManager losing entropy", async () => {
        const km = await __1.KeyManager.generate_Id25519();
        const secret = km.getSecret();
        const km2 = __1.KeyManager.fromSecret(secret);
        assert_1.default.equal(km.id.toString("hex"), km2.id.toString("hex"));
    });
    it("serder a private KeyManager to a public KeyManager", async () => {
        const km = await __1.KeyManager.generate_Id25519();
        const id = km.id;
        const publicKM = __1.KeyManager.fromId(id);
        assert_1.default.equal(id.toString("hex"), publicKM.id.toString("hex"));
    });
    it("sign and verify a message", async () => {
        const signer = await __1.KeyManager.generate_Id25519();
        const id = signer.id;
        const verifier = __1.KeyManager.fromId(id);
        const message = buffer_1.Buffer.from("this is a message to be verified man", "utf-8");
        const signature = await signer.sign(message);
        if (!signature)
            assert_1.default.fail();
        assert_1.default.notEqual(signature, null);
        assert_1.default.ok(verifier.verify(message, signature));
    });
    // it("create and verify a HISCP Certificate", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    // });
    // it("create vector for HISCP", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   writeVector(km);
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   writeCertificate(hiscp);
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    // });
    // it("create vector for HISCP Certificate Chaining", async () => {
    //   const km = await KeyManager.generate_Id25519();
    //   writeVector(km);
    //   const hiscp = await km.createSwapingCertificate();
    //   if (!hiscp) assert.fail();
    //   writeCertificate(hiscp);
    //   const publicKM = KeyManager.fromId(km.id);
    //   publicKM.verifySwapingCertificate(hiscp);
    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));
    //   // create the new Keymanager iterating on the index
    //   if (!km.entropy) assert.fail();
    //   const newkm = await KeyManager.create_Id25519_fromEntropy(km.entropy, 1);
    //   assert.equal(newkm.id.toString("hex"), hiscp?.newId.toString("hex"));
    // });
    it("signcrypt and decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("encrypt and decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await __1.KeyManager.encrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("signcrypt and blind decrypt messages", async () => {
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const eve = await __1.KeyManager.generate_Id25519();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: signcrypt and decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: encrypt and decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await __1.VaultysId.encrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        if (!ENCRYPTED)
            assert_1.default.fail();
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("VaultysId: signcrypt and blind decrypt messages", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
    it("Decrypt a sample encrypted message", async () => {
        // const bob = await createRandomVaultysId();
        // console.log(await VaultysId.encrypt("test", [bob.id]));
        // console.log(bob.getSecret("base64"));
        const message = "BEGIN SALTPACK ENCRYPTED MESSAGE. keDIDMQWYvVR58B FTfTeD305hcoHcr Wi4X4pWBmPExHwE WaBDIrIPJ7pgJVE 2Yaxiu3jYK3Osf2 uhjKjQeNaUshMjT QrZdWGFObOEKXZS u5ZF9IyxzRQiBF8 vtIJhLH1kKcDJj4 IQGkhxNTmUljHeo ulEUOyGRt0K3CrR gVkJxxehI8H0GJy 0iJTgCMM7DEX4Jk qmUWofh3hNbfZcs G171PLnJVJ484sS ozpRNJIRMYpHD4g lEdwwVM3NfIoSW3 Cg6FKTrtiNoDgtN gvXoqM96taPvEal dAjNjMgXFcuPT2b U0CFssYXxGKzAnJ gevNrFwrZGLd78h. END SALTPACK ENCRYPTED MESSAGE.";
        const id = __1.VaultysId.fromSecret("AIShdgGhcMQg3KBa7NhKclRHgvQL/51gDBKkVt9ndZurKDM+wDY4uBSheMRgIEM+lQwxORCD8hOul7keOXea5fMYYghYYL2inBxdB1Uop0p+SGS0ju18I7OOTiMDGGKo7wzTR0xj5xxE9qpTHqHAbWi6fPFaYOXNTK1t6NwVTiNkJDrvqK1OvVrzHnOGoWXEIJRd5AQLlhofk5h7yIGMHzJt5kWUX/J+sTH4gQhGtW1S", "base64");
        const decrypted = await id.decrypt(message);
        assert_1.default.equal(decrypted, "test");
    });
    it("should perform Diffie-Hellman key exchange between two KeyManager instances", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Alice performs DH with Bob
        const aliceSharedSecret = await alice.performDiffieHellman(bob);
        // Bob performs DH with Alice
        const bobSharedSecret = await bob.performDiffieHellman(alice);
        // Verify that they derived the same shared secret
        assert_1.default.notEqual(aliceSharedSecret, null);
        assert_1.default.notEqual(bobSharedSecret, null);
        assert_1.default.equal(aliceSharedSecret?.toString("hex"), bobSharedSecret?.toString("hex"));
    });
    it("should perform Diffie-Hellman key exchange using static method", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Perform DH using static method
        const sharedSecret1 = await __1.KeyManager.diffieHellman(alice, bob);
        const sharedSecret2 = await __1.KeyManager.diffieHellman(bob, alice);
        // Verify that the static method derives the same shared secret regardless of order
        assert_1.default.notEqual(sharedSecret1, null);
        assert_1.default.notEqual(sharedSecret2, null);
        assert_1.default.equal(sharedSecret1?.toString("hex"), sharedSecret2?.toString("hex"));
    });
    it("should fail Diffie-Hellman key exchange with a public KeyManager", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bobPrivate = await __1.KeyManager.generate_Id25519();
        // Create a public-only version of Bob's KeyManager
        const bobPublic = __1.KeyManager.fromId(bobPrivate.id);
        // Alice attempts DH with Bob's public KeyManager (should fail)
        const aliceSharedSecret = await alice.performDiffieHellman(bobPublic);
        // Bob's public KeyManager attempts DH with Alice (should fail)
        const bobSharedSecret = await bobPublic.performDiffieHellman(alice);
        // Verify that the operations failed
        // assert.equal(aliceSharedSecret, null);
        assert_1.default.equal(bobSharedSecret, null);
    });
    it("should be able to use DH shared secret for encryption and decryption", async () => {
        // Create two key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        // Perform DH to get shared secret
        const aliceSharedSecret = await alice.performDiffieHellman(bob);
        assert_1.default.notEqual(aliceSharedSecret, null);
        const nonce = tweetnacl_1.default.randomBytes(tweetnacl_1.default.box.nonceLength);
        // Use the shared secret for encryption (using a simple XOR for demonstration)
        const plaintext = buffer_1.Buffer.from("Secret message for testing", "utf-8");
        const encryptedMessage = tweetnacl_1.default.secretbox(plaintext, nonce, aliceSharedSecret);
        // Bob also derives the shared secret
        const bobSharedSecret = await bob.performDiffieHellman(alice);
        assert_1.default.notEqual(bobSharedSecret, null);
        // Bob decrypts the message
        const decryptedMessage = buffer_1.Buffer.from(tweetnacl_1.default.secretbox.open(encryptedMessage, nonce, bobSharedSecret));
        // Verify the decrypted message matches the original
        assert_1.default.equal(decryptedMessage.toString("utf-8"), plaintext.toString("utf-8"));
    });
    it("should generate different shared secrets with different key pairs", async () => {
        // Create three key managers
        const alice = await __1.KeyManager.generate_Id25519();
        const bob = await __1.KeyManager.generate_Id25519();
        const charlie = await __1.KeyManager.generate_Id25519();
        // Alice-Bob shared secret
        const secretAB = await alice.performDiffieHellman(bob);
        // Alice-Charlie shared secret
        const secretAC = await alice.performDiffieHellman(charlie);
        // Bob-Charlie shared secret
        const secretBC = await bob.performDiffieHellman(charlie);
        // Verify all shared secrets are different
        assert_1.default.notEqual(secretAB?.toString("hex"), secretAC?.toString("hex"));
        assert_1.default.notEqual(secretAB?.toString("hex"), secretBC?.toString("hex"));
        assert_1.default.notEqual(secretAC?.toString("hex"), secretBC?.toString("hex"));
    });
});


/***/ }),

/***/ "./test/pqc.test.ts":
/*!**************************!*\
  !*** ./test/pqc.test.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
const pqCrypto_1 = __webpack_require__(/*! ../src/pqCrypto */ "./src/pqCrypto.ts");
const buffer_1 = __webpack_require__(/*! buffer/ */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js");
describe("Post-Quantum Cryptography", () => {
    let keyPair;
    const testMessage = buffer_1.Buffer.from("Hello, Post-Quantum World!");
    beforeEach(() => {
        keyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
    });
    describe("DILITHIUM Key Generation", () => {
        it("should generate different key pairs on each call", async () => {
            const keyPair1 = (0, pqCrypto_1.generateDilithiumKeyPair)();
            const keyPair2 = (0, pqCrypto_1.generateDilithiumKeyPair)();
            assert_1.default.notDeepEqual(keyPair1.publicKey, keyPair2.publicKey);
            assert_1.default.notDeepEqual(keyPair1.secretKey, keyPair2.secretKey);
        });
        it("should generate keys with correct sizes", async () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(keyPair.publicKey.length, keyInfo.publicKeySize);
            assert_1.default.equal(keyPair.secretKey.length, keyInfo.secretKeySize);
        });
    });
    describe("DILITHIUM Signing", () => {
        it("should sign a message successfully", async () => {
            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
            assert_1.default.equal(signature.length > 0, true);
        });
        it("should produce signatures of correct size", async () => {
            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(signature.length, keyInfo.signatureSize);
        });
        it("should produce different signatures for different messages", async () => {
            const message1 = buffer_1.Buffer.from("Message 1");
            const message2 = buffer_1.Buffer.from("Message 2");
            const signature1 = (0, pqCrypto_1.signDilithium)(message1, keyPair.secretKey);
            const signature2 = (0, pqCrypto_1.signDilithium)(message2, keyPair.secretKey);
            assert_1.default.notDeepEqual(signature1, signature2);
        });
    });
    describe("DILITHIUM Verification", () => {
        let signature;
        beforeEach(async () => {
            signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);
        });
        it("should verify a valid signature", async () => {
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, keyPair.publicKey);
            assert_1.default.equal(isValid, true);
        });
        it("should reject an invalid signature", async () => {
            const invalidSignature = buffer_1.Buffer.alloc(signature.length, 0);
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, invalidSignature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should reject signature with wrong message", async () => {
            const wrongMessage = buffer_1.Buffer.from("Wrong message");
            const isValid = (0, pqCrypto_1.verifyDilithium)(wrongMessage, signature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should reject signature with wrong public key", async () => {
            const wrongKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, wrongKeyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
        it("should work with Uint8Array inputs", async () => {
            const messageArray = new Uint8Array(testMessage);
            const signatureArray = new Uint8Array(signature);
            const publicKeyArray = new Uint8Array(keyPair.publicKey);
            const isValid = (0, pqCrypto_1.verifyDilithium)(messageArray, signatureArray, publicKeyArray);
            assert_1.default.equal(isValid, true);
        });
        it("should handle corrupted signature gracefully", async () => {
            const corruptedSignature = buffer_1.Buffer.from(signature);
            corruptedSignature[0] = corruptedSignature[0] ^ 0xff; // Flip bits
            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, corruptedSignature, keyPair.publicKey);
            assert_1.default.equal(isValid, false);
        });
    });
    describe("COSE Key Creation", () => {
        it("should create a valid COSE key", () => {
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(keyPair.publicKey);
            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);
            assert_1.default.equal(coseKey.get(3), pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);
            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE), 2);
            assert_1.default.deepEqual(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), keyPair.publicKey);
        });
        it("should work with Uint8Array input", () => {
            const publicKeyArray = new Uint8Array(keyPair.publicKey);
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(publicKeyArray);
            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);
        });
    });
    describe("Key Info", () => {
        it("should return correct key size information", () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            assert_1.default.equal(keyInfo.publicKeySize, 1952);
            assert_1.default.equal(keyInfo.secretKeySize, 4032);
            assert_1.default.equal(keyInfo.signatureSize, 3309);
        });
        it("should match actual generated key sizes", async () => {
            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();
            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            assert_1.default.equal(testKeyPair.publicKey.length, keyInfo.publicKeySize);
            assert_1.default.equal(testKeyPair.secretKey.length, keyInfo.secretKeySize);
        });
    });
    describe("Constants", () => {
        it("should have correct COSE algorithm identifiers", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM2, -46);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM3, -47);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM5, -48);
        });
        it("should have correct COSE key type", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM, 4);
        });
        it("should have correct COSE key parameters", () => {
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, -100);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, -101);
            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_SK, -102);
        });
    });
    describe("End-to-End Workflow", () => {
        it("should complete full sign-verify cycle", async () => {
            // Generate keys
            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();
            // Sign message
            const message = buffer_1.Buffer.from("End-to-end test message");
            const signature = (0, pqCrypto_1.signDilithium)(message, testKeyPair.secretKey);
            // Verify signature
            const isValid = (0, pqCrypto_1.verifyDilithium)(message, signature, testKeyPair.publicKey);
            // Create COSE key
            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(testKeyPair.publicKey);
            assert_1.default.equal(isValid, true);
            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), testKeyPair.publicKey);
        });
        it("should handle multiple signatures with same key pair", async () => {
            const messages = [buffer_1.Buffer.from("Message 1"), buffer_1.Buffer.from("Message 2"), buffer_1.Buffer.from("Message 3")];
            const signatures = [];
            // Sign all messages
            for (const message of messages) {
                const signature = (0, pqCrypto_1.signDilithium)(message, keyPair.secretKey);
                signatures.push(signature);
            }
            // Verify all signatures
            for (let i = 0; i < messages.length; i++) {
                const isValid = (0, pqCrypto_1.verifyDilithium)(messages[i], signatures[i], keyPair.publicKey);
                assert_1.default.equal(isValid, true);
            }
        });
    });
});


/***/ }),

/***/ "./test/pqcManager.web.test.ts":
/*!*************************************!*\
  !*** ./test/pqcManager.web.test.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const VaultysId_1 = __importDefault(__webpack_require__(/*! ../src/VaultysId */ "./src/VaultysId.ts"));
const crypto_1 = __webpack_require__(/*! ../src/crypto */ "./src/crypto.ts");
describe("PQC", () => {
    it("serder a VaultytsID secret - software", async () => {
        const vaultysId = await VaultysId_1.default.generatePerson(true);
        if (!vaultysId)
            assert_1.default.fail("VaultysId creation failed");
        assert_1.default.equal(vaultysId.id.length, 2034);
        assert_1.default.equal(vaultysId.id.toString("hex").length, 4068);
        assert_1.default.equal(vaultysId.id.toString("base64").length, 2712);
        assert_1.default.equal(vaultysId.keyManager.signer.publicKey.length, 1952);
        const id2 = VaultysId_1.default.fromSecret(vaultysId.getSecret());
        assert_1.default.equal(vaultysId.id.toString("hex"), id2.id.toString("hex"));
    });
    it("serder a VaultytsID - software", async () => {
        const vaultysId = await VaultysId_1.default.generateOrganization(true);
        if (!vaultysId)
            assert_1.default.fail("VaultysId creation failed");
        assert_1.default.equal(vaultysId.keyManager.signer.publicKey.length, 1952);
        assert_1.default.equal(vaultysId.id.length, 2034);
        const id2 = VaultysId_1.default.fromId(vaultysId.id);
        assert_1.default.equal(vaultysId.id.toString("hex"), id2.id.toString("hex"));
    });
    it("sign/verify with VaultytsID - software", async () => {
        const vaultysId = await VaultysId_1.default.generateMachine(true);
        if (!vaultysId)
            assert_1.default.fail("VaultysId creation failed");
        const challenge = (0, crypto_1.randomBytes)(32);
        const signature = await vaultysId.signChallenge(challenge);
        assert_1.default.equal(vaultysId.verifyChallenge(challenge, signature, false), true);
    });
});


/***/ }),

/***/ "./test/saltpack.test.ts":
/*!*******************************!*\
  !*** ./test/saltpack.test.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
describe("Saltpack", () => {
    it("Saltpack working with ID", async () => {
        const alice = await (0, utils_1.createRandomVaultysId)();
        const bob = await (0, utils_1.createRandomVaultysId)();
        const eve = await (0, utils_1.createRandomVaultysId)();
        const plaintext = "This message is authentic!";
        const recipients = [bob.id, eve.id, alice.id.toString("hex")];
        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);
        if (!ENCRYPTED)
            assert_1.default.fail();
        assert_1.default.equal(ENCRYPTED.substring(0, 33), "BEGIN SALTPACK ENCRYPTED MESSAGE.");
        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);
        const decryptedEve = await eve.decrypt(ENCRYPTED);
        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);
        assert_1.default.equal(decryptedEve, plaintext);
        assert_1.default.equal(decryptedEve, decryptedBob);
        assert_1.default.equal(decryptedEve, decryptedAlice);
    });
});


/***/ }),

/***/ "./test/shims.ts":
/*!***********************!*\
  !*** ./test/shims.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// nodejs polyfill
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
if (typeof window !== "undefined") {
    window.global = window;
    // @ts-ignore
    window.process = { env: {} };
}
else {
    if (__webpack_require__.g.navigator) {
        // node > 20
        // @ts-ignore
        __webpack_require__.g.navigator.credentials = SoftCredentials_1.default;
    }
    else {
        // node <= 20
        // @ts-ignore
        __webpack_require__.g.navigator = {
            // @ts-ignore
            credentials: SoftCredentials_1.default,
        };
    }
}
if (!__webpack_require__.g.atob)
    __webpack_require__.g.atob = (str) => Buffer.from(str, "base64").toString("latin1");
if (!__webpack_require__.g.btoa)
    __webpack_require__.g.btoa = (str) => Buffer.from(str, "latin1").toString("base64");
// @ts-ignore
__webpack_require__.g.CredentialUserInteractionRequest = () => __webpack_require__.g.CredentialUserInteractionRequested++;


/***/ }),

/***/ "./test/softCredentials.test.ts":
/*!**************************************!*\
  !*** ./test/softCredentials.test.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "./node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js"));
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
// credentials request payload
const createRequest = (alg) => {
    const challenge = crypto_1.default.randomBytes(32);
    return {
        publicKey: {
            challenge,
            rp: {
                name: "Tests ID",
                id: "I am the new guy",
            },
            user: {
                id: Buffer.from("ertyu45678RUTYESEZTYSDYJTUE4576232453", "utf8"),
                name: "john.smith@mail.com",
                displayName: "John Smith",
            },
            pubKeyCredParams: [
                {
                    type: "public-key",
                    alg,
                },
            ],
        },
    };
};
let attestation;
let attestationSafe;
describe("SoftCredentials", () => {
    it("create attestation (ECDSA)", async () => {
        attestation = await SoftCredentials_1.default.create(createRequest(-7));
        //console.log(attestation);
    });
    it("create attestation (EdDSA)", async () => {
        attestationSafe = await SoftCredentials_1.default.create(createRequest(-8));
    });
    it("get assertion and verify with attestation using ECDSA", async () => {
        const payload = {
            publicKey: {
                challenge: crypto_1.default.randomBytes(32),
                allowCredentials: [
                    {
                        type: "public-key",
                        id: attestation.rawId,
                    },
                ],
            },
        };
        const assertion = await SoftCredentials_1.default.get(payload);
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(Buffer.from(assertion.response.clientDataJSON)), payload.publicKey.challenge.toString("base64"));
        const verified = SoftCredentials_1.default.verify(attestation, assertion);
        assert_1.default.ok(verified);
    });
    it("verify assertion with attestation using github webauthn json coming from yubikey credentials", async () => {
        const attestationSafe = {
            type: "public-key",
            id: "vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA",
            rawId: Buffer.from("vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiZkl3bFU5NHNNcUsyMVNrX1BYbFIzU2hLU0JVc0t6dFVpX0pqNE5YampSOCIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ", "base64"),
                attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjh3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolBBAAAAAQAAAAAAAAAAAAAAAAAAAAAAgLy4xOjmwXw2QmUiRKrdR4Q6JLjujuRc7cew0n0LbO0BGo9Am469Eq8vo1binQwNzicM5PI4coI5uvulrJIbFjMgQ3DDLYrTErcGO4rPBu6QirlIqw2d_gCmWAKppxegqiIiwcUsbw5ddYlTjHAYJBcDi3_Kxqr9OXN5Oq9l2dEgpAEBAycgBiFYIO6J63OnkjzyQ--iXSbgm1oLSl3wzlDCy4ohwkbN-l4I", "base64"),
                transports: ["nfc", "usb", "ble", "internal", "hybrid"],
            },
            clientExtensionResults: {},
        };
        const assertion = {
            type: "public-key",
            id: "vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA",
            rawId: Buffer.from("vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQU9tZmdkbnV4cl8ydWw4T1pMekFXUk1SYkd0NXkzbHIxMURxcnF3UUdMVSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wucWp6OXprL3lhYlBleCJ9", "base64"),
                authenticatorData: Buffer.from("3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolABAAAAIQ", "base64"),
                signature: Buffer.from("_eq8EwX_twQyWjyiCvCDu5JLKEWpMxW9Pz0Qwpt8A5UcHJyGoGQMrssaws-jwqIpKxkVU7MBlHzHUgFULFn5Cw", "base64"),
                userHandle: null,
            },
            clientExtensionResults: {},
        };
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), "fIwlU94sMqK21Sk/PXlR3ShKSBUsKztUi/Jj4NXjjR8=");
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), "AOmfgdnuxr/2ul8OZLzAWRMRbGt5y3lr11DqrqwQGLU=");
        // @ts-expect-error mockup
        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion);
        assert_1.default.ok(verified);
    });
    it("attestation response from yubikey should be verified", async () => {
        const response = {
            clientDataJSON: Buffer.from("eyJjaGFsbGVuZ2UiOiJZTVdFVGYtUDc5aU1iLUJxZFRreVNOUmVPdmE3bksyaVZDOWZpQzhpR3ZZeXB1bkVPQ1pHWjYtWTVPVjFydk1pRGdBaldmRmk2VUMwV3lLR3NqQS1nQSIsIm9yaWdpbiI6Imh0dHBzOi8vd2ViYXV0aG4ub3JnIiwidHlwZSI6IndlYmF1dGhuLmNyZWF0ZSJ9", "base64"),
            attestationObject: Buffer.from("o2NmbXRmcGFja2VkZ2F0dFN0bXSjY2FsZyZjc2lnWEcwRQIhAIzOihC6Ba80o5JnoYOJJ_EtEVmWQcAvxVCnsCFnVRQZAiAfeIddLPsPl1FeSX8B5xZANcQKGNoO7pb0TZPnuJdebGN4NWOBWQKzMIICrzCCAZegAwIBAgIESFs9tjANBgkqhkiG9w0BAQsFADAhMR8wHQYDVQQDDBZZdWJpY28gRklETyBQcmV2aWV3IENBMB4XDTE4MDQxMjEwNTcxMFoXDTE4MTIzMTEwNTcxMFowbzELMAkGA1UEBhMCU0UxEjAQBgNVBAoMCVl1YmljbyBBQjEiMCAGA1UECwwZQXV0aGVudGljYXRvciBBdHRlc3RhdGlvbjEoMCYGA1UEAwwfWXViaWNvIFUyRiBFRSBTZXJpYWwgMTIxMzkzOTEyNjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABPss3TBDKMVySlDM5vYLrX0nqRtZ4eZvKXuJydQ9wrLHeIm08P-dAijLlG384BsZWJtngEqsl38oGJzNsyV0yiijbDBqMCIGCSsGAQQBgsQKAgQVMS4zLjYuMS40LjEuNDE0ODIuMS42MBMGCysGAQQBguUcAgEBBAQDAgQwMCEGCysGAQQBguUcAQEEBBIEEPigEfOMCk0VgAYXER-e3H0wDAYDVR0TAQH_BAIwADANBgkqhkiG9w0BAQsFAAOCAQEAMvPkvVjXQiuvSZmGCB8NqTvGqhxyEfkoU-vz63PaaTsG3jEzjl0C7PZ26VxCvqWPJdM3P3e7Kp18sj4RjEHUmkya2PPipOwBd3p0qMQSQ8MeziCPLQ9uvGGb4YShcvaprMv4c21b4piza-znHneNCmmq-ZS4Y23o-vYv085_BEwyLPcmPjSZ5qWysCq7rVvZ7OWwcU1zu5RhSZyUKl8dzK9lAzs5OdRH2fzEewsW2OkB_Ow_jBvAxqwLXXTHuwMFaRfpmBoZuQlcofSrnwJ8KA-K-e0dKTz2zC8EbZrWYrSpbrHKyqxeBT6DkUd8H4tgAd5lOr_yqrtVmIaRfq07NmhhdXRoRGF0YVjElWkIjx7O4yMpVANdvRDXyuORMFonUbVZu4_Xy7IpvdRBAAAAAPigEfOMCk0VgAYXER-e3H0AQMLC68jgMVzFOeLNnwklj81o1xzgSj6ZaDflB37Y-P66SLugWcTV6aZvNn-2Ool_RRDiinkufjdkwC3ssy5yXwClAQIDJiABIVggAYD1TSpf120DSVxen8ki56kF1bmT4EXO-P0JnSk5mMwiWCB3TlMZBRqPY6llzDcfHd-oW0EHdaFNgBdlGGFobpHKlw", "base64"),
        };
        // @ts-expect-error mockup
        const info = SoftCredentials_1.default.getCertificateInfo(response);
        assert_1.default.deepStrictEqual(info, {
            issuer: "CN=Yubico FIDO Preview CA",
            issuerName: "CN=Yubico FIDO Preview CA",
            subject: {
                C: "SE",
                O: "Yubico AB",
                OU: "Authenticator Attestation",
                CN: "Yubico U2F EE Serial 1213939126",
            },
            version: "v3 (2)",
            basicConstraintsCA: false,
        });
        // @ts-expect-error mockup
        assert_1.default.ok(await SoftCredentials_1.default.verifyPackedAttestation(response));
    });
    it("no attestation in response should be valid and not be verified", async () => {
        const response = {
            attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjFk2rw5H3LiaP/1p3XV4I1wW43p60EG8RCpFuQTrBOPiRFAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQGV0qcd/M/uuCBaLC0jX8PRZ9e5cEZTKp9Ngf6NCKWSdWinmpK7FYog14m5kfAepzh93Z4hrGD8M57ljxoBKXL0pQECAyYgASFYIIqukdwfB/WgIxfpOO3tGOKIp+xPsx1TCc2UPjC7G7BlIlggNJL1zJSlN2EAFhnKSxihoY6HZXopi1Wte83dgWlosoQ=", "base64"),
            clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiWXpTYkpBbGIya0N6Qm1xa1U3cG9Nem92LXNONU5HcHRuWUFrUElkRWt4VSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5c2lkMi5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ==", "base64"),
        };
        // @ts-expect-error mockup
        const info = SoftCredentials_1.default.getCertificateInfo(response);
        assert_1.default.equal(info, null);
        // @ts-expect-error mockup
        assert_1.default.ok(!(await SoftCredentials_1.default.verifyPackedAttestation(response)));
    });
    it("verify assertion with attestation using github webauthn json coming from macosx credentials", async () => {
        const attestationSafe = {
            type: "public-key",
            id: "AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww",
            rawId: Buffer.from("AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYVJFMWVnWjZHMS1BRUVPSXpQbWxOckFnT1N5RWVWRG44OUtDREUxRGRPRSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wveWFiUGV4In0", "base64"),
                attestationObject: Buffer.from("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVkBP95PnSmphYcbW5aQmrH4XxNTCSWKcxK2I6tg6rwoRqJQRWH4It6tzgACNbzGCmSLCyXx8FUDALsB0ZOqKwDT-cWVs5CONEISWspV32MwLtg4zUubj0ChAUtd9UrxNBmi-E3xgRklpMdTscGJhgCcIfjAgMANx5bSdj9RKVz_4oszDIH81EvIuBtDfhJQtNJiMcXi09lY7vVaDBpcLGnhM-LovZKjQvfDoH_G_1Zu98IoMCnnomTjiT-VCw_jfVb-DmFjU-x3Wv9U4i668_5h-W7HBZLoLiafYEu-n8tt12Gf1VT9frDUfMcmI5lubUOWTRjDpQECAyYgASFYIM3N0z1jSTixc7fNwxy1BtBUrNUOiPOm2j7Zlwx6s8eXIlggKB-zZiuYTAaAdPVQuN5EUQeRNX0kjS2oikGCJsymvH8", "base64"),
                transports: ["internal"],
            },
            clientExtensionResults: {},
        };
        const assertion = {
            type: "public-key",
            id: "AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww",
            rawId: Buffer.from("AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww", "base64"),
            response: {
                clientDataJSON: Buffer.from("eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoibUlySjNsVWxsNXRadjhfa25kMEJEeU12VlVFcnhBY19CWWNkX2hOQ2lZZyIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ", "base64"),
                authenticatorData: Buffer.from("3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolAFYgu7dQ", "base64"),
                signature: Buffer.from("MEQCIFyGZIbrLunau93lnx0vTkWQjr_CcTkjYhyZ1-szXRPeAiBXwyQRQhMn59eva_CRlZOTQ_TLAgxr3eCWbwa1dQBnTA", "base64"),
                userHandle: Buffer.from("ZGlkOnZhdWx0eXM6MzI2ZjUyY2VkNjRhYmE4YzQ4MWRkMDU3ZDFkODA0MGY0ZWE3MzZiMA", "base64"),
            },
            clientExtensionResults: {},
        };
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), "aRE1egZ6G1+AEEOIzPmlNrAgOSyEeVDn89KCDE1DdOE=");
        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), "mIrJ3lUll5tZv8/knd0BDyMvVUErxAc/BYcd/hNCiYg=");
        // @ts-expect-error mockup
        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion, true);
        assert_1.default.ok(verified);
    });
});


/***/ }),

/***/ "./test/utils.ts":
/*!***********************!*\
  !*** ./test/utils.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRandomVaultysId = void 0;
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const SoftCredentials_1 = __importDefault(__webpack_require__(/*! ../src/platform/SoftCredentials */ "./src/platform/SoftCredentials.ts"));
const pqCrypto_1 = __webpack_require__(/*! ../src/pqCrypto */ "./src/pqCrypto.ts");
const createRandomVaultysId = async () => {
    const types = [0, 1, 2];
    if (typeof window === "undefined") {
        types.push(3);
        types.push(4);
    }
    const pqc = Math.random() < 0.5;
    const type = types[Math.floor(Math.random() * types.length)];
    switch (type) {
        case 0:
            return __1.VaultysId.generateMachine(pqc);
        case 1:
            return __1.VaultysId.generatePerson(pqc);
        case 2:
            return __1.VaultysId.generateOrganization(pqc);
        case 3:
            const attestation1 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, false));
            // @ts-expect-error mockup
            return __1.VaultysId.fido2FromAttestation(attestation1);
        case 4:
            const attestation2 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, true));
            // @ts-expect-error mockup
            return __1.VaultysId.fido2FromAttestation(attestation2);
        default:
            return __1.VaultysId.generatePerson();
    }
};
exports.createRandomVaultysId = createRandomVaultysId;


/***/ }),

/***/ "./test/v0toV1.test.ts":
/*!*****************************!*\
  !*** ./test/v0toV1.test.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(/*! ../ */ "./dist/node/index.js");
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js"));
__webpack_require__(/*! ./shims */ "./test/shims.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./test/utils.ts");
const generateWot = async (max = 4) => {
    const result = [];
    for (let i = 0; i < max; i++) {
        const vaultysId = await __1.VaultysId.generatePerson();
        const s = (0, __1.MemoryStorage)(() => "");
        const jeanjacques = new __1.IdManager(vaultysId, s);
        result.push(jeanjacques);
    }
    return result;
};
const testCertificate = (rogueCert) => {
    try {
        const result = __1.Challenger.deserializeCertificate(rogueCert);
        return result;
    }
    catch (error) {
        return {
            state: -2,
        };
    }
};
describe("VaultysId Migration", () => {
    it("create VaultysId  with version 1 by default", async () => {
        const bob = await (0, utils_1.createRandomVaultysId)();
        assert_1.default.equal(bob.version, 1);
    });
    it("Migrate VaultysId to Version 0", async () => {
        const bob = await (0, utils_1.createRandomVaultysId)();
        bob.toVersion(0);
        assert_1.default.equal(bob.version, 0);
    });
    it("Migrate IdManager to Version 0", async () => {
        const vaultysId = await (0, utils_1.createRandomVaultysId)();
        const s = (0, __1.MemoryStorage)(() => "");
        const bob = new __1.IdManager(vaultysId, s);
        const wot = await generateWot();
        for (let i = 0; i < wot.length; i++) {
            const jeanjacques = wot[i];
            const channel = __1.MemoryChannel.createBidirectionnal();
            if (!channel.otherend)
                assert_1.default.fail();
            await Promise.all([jeanjacques.askContact(channel), bob.acceptContact(channel.otherend)]);
        }
        bob.migrate(0);
        wot.forEach((jeanjacques) => {
            jeanjacques.migrate(0);
            // console.log(jeanjacques);
            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);
        });
        assert_1.default.equal(bob.store.substore("wot").list().length, wot.length);
        assert_1.default.equal(bob.store.substore("contacts").list().length, wot.length);
        assert_1.default.equal(bob.vaultysId.version, 0);
        bob.migrate(1);
        wot.forEach((jeanjacques) => {
            jeanjacques.migrate(1);
            //console.log(jeanjacques);
            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);
        });
        assert_1.default.equal(bob.store.substore("wot").list().length, wot.length);
        assert_1.default.equal(bob.store.substore("contacts").list().length, wot.length);
        assert_1.default.equal(bob.vaultysId.version, 1);
    }).timeout(5000);
});
describe("Symetric Proof of Relationship - SRG - V0", () => {
    it("Perform Protocol with KeyManager", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 0);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Succeed for different vaultysId versions", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 0);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
});
describe("Symetric Proof of Relationship - SRG - V1", () => {
    it("Perform Protocol with KeyManager", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1);
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.equal(challenger1.isComplete(), false);
        assert_1.default.equal(challenger1.hasFailed(), false);
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(!challenger2.isComplete());
        await challenger2.update(challenger1.getCertificate());
        // SYMETRIC PROOF
        assert_1.default.ok(challenger1.isComplete());
        assert_1.default.ok(challenger2.isComplete());
        assert_1.default.equal(challenger1.toString(), challenger2.toString());
    });
    it("Succeed for different vaultysId versions", async () => {
        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();
        const challenger1 = new __1.Challenger(vaultysId1.toVersion(0));
        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();
        const challenger2 = new __1.Challenger(vaultysId2);
        assert_1.default.ok(!challenger1.isComplete());
        assert_1.default.ok(!challenger1.hasFailed());
        challenger1.createChallenge("p2p", "auth", 1);
        await challenger2.update(challenger1.getCertificate());
        await challenger1.update(challenger2.getCertificate());
        await challenger2.update(challenger1.getCertificate());
    });
});


/***/ }),

/***/ "?2534":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?718d":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?78b1":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9bba":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b231":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./test/shims.ts");
/******/ 	__webpack_require__("./test/pqc.test.ts");
/******/ 	__webpack_require__("./test/pqcManager.web.test.ts");
/******/ 	__webpack_require__("./test/challenger_v0.test.ts");
/******/ 	__webpack_require__("./test/challenger.test.ts");
/******/ 	__webpack_require__("./test/file.browser_test.ts");
/******/ 	__webpack_require__("./test/channel.test.ts");
/******/ 	__webpack_require__("./test/idManager.test.ts");
/******/ 	__webpack_require__("./test/saltpack.test.ts");
/******/ 	__webpack_require__("./test/softCredentials.test.ts");
/******/ 	__webpack_require__("./test/v0toV1.test.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./test/keymanager.test.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=test-bundle.js.map