{"version":3,"file":"test-bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,8CAA8C,GAAG,8CAA8C,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,cAAc,GAAG,cAAc;AACnW,qCAAqC,mBAAO,CAAC,uDAAkB;AAC/D,kBAAkB;AAClB,oCAAoC,mBAAO,CAAC,qDAAiB;AAC7D,iBAAiB;AACjB,qCAAqC,mBAAO,CAAC,uDAAkB;AAC/D,kBAAkB;AAClB,oCAAoC,mBAAO,CAAC,qDAAiB;AAC7D,iBAAiB;AACjB,wBAAwB,mBAAO,CAAC,6DAAqB;AACrD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,0EAAyE,EAAE,qCAAqC,kEAAkE,EAAC;AACnL,0EAAyE,EAAE,qCAAqC,kEAAkE,EAAC;AACnL,wBAAwB,mBAAO,CAAC,6DAAqB;AACrD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,gDAA+C,EAAE,qCAAqC,wCAAwC,EAAC;AAC/H,yCAAyC,mBAAO,CAAC,+DAAsB;AACvE,sBAAsB;AACtB,wCAAwC,mBAAO,CAAC,6DAAqB;AACrE,qBAAqB;AACrB;AACA,4BAA4B,mBAAO,CAAC,+CAAc;AAClD,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpEa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,oCAAoC,mBAAO,CAAC,iDAAa;AACzD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAkE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAAgF;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAA8D;AAC9E,yBAAyB;AACzB;AACA;AACA;AACA;AACA,gBAAgB,0EAA0E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAiF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAmE;AAC/E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,wBAAwB,iBAAiB,uBAAuB,eAAe,uBAAuB,SAAS,sBAAsB;AAC9M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,kBAAkB,qBAAqB,WAAW;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,wBAAwB,iBAAiB,uBAAuB,eAAe,uBAAuB,SAAS,sBAAsB;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,oBAAoB,uBAAuB,eAAe;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AClgBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,mBAAmB,mBAAO,CAAC,iEAAqB;AAChD,qCAAqC,mBAAO,CAAC,mDAAc;AAC3D,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,0CAA0C,mBAAO,CAAC,+EAA4B;AAC9E,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,mBAAmB,mBAAO,CAAC,+CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACtOF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,0CAA0C,mBAAO,CAAC,+EAA4B;AAC9E,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,uCAAuC,mBAAO,CAAC,uDAAgB;AAC/D,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,mBAAmB,mBAAO,CAAC,+CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACzIF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,2CAAU;AACnC;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,wBAAwB,QAAQ;AAChC;AACA,gCAAgC,WAAW;AAC3C,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACpHa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC,mBAAO,CAAC,mDAAc;AAC3D,uCAAuC,mBAAO,CAAC,uDAAgB;AAC/D,qCAAqC,mBAAO,CAAC,mDAAc;AAC3D,wBAAwB,mBAAO,CAAC,yDAAiB;AACjD,0CAA0C,mBAAO,CAAC,+EAA4B;AAC9E,oCAAoC,mBAAO,CAAC,iDAAa;AACzD,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,0CAA0C,mBAAO,CAAC,6DAAmB;AACrE,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,oCAAoC,mBAAO,CAAC,iDAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAiE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0EAA0E,EAAE,aAAa,WAAW;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iEAAiE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4HAA4H;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC5qBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,mBAAmB,mBAAO,CAAC,0HAAmB;AAC9C,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,kBAAkB,mBAAO,CAAC,6GAAuB;AACjD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,UAAU;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC9cF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB,8CAA8C;AAC9C,8CAA8C;AAC9C,wCAAwC,mBAAO,CAAC,yDAAiB;AACjE,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA,gCAAgC;AAChC;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,yCAAyC;AACzC;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AC5VR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB;AACtF,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;ACnFa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,mBAAmB,mBAAO,CAAC,+CAAY;AACvC,qCAAqC,mBAAO,CAAC,mDAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACtGF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,uCAAuC,mBAAO,CAAC,uDAAgB;AAC/D,0CAA0C,mBAAO,CAAC,6DAAmB;AACrE,qCAAqC,mBAAO,CAAC,mDAAc;AAC3D,0CAA0C,mBAAO,CAAC,+EAA4B;AAC9E,mBAAmB,mBAAO,CAAC,iEAAqB;AAChD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,iDAAa;AACzD,mBAAmB,mBAAO,CAAC,+CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS,GAAG,QAAQ;AAClD;AACA;AACA,+CAA+C,SAAS,GAAG,QAAQ;AACnE,kCAAkC,SAAS,GAAG,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sEAAsE,GAAG,OAAO,MAAM,QAAQ,KAAK,SAAS,WAAW;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,6BAA6B,4DAA4D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC7cF;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,gBAAgB,GAAG,eAAe,GAAG,kBAAkB,GAAG,cAAc,GAAG,aAAa,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,YAAY,GAAG,YAAY,GAAG,cAAc;AAC1N,iCAAiC,mBAAO,CAAC,2FAAW;AACpD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,iBAAiB;AACjB;AACA,gBAAgB;AAChB;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,eAAe;AACf;AACA,gBAAgB;AAChB;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AC5EN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,eAAe;AACjC,iBAAiB,mBAAO,CAAC,2CAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iBAAiB,mBAAO,CAAC,4CAAW;AACpC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,kBAAkB,mBAAO,CAAC,6GAAuB;AACjD,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,YAAY,6CAA6C;AACzD,mBAAmB,mBAAO,CAAC,gDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,4CAA4C,OAAO,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4DAA4D,uBAAuB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,WAAW;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACngBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,uBAAuB;AAC9C,2BAA2B;AAC3B,+BAA+B;AAC/B,0CAA0C,mBAAO,CAAC,sEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,wBAAwB,GAAG,mBAAmB;AAC3E,gCAAgC;AAChC,qBAAqB;AACrB,uBAAuB;AACvB,8BAA8B;AAC9B,2BAA2B;AAC3B,oBAAoB,mBAAO,CAAC,gIAA+B;AAC3D,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iBAAiB,mBAAO,CAAC,2CAAU;AACnC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,oDAAoD;AACpD;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClGgD;AAChD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACboD;AACE;AACY;AACpB;AACa;AACD;AACV;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAgB;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+DAAc;AACvE,yCAAyC;AACzC;AACA;AACA,qDAAqD,sDAAU;AAC/D,qDAAqD,sDAAU;AAC/D,yDAAyD,sDAAU;AACnE,qDAAqD,sDAAU;AAC/D,qDAAqD,sDAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,uCAAuC,uBAAuB,KAAK,iBAAiB,0BAA0B,UAAU;AACxH;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C,iEAAiE,iEAAU,YAAY,KAAK,UAAU,GAAG,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAW,4BAA4B,iEAAU,WAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAW,kCAAkC,iEAAU,WAAW;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW,qCAAqC,KAAK,0BAA0B,kBAAkB;AACvH;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW,uCAAuC,KAAK,sBAAsB,oBAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sBAAsB,yDAAW,4CAA4C,WAAW,oBAAoB,kBAAkB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sBAAsB,yDAAW,qCAAqC,WAAW,oBAAoB,kBAAkB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW,qCAAqC,KAAK,oBAAoB,kBAAkB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAS;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,wDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACptByD;AACH;AACA;AACK;AACpD;AACA;AACA;AACP;AACA;AACA,yDAAyD,+DAAc;AACvE,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB,0FAA0F,qBAAqB;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA,2BAA2B,0DAAS;AACpC;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,sBAAsB,wEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;AACA;AACA,QAAQ,wDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjeA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACTA;AACwC;AACa;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAkB;AACxC;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAO;AACtC;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAO;AACtC;AACA;AACA;AACA,8BAA8B,iDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAO;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEwC;AACxC;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB,GAAG,wBAAwB,MAAM,wBAAwB;AAC7H;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAmB;AAC/B;AACO;AACP,wBAAwB,iDAAO;AAC/B;AACA;AACA;AACA;AACA,6BAA6B,wBAAwB;AACrD;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAmB;AAC/B;AACO;AACP,wBAAwB,iDAAO;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzBwC;AACiB;AACzD;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAmB;AAC/B;AACO;AACP,mBAAmB,sEAAmB;AACtC,wBAAwB,iDAAO;AAC/B;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAmB;AAC/B;AACO;AACP,mBAAmB,sEAAmB;AACtC,wBAAwB,iDAAO;AAC/B;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAmB;AAC/B;AACO;AACP,mBAAmB,sEAAmB;AACtC,wBAAwB,iDAAO;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;AC7BwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,iDAAO;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACsC;AACpB;AACiC;AACpB;AACuD;AACzB;AACrB;AACrB;AAC6B;AACzB;AACiB;AACrB;AACnB;AACsD;AAC5B;AACc;AACrB;AAC8J;AACvB;AAC1J;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACgD;AACK;AAC9C;AACP,6CAA6C;AAC7C,6CAA6C;AACtC,qCAAqC,WAAW;AACvD;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wDAAQ;AAChB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gCAAgC;AAChC,wBAAwB,wDAAQ;AAChC;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB,yDAAW,iEAAiE,YAAY;AAC9G;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/FA;AACO;AACP;AACA;AACO;AACP;AACA,uBAAuB;AACvB;AACA;AACA;AACO;AACP;AACA,uBAAuB;AACvB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BO;AACP,cAAc,oBAAoB,IAAI,6CAA6C;AACnF;AACA;;;;;;;;;;;;;;;;;ACHA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,8HAA2B;AAC5D;AACA;AACA,aAAa;AACb;AACA;AACA,iEAAiE,yBAAyB;AAC1F,aAAa;AACb;AACA;;;;;;;;;;;AClBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,kBAAkB;AAClB,YAAY;AACZ,qBAAqB;AACrB,iBAAiB;AACjB,2BAA2B;AAC3B,qBAAqB;AACrB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,iGAAa;AACxC,qBAAqB,mBAAO,CAAC,6GAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,qCAAqC;AACrC,8BAA8B;AAC9B,6CAA6C;AAC7C,+BAA+B;AAC/B,aAAa;AACb;AACA;AACA,YAAY,uCAAuC;AACnD,kCAAkC;AAClC,8BAA8B;AAC9B;AACA;AACA,+BAA+B;AAC/B,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA,4BAA4B;AAC5B,sBAAsB;AACtB;AACA;AACA,sDAAsD;AACtD,gCAAgC;AAChC,6BAA6B;AAC7B,qCAAqC;AACrC,iCAAiC;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,wBAAwB,gDAAgD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,2BAA2B;AAC3B,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,wDAAwD;AACxD;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG;AACxC;AACA,aAAa;AACb;AACA;;;;;;;;;;;ACtda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,aAAa;AACb,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,iGAAa;AACxC,mBAAmB,mBAAO,CAAC,yGAAY;AACvC,qBAAqB,mBAAO,CAAC,6GAAc;AAC3C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,YAAY,SAAS;AACrB,YAAY,8BAA8B;AAC1C,iDAAiD,IAAI,qBAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,gBAAgB,OAAO;AACvB;AACA,gDAAgD;AAChD;AACA;AACA,gBAAgB,6BAA6B;AAC7C,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,kCAAkC;AAClC,kCAAkC;AAClC,gDAAgD;AAChD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB,oBAAoB,yBAAyB;AAC7C,qCAAqC;AACrC,qCAAqC;AACrC,iDAAiD;AACjD,mCAAmC;AACnC;AACA,uDAAuD;AACvD,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,iCAAiC;AACrD,oBAAoB,iCAAiC;AACrD,qCAAqC;AACrC,qCAAqC;AACrC,yCAAyC;AACzC,qCAAqC;AACrC,2DAA2D;AAC3D,6BAA6B;AAC7B,6BAA6B;AAC7B,uCAAuC;AACvC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,qEAAqE;AACrE;AACA,wCAAwC;AACxC,2CAA2C;AAC3C,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,wCAAwC;AACxC,kBAAkB,oBAAoB,iBAAiB;AACvD;AACA;AACA,8CAA8C;AAC9C,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wEAAwE;AACxE,2DAA2D;AAC3D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,uBAAuB;AACnC,YAAY,kBAAkB;AAC9B;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,mDAAmD;AACnD,sCAAsC;AACtC,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,gCAAgC;AAChC,gBAAgB,6BAA6B;AAC7C,oEAAoE;AACpE,2CAA2C;AAC3C,2EAA2E;AAC3E,wCAAwC;AACxC,sEAAsE;AACtE;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,8BAA8B;AAC9B,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,WAAW,sCAAsC;AACpF;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,0BAA0B;AAC1B,qBAAqB;AACrB,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB,mBAAO,CAAC,iGAAa;AACxC,qBAAqB,mBAAO,CAAC,6GAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAA6E;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,mCAAmC;AACnC,iDAAiD;AACjD,iBAAiB;AACjB;AACA;AACA,8EAA8E,gBAAgB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC;AACzC;AACA;AACA,SAAS;AACT,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;ACtMa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,WAAW;AACX,WAAW;AACX,YAAY;AACZ,cAAc;AACd,qBAAqB;AACrB,cAAc;AACd,qBAAqB;AACrB,aAAa;AACb,qBAAqB;AACrB,aAAa;AACb,kBAAkB;AAClB,kBAAkB;AAClB,eAAe;AACf,aAAa;AACb,iBAAiB;AACjB,kBAAkB;AAClB,2BAA2B;AAC3B,2BAA2B;AAC3B,wBAAwB;AACxB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,iGAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,kCAAkC;AAClC,kCAAkC;AAClC,yCAAyC;AACzC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,8BAA8B;AAC9B,mCAAmC;AACnC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,mCAAmC;AACnC;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,uDAAuD;AACvD,2CAA2C;AAC3C;AACA;AACA,2BAA2B;AAC3B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAuC;AACnD;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,iGAAa;AACxC,qBAAqB,mBAAO,CAAC,6GAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,UAAU;AACrC;AACA;AACA;AACA,YAAY,4DAA4D;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,qBAAqB;AAChC,oCAAoC;AACpC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAgD;AACjE;AACA;AACA;AACA;;;;;;;;;;;AC5Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW,GAAG,cAAc;AAC5B,0BAA0B;AAC1B,6BAA6B;AAC7B,oBAAoB;AACpB,yBAAyB;AACzB,aAAa;AACb,mBAAmB;AACnB,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,0GAAuB;AACjD,mBAAmB,mBAAO,CAAC,iGAAa;AACxC,mBAAmB,mBAAO,CAAC,yGAAY;AACvC,qBAAqB,mBAAO,CAAC,6GAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA,gBAAgB,2BAA2B;AAC3C,gBAAgB,2BAA2B;AAC3C;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kCAAkC;AAClC,oDAAoD;AACpD;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,SAAS,QAAQ,WAAW;AAC1G;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY,SAAS;AACrB,YAAY,8BAA8B;AAC1C,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,OAAO;AACnB;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,gDAAgD;AAChD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qDAAqD,OAAO,wBAAwB,IAAI,kBAAkB,GAAG;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,iEAAiE;AACjE,6BAA6B;AAC7B;AACA,8BAA8B,wBAAwB;AACtD;AACA,wBAAwB,uBAAuB;AAC/C,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,+CAA+C;AAC/C,iDAAiD,kBAAkB;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,sFAAsF;AACtF,2CAA2C;AAC3C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,qDAAqD;AACrD;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,cAAc,mCAAmC,QAAQ;AACzD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,mEAAmE;AACnE,2EAA2E;AAC3E;AACA,+DAA+D;AAC/D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wBAAwB;AACxB,kCAAkC;AAClC,yDAAyD;AACzD,sCAAsC;AACtC;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,oEAAoE;AACpE;AACA;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA,sDAAsD;AACtD;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,mCAAmC;AACjE;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,0CAA0C;AAC1C,8BAA8B;AAC9B,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,6CAA6C,aAAa,iBAAiB,aAAa;AACxF,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA,kBAAkB;AAClB,2DAA2D;AAC3D;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC;AACjC,iCAAiC;AACjC,6BAA6B;AAC7B,8BAA8B;AAC9B,4CAA4C;AAC5C;AACA,sBAAsB;AACtB,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;AAC9B,oCAAoC;AACpC,+BAA+B;AAC/B,wCAAwC;AACxC,+BAA+B;AAC/B,gCAAgC;AAChC,uCAAuC;AACvC,uCAAuC;AACvC;AACA,yBAAyB,SAAS;AAClC,+BAA+B;AAC/B,sCAAsC;AACtC,yCAAyC;AACzC,6CAA6C;AAC7C,oCAAoC;AACpC,oCAAoC;AACpC,qCAAqC;AACrC,yCAAyC;AACzC,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C;AAC3C,uCAAuC;AACvC;AACA,iCAAiC;AACjC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,kCAAkC;AAClC,uCAAuC;AACvC,+CAA+C,kBAAkB;AACjE,yCAAyC;AACzC,2CAA2C;AAC3C,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,2BAA2B;AAC3B,gCAAgC;AAChC,mCAAmC;AACnC,8BAA8B;AAC9B,8DAA8D;AAC9D,8BAA8B;AAC9B,2BAA2B;AAC3B,2BAA2B;AAC3B,8BAA8B;AAC9B,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,8BAA8B;AAC9B,gCAAgC;AAChC,8BAA8B;AAC9B,gBAAgB,iBAAiB,uBAAuB;AACxD,4BAA4B;AAC5B,8BAA8B;AAC9B,sCAAsC;AACtC,wCAAwC;AACxC,gDAAgD;AAChD,uCAAuC;AACvC;AACA,gCAAgC;AAChC,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;ACzwCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,2BAA2B,GAAG,cAAc,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,eAAe,GAAG,gCAAgC;AACtS,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,0GAAuB;AACjD,mBAAmB,mBAAO,CAAC,4GAAwB;AACnD,mBAAmB,mBAAO,CAAC,kHAAqB;AAChD,qBAAqB,mBAAO,CAAC,sHAAuB;AACpD,2BAA2B,mBAAO,CAAC,kIAA6B;AAChE,qBAAqB,mBAAO,CAAC,sHAAuB;AACpD,wBAAwB,mBAAO,CAAC,4HAA0B;AAC1D,mBAAmB,mBAAO,CAAC,gGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,sDAAsD;AACtD;AACA;AACA,oDAAoD;AACpD,qDAAqD;AACrD,qBAAqB;AACrB,iEAAiE;AACjE,gCAAgC;AAChC,2DAA2D;AAC3D,2EAA2E;AAC3E;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,kCAAkC;AAClC,mCAAmC,eAAe,GAAG;AACrD;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,CAAC;AACD,iBAAiB,2DAA2D;AAC5E;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,SAAS;AACT;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,gEAAgE;AAChE,mEAAmE;AACnE;AACA;AACA,4CAA4C;AAC5C;AACA,yBAAyB;AACzB,4BAA4B;AAC5B,kCAAkC;AAClC,8BAA8B;AAC9B,0BAA0B;AAC1B,+BAA+B;AAC/B,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,2BAA2B;AAC3B,uBAAuB;AACvB,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,oCAAoC;AACpC,4BAA4B;AAC5B,oCAAoC;AACpC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,gCAAgC;AAChC,8BAA8B;AAC9B,gCAAgC;AAChC,oCAAoC;AACpC,gCAAgC;AAChC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,sBAAsB;AACtB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,iCAAiC;AACjC,0BAA0B;AAC1B,0CAA0C;AAC1C,aAAa,sCAAsC;AACnD;AACA,4GAA4G;AAC5G;AACA,YAAY,qBAAqB,yCAAyC;AAC1E;AACA,+BAA+B;AAC/B,sCAAsC;AACtC,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,kCAAkC;AAClC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,kFAAkF;AAClF,aAAa,gDAAgD;AAC7D;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mBAAmB;AACnB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA,sCAAsC;AACtC,gDAAgD;AAChD,wBAAwB;AACxB,6CAA6C;AAC7C,UAAU,gCAAgC,kBAAkB;AAC5D,0BAA0B;AAC1B;AACA;AACA;AACA,gBAAgB;AAChB;AACA,eAAe;AACf,wDAAwD;AACxD;AACA,iCAAiC;AACjC,4CAA4C;AAC5C,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA,4CAA4C;AAC5C,gBAAgB,oBAAoB,6BAA6B;AACjE,gCAAgC;AAChC,oCAAoC;AACpC,mCAAmC;AACnC;AACA,yBAAyB;AACzB,gCAAgC;AAChC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA,iDAAiD;AACjD,+BAA+B;AAC/B;AACA;AACA,gBAAgB,iBAAiB,8BAA8B;AAC/D,sCAAsC;AACtC,sCAAsC;AACtC,uCAAuC;AACvC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,yBAAyB;AACzB,kCAAkC;AAClC;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,4BAA4B,+BAA+B;AAC3D;;;;;;;;;;;AC/ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,iBAAiB,GAAG,YAAY,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY;AACxK;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,0GAAuB;AACjD,2BAA2B,mBAAO,CAAC,gHAAoB;AACvD,2BAA2B,mBAAO,CAAC,kIAA6B;AAChE,qBAAqB,mBAAO,CAAC,sHAAuB;AACpD,yBAAyB,mBAAO,CAAC,8HAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC,uCAAuC;AAC5F;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,YAAY,yCAAyC,uCAAuC;AAC5F;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,YAAY,yCAAyC,kFAAkF;AACvI;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;;;;;;;;;;;AChHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY;AAC9E,kBAAkB,mBAAO,CAAC,8FAAW;AACrC,YAAY;AACZ,iBAAiB;AACjB,mBAAmB;AACnB,qBAAqB;AACrB;;;;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY;AAC9E,kBAAkB,mBAAO,CAAC,8FAAW;AACrC,YAAY;AACZ,iBAAiB;AACjB,mBAAmB;AACnB,qBAAqB;AACrB,8BAA8B,cAAc;AAC5C;;;;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY;AAC9E,kBAAkB,mBAAO,CAAC,8FAAW;AACrC,YAAY;AACZ,iBAAiB;AACjB,mBAAmB;AACnB,qBAAqB;AACrB;;;;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,eAAe,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,eAAe,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,eAAe,GAAG,cAAc;AAC/N,aAAa;AACb,2BAA2B;AAC3B,mBAAmB;AACnB,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,0BAA0B;AAC1B,mBAAmB;AACnB,kBAAkB;AAClB,eAAe;AACf,gBAAgB;AAChB,cAAc;AACd,cAAc;AACd,cAAc;AACd,sBAAsB;AACtB,sBAAsB;AACtB,cAAc;AACd,uBAAuB;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,4GAAwB;AACnD,iBAAiB,mBAAO,CAAC,4GAAwB;AACjD,0CAAyC,EAAE,qCAAqC,6BAA6B,EAAC;AAC9G,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,gDAAgD;AAChD,0BAA0B;AAC1B,0BAA0B;AAC1B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,iCAAiC;AACjC,iBAAiB;AACjB;AACA;AACA,iCAAiC;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,WAAW,YAAY,IAAI;AACpD,kCAAkC,oBAAoB,IAAI,aAAa,GAAG;AAC1E;AACA,kCAAkC,UAAU,IAAI,SAAS;AACzD,kCAAkC,oBAAoB,IAAI,SAAS;AACnE,kCAAkC,2BAA2B;AAC7D,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU,yBAAyB,aAAa,QAAQ,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,cAAc;AAC9F,oBAAoB;AACpB,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;;;;;;;;;ACjKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe,GAAG,eAAe,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,aAAa,GAAG,aAAa,GAAG,aAAa,GAAG,aAAa,GAAG,aAAa,GAAG,aAAa;AACzT,WAAW;AACX,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,cAAc;AACd;;;;;;;;;;;ACJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,YAAY;AAC3B;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY;AACZ,mBAAmB;AACnB;;;;;;;;;;;AC1Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,kBAAkB,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc;AACzN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,4FAAU;AACnC,YAAY,mBAAO,CAAC,8FAAW;AAC/B,mBAAmB,mBAAO,CAAC,gGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;;AC/Xa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,cAAc;AACpN,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,8FAAW;AACrC;AACA,mBAAmB,mBAAO,CAAC,gGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,wBAAwB,QAAQ;AAChC;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,0BAA0B,UAAU;AACpC;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB,wFAAwF;AACxF;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;;;;;;;;;;;AC9Oa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,GAAG,+BAA+B,GAAG,uBAAuB,GAAG,YAAY,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,YAAY;AAC/M,eAAe;AACf,eAAe;AACf,cAAc;AACd,aAAa;AACb,eAAe;AACf,eAAe;AACf,UAAU;AACV,WAAW;AACX,aAAa;AACb,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,gBAAgB;AAChB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,iBAAiB;AACjB,mBAAmB;AACnB,mBAAmB;AACnB,eAAe;AACf,uBAAuB;AACvB,mBAAmB;AACnB,iBAAiB;AACjB,oBAAoB;AACpB,uBAAuB;AACvB,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,2GAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B;AAC/B;AACA,qCAAqC;AACrC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,+BAA+B;AAC/B,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,cAAc,GAAG,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,mBAAmB,mBAAO,CAAC,4GAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD,oCAAoC,WAAW;AAC/C;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mDAAmD,mBAAmB;AACtE,oCAAoC,WAAW;AAC/C;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd,cAAc;AACd;;;;;;;;;;;AChJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,uBAAuB,mBAAO,CAAC,oHAAgB;AAC/C,mBAAmB,mBAAO,CAAC,4GAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,SAAS,8EAA8E;AACvF,SAAS,8EAA8E;AACvF,SAAS,8EAA8E;AACvF;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAwC;AACpD,YAAY,qDAAqD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,mCAAmC,OAAO;AAC1C,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mDAAmD,GAAG,wBAAwB,KAAK,IAAI,IAAI;AAC3F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,2BAA2B;AACpH;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,2BAA2B;AAC3B,gCAAgC,OAAO;AACvC,2DAA2D;AAC3D;AACA;AACA;AACA,wBAAwB,SAAS,qCAAqC;AACtE;AACA;AACA;AACA,6DAA6D;AAC7D,yDAAyD,iBAAiB,GAAG;AAC7E,6EAA6E;AAC7E;AACA;AACA;AACA,4BAA4B,oBAAoB,cAAc,oBAAoB,eAAe;AACjG,2BAA2B,qBAAqB,cAAc,qBAAqB,cAAc;AACjG;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA,0BAA0B;AAC1B;AACA,4BAA4B,OAAO;AACnC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,mCAAmC;AACnC,4BAA4B,OAAO;AACnC,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB,mCAAmC;AAChG;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,yCAAyC,UAAU;AACnD;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B;AACzF;AACA;AACA,gCAAgC,OAAO;AACvC,uDAAuD;AACvD;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,uEAAuE;AACvE,gEAAgE;AAChE;AACA,4CAA4C;AAC5C,uEAAuE;AACvE;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6DAA6D;AAC7D,yDAAyD,iBAAiB,GAAG;AAC7E;AACA,8BAA8B;AAC9B,yDAAyD;AACzD;AACA,8BAA8B;AAC9B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB,mCAAmC;AAChG;AACA,wDAAwD;AACxD,kDAAkD;AAClD,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,8EAA8E;AAC9E,uCAAuC;AACvC,gCAAgC,OAAO;AACvC,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,wDAAwD;AACxD;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;AC/gBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AACrG,kBAAkB;AAClB,kBAAkB;AAClB,gBAAgB;AAChB,kBAAkB;AAClB,eAAe;AACf,kBAAkB;AAClB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,gBAAgB,mBAAO,CAAC,yGAAqB;AAC7C,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS,cAAc,OAAO;AAC/F;AACA,qCAAqC,cAAc;AACnD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6EAA6E;AAC/F,kBAAkB,6EAA6E;AAC/F,kBAAkB,6EAA6E;AAC/F,kBAAkB,6EAA6E;AAC/F,sBAAsB,iFAAiF;AACvG,sBAAsB,iFAAiF;AACvG,kBAAkB,+EAA+E;AACjG,kBAAkB,+EAA+E;AACjG,kBAAkB,+EAA+E;AACjG,kBAAkB,+EAA+E;AACjG;AACA;AACA,mDAAmD,WAAW;AAC9D,KAAK;AACL;AACA;AACA,mDAAmD,WAAW;AAC9D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;;;;;;;;;;;;AC/Ia;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa;AACjF,aAAa;AACb,eAAe;AACf,mBAAmB;AACnB,mBAAmB;AACnB,2BAA2B;AAC3B,yBAAyB,mBAAO,CAAC,kIAAkB;AACnD,eAAe,mBAAO,CAAC,8GAAQ;AAC/B,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,uCAAuC,mBAAO,CAAC,gGAAc;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qCAAqC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxYa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sCAAsC,mBAAO,CAAC,mIAAmB;AACjE,oCAAoC,mBAAO,CAAC,mIAAa;AACzD,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,eAAe,mBAAO,CAAC,+GAAS;AAChC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,MAAM;AAClC,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D,kBAAe;AACf;;;;;;;;;;;;AC1Ja;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB;AAC7C,mBAAmB;AACnB,uBAAuB;AACvB,eAAe;AACf,eAAe;AACf,iCAAiC,mBAAO,CAAC,6HAAU;AACnD,oCAAoC,mBAAO,CAAC,mIAAa;AACzD,kCAAkC,mBAAO,CAAC,+HAAW;AACrD,eAAe,mBAAO,CAAC,+GAAS;AAChC,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,MAAM;AACvG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM,yBAAyB,MAAM;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,gGAAgG,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,yCAAyC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;;AC1Qa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD,kBAAe;AACf;;;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,eAAe,mBAAO,CAAC,+GAAS;AAChC,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,4DAA4D,MAAM;AAClE,kBAAe;AACf;;;;;;;;;;;ACpHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,+BAA+B,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,8BAA8B,GAAG,0BAA0B,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,+BAA+B,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,uBAAuB,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,cAAc,GAAG,kBAAkB,GAAG,YAAY,GAAG,qBAAqB,GAAG,eAAe,GAAG,qBAAqB,GAAG,eAAe,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,eAAe,GAAG,mBAAmB,GAAG,aAAa;AAC31B,cAAc,mBAAO,CAAC,gHAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,2CAA0C,EAAE,qCAAqC,2BAA2B,EAAC;AAC7G,iDAAgD,EAAE,qCAAqC,iCAAiC,EAAC;AACzH,uBAAuB,mBAAO,CAAC,kIAAkB;AACjD,+CAA8C,EAAE,qCAAqC,wCAAwC,EAAC;AAC9H,mBAAmB,mBAAO,CAAC,gIAAc;AACzC,2CAA0C,EAAE,qCAAqC,gCAAgC,EAAC;AAClH,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,2CAA0C,EAAE,qCAAqC,gCAAgC,EAAC;AAClH,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,gBAAgB,mBAAO,CAAC,0HAAW;AACnC,wCAAuC,EAAE,qCAAqC,0BAA0B,EAAC;AACzG,8CAA6C,EAAE,qCAAqC,gCAAgC,EAAC;AACrH,0CAAyC,EAAE,qCAAqC,4BAA4B,EAAC;AAC7G,gDAA+C,EAAE,qCAAqC,kCAAkC,EAAC;AACzH,gDAA+C,EAAE,qCAAqC,kCAAkC,EAAC;AACzH,kDAAiD,EAAE,qCAAqC,oCAAoC,EAAC;AAC7H,qBAAqB,mBAAO,CAAC,oIAAgB;AAC7C,6CAA4C,EAAE,qCAAqC,oCAAoC,EAAC;AACxH,mDAAkD,EAAE,qCAAqC,0CAA0C,EAAC;AACpI,+CAA8C,EAAE,qCAAqC,sCAAsC,EAAC;AAC5H,qDAAoD,EAAE,qCAAqC,4CAA4C,EAAC;AACxI,kBAAkB,mBAAO,CAAC,kJAA0B;AACpD,yDAAwD,EAAE,qCAAqC,6CAA6C,EAAC;AAC7I,mBAAmB,mBAAO,CAAC,0HAAc;AACzC,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,qDAAoD,EAAE,qCAAqC,0CAA0C,EAAC;AACtI,yDAAwD,EAAE,qCAAqC,8CAA8C,EAAC;AAC9I,2DAA0D,EAAE,qCAAqC,gDAAgD,EAAC;AAClJ,gDAA+C,EAAE,qCAAqC,qCAAqC,EAAC;AAC5H,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,sDAAqD,EAAE,qCAAqC,2CAA2C,EAAC;AACxI,0DAAyD,EAAE,qCAAqC,+CAA+C,EAAC;AAChJ,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,yDAAwD,EAAE,qCAAqC,8CAA8C,EAAC;AAC9I,qDAAoD,EAAE,qCAAqC,0CAA0C,EAAC;AACtI,yDAAwD,EAAE,qCAAqC,8CAA8C,EAAC;AAC9I,2DAA0D,EAAE,qCAAqC,gDAAgD,EAAC;AAClJ,+DAA8D,EAAE,qCAAqC,oDAAoD,EAAC;AAC1J;;;;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;;ACtCa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sCAAsC,mBAAO,CAAC,mIAAmB;AACjE,oCAAoC,mBAAO,CAAC,qIAAa;AACzD,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,eAAe,mBAAO,CAAC,+GAAS;AAChC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D,kBAAe;AACf;;;;;;;;;;;;AC9Ka;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,uBAAuB;AACnD,mBAAmB;AACnB,uBAAuB;AACvB,iBAAiB;AACjB,mBAAmB;AACnB,iCAAiC,mBAAO,CAAC,+HAAU;AACnD,iCAAiC,mBAAO,CAAC,qIAAa;AACtD,kCAAkC,mBAAO,CAAC,iIAAW;AACrD,eAAe,mBAAO,CAAC,+GAAS;AAChC,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM,yBAAyB,MAAM;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,gGAAgG,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,yCAAyC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,gCAAgC,MAAM;AAC1F;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM,gCAAgC,MAAM;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;;;;;;;;;;;AChTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gLAAgL,MAAM;AACtL;AACA;AACA,kCAAkC,MAAM,iDAAiD,MAAM;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM,WAAW,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM,SAAS,MAAM,uCAAuC,MAAM,mCAAmC,MAAM;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD,kBAAe;AACf;;;;;;;;;;;;AC7Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,eAAe,mBAAO,CAAC,+GAAS;AAChC,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM,+DAA+D,MAAM;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM,2CAA2C,MAAM;AAC5F;AACA;AACA;AACA,qCAAqC,MAAM,qDAAqD,MAAM;AACtG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM,2CAA2C,MAAM;AAC5F;AACA;AACA;AACA,qCAAqC,MAAM,qDAAqD,MAAM;AACtG,iBAAiB;AACjB;AACA;AACA,+CAA+C,MAAM;AACrD,uCAAuC,MAAM;AAC7C,iDAAiD,MAAM;AACvD,8DAA8D,MAAM;AACpE,kBAAe;AACf;;;;;;;;;;;;;AClGa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,sCAAsC,mBAAO,CAAC,mIAAmB;AACjE,eAAe,mBAAO,CAAC,+GAAS;AAChC,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD,sCAAsC,OAAO,YAAY,MAAM;AAC/D,kBAAe;AACf;;;;;;;;;;;;ACvHa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,kBAAkB,GAAG,oBAAoB;AAChE,YAAY;AACZ,cAAc;AACd,oBAAoB;AACpB,sBAAsB;AACtB,iCAAiC,mBAAO,CAAC,0HAAU;AACnD,kCAAkC,mBAAO,CAAC,4HAAW;AACrD,eAAe,mBAAO,CAAC,+GAAS;AAChC,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,yBAAyB,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,yCAAyC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,WAAW,MAAM,mEAAmE,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,yCAAyC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;AC9Pa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,oBAAoB,mBAAO,CAAC,2FAAW;AACvC,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD,kBAAe;AACf;;;;;;;;;;;;ACzEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,mBAAmB;AACnB,mBAAmB;AACnB;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA,oCAAoC,MAAM,aAAa,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,+BAA+B,GAAG,8BAA8B,GAAG,0BAA0B,GAAG,+BAA+B,GAAG,6BAA6B;AACrM,uBAAuB;AACvB,yBAAyB;AACzB,oBAAoB;AACpB,qBAAqB;AACrB,4BAA4B;AAC5B,6BAA6B;AAC7B,yBAAyB;AACzB,6BAA6B;AAC7B,qBAAqB,mBAAO,CAAC,gIAAc;AAC3C,kBAAkB,mBAAO,CAAC,0HAAW;AACrC,uBAAuB,mBAAO,CAAC,oIAAgB;AAC/C,gBAAgB,mBAAO,CAAC,gHAAS;AACjC,kCAAkC,mBAAO,CAAC,iFAAS;AACnD;AACA;AACA;AACA,+CAA+C,qDAAqD;AACpG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,4CAA4C,kDAAkD;AAC9F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,4CAA4C,sDAAsD;AAClG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,qDAAqD;AACpG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;;;;;;;;;;;ACxKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,kDAAkD,0CAA0C;AAC5F,eAAe,mBAAO,CAAC,yGAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,yIAAmC;AAChE,gBAAgB,mBAAO,CAAC,yEAAO;AAC/B;AACA,qBAAqB,sGAAsB;AAC3C;AACA;AACA,mBAAmB,mBAAO,CAAC,+GAAwB;AACnD,eAAe,mBAAO,CAAC,mGAAoB;AAC3C,0BAA0B,mBAAO,CAAC,qGAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6HAA6B;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,iBAAiB,OAAO,eAAe,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;AC7kBA;AACA;;AAEa;;AAEb,yBAAyB,wBAAwB,oCAAoC,yCAAyC,kCAAkC,0DAA0D,0BAA0B;AACpP,4BAA4B,gBAAgB,sBAAsB,OAAO,kDAAkD,sDAAsD,8BAA8B,mJAAmJ,qEAAqE,KAAK;AAC5a,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,kDAAkD,0CAA0C;AAC5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,2CAA2C,+DAA+D,6EAA6E,yEAAyE,eAAe,uDAAuD,GAAG,+CAA+C,iBAAiB,GAAG;AAC5Y,iCAAiC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,2DAA2D,OAAO,yCAAyC;AACpX,kDAAkD,0EAA0E,eAAe,4BAA4B,mFAAmF;AAC1P,wCAAwC,uBAAuB,yFAAyF;AACxJ,mCAAmC,gEAAgE,sDAAsD,+DAA+D,mCAAmC,6EAA6E,qCAAqC,iDAAiD,8BAA8B,qBAAqB,0EAA0E,qDAAqD,eAAe,yEAAyE,GAAG,2CAA2C;AACttB,2CAA2C,mCAAmC,yCAAyC,OAAO,wDAAwD,gBAAgB,uBAAuB,kDAAkD,kCAAkC,uDAAuD,sBAAsB;AAC9X,uCAAuC,wEAAwE,0CAA0C,8CAA8C,MAAM,4EAA4E,IAAI,eAAe,YAAY;AACxT,iCAAiC;AACjC,iCAAiC,0GAA0G,iBAAiB,aAAa;AACzK,8BAA8B,uGAAuG,mDAAmD;AACxL,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,eAAe,mBAAO,CAAC,yEAAO;AAC9B;AACA,gBAAgB,mBAAO,CAAC,iGAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sBAAsB,OAAO,WAAW,OAAO,gBAAgB,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,IAAI,aAAa;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,UAAU,OAAO,WAAW,OAAO;AACnC;AACA;AACA,YAAY,OAAO,WAAW,OAAO,yBAAyB,OAAO;AACrE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;AACD;;;;;;;;;;;AC5bA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,kDAAkD,0CAA0C;AAC5F,2CAA2C,+DAA+D,6EAA6E,yEAAyE,eAAe,uDAAuD,GAAG,+CAA+C,iBAAiB,GAAG;AAC5Y,iCAAiC,0GAA0G,iBAAiB,aAAa;AACzK,iCAAiC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,2DAA2D,OAAO,yCAAyC;AACpX,kDAAkD,0EAA0E,eAAe,4BAA4B,mFAAmF;AAC1P,wCAAwC,uBAAuB,yFAAyF;AACxJ,uCAAuC,wEAAwE,0CAA0C,8CAA8C,MAAM,4EAA4E,IAAI,eAAe,YAAY;AACxT,8BAA8B,uGAAuG,mDAAmD;AACxL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,wFAAW;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAO;AAChD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA,sEAAsE,aAAa;AACnF;AACA;AACA,qCAAqC,mBAAO,CAAC,wFAAW;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB;;;;;;;;;;;AC1KpB;AACA;;AAEa;;AAEb,kCAAkC;AAClC,8BAA8B;AAC9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;AAC7S,uCAAuC,uDAAuD,uCAAuC,SAAS,uBAAuB;AACrK,uCAAuC,kGAAkG,iBAAiB,wCAAwC,MAAM,yCAAyC,6BAA6B,UAAU,YAAY,kEAAkE,WAAW,YAAY,iBAAiB,UAAU,MAAM,2EAA2E,UAAU,oBAAoB;AACvgB,gCAAgC;AAChC,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC,mBAAO,CAAC,uFAAW;AAC1D;AACA;AACA;AACA,gDAAgD,mBAAO,CAAC,8EAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sGAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,oBAAoB,WAAW;AACzD;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9jBa;;AAEb,oBAAoB,mBAAO,CAAC,0IAA4B;;AAExD,4CAA4C,qBAAM;;AAElD,WAAW,aAAa;AACxB;AACA,gBAAgB,yCAAyC;AACzD,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBY;;AAEZ,kBAAkB;AAClB,mBAAmB;AACnB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,eAAe,mBAAO,CAAC,uFAAW;AAClC,gBAAgB,mBAAO,CAAC,iFAAS;AACjC;AACA;AACA;AACA;;AAEA,cAAc;AACd,kBAAkB;AAClB,yBAAyB;;AAEzB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,yBAAyB,QAAQ;AACjC;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qBAAqB,WAAW,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,gBAAgB,WAAW,GAAG,IAAI,KAAK,aAAa;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;;AAEA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,KAAK,mDAAmD,cAAc;AACzF,GAAG;AACH;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;AACtD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB,cAAc,oBAAoB,EAAE,IAAI;AACxC;AACA,YAAY,gBAAgB,EAAE,IAAI;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,SAAS,GAAG,KAAK,qBAAqB,EAAE,EAAE;AACpE,QAAQ;AACR,yBAAyB,GAAG,KAAK,yBAAyB,EAAE,EAAE;AAC9D,mBAAmB,yBAAyB,EAAE,EAAE;AAChD;AACA,MAAM;AACN,oBAAoB,IAAI,EAAE,GAAG,SAAS,IAAI,EAAE,EAAE;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc,SAAS,OAAO;AACxE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACzjEa;;AAEb,WAAW,mBAAO,CAAC,mGAAe;;AAElC,aAAa,mBAAO,CAAC,iIAAiB;AACtC,YAAY,mBAAO,CAAC,+HAAgB;AACpC,oBAAoB,mBAAO,CAAC,+HAAgB;;AAE5C,WAAW,yBAAyB;AACpC;;;;;;;;;;;;ACTa;;AAEb,WAAW,mBAAO,CAAC,mGAAe;AAClC,aAAa,mBAAO,CAAC,iIAAiB;AACtC,kBAAkB,mBAAO,CAAC,6HAAe;;AAEzC,WAAW,uBAAuB;AAClC;AACA;AACA;;;;;;;;;;;;ACTa;;AAEb,WAAW,2BAA2B;AACtC;;;;;;;;;;;;ACHa;;AAEb,WAAW,0BAA0B;AACrC;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAO,CAAC,mGAAe;AAClC,iBAAiB,mBAAO,CAAC,2FAAgB;;AAEzC,YAAY,mBAAO,CAAC,+HAAgB;AACpC,mBAAmB,mBAAO,CAAC,6HAAe;;AAE1C,WAAW,uEAAuE;AAClF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACda;;AAEb,WAAW,0BAA0B;AACrC;;;;;;;;;;;;ACHa;;AAEb,mBAAmB,mBAAO,CAAC,mGAAe;;AAE1C,eAAe,mBAAO,CAAC,gFAAI;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACda;;AAEb,wBAAwB,mBAAO,CAAC,qHAAqB;;AAErD,sBAAsB,mBAAO,CAAC,kHAAoB;;AAElD,oBAAoB,mBAAO,CAAC,iIAAyB;AACrD,gBAAgB,mBAAO,CAAC,+IAAmC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,kBAAkB;AAC9D,EAAE;AACF,CAAC,oBAAoB;AACrB;;;;;;;;;;;;ACvBa;;AAEb,mBAAmB,mBAAO,CAAC,mGAAe;;AAE1C,oBAAoB,mBAAO,CAAC,iIAAyB;;AAErD,WAAW,sEAAsE;AACjF;;AAEA,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,gDAAgD;AAC5E;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;;;;;;;;;;;;AClBa;;AAEb,kBAAkB,mBAAO,CAAC,wFAAa;AACvC,iBAAiB,mBAAO,CAAC,sFAAY;AACrC,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,eAAe,mBAAO,CAAC,kFAAU;AACjC,eAAe,mBAAO,CAAC,kFAAU;AACjC,YAAY,mBAAO,CAAC,4EAAO;AAC3B,2BAA2B,mBAAO,CAAC,0GAAsB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,yBAAyB;AACpD;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA;AACA,MAAM,2DAA2D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qBAAqB,KAAK;AAC1B,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACjHa;;AAEb,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,cAAc,mBAAO,CAAC,gFAAS;AAC/B,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC,OAAO,oBAAoB,EAAE,mBAAO,CAAC,wFAAa;AAClD,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD;AACA,WAAW,iBAAiB;AAC5B,cAAc,+CAA+C;AAC7D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,iBAAiB;AAC3D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,UAAU,gBAAgB;AACxC;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB,WAAW;AACxC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,wCAAwC;;AAErE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC;AAClC,aAAa,8CAA8C,WAAW;AACtE;AACA,aAAa,iBAAiB;AAC9B,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA,oCAAoC;AACpC;AACA;AACA;AACA,MAAM,aAAa;AACnB;AACA,WAAW,2BAA2B;AACtC;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,iBAAiB,MAAM,OAAO,KAAK,MAAM,YAAY;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA,iBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA,sBAAsB,MAAM,qBAAqB;AACjD,UAAU;AACV,sBAAsB,MAAM,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,8BAA8B,KAAK,MAAM,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,4BAA4B,KAAK,MAAM,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,wBAAwB,MAAM,qBAAqB;AACnD,YAAY;AACZ,wBAAwB,MAAM,qBAAqB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7Xa;;AAEb;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;AAEf,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ea;;AAEb,0BAA0B,mBAAO,CAAC,6HAA+B;AACjE,eAAe,mBAAO,CAAC,kFAAU;AACjC,eAAe,mBAAO,CAAC,kFAAU;AACjC,cAAc,mBAAO,CAAC,gFAAS;AAC/B,iBAAiB,mBAAO,CAAC,wFAAU;AACnC,kBAAkB,mBAAO,CAAC,wFAAa;AACvC,OAAO,wBAAwB;AAC/B,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,0CAA0C;AAC1C;AACA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,2CAA2C,+BAA+B;AAC1E,MAAM,mCAAmC;AACzC;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,iCAAiC;AACjC;AACA,cAAc,eAAe;AAC7B;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB,kDAAkD,sBAAsB;AACxE;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,gBAAgB;AAC3B,cAAc,8CAA8C;AAC5D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,gBAAgB;AAC1D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB,WAAW;AACxC;AACA,0BAA0B;AAC1B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,WAAW,wCAAwC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,KAAK;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA,aAAa,uBAAuB,WAAW;AAC/C,eAAe,qBAAqB;AACpC,cAAc,qBAAqB;AACnC,cAAc,OAAO;AACrB;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,MAAM,SAAS;AACf,WAAW,2BAA2B;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,aAAa,YAAY;AACzB,aAAa,uBAAuB,WAAW;AAC/C;AACA,eAAe,mCAAmC;AAClD,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,MAAM,SAAS;AACf,WAAW,2BAA2B;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,mBAAmB;AACzB;AACA;AACA,aAAa,YAAY;AACzB,aAAa,sCAAsC,WAAW;AAC9D;AACA,aAAa,gBAAgB;AAC7B,eAAe,8BAA8B;AAC7C;AACA,cAAc,WAAW;AACzB;AACA,wCAAwC;AACxC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,6CAA6C;;AAExD;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,mCAAmC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,yCAAyC,WAAW;AACjE;AACA,aAAa,mBAAmB;AAChC,eAAe,4CAA4C;AAC3D;AACA,cAAc,WAAW;AACzB;AACA,sCAAsC;AACtC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,2BAA2B;;AAEtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gCAAgC;AAC/C;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,gBAAgB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACvqBa;;AAEb,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,cAAc,mBAAO,CAAC,gFAAS;AAC/B,iBAAiB,mBAAO,CAAC,wFAAU;AACnC,OAAO,UAAU,EAAE,mBAAO,CAAC,wFAAa;;AAExC;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,iCAAiC;AACjC;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,yCAAyC;AACpD;AACA,WAAW,kBAAkB;AAC7B,cAAc,iDAAiD;AAC/D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,kBAAkB;AAC5D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB,WAAW;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,0CAA0C,WAAW;AAClE;AACA,aAAa,kBAAkB;AAC/B,eAAe,SAAS;AACxB,cAAc,WAAW;AACzB;AACA,qCAAqC;AACrC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,2BAA2B;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjRa;;AAEb,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,iBAAiB,mBAAO,CAAC,wFAAU;AACnC,cAAc,mBAAO,CAAC,gFAAS;AAC/B,kBAAkB,mBAAO,CAAC,wFAAa;AACvC;AACA;AACA,EAAE;AACF,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa,iCAAiC;AAC9C,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,cAAc,mCAAmC;AACjD;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB,WAAW;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,gBAAgB;AAC7B,eAAe,iBAAiB;AAChC;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA;AACA;AACA,2BAA2B,WAAW,IAAI,2DAA2D;AACrG;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,MAAM;AACnB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,mBAAmB;AAChC,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;;AAEjB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc,cAAc;AAC5B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,gCAAgC;AAC7C;AACA,aAAa,iBAAiB,WAAW;AACzC,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,iBAAiB,WAAW;AACzC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,iBAAiB,WAAW;AACzC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AChmCa;;AAEb,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;AACjC,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,OAAO,IAAI,EAAE,mBAAO,CAAC,wFAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,aAAa,KAAK;AAClB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,SAAS;AACxB,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA,aAAa,KAAK;AAClB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxLa;;AAEb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtEa;;AAEb,gBAAgB,mBAAO,CAAC,oFAAW;AACnC,uBAAuB,mBAAO,CAAC,kGAAkB;AACjD,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;;AAEjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,mCAAmC;AAChD;AACA,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,2BAA2B,GAAG;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,qCAAqC,WAAW;AAC7D;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,qCAAqC,WAAW;AAC7D;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AC5Ia;;AAEb,OAAO,kBAAkB,EAAE,mBAAO,CAAC,wFAAa;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,eAAe,wCAAwC;AACvD,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvGa;;AAEb,kBAAkB,mBAAO,CAAC,wFAAa;AACvC,cAAc,mBAAO,CAAC,gFAAS;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ,mCAAmC;AACtD;AACA,aAAa,KAAK;AAClB;;AAEA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA,gCAAgC;AAChC;AACA,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,gDAAgD;AAChD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,6CAA6C;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,6CAA6C;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,UAAU;AACV;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,SAAS,GAAG,2BAA2B;AACrD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzXa;;AAEb,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;AACjC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,kBAAkB,mBAAO,CAAC,wFAAa;AACvC,OAAO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE,YAAY;AACZ,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,GAAG;AAC7D;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC,gCAAgC;AAChC;;AAEA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,6CAA6C;AAC7C;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,SAAS,oCAAoC;AAC7C;;AAEA;;AAEA,WAAW;AACX,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;;AAEA,WAAW;AACX;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,qBAAqB,oBAAoB;AACzC;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,GAAG,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0DAA0D;AACrE;AACA,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,WAAW,0DAA0D;AACrE;AACA,aAAa,QAAQ;AACrB;AACA;AACA,cAAc;AACd;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEa;AACb;AACA,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,iBAAiB,mBAAO,CAAC,wFAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9Ga;;AAEb,sBAAsB,mBAAO,CAAC,kHAAoB;;AAElD,mBAAmB,mBAAO,CAAC,+FAAkB;AAC7C,iBAAiB,mBAAO,CAAC,2FAAgB;;AAEzC,WAAW,mBAAO,CAAC,wEAAM;;AAEzB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,0CAA0C;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACvDa;;AAEb,WAAW,mBAAO,CAAC,6FAAa;AAChC;;AAEA;AACA;AACA,yBAAyB,mBAAO,CAAC,wHAAsB;;AAEvD;AACA;AACA;;AAEA,0BAA0B,mBAAO,CAAC,oIAA0B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9Ca;;AAEb,eAAe,mBAAO,CAAC,iIAAyB;AAChD,WAAW,mBAAO,CAAC,wEAAM;;AAEzB;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,2EAA2E,+BAA+B;;AAE1G;AACA;;AAEA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA,aAAa,mBAAO,CAAC,oHAAiB;AACtC,UAAU,mBAAO,CAAC,mGAAe;AACjC,eAAe,mBAAO,CAAC,+FAAU;AACjC,YAAY,mBAAO,CAAC,gGAAc;;AAElC,oBAAoB,MAAM,SAAS,MAAM;AACzC,IAAI,MAAM;AACV,QAAQ,MAAM;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,kCAAkC;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE,OAAO;AACT;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7OA,WAAW,mBAAO,CAAC,uEAAM;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,4BAA4B;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7Fa;;AAEb,WAAW,aAAa;AACxB;AACA;AACA;AACA,oBAAoB,SAAS,UAAU;AACvC,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACba;;AAEb,WAAW,kBAAkB;AAC7B;;;;;;;;;;;;ACHa;;AAEb,WAAW,aAAa;AACxB;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAmB;AAC9B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,oBAAoB;AAC/B;;;;;;;;;;;;ACHa;;AAEb,WAAW,kBAAkB;AAC7B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,aAAa;AACxB;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;AChfa;;AAEb,iBAAiB,mBAAO,CAAC,6FAAa;;AAEtC;AACA;;AAEA,WAAW,kKAAkK;AAC7K;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,WAAW,4JAA4J;AACvK;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,WAAW,yIAAyI;AACpJ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,WAAW,yCAAyC;AACpD;AACA;AACA;;AAEA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;;;;;;;;;;;ACpEa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA,iFAAiF,sCAAsC;;AAEvH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACnFa;;AAEb,qBAAqB,mBAAO,CAAC,+GAAkB;;AAE/C;;;;;;;;;;;;ACJa;;AAEb;;AAEA,cAAc,mBAAO,CAAC,yGAAiB;;AAEvC,aAAa,mBAAO,CAAC,uFAAW;AAChC,iBAAiB,mBAAO,CAAC,2FAAgB;AACzC,kBAAkB,mBAAO,CAAC,6FAAiB;AAC3C,sBAAsB,mBAAO,CAAC,yFAAe;AAC7C,mBAAmB,mBAAO,CAAC,+FAAkB;AAC7C,iBAAiB,mBAAO,CAAC,2FAAgB;AACzC,gBAAgB,mBAAO,CAAC,yFAAe;;AAEvC,UAAU,mBAAO,CAAC,2GAAqB;AACvC,YAAY,mBAAO,CAAC,+GAAuB;AAC3C,UAAU,mBAAO,CAAC,2GAAqB;AACvC,UAAU,mBAAO,CAAC,2GAAqB;AACvC,UAAU,mBAAO,CAAC,2GAAqB;AACvC,YAAY,mBAAO,CAAC,+GAAuB;AAC3C,WAAW,mBAAO,CAAC,6GAAsB;;AAEzC;;AAEA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF,GAAG;AACH;;AAEA,YAAY,mBAAO,CAAC,wEAAM;AAC1B,sBAAsB,mBAAO,CAAC,kHAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAO,CAAC,6FAAa;;AAEtC,eAAe,mBAAO,CAAC,uFAAW;AAClC,iBAAiB,mBAAO,CAAC,6HAAiC;AAC1D,kBAAkB,mBAAO,CAAC,+HAAkC;;AAE5D,aAAa,mBAAO,CAAC,uJAAuC;AAC5D,YAAY,mBAAO,CAAC,qJAAsC;;AAE1D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH,gDAAgD;AAChD,GAAG;AACH,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,mGAAe;AAClC,aAAa,mBAAO,CAAC,8EAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzXa;;AAEb,cAAc,mBAAO,CAAC,yGAAiB;;AAEvC,WAAW,mCAAmC;AAC9C;;;;;;;;;;;;ACLa;;AAEb,WAAW,oCAAoC;AAC/C;;;;;;;;;;;;ACHa;;AAEb,sBAAsB,mBAAO,CAAC,uHAA0B;AACxD,uBAAuB,mBAAO,CAAC,qHAAyB;;AAExD,qBAAqB,mBAAO,CAAC,kGAAkB;;AAE/C,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Ba;;AAEb,WAAW,kBAAkB;AAC7B;;;;;;;;;;;;ACHa;;AAEb,WAAW,aAAa;AACxB,YAAY,mBAAO,CAAC,yEAAQ;;AAE5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACda;;AAEb,sBAAsB,mBAAO,CAAC,kHAAoB;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBa;;AAEb;AACA,oBAAoB,mBAAO,CAAC,yFAAS;;AAErC,WAAW,aAAa;AACxB;AACA,yCAAyC;AACzC,qCAAqC;AACrC,8CAA8C;AAC9C,0CAA0C;;AAE1C;AACA;;;;;;;;;;;;ACba;;AAEb,WAAW,mBAAmB;AAC9B;AACA;AACA,2FAA2F;AAC3F,4CAA4C;;AAE5C,cAAc,2BAA2B;AACzC;AACA;AACA;AACA,gCAAgC;;AAEhC,kEAAkE;AAClE,qEAAqE;;AAErE;AACA,iCAAiC;AACjC;AACA,uCAAuC;;AAEvC,2DAA2D;AAC3D,+DAA+D;;AAE/D;AACA;AACA,sBAAsB,gBAAgB;AACtC,2EAA2E;;AAE3E,yGAAyG;;AAEzG;AACA,6CAA6C;;AAE7C,8DAA8D;;AAE9D;AACA;AACA,8BAA8B,oBAAoB;AAClD,uEAAuE;AACvE;;AAEA;AACA;;;;;;;;;;;;AC5Ca;;AAEb,iBAAiB,mBAAO,CAAC,mGAAmB;;AAE5C,WAAW,aAAa;AACxB;AACA;AACA;;;;;;;;;;;;ACPa;;AAEb;AACA;AACA,WAAW,mBAAO,CAAC,mGAAe;;AAElC,WAAW,aAAa;AACxB;;;;;;;;;;;ACPA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,SAAS,WAAW;;AAEpB;AACA;AACA,SAAS,UAAU;;AAEnB;AACA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Ba;;AAEb,qBAAqB,mBAAO,CAAC,+GAAuB;AACpD,gBAAgB,mBAAO,CAAC,0FAAY;;AAEpC;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA,2DAA2D;;AAE3D,WAAW,aAAa;AACxB;;;;;;;;;;;;AC3Ca;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,WAAW;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,2CAA2C;AAC3C,2EAA2E;;AAE3E,0BAA0B;;AAE1B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,gBAAgB;AAChB,kEAAkE;AAClE;AACA;AACA,IAAI;AACJ,iCAAiC;AACjC;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gBAAgB;AAChB,kEAAkE;AAClE,wBAAwB;AACxB,6BAA6B;AAC7B;AACA,6FAA6F;AAC7F;AACA;;;;;;;;;;;;ACpGa;;AAEb,gBAAgB,mBAAO,CAAC,0FAAY;AACpC,oBAAoB,mBAAO,CAAC,yGAAiB;AAC7C;AACA,qBAAqB,mBAAO,CAAC,+GAAuB;AACpD,eAAe,mBAAO,CAAC,uFAAW;;AAElC;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,wCAAwC;AACxC,GAAG;AACH;AACA;AACA,WAAW,yDAAyD;AACpE;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;;;;;;;;;;;;AC9Ca;;AAEb;;AAEA;AACA;AACA;;;;;;;;;;;;ACNa;;AAEb,eAAe,mBAAO,CAAC,uFAAW;AAClC,aAAa,mBAAO,CAAC,+GAAmB;;AAExC,qBAAqB,mBAAO,CAAC,iGAAkB;AAC/C,kBAAkB,mBAAO,CAAC,qFAAY;AACtC,WAAW,mBAAO,CAAC,6EAAQ;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACnBa;;AAEb,qBAAqB,mBAAO,CAAC,iGAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTa;;AAEb,aAAa,mBAAO,CAAC,+GAAmB;AACxC,kBAAkB,mBAAO,CAAC,qFAAY;;AAEtC;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;ACfa;;AAEb,gBAAgB,mBAAO,CAAC,0FAAY;AACpC,qBAAqB,mBAAO,CAAC,+GAAuB;AACpD,aAAa,mBAAO,CAAC,8EAAQ;AAC7B,WAAW,mBAAO,CAAC,wEAAM;;AAEzB,WAAW,aAAa;AACxB;;AAEA;AACA,YAAY,4JAA4J;AACxK;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,0BAA0B,uBAAuB,uBAAuB;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ,eAAe,SAAS;AAC3D,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF,YAAY,wKAAwK;AACpL;AACA,mBAAmB,mBAAmB;AACtC;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpEa;;AAEb,sBAAsB,mBAAO,CAAC,gHAAmB;;AAEjD,WAAW,aAAa;AACxB;AACA;AACA;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1da;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAmB;AAC9B;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAmB;AAC9B;AACA;AACA;;;;;;;;;;;;ACLa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAmB;AAC9B;;;;;;;;;;;;ACHa;;AAEb,aAAa,mBAAO,CAAC,iGAAS;;AAE9B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVY;;AAEZ,eAAe,mBAAO,CAAC,oGAAQ;AAC/B,OAAO,QAAQ,EAAE,mBAAO,CAAC,8EAAQ;AACjC,oCAAoC,6BAA6B;;AAEjE;AACA,aAAa,QAAQ;AACrB,cAAc,eAAe;AAC7B,cAAc,gBAAgB;AAC9B;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,gCAAgC;AAC7C;AACA,aAAa,iBAAiB;AAC9B;AACA,gDAAgD;AAChD;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB,eAAe,QAAQ;AACvB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,gCAAgC,WAAW,WAAW,KAAK;AAC3D;AACA,MAAM;AACN,mDAAmD,KAAK;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,QAAQ;AACvB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,uBAAuB,GAAG,IAAI;AAC5C;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9hCa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,aAAa,mBAAO,CAAC,+GAAmB;AACxC,eAAe,mBAAO,CAAC,uFAAW;;AAElC,qBAAqB,mBAAO,CAAC,uGAAkB;AAC/C,kBAAkB,mBAAO,CAAC,2FAAY;AACtC,WAAW,mBAAO,CAAC,mFAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACjBa;;AAEb,qBAAqB,mBAAO,CAAC,uGAAkB;;AAE/C;AACA;AACA;;;;;;;;;;;;ACNa;;AAEb,kBAAkB,mBAAO,CAAC,2FAAY;AACtC,aAAa,mBAAO,CAAC,+GAAmB;;AAExC;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;ACba;;AAEb;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,qGAAe,GAAG;AACxC;AACA,2CAA2C,gBAAgB;AAC3D,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHa;;AAEb;AACA,aAAa,mBAAO,CAAC,qGAAe;;AAEpC;AACA,6CAA6C,sBAAsB,EAAE,mBAAO,CAAC,2GAAkB;;AAE/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/Ba;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBa;;AAEb;AACA,iBAAiB,mBAAO,CAAC,6FAAa;AACtC,iBAAiB,mBAAO,CAAC,mGAAmB;AAC5C,gBAAgB,mBAAO,CAAC,0FAAY;AACpC,cAAc,mBAAO,CAAC,yGAAiB;AACvC;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA,iBAAiB,sBAAsB;AACvC,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA,2CAA2C;AAC3C,mCAAmC;AACnC,6BAA6B;AAC7B;AACA;AACA;;AAEA,YAAY;AACZ;;;;;;;;;;;;AC7Ca;;AAEb,qBAAqB,mBAAO,CAAC,+GAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtDA,aAAa,mBAAO,CAAC,+EAAQ;AAC7B;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCa;;AAEb,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;ACvL7B,WAAW,mBAAO,CAAC,uEAAM;AACzB,UAAU,mBAAO,CAAC,mGAAe;AACjC;;AAEA;AACA,OAAO,mBAAO,CAAC,iBAAI;AACnB,EAAE;;AAEF;AACA,4BAA4B,OAAO;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACrFA,WAAW,mBAAO,CAAC,wEAAM;AACzB,eAAe,mBAAO,CAAC,+FAAU;AACjC,gBAAgB,mBAAO,CAAC,uFAAW;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,iCAAiC;AAC1D,kBAAkB,WAAW,qEAAqE;AAClG,mBAAmB;;;;;;;;;;;;AC3DN;;AAEb,gDAAgD,0DAA0D,2CAA2C;;AAErJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;;AAGF;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB;;;;;;;;;;;;;AC9HpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,2HAAoB;AAC3C,eAAe,mBAAO,CAAC,2HAAoB;AAC3C,mBAAO,CAAC,+FAAU;AAClB;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC7HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;AACA,gBAAgB,mBAAO,CAAC,6HAAqB;AAC7C,mBAAO,CAAC,+FAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,mHAA8B;AACvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,iJAA2B;AAChD;;AAEA,aAAa,4GAAwB;AACrC,4BAA4B,qBAAM,mBAAmB,qBAAM,mFAAmF;AAC9I;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,mBAAM;AAC9B;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,mJAAgC;AACzD,kBAAkB,mBAAO,CAAC,2IAA4B;AACtD,eAAe,mBAAO,CAAC,uIAA0B;AACjD;AACA,qBAAqB,yIAA0B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAO,CAAC,+FAAU;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,mFAAmF;AAC5J;AACA;AACA,qBAAqB,mBAAO,CAAC,uHAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yJAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,uHAAkB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,4FAA4F;AAC5F,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,yJAAwC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO,oBAAoB,OAAO;AAClG;AACA,wBAAwB,OAAO,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAO,CAAC,yJAAmC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mDAAmD,+DAA+D;AAClH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,6IAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;;;;;;;;;;AClgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,qBAAqB,yIAA0B;AAC/C;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,uHAAkB;AACvC,mBAAO,CAAC,+FAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,wGAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,iJAA2B;AAChD;;AAEA,aAAa,4GAAwB;AACrC,4BAA4B,qBAAM,mBAAmB,qBAAM,mFAAmF;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,2IAA4B;AACtD,eAAe,mBAAO,CAAC,uIAA0B;AACjD;AACA,qBAAqB,yIAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAO,CAAC,+FAAU;AAClB;AACA;AACA,qBAAqB,mBAAO,CAAC,uHAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,uHAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sDAAsD;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChoBa;;AAEb;AACA,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,+BAA+B,uCAAuC;AACtE,qCAAqC,+DAA+D,sCAAsC,0BAA0B,+CAA+C,yCAAyC,uEAAuE;AACnU,eAAe,mBAAO,CAAC,sIAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA,yFAAyF;AACzF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;ACnLa;;AAEb,2CAA2C,gCAAgC,oCAAoC,oDAAoD,6DAA6D,iEAAiE,sCAAsC;AACvU,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,6DAA6D,4CAA4C,oKAAoK,mFAAmF,KAAK;AAC1e,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,kDAAkD,0CAA0C;AAC5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,+DAA+D,sCAAsC,0BAA0B,+CAA+C,yCAAyC,uEAAuE;AACnU,eAAe,mBAAO,CAAC,8EAAQ;AAC/B;AACA,gBAAgB,mBAAO,CAAC,mBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;ACtLY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,OAAO;AACf,QAAQ;AACR;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf,QAAQ;AACR;AACA,QAAQ,OAAO;AACf,QAAQ;AACR,QAAQ,OAAO;AACf;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/FA;AACA;;AAEa;;AAEb,iCAAiC,+IAAgC;AACjE;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+IAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+BAA+B,mBAAO,CAAC,sIAAiB;AACxD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,aAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACrFa;;AAEb,4BAA4B,+IAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrBA,kIAA+C;;;;;;;;;;;ACA/C,UAAU,wKAAqD;AAC/D,cAAc;AACd,gBAAgB;AAChB,0KAAuD;AACvD,oKAAmD;AACnD,6KAAyD;AACzD,mLAA6D;AAC7D,sMAAqE;AACrE,4LAAgE;;;;;;;;;;;ACRhE;AACA;AACA,aAAa,mBAAO,CAAC,8EAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEa;;AAEb,gBAAgB,mBAAO,CAAC,0FAAY;AACpC,cAAc,mBAAO,CAAC,oFAAU;;AAEhC;AACA,iBAAiB,mBAAO,CAAC,2FAAgB;;AAEzC,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBa;;AAEb,mBAAmB,mBAAO,CAAC,mGAAe;AAC1C,aAAa,mBAAO,CAAC,wHAAsB;AAC3C,qBAAqB,mBAAO,CAAC,oIAA0B;AACvD,WAAW,mBAAO,CAAC,wEAAM;;AAEzB,iBAAiB,mBAAO,CAAC,2FAAgB;AACzC;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,uBAAuB;AAC5C,IAAI;AACJ,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,mHAA8B;AACvC,eAAe,mBAAO,CAAC,+FAAU;;AAEjC;AACA,kBAAkB,mBAAO,CAAC,gJAAyC;AACnE,kBAAkB,mBAAO,CAAC,gJAAyC;AACnE,gBAAgB,mBAAO,CAAC,4IAAuC;AAC/D,mBAAmB,mBAAO,CAAC,kJAA0C;AACrE,qBAAqB,mBAAO,CAAC,sJAA4C;AACzE,kBAAkB,mBAAO,CAAC,4KAAuD;AACjF,kBAAkB,mBAAO,CAAC,kKAAkD;;AAE5E;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;AChIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,2HAA6B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACvSA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;AACvD;AACA,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;;AAEA,2BAA2B;AAC3B,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;;AAErB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;;AAEtB;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;;AAEA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,KAAK;AACL,IAAI,SAAS,IAA8B;AAC3C;AACA,aAAa,mBAAO,CAAC,qBAAQ;AAC7B;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,OAAO;AACP;AACA;AACA,CAAC;;AAED,CAAC,EAAE,KAA6B,kEAAkE;;;;;;;;;;;;ACr1ElG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,SAAS,qBAAM;AACf,IAAI;AACJ;AACA;AACA,YAAY,qBAAM;AAClB;AACA;AACA;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;AACA;;AAEa;;AAEb,wBAAwB,mBAAO,CAAC,gGAAc;AAC9C,0BAA0B,mBAAO,CAAC,2HAAuB;AACzD,sBAAsB,mBAAO,CAAC,gHAAmB;AACjD,mBAAmB,mBAAO,CAAC,uGAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,yBAAyB;AACzB,2BAA2B;AAC3B,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;AAGzB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;AC7UD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,SAAS;AACjC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,OAAO,oBAAoB,OAAO;AAC/C;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA,QAAQ,SAAS,OAAO;AACxB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,IAAI,KAAsB,EAAE;AAAA,iBAO3B;AACD,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;AAGf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,iIAA0C;;AAE1C;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,gBAAgB;AAChB,sBAAsB;;AAEtB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,cAAc;AACd,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,eAAe;AACf,2BAA2B;;AAE3B;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,iJAAgD;;AAEhD;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW;AACX;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,uIAAsC;;AAEtC,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,qCAAqC;AACxE,4BAA4B,OAAO,sDAAsD;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AC1sBN;;AAEb,cAAc,mBAAO,CAAC,oFAAU;AAChC,2BAA2B,mBAAO,CAAC,8HAAwB;AAC3D,eAAe,mBAAO,CAAC,uFAAW;AAClC,gBAAgB,mBAAO,CAAC,0FAAY;AACpC,WAAW,mBAAO,CAAC,wEAAM;AACzB,eAAe,mBAAO,CAAC,uFAAW;;AAElC;AACA,qBAAqB,mBAAO,CAAC,+GAAuB;;AAEpD,4CAA4C,qBAAM;AAClD;;AAEA;;AAEA,WAAW,8DAA8D;AACzE;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,0BAA0B;AACxC,WAAW,yBAAyB;AACpC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI,2BAA2B,GAAG;AACjD,kBAAkB,2DAA2D;AAC7E;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,WAAW,uDAAuD;AAClE;AACA,YAAY,sCAAsC;AAClD;AACA,aAAa,YAAY,2BAA2B,YAAY;AAChE,aAAa,4BAA4B,2BAA2B,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAuD;AAClE;AACA,YAAY,iCAAiC;AAC7C;AACA,aAAa,YAAY,2BAA2B,YAAY;AAChE,aAAa,4BAA4B,2BAA2B,YAAY;AAChF;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA,WAAW,aAAa;AACxB;AACA,4CAA4C;AAC5C;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;;;;;;;;;;AChCa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,mBAAmB,mBAAO,CAAC,uDAAqB;AAChD,qCAAqC,mBAAO,CAAC,yCAAc;AAC3D,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,0CAA0C,mBAAO,CAAC,qEAA4B;AAC9E,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,mBAAmB,mBAAO,CAAC,qCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACtOF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,0CAA0C,mBAAO,CAAC,qEAA4B;AAC9E,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,uCAAuC,mBAAO,CAAC,6CAAgB;AAC/D,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,mBAAmB,mBAAO,CAAC,qCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACzIF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,mBAAmB,mBAAO,CAAC,0HAAmB;AAC9C,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,kBAAkB,mBAAO,CAAC,6GAAuB;AACjD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,UAAU;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC9cF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB,8CAA8C;AAC9C,8CAA8C;AAC9C,wCAAwC,mBAAO,CAAC,+CAAiB;AACjE,iBAAiB,mBAAO,CAAC,oGAAQ;AACjC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA,gCAAgC;AAChC;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,yCAAyC;AACzC;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AC5VR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB;AACtF,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;ACnFa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD,kBAAkB,mBAAO,CAAC,sHAAkB;AAC5C,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,qCAAqC,mBAAO,CAAC,yCAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACtGF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,uCAAuC,mBAAO,CAAC,6CAAgB;AAC/D,0CAA0C,mBAAO,CAAC,mDAAmB;AACrE,qCAAqC,mBAAO,CAAC,yCAAc;AAC3D,0CAA0C,mBAAO,CAAC,qEAA4B;AAC9E,mBAAmB,mBAAO,CAAC,uDAAqB;AAChD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,oCAAoC,mBAAO,CAAC,uCAAa;AACzD,mBAAmB,mBAAO,CAAC,qCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS,GAAG,QAAQ;AAClD;AACA;AACA,+CAA+C,SAAS,GAAG,QAAQ;AACnE,kCAAkC,SAAS,GAAG,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sEAAsE,GAAG,OAAO,MAAM,QAAQ,KAAK,SAAS,WAAW;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,6BAA6B,4DAA4D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC7cF;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,CAAC;AACD,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,gBAAgB,GAAG,eAAe,GAAG,kBAAkB,GAAG,cAAc,GAAG,aAAa,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,YAAY,GAAG,YAAY,GAAG,cAAc;AAC1N,iCAAiC,mBAAO,CAAC,2FAAW;AACpD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,iBAAiB;AACjB;AACA,gBAAgB;AAChB;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,eAAe;AACf;AACA,gBAAgB;AAChB;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AC5EN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,eAAe;AACjC,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,iBAAiB,mBAAO,CAAC,+EAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iBAAiB,mBAAO,CAAC,kCAAW;AACpC,+BAA+B,mBAAO,CAAC,4EAAM;AAC7C,kBAAkB,mBAAO,CAAC,6GAAuB;AACjD,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,eAAe,mBAAO,CAAC,uGAAoB;AAC3C,YAAY,6CAA6C;AACzD,mBAAmB,mBAAO,CAAC,sCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,4CAA4C,OAAO,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4DAA4D,uBAAuB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,WAAW;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACngBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,uBAAuB;AAC9C,2BAA2B;AAC3B,+BAA+B;AAC/B,0CAA0C,mBAAO,CAAC,4DAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,wBAAwB,GAAG,mBAAmB;AAC3E,gCAAgC;AAChC,qBAAqB;AACrB,uBAAuB;AACvB,8BAA8B;AAC9B,2BAA2B;AAC3B,oBAAoB,mBAAO,CAAC,gIAA+B;AAC3D,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iBAAiB,mBAAO,CAAC,iCAAU;AACnC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,oDAAoD;AACpD;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClGa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,iCAAK;AACzB,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,iBAAiB,mBAAO,CAAC,sCAAe;AACxC,gBAAgB,mBAAO,CAAC,gCAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;AClcY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,iCAAK;AACzB,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,iBAAiB,mBAAO,CAAC,sCAAe;AACxC,gBAAgB,mBAAO,CAAC,gCAAS;AACjC,wBAAwB,mBAAO,CAAC,oDAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;ACvdY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,wBAAwB,mBAAO,CAAC,oDAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;;;;;;;;;;;;AC5GS;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,YAAY,mBAAO,CAAC,iCAAK;AACzB,gBAAgB,mBAAO,CAAC,gCAAS;AACjC,wBAAwB,mBAAO,CAAC,oDAAsB;AACtD,wBAAwB,mBAAO,CAAC,oDAAsB;AACtD,mBAAO,CAAC,gCAAS;AACjB,iBAAiB,mBAAO,CAAC,sCAAe;AACxC;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,WAAW;AAC3B,gBAAgB,SAAS;AACzB;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AClHY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,YAAY,mBAAO,CAAC,gCAAI;AACxB,YAAY,mBAAO,CAAC,gCAAI;AACxB,mBAAO,CAAC,gCAAS;AACjB,iBAAiB,mBAAO,CAAC,sCAAe;AACxC,gBAAgB,mBAAO,CAAC,gCAAS;AACjC;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAiD;AACnE,kBAAkB,yDAAyD;AAC3E,kBAAkB,mDAAmD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA,4EAA4E,cAAc;AAC1F,mHAAmH,cAAc;AACjI,mHAAmH,cAAc;AACjI,+IAA+I,cAAc;AAC7J;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAiD;AACnE,kBAAkB,yDAAyD;AAC3E,kBAAkB,mDAAmD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA,4EAA4E,cAAc;AAC1F,mHAAmH,cAAc;AACjI,mHAAmH,cAAc;AACjI,+IAA+I,cAAc;AAC7J;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;;;;;;;;;;;ACrzBY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,iBAAiB,mBAAO,CAAC,+EAAS;AAClC,YAAY,6CAA6C;AACzD;AACA,YAAY,mBAAO,CAAC,iCAAK;AACzB,gBAAgB,mBAAO,CAAC,gCAAS;AACjC,oCAAoC,mBAAO,CAAC,2FAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC3SY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAmB,mBAAO,CAAC,0CAAiB;AAC5C,iBAAiB,mBAAO,CAAC,sCAAe;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kEAAkE;AAClE;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;;;;;;;;;;;AC3JY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,oCAAoC,mBAAO,CAAC,4CAAkB;AAC9D,iBAAiB,mBAAO,CAAC,sCAAe;AACxC,oCAAoC,mBAAO,CAAC,4CAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC3CY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,gBAAgB,mBAAO,CAAC,gCAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;AC1BY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,0CAA0C,mBAAO,CAAC,0EAAiC;AACnF;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,QAAQ,qBAAM;AACd;AACA;AACA,QAAQ,qBAAM;AACd;AACA;AACA;AACA;AACA,QAAQ,qBAAM;AACd;AACA;AACA;AACA;AACA;AACA,KAAK,qBAAM;AACX,IAAI,qBAAM,iBAAiB,MAAM;AACjC,KAAK,qBAAM;AACX,IAAI,qBAAM,iBAAiB,MAAM;AACjC;AACA,qBAAM,0CAA0C,qBAAM;;;;;;;;;;;;;AChCzC;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C,mBAAO,CAAC,0EAAiC;AACnF,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,iBAAiB,mBAAO,CAAC,sCAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,0EAA0E,MAAM;AAChF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA,gCAAgC,MAAM;AACtC,mCAAmC,MAAM;AACzC;AACA,aAAa;AACb,sCAAsC;AACtC;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA,gCAAgC,MAAM;AACtC,mCAAmC,MAAM;AACzC,2BAA2B,MAAM;AACjC;AACA,aAAa;AACb,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA,gCAAgC,MAAM;AACtC,mCAAmC,MAAM;AACzC;AACA,aAAa;AACb,sCAAsC;AACtC;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA,gCAAgC,MAAM;AACtC,mCAAmC,MAAM;AACzC,2BAA2B,MAAM;AACjC,4BAA4B,MAAM;AAClC,aAAa;AACb,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACxJY;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,6BAA6B;AACxD,YAAY,mBAAO,CAAC,iCAAK;AACzB,0CAA0C,mBAAO,CAAC,0EAAiC;AACnF,mBAAmB,mBAAO,CAAC,0CAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;;ACpDX;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,iCAAK;AACzB,iCAAiC,mBAAO,CAAC,qFAAQ;AACjD,mBAAO,CAAC,gCAAS;AACjB,gBAAgB,mBAAO,CAAC,gCAAS;AACjC;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;ACvID;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA","sources":["webpack://@vaultys/id/./dist/node/index.js","webpack://@vaultys/id/./dist/node/src/Challenger.js","webpack://@vaultys/id/./dist/node/src/Fido2Manager.js","webpack://@vaultys/id/./dist/node/src/Fido2PRFManager.js","webpack://@vaultys/id/./dist/node/src/GameOfLifeIcon.js","webpack://@vaultys/id/./dist/node/src/IdManager.js","webpack://@vaultys/id/./dist/node/src/KeyManager.js","webpack://@vaultys/id/./dist/node/src/MemoryChannel.js","webpack://@vaultys/id/./dist/node/src/MemoryStorage.js","webpack://@vaultys/id/./dist/node/src/PQManager.js","webpack://@vaultys/id/./dist/node/src/VaultysId.js","webpack://@vaultys/id/./dist/node/src/crypto.js","webpack://@vaultys/id/./dist/node/src/cryptoChannel.js","webpack://@vaultys/id/./dist/node/src/platform/SoftCredentials.js","webpack://@vaultys/id/./dist/node/src/platform/webauthn.js","webpack://@vaultys/id/./dist/node/src/pqCrypto.js","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decode.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/encode.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/index.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@msgpack+msgpack@3.1.2/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/nist.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p256.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p384.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/p521.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/_crystals.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/ml-dsa.js","webpack://@vaultys/id/./node_modules/.pnpm/@noble+post-quantum@0.4.1/node_modules/@noble/post-quantum/utils.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/armor.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/header.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/index.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/payload.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/encryption/recipient.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/index.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/message-header.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/header.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/index.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/payload.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signcryption/recipient.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/header.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/index.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/signing/payload.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/util.js","webpack://@vaultys/id/./node_modules/.pnpm/@vaultys+saltpack@1.0.0-beta4/node_modules/@vaultys/saltpack/dist/with-armor.js","webpack://@vaultys/id/./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js","webpack://@vaultys/id/./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js","webpack://@vaultys/id/./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js","webpack://@vaultys/id/./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js","webpack://@vaultys/id/./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js","webpack://@vaultys/id/./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js","webpack://@vaultys/id/./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js","webpack://@vaultys/id/./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/cbor.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/commented.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/constants.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/decoder.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/diagnose.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/encoder.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/map.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/objectRecorder.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/sharedValueEncoder.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/simple.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/tagged.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/lib/utils.js","webpack://@vaultys/id/./node_modules/.pnpm/cbor@10.0.3/node_modules/cbor/vendor/binary-parse-stream/index.js","webpack://@vaultys/id/./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js","webpack://@vaultys/id/./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js","webpack://@vaultys/id/./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js","webpack://@vaultys/id/./node_modules/.pnpm/duplexify@4.1.3/node_modules/duplexify/index.js","webpack://@vaultys/id/./node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js","webpack://@vaultys/id/./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js","webpack://@vaultys/id/./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js","webpack://@vaultys/id/./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js","webpack://@vaultys/id/./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","webpack://@vaultys/id/./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js","webpack://@vaultys/id/./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js","webpack://@vaultys/id/./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js","webpack://@vaultys/id/./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js","webpack://@vaultys/id/./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js","webpack://@vaultys/id/./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js","webpack://@vaultys/id/./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js","webpack://@vaultys/id/./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js","webpack://@vaultys/id/./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js","webpack://@vaultys/id/./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js","webpack://@vaultys/id/./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js","webpack://@vaultys/id/./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js","webpack://@vaultys/id/./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js","webpack://@vaultys/id/./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js","webpack://@vaultys/id/./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js","webpack://@vaultys/id/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js","webpack://@vaultys/id/./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js","webpack://@vaultys/id/./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js","webpack://@vaultys/id/./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js","webpack://@vaultys/id/./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js","webpack://@vaultys/id/./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js","webpack://@vaultys/id/./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js","webpack://@vaultys/id/./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js","webpack://@vaultys/id/./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js","webpack://@vaultys/id/./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js","webpack://@vaultys/id/./node_modules/.pnpm/lodash.chunk@4.2.0/node_modules/lodash.chunk/index.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js","webpack://@vaultys/id/./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js","webpack://@vaultys/id/./node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js","webpack://@vaultys/id/./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js","webpack://@vaultys/id/./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js","webpack://@vaultys/id/./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js","webpack://@vaultys/id/./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js","webpack://@vaultys/id/./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js","webpack://@vaultys/id/./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js","webpack://@vaultys/id/./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js","webpack://@vaultys/id/./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js","webpack://@vaultys/id/./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js","webpack://@vaultys/id/./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","webpack://@vaultys/id/./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js","webpack://@vaultys/id/./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js","webpack://@vaultys/id/./node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js","webpack://@vaultys/id/./node_modules/.pnpm/pumpify@2.0.1/node_modules/pumpify/index.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack://@vaultys/id/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js","webpack://@vaultys/id/./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js","webpack://@vaultys/id/./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js","webpack://@vaultys/id/./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js","webpack://@vaultys/id/./node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js","webpack://@vaultys/id/./node_modules/.pnpm/stream-shift@1.0.3/node_modules/stream-shift/index.js","webpack://@vaultys/id/./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js","webpack://@vaultys/id/./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js","webpack://@vaultys/id/./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js","webpack://@vaultys/id/./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js","webpack://@vaultys/id/./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js","webpack://@vaultys/id/./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js","webpack://@vaultys/id/./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js","webpack://@vaultys/id/./node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","webpack://@vaultys/id/./src/Fido2Manager.ts","webpack://@vaultys/id/./src/Fido2PRFManager.ts","webpack://@vaultys/id/./src/KeyManager.ts","webpack://@vaultys/id/./src/MemoryChannel.ts","webpack://@vaultys/id/./src/MemoryStorage.ts","webpack://@vaultys/id/./src/PQManager.ts","webpack://@vaultys/id/./src/VaultysId.ts","webpack://@vaultys/id/./src/crypto.ts","webpack://@vaultys/id/./src/cryptoChannel.ts","webpack://@vaultys/id/./src/platform/SoftCredentials.ts","webpack://@vaultys/id/./src/platform/webauthn.ts","webpack://@vaultys/id/./src/pqCrypto.ts","webpack://@vaultys/id/./test/challenger.test.ts","webpack://@vaultys/id/./test/challenger_v0.test.ts","webpack://@vaultys/id/./test/channel.test.ts","webpack://@vaultys/id/./test/file.browser_test.ts","webpack://@vaultys/id/./test/idManager.test.ts","webpack://@vaultys/id/./test/keymanager.test.ts","webpack://@vaultys/id/./test/pqc.test.ts","webpack://@vaultys/id/./test/pqcManager.web.test.ts","webpack://@vaultys/id/./test/saltpack.test.ts","webpack://@vaultys/id/./test/shims.ts","webpack://@vaultys/id/./test/softCredentials.test.ts","webpack://@vaultys/id/./test/utils.ts","webpack://@vaultys/id/./test/v0toV1.test.ts","webpack://@vaultys/id/ignored|/Users/fxthoorens/Documents/GitHub/vaultysid/node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl|crypto","webpack://@vaultys/id/ignored|/Users/fxthoorens/Documents/GitHub/vaultysid/node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib|util","webpack://@vaultys/id/ignored|/Users/fxthoorens/Documents/GitHub/vaultysid/node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams|util","webpack://@vaultys/id/ignored|/Users/fxthoorens/Documents/GitHub/vaultysid/node_modules/.pnpm/pump@3.0.2/node_modules/pump|fs","webpack://@vaultys/id/webpack/bootstrap","webpack://@vaultys/id/webpack/runtime/define property getters","webpack://@vaultys/id/webpack/runtime/global","webpack://@vaultys/id/webpack/runtime/hasOwnProperty shorthand","webpack://@vaultys/id/webpack/runtime/make namespace object","webpack://@vaultys/id/webpack/before-startup","webpack://@vaultys/id/webpack/startup","webpack://@vaultys/id/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoChannel = exports.GameOfLifeIcon = exports.KeyManager = exports.IdManager = exports.LocalStorage = exports.convertWebWritableStreamToNodeWritable = exports.convertWebReadableStreamToNodeReadable = exports.StreamChannel = exports.MemoryStorage = exports.MemoryChannel = exports.Challenger = exports.VaultysId = exports.Buffer = exports.crypto = void 0;\nconst Challenger_1 = __importDefault(require(\"./src/Challenger\"));\nexports.Challenger = Challenger_1.default;\nconst IdManager_1 = __importDefault(require(\"./src/IdManager\"));\nexports.IdManager = IdManager_1.default;\nconst KeyManager_1 = __importDefault(require(\"./src/KeyManager\"));\nexports.KeyManager = KeyManager_1.default;\nconst VaultysId_1 = __importDefault(require(\"./src/VaultysId\"));\nexports.VaultysId = VaultysId_1.default;\nconst MemoryChannel_1 = require(\"./src/MemoryChannel\");\nObject.defineProperty(exports, \"MemoryChannel\", { enumerable: true, get: function () { return MemoryChannel_1.MemoryChannel; } });\nObject.defineProperty(exports, \"StreamChannel\", { enumerable: true, get: function () { return MemoryChannel_1.StreamChannel; } });\nObject.defineProperty(exports, \"convertWebReadableStreamToNodeReadable\", { enumerable: true, get: function () { return MemoryChannel_1.convertWebReadableStreamToNodeReadable; } });\nObject.defineProperty(exports, \"convertWebWritableStreamToNodeWritable\", { enumerable: true, get: function () { return MemoryChannel_1.convertWebWritableStreamToNodeWritable; } });\nconst MemoryStorage_1 = require(\"./src/MemoryStorage\");\nObject.defineProperty(exports, \"MemoryStorage\", { enumerable: true, get: function () { return MemoryStorage_1.MemoryStorage; } });\nObject.defineProperty(exports, \"LocalStorage\", { enumerable: true, get: function () { return MemoryStorage_1.LocalStorage; } });\nconst GameOfLifeIcon_1 = __importDefault(require(\"./src/GameOfLifeIcon\"));\nexports.GameOfLifeIcon = GameOfLifeIcon_1.default;\nconst cryptoChannel_1 = __importDefault(require(\"./src/cryptoChannel\"));\nexports.CryptoChannel = cryptoChannel_1.default;\n//utils\nconst crypto = __importStar(require(\"./src/crypto\"));\nexports.crypto = crypto;\nconst Buffer = crypto.Buffer;\nexports.Buffer = Buffer;\nif (typeof Symbol.dispose === \"undefined\") {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    Symbol.dispose = Symbol(\"Symbol.dispose\");\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst crypto_1 = require(\"./crypto\");\nconst VaultysId_1 = __importDefault(require(\"./VaultysId\"));\nconst buffer_1 = require(\"buffer/\");\nconst ERROR = -2;\nconst UNINITIALISED = -1;\nconst INIT = 0;\nconst STEP1 = 1;\nconst COMPLETE = 2;\nconst writeString = (name, value) => buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, \"ascii\"), buffer_1.Buffer.from([0xa0 + value.length]), buffer_1.Buffer.from(value, \"ascii\")]);\nconst writeBuffer = (name, value) => {\n    const nameHeader = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, \"ascii\")]);\n    let lengthHeader;\n    if (value.length <= 65535) {\n        // bin16: binary data whose length is upto (2^16)-1 bytes\n        lengthHeader = buffer_1.Buffer.from([0xc5, (value.length >> 8) & 0xff, value.length & 0xff]);\n    }\n    else {\n        // bin32: binary data whose length is upto (2^32)-1 bytes\n        lengthHeader = buffer_1.Buffer.from([0xc6, (value.length >> 24) & 0xff, (value.length >> 16) & 0xff, (value.length >> 8) & 0xff, value.length & 0xff]);\n    }\n    return buffer_1.Buffer.concat([nameHeader, lengthHeader, value]);\n};\nconst writeInt = (name, value) => {\n    // console.log(value)\n    const start = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa0 + name.length]), buffer_1.Buffer.from(name, \"ascii\")]);\n    let end;\n    if (value >= 0 && value <= 0x7f) {\n        end = buffer_1.Buffer.from([value]);\n    }\n    else if (value < 0 && value >= -0x20) {\n        end = buffer_1.Buffer.from([value]);\n    }\n    else if (value > 0 && value <= 0xff) {\n        // uint8\n        end = buffer_1.Buffer.from([0xcc, value]);\n    }\n    else if (value >= -0x80 && value <= 0x7f) {\n        // int8\n        end = buffer_1.Buffer.from([0xd0, value]);\n    }\n    else if (value > 0 && value <= 0xffff) {\n        // uint16\n        end = buffer_1.Buffer.from([0xcd, value >>> 8, value]);\n    }\n    else if (value >= -0x8000 && value <= 0x7fff) {\n        // int16\n        end = buffer_1.Buffer.from([0xd1, value >>> 8, value]);\n    }\n    else if (value > 0 && value <= 0xffffffff) {\n        // uint32\n        end = buffer_1.Buffer.from([0xce, value >>> 24, value >>> 16, value >>> 8, value]);\n    }\n    else if (value >= -0x80000000 && value <= 0x7fffffff) {\n        // int32\n        end = buffer_1.Buffer.from([0xd2, value >>> 24, value >>> 16, value >>> 8, value]);\n    }\n    else if (value > 0 && value <= 0xffffffffffffffffn) {\n        // uint64\n        // Split 64 bit number into two 32 bit numbers because JavaScript only regards\n        // 32 bits for bitwise operations.\n        const hi = value / 2 ** 32;\n        const lo = value % 2 ** 32;\n        end = buffer_1.Buffer.from([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\n    }\n    else {\n        end = buffer_1.Buffer.from([0x00]);\n    }\n    return buffer_1.Buffer.concat([start, end]);\n};\nconst encode_v0 = ({ version, protocol, service, timestamp, pk1, pk2, nonce, metadata }) => {\n    const p = buffer_1.Buffer.concat([\n        buffer_1.Buffer.from([0x87]),\n        writeString(\"protocol\", protocol),\n        writeString(\"service\", service),\n        writeInt(\"timestamp\", timestamp),\n        writeBuffer(\"pk1\", pk1),\n        writeBuffer(\"pk2\", pk2),\n        writeBuffer(\"nonce\", nonce),\n        buffer_1.Buffer.from([0xa0 + \"metadata\".length]),\n        buffer_1.Buffer.from(\"metadata\", \"ascii\"),\n        buffer_1.Buffer.from([0x80]), // empty metadata\n    ]);\n    // console.log(p.toString(\"base64\"));\n    return p;\n};\nconst encode_v0_full = ({ version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata }) => {\n    const p = buffer_1.Buffer.concat([\n        buffer_1.Buffer.from([0x89]),\n        writeString(\"protocol\", protocol),\n        writeString(\"service\", service),\n        writeInt(\"timestamp\", timestamp),\n        writeBuffer(\"pk1\", pk1),\n        writeBuffer(\"pk2\", pk2),\n        writeBuffer(\"nonce\", nonce),\n        writeBuffer(\"sign1\", sign1),\n        writeBuffer(\"sign2\", sign2),\n        buffer_1.Buffer.from([0xa0 + \"metadata\".length]),\n        buffer_1.Buffer.from(\"metadata\", \"ascii\"),\n        buffer_1.Buffer.from([0x80]), // empty metadata\n    ]);\n    //console.log(p.toString(\"ascii\"))\n    return p;\n};\nconst deserialize = (challenge) => {\n    const unpacked = (0, msgpack_1.decode)(challenge);\n    const state = {\n        state: ERROR,\n        error: \"\",\n    };\n    if (!unpacked.version) {\n        unpacked.version = 0;\n    }\n    const result = {\n        ...unpacked,\n        ...state,\n    };\n    try {\n        if (!result.timestamp || !result.protocol || !result.service) {\n            result.state = ERROR;\n            result.error = \"[ERROR] Challenge is missing values\";\n        }\n        else if (!result.pk2 && !!result.pk1 && !result.sign1 && !result.sign2 && result.nonce?.length === 16) {\n            result.state = INIT;\n        }\n        else if (!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {\n            result.state = STEP1;\n            const id2 = VaultysId_1.default.fromId(result.pk2);\n            const challenge = serializeUnsigned(result);\n            if (!id2.verifyChallenge(challenge, result.sign2, true)) {\n                result.state = ERROR;\n                result.error = \"[STEP1] failed the verification of pk2\";\n            }\n        }\n        else if (!!result.sign1 && result.nonce?.length === 32 && !!result.pk1 && !!result.pk2 && !!result.sign2) {\n            result.state = COMPLETE;\n            //console.log(result);\n            const id1 = VaultysId_1.default.fromId(result.pk1);\n            const id2 = VaultysId_1.default.fromId(result.pk2);\n            if (id1.version !== unpacked.version || id2.version !== unpacked.version) {\n                //console.log(id1.version, id2.version, unpacked.version);\n                result.state = ERROR;\n                result.error = \"[COMPLETE] pk1 and pk2 are using different serialization version\";\n            }\n            const challenge = serializeUnsigned(result);\n            if (!id2.verifyChallenge(challenge, result.sign2, true)) {\n                result.state = ERROR;\n                result.error = \"[COMPLETE] failed the verification of pk2\";\n            }\n            if (!id1.verifyChallenge(challenge, result.sign1, true)) {\n                result.state = ERROR;\n                result.error = \"[COMPLETE] failed the verification of pk1\";\n            }\n        }\n    }\n    catch (error) {\n        result.error = \"[\" + result.state + \" -> ERROR] \" + error;\n        result.state = ERROR;\n    }\n    return result;\n};\nconst serialize = (data) => {\n    if (data.state == INIT) {\n        const { version, protocol, service, timestamp, pk1, nonce, metadata } = data;\n        const picked = { version, protocol, service, timestamp, pk1, nonce, metadata };\n        const encoded = (0, msgpack_1.encode)(picked);\n        return buffer_1.Buffer.from(encoded);\n    }\n    if (data.state == STEP1) {\n        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign2, metadata } = data;\n        const picked = {\n            version,\n            protocol,\n            service,\n            timestamp,\n            pk1,\n            pk2,\n            nonce,\n            sign2,\n            metadata,\n        };\n        const encoded = (0, msgpack_1.encode)(picked);\n        return buffer_1.Buffer.from(encoded);\n    }\n    if (data.state == COMPLETE) {\n        const { version, protocol, service, timestamp, pk1, pk2, nonce, sign1, sign2, metadata } = data;\n        const picked = {\n            version,\n            protocol,\n            service,\n            timestamp,\n            pk1,\n            pk2,\n            nonce,\n            sign1,\n            sign2,\n            metadata,\n        };\n        const encoded = (0, msgpack_1.encode)(picked);\n        return buffer_1.Buffer.from(encoded);\n    }\n    return null;\n};\nconst serializeUnsigned = (challenge) => {\n    const { version, protocol, service, timestamp, pk1, pk2, nonce, metadata } = challenge;\n    const picked = { version, protocol, service, timestamp, pk1, pk2, nonce, metadata };\n    return version === 0 ? encode_v0(picked) : buffer_1.Buffer.from((0, msgpack_1.encode)(picked));\n};\nconst isLive = (challenge, liveliness, time = Date.now()) => {\n    return challenge.timestamp > time - liveliness && challenge.timestamp < time + liveliness;\n};\nclass Challenger {\n    constructor(vaultysId, liveliness = 60 * 1000) {\n        this.version = 0;\n        this.state = UNINITIALISED;\n        // create a copy of VaultysId\n        this.vaultysId = VaultysId_1.default.fromSecret(vaultysId.getSecret());\n        this.liveliness = liveliness;\n    }\n    static async verifyCertificate(certificate) {\n        const deser = deserialize(certificate);\n        return deser.state === COMPLETE;\n    }\n    static async fromCertificate(certificate, liveliness) {\n        const deser = deserialize(certificate);\n        if (!deser.version) {\n            deser.version = 0;\n        }\n        if (deser.state === INIT) {\n            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk1).toVersion(deser.version), liveliness);\n            challenger.challenge = deser;\n            challenger.mykey = deser.pk1;\n            challenger.state = INIT;\n        }\n        else if (deser.state === STEP1) {\n            const challenger = new Challenger(VaultysId_1.default.fromId(deser.pk2).toVersion(deser.version), liveliness);\n            challenger.challenge = deser;\n            challenger.mykey = deser.pk2;\n            challenger.hisKey = deser.pk1;\n            challenger.state = STEP1;\n            return challenger;\n        }\n    }\n    async setChallenge(challengeString) {\n        if (this.state !== UNINITIALISED) {\n            this.state = ERROR;\n            throw new Error(\"Challenger already initialised, can't reset the state\");\n        }\n        this.challenge = deserialize(challengeString);\n        this.version = this.challenge.version;\n        if (!isLive(this.challenge, this.liveliness)) {\n            this.state = ERROR;\n            this.challenge.error = \"challenge timestamp failed the liveliness at first signature\";\n            throw new Error(this.challenge.error);\n        }\n        if (this.challenge.state === ERROR) {\n            this.state = ERROR;\n            throw new Error(this.challenge.error);\n        }\n        else if (this.challenge.state === INIT) {\n            //this.vaultysId.toVersion(this.challenge.version);\n            this.mykey = this.vaultysId.id;\n            this.challenge.pk2 = this.mykey;\n            this.hisKey = this.challenge.pk1;\n            this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce || new Uint8Array(), (0, crypto_1.randomBytes)(16)]);\n            const serialized = this.getUnsignedChallenge();\n            if (!serialized)\n                throw new Error(\"Error processing Challenge\");\n            this.challenge.sign2 = (await this.vaultysId.signChallenge(serialized)) || undefined;\n            this.challenge.state = this.state = STEP1;\n        }\n        else if (this.challenge.state === COMPLETE) {\n            //this.vaultysId.toVersion(this.challenge.version);\n            this.mykey = this.vaultysId.id;\n            if (!this.challenge.pk1?.equals(this.mykey) && !this.challenge.pk1?.equals(this.mykey)) {\n                this.state = ERROR;\n                throw new Error(\"Can't link the vaultys id to this challenge\");\n            }\n            else {\n                this.state = COMPLETE;\n            }\n        }\n        else {\n            throw new Error(\"Challenge is from a protocol already launched, this is completely unsafe\");\n        }\n    }\n    getContext() {\n        return {\n            protocol: this.challenge?.protocol,\n            service: this.challenge?.service,\n            metadata: this.challenge?.metadata,\n        };\n    }\n    createChallenge(protocol, service, version = 0, metadata) {\n        this.version = version;\n        if (this.state == UNINITIALISED) {\n            this.mykey = this.vaultysId.toVersion(version).id;\n            // console.log(this)\n            this.challenge = {\n                version,\n                protocol,\n                service,\n                metadata: metadata ? { pk1: metadata } : {},\n                timestamp: Date.now(),\n                pk1: this.mykey,\n                nonce: (0, crypto_1.randomBytes)(16),\n                state: INIT,\n            };\n            this.state = INIT;\n        }\n        else {\n            this.state = ERROR;\n            throw new Error(\"Challenger already initialised, can't reset the state\");\n        }\n    }\n    getCertificate() {\n        if (!this.challenge)\n            return buffer_1.Buffer.from([]);\n        return serialize(this.challenge) || buffer_1.Buffer.from([]);\n    }\n    getUnsignedChallenge() {\n        return serializeUnsigned(this.challenge);\n    }\n    getContactDid() {\n        if (!this.hisKey)\n            return null;\n        return VaultysId_1.default.fromId(this.hisKey).did;\n    }\n    getContactId() {\n        // to be sure this function is not misused, we get the id of the contact only once the protocol is complete\n        if (this.isComplete()) {\n            const contact = VaultysId_1.default.fromId(this.hisKey, this.getCertificate() || undefined);\n            return contact;\n        }\n        else\n            throw new Error(\"The challenge is not COMPLETE, it is unsafe to get the Contact ID before\");\n    }\n    static fromString(vaultysId, challengeString) {\n        const challenger = new Challenger(vaultysId);\n        challenger.setChallenge(challengeString);\n        return challenger;\n    }\n    hasFailed() {\n        return this.state == ERROR;\n    }\n    isComplete() {\n        return this.state == COMPLETE;\n    }\n    async init(challengeString) {\n        if (this.state !== UNINITIALISED) {\n            throw new Error(\"Can't init INITIALISED challenge\");\n        }\n        const tempchallenge = deserialize(challengeString);\n        this.version = tempchallenge.version = tempchallenge.version ? 1 : 0;\n        this.vaultysId.toVersion(this.version);\n        if (tempchallenge.state === INIT) {\n            if (tempchallenge.pk2?.toString(\"base64\") !== this.vaultysId.id.toString(\"base64\")) {\n                this.state = ERROR;\n                throw new Error(\"challenge is not corresponding to the right id\");\n            }\n            this.challenge = tempchallenge;\n            this.version = tempchallenge.version;\n            this.mykey = this.challenge.pk2 = this.vaultysId.id;\n            this.hisKey = this.challenge.pk1;\n            this.challenge.state = this.state = INIT;\n            return;\n        }\n        if (tempchallenge.state === STEP1) {\n            if (tempchallenge.pk2?.toString(\"base64\") !== this.vaultysId.id.toString(\"base64\")) {\n                this.state = ERROR;\n                throw new Error(\"challenge is not corresponding to the right id\");\n            }\n            this.challenge = tempchallenge;\n            this.version = tempchallenge.version;\n            this.mykey = this.challenge.pk2;\n            this.hisKey = this.challenge.pk1;\n            this.state = this.challenge.state = STEP1;\n            return;\n        }\n    }\n    async update(challengeString, metadata) {\n        if (this.state === ERROR) {\n            throw new Error(\"Can't update errorneous challenge\");\n        }\n        else if (this.state === COMPLETE) {\n            throw new Error(\"Can't update COMPLETE challenge\");\n        }\n        else {\n            const tempchallenge = deserialize(challengeString);\n            // console.log(this.state, tempchallenge.state);\n            if (!tempchallenge) {\n                this.state = ERROR;\n                throw new Error(\"Can't read the new incoming challenge\");\n            }\n            if (tempchallenge.state === ERROR) {\n                //console.log(tempchallenge.pk1?.length, tempchallenge.pk2?.length);\n                this.state = ERROR;\n                throw new Error(tempchallenge.error);\n            }\n            if (!isLive(tempchallenge, this.liveliness)) {\n                // console.log(this.liveliness);\n                // const time = Date.now();\n                // console.log(time - tempchallenge.timestamp, this.liveliness);\n                // console.log(tempchallenge.timestamp > time - this.liveliness && tempchallenge.timestamp < time + this.liveliness);\n                this.state = ERROR;\n                throw new Error(\"challenge timestamp failed the liveliness\");\n            }\n            this.version = tempchallenge.version;\n            this.vaultysId.toVersion(this.version);\n            if (this.state === UNINITIALISED && tempchallenge.state === INIT) {\n                if (tempchallenge.metadata.pk2) {\n                    this.state = ERROR;\n                    throw new Error(\"Metadata is malformed: pk2 is already set\");\n                }\n                this.challenge = tempchallenge;\n                this.mykey = this.challenge.pk2 = this.vaultysId.id;\n                this.hisKey = this.challenge.pk1;\n                if (metadata)\n                    this.challenge.metadata.pk2 = metadata;\n                this.challenge.nonce = buffer_1.Buffer.concat([this.challenge.nonce, (0, crypto_1.randomBytes)(16)]);\n                const serialized = this.getUnsignedChallenge();\n                this.challenge.sign2 = await this.vaultysId.signChallenge(serialized);\n                this.challenge.state = this.state = STEP1;\n                return;\n            }\n            if (this.state === UNINITIALISED && tempchallenge.state === STEP1) {\n                if (tempchallenge.pk1?.toString(\"base64\") !== this.vaultysId.id.toString(\"base64\")) {\n                    // console.log(this.vaultysId.version, this);\n                    this.state = ERROR;\n                    throw new Error(\"challenge is not corresponding to the right id\");\n                }\n                const serialized = serializeUnsigned(tempchallenge);\n                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);\n                this.challenge = tempchallenge;\n                this.mykey = this.challenge.pk1;\n                this.hisKey = this.challenge.pk2;\n                this.state = this.challenge.state = COMPLETE;\n                return;\n            }\n            if (this.state === UNINITIALISED && tempchallenge.state === COMPLETE) {\n                console.log(\"COMPLETE case?!!\");\n                return;\n            }\n            if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {\n                this.state = ERROR;\n                throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);\n            }\n            if (this.state === INIT && tempchallenge.state === STEP1) {\n                // @ts-ignore\n                if (!tempchallenge.nonce?.subarray(0, 16).equals(this.challenge.nonce.subarray(0, 16))) {\n                    this.state = ERROR;\n                    throw new Error(\"Nonce has been tampered with\");\n                }\n                if (tempchallenge.timestamp !== this.challenge?.timestamp) {\n                    this.state = ERROR;\n                    throw new Error(\"Timestamp has been tampered with\");\n                }\n                if (!this.mykey?.equals(tempchallenge.pk1)) {\n                    this.state = ERROR;\n                    throw new Error(`The challenge has been tampered with. Received pk1 = '${tempchallenge.pk1}', expected pk1 = '${this.mykey}'`);\n                }\n                const serialized = serializeUnsigned(tempchallenge);\n                if (!serialized) {\n                    this.state = ERROR;\n                    throw new Error(\"Error processing Challenge\");\n                }\n                tempchallenge.sign1 = await this.vaultysId.signChallenge(serialized);\n                this.challenge = tempchallenge;\n                this.hisKey = tempchallenge.pk2;\n                this.state = this.challenge.state = COMPLETE;\n            }\n            else if (this.state === STEP1 && tempchallenge.state === COMPLETE) {\n                if (tempchallenge.protocol !== this.challenge.protocol || tempchallenge.service !== this.challenge.service) {\n                    this.state = ERROR;\n                    throw new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${tempchallenge.protocol}' and '${tempchallenge.service}'`);\n                }\n                // @ts-ignore\n                if (!tempchallenge.nonce?.subarray(16, 32).equals(this.challenge.nonce.subarray(16, 32))) {\n                    this.state = ERROR;\n                    throw new Error(\"Nonce has been tampered with\");\n                }\n                if (tempchallenge.timestamp !== this.challenge?.timestamp) {\n                    this.state = ERROR;\n                    throw new Error(\"Timestamp has been tampered with\");\n                }\n                // INFO: no need for liveliness check since the whole certificate is complete\n                // if (!isLive(tempchallenge, this.liveliness)) {\n                //   this.state = ERROR;\n                //   throw new Error(\"challenge timestamp failed the liveliness at 2nd signature\");\n                // }\n                if (!this.mykey.equals(tempchallenge.pk2)) {\n                    this.state = ERROR;\n                    throw new Error(`The challenge pk2 has been tampered with`);\n                }\n                this.challenge = tempchallenge;\n                this.state = COMPLETE;\n            }\n            else {\n                //console.log(tempchallenge);\n                const error = `The challenge is in an expected state. Received state = '${tempchallenge.state}', expected state = '${this.state + 1}'`;\n                this.state = ERROR;\n                throw new Error(error);\n            }\n        }\n    }\n}\nChallenger.deserializeCertificate = deserialize;\nChallenger.serializeCertificate_v0 = encode_v0_full;\nChallenger.serializeCertificate = serializeUnsigned;\nexports.default = Challenger;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst webauthn_1 = require(\"./platform/webauthn\");\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst buffer_1 = require(\"buffer/\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nconst lookup = {\n    usb: 1,\n    nfc: 2,\n    ble: 4,\n    internal: 8,\n    hybrid: 16,\n    \"smart-card\": 32,\n};\nconst encodeBinary = (data) => {\n    if (data.length <= 65535) {\n        // bin16: binary data whose length is upto (2^16)-1 bytes\n        return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);\n    }\n    else {\n        // bin32: binary data whose length is upto (2^32)-1 bytes\n        return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);\n    }\n};\nconst serializeID_v0 = (km) => {\n    const version = buffer_1.Buffer.from([0x83, 0xa1, 0x76, km.version]);\n    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);\n    const ckey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x63]), encodeBinary(km.ckey)]);\n    return buffer_1.Buffer.concat([version, ckey, cypher]);\n};\nconst getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);\nconst fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);\nconst getAuthTypeFromCkey = (ckey) => {\n    const type = cbor_1.default.decode(ckey).get(1);\n    if (type === 1) {\n        return \"Ed25519VerificationKey2020\";\n    }\n    else if (type === 2) {\n        return \"P256VerificationKey2020\";\n    }\n    else\n        return \"Unknown\";\n};\nconst getSignerFromCkey = (ckey) => {\n    const k = cbor_1.default.decode(ckey);\n    let publicKey = buffer_1.Buffer.from([]);\n    if (k.get(3) == -7)\n        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), k.get(-2), k.get(-3)]);\n    else if (k.get(3) == -8)\n        publicKey = k.get(-2);\n    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)\n        publicKey = k.get(-101);\n    return { publicKey };\n};\nclass Fido2Manager extends KeyManager_1.default {\n    constructor() {\n        super();\n        this._transports = 0;\n        this.level = 1; // ROOT, no Proof Management\n        this.encType = \"X25519KeyAgreementKey2019\";\n        this.webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n    }\n    get transports() {\n        return getTransports(this._transports);\n    }\n    static async createFromAttestation(attestation) {\n        const f2m = new Fido2Manager();\n        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.fid = buffer_1.Buffer.from(attestation.id, \"base64\");\n        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports\n        const response = attestation.response;\n        const transports = response.getTransports ? response.getTransports() : [\"usb\"];\n        f2m._transports = fromTransports(transports);\n        // signing\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        //encrypting\n        const entropy = (0, crypto_1.randomBytes)(32);\n        const seed = sha512(entropy);\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed.slice(0, 32));\n        f2m.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        f2m.entropy = entropy;\n        return f2m;\n    }\n    get id() {\n        if (this.version == 0)\n            return serializeID_v0(this);\n        else\n            return buffer_1.Buffer.from((0, msgpack_1.encode)({\n                v: this.version,\n                c: this.ckey,\n                e: this.cypher.publicKey,\n            }));\n    }\n    get id_v0() {\n        return serializeID_v0(this);\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            f: this.fid,\n            t: this._transports,\n            c: this.ckey,\n            e: this.cypher.secretKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const f2m = new Fido2Manager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"private\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m._transports = data.t ? data.t : 15;\n        f2m.ckey = data.c;\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.signer = getSignerFromCkey(data.c);\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);\n        f2m.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return f2m;\n    }\n    static instantiate(obj) {\n        const f2m = new Fido2Manager();\n        f2m.version = obj.version ?? 0;\n        f2m.level = obj.level;\n        f2m.fid = typeof obj.fid === \"string\" ? buffer_1.Buffer.from(obj.fid, \"base64\") : obj.fid;\n        f2m._transports = obj.t ? obj.t : 15;\n        f2m.ckey = obj.ckey.data ? buffer_1.Buffer.from(obj.ckey.data) : buffer_1.Buffer.from(obj.ckey);\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return f2m;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const f2m = new Fido2Manager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"public\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m.ckey = data.c;\n        f2m.signer = getSignerFromCkey(data.c);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.cypher = {\n            publicKey: data.e,\n        };\n        return f2m;\n    }\n    async getSigner() {\n        return {\n            sign: async (data) => {\n                if (!navigator.credentials)\n                    return null;\n                // ugly request userinteraction (needed for Safari and iOS)\n                try {\n                    await window?.CredentialUserInteractionRequest();\n                }\n                catch (error) { }\n                const challenge = (0, crypto_1.hash)(\"sha256\", data);\n                const publicKey = {\n                    challenge,\n                    userVerification: \"preferred\",\n                    allowCredentials: [\n                        {\n                            type: \"public-key\",\n                            id: this.fid,\n                            transports: getTransports(this._transports),\n                        },\n                    ],\n                };\n                const { response } = (await this.webAuthn.get(publicKey));\n                const publicKeyResponse = response;\n                const output = {\n                    s: buffer_1.Buffer.from(publicKeyResponse.signature),\n                    c: buffer_1.Buffer.from(publicKeyResponse.clientDataJSON),\n                    a: buffer_1.Buffer.from(publicKeyResponse.authenticatorData),\n                };\n                return buffer_1.Buffer.from((0, msgpack_1.encode)(output));\n            },\n        };\n    }\n    verify(data, signature, userVerification = false) {\n        const signatureBuffer = buffer_1.Buffer.from(signature);\n        const decoded = (0, msgpack_1.decode)(signatureBuffer);\n        const response = {\n            signature: decoded.s,\n            clientDataJSON: decoded.c,\n            authenticatorData: decoded.a,\n            userHandle: buffer_1.Buffer.from([]).buffer,\n        };\n        const challenge = (0, crypto_1.hash)(\"sha256\", data).toString(\"base64\");\n        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);\n        if (challenge !== extractedChallenge) {\n            return false;\n        }\n        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);\n    }\n    verifyCredentials(credentials, userVerification = false) {\n        if (credentials.id !== this.fid.toString(\"base64\")) {\n            return false;\n        }\n        const response = credentials.response;\n        const rpIdHash = buffer_1.Buffer.from(response.authenticatorData.slice(0, 32)).toString(\"hex\");\n        const myIdHash = sha256(buffer_1.Buffer.from(credentials.id, \"base64\")).toString(\"hex\");\n        if (rpIdHash !== myIdHash) {\n            return false;\n        }\n        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);\n    }\n    async createRevocationCertificate() {\n        // TODO use an external id\n        return null;\n    }\n}\nexports.default = Fido2Manager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst Fido2Manager_1 = __importDefault(require(\"./Fido2Manager\"));\nconst buffer_1 = require(\"buffer/\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst lookup = {\n    usb: 1,\n    nfc: 2,\n    ble: 4,\n    internal: 8,\n    hybrid: 16,\n    \"smart-card\": 32,\n};\nconst getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);\nconst fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);\nconst getAuthTypeFromCkey = (ckey) => {\n    const decoded = cbor_1.default.decode(ckey, { extendedResults: true });\n    const type = decoded.value.get(1);\n    if (type === 1) {\n        return \"Ed25519VerificationKey2020\";\n    }\n    else if (type === 2) {\n        return \"P256VerificationKey2020\";\n    }\n    else\n        return \"Unknown\";\n};\nconst getSignerFromCkey = (ckey) => {\n    const k = cbor_1.default.decode(ckey, { extendedResults: true }).value;\n    //console.log(\"getSignerFromCkey\", k);\n    let publicKey = buffer_1.Buffer.from([]);\n    if (k.get(3) == -7)\n        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), k.get(-2), k.get(-3)]);\n    else if (k.get(3) == -8)\n        publicKey = k.get(-2);\n    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)\n        publicKey = k.get(-101);\n    return { publicKey };\n};\nclass Fido2PRFManager extends Fido2Manager_1.default {\n    constructor() {\n        super();\n        this.prfsalt = buffer_1.Buffer.from(\"VaultysID salt\");\n    }\n    static async createFromAttestation(attestation) {\n        const f2m = new Fido2PRFManager();\n        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);\n        //console.log(attestation, f2m.ckey);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.fid = buffer_1.Buffer.from(attestation.id, \"base64\");\n        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports\n        const response = attestation.response;\n        const transports = response.getTransports ? response.getTransports() : [\"usb\"];\n        f2m._transports = fromTransports(transports);\n        // signing\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        await f2m.getCypher();\n        delete f2m.cypher.secretKey;\n        return f2m;\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            f: this.fid,\n            t: this._transports,\n            c: this.ckey,\n            e: this.cypher.publicKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const f2m = new Fido2PRFManager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"private\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m._transports = data.t ? data.t : 15;\n        f2m.ckey = data.c;\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.signer = getSignerFromCkey(data.c);\n        f2m.cypher = { publicKey: data.e };\n        return f2m;\n    }\n    cleanSecureData() {\n        if (this.cypher?.secretKey) {\n            (0, crypto_1.secureErase)(this.cypher.secretKey);\n            delete this.cypher.secretKey;\n        }\n    }\n    async getCypher() {\n        if (!this.cypher?.secretKey) {\n            const publicKey = {\n                challenge: buffer_1.Buffer.from([]),\n                userVerification: \"preferred\",\n                allowCredentials: [\n                    {\n                        type: \"public-key\",\n                        id: this.fid,\n                        transports: getTransports(this._transports),\n                    },\n                ],\n                extensions: {\n                    prf: {\n                        eval: {\n                            // Input the contextual information\n                            first: this.prfsalt,\n                            // There is a \"second\" optional field too\n                            // Though it is intended for key rotation.\n                        },\n                    },\n                },\n            };\n            const result = await this.webAuthn.get(publicKey);\n            const { prf } = result.getClientExtensionResults();\n            const first = prf?.results?.first;\n            if (!first)\n                throw new Error(\"PRF failed\");\n            const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(first));\n            this.cypher = {\n                publicKey: buffer_1.Buffer.from(cypher.publicKey),\n                secretKey: buffer_1.Buffer.from(cypher.secretKey),\n            };\n        }\n        return super.getCypher();\n    }\n    async createRevocationCertificate() {\n        // impossible\n        return null;\n    }\n}\nexports.default = Fido2PRFManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst squareSize = 10;\nconst boardTopx = 0;\nconst boardTopy = 0;\nconst createFrom256 = (hex) => hex.match(/.{1,4}/g)?.map((line) => parseInt(line, 16).toString(2).padStart(16, \"0\")) || [];\nconst createFromFingerprint = (fp) => createFrom256((0, crypto_1.hash)(\"sha256\", (0, crypto_1.fromHex)(fp.replaceAll(\" \", \"\"))).toString(\"hex\"));\nconst nextstep = (bin, memo) => {\n    const output = [];\n    for (let i = 0; i < 16; i++) {\n        let line = \"\";\n        for (let j = 0; j < 16; j++) {\n            let count = 0;\n            for (let k = i - 1; k < i + 2; k++) {\n                for (let l = j - 1; l < j + 2; l++) {\n                    if (k > -1 && k < 16 && l > -1 && l < 16) {\n                        if ((k != i || l != j) && bin[k][l] == \"1\")\n                            count++;\n                    }\n                }\n            }\n            let live = false;\n            if (count == 3)\n                live = true;\n            else if (count == 2 && bin[i][j] == \"1\")\n                live = true;\n            line += live ? \"1\" : \"O\";\n            if (memo && live) {\n                memo[i][j]++;\n            }\n        }\n        output.push(line);\n    }\n    return output;\n};\nconst run = (hex, max) => {\n    const result = createFrom256(hex)?.map((line) => line.split(\"\").map((c) => parseInt(c)));\n    let step = createFrom256(hex);\n    for (let a = 0; a < max; a++) {\n        step = nextstep(step, result);\n    }\n    return result;\n};\nconst renderStep = (context, step) => {\n    for (let i = 0; i < 16; i++) {\n        for (let j = 0; j < 16; j++) {\n            context.fillStyle = step[i][j] == 1 ? \"black\" : \"white\";\n            let xOffset = boardTopx + j * squareSize;\n            let yOffset = boardTopy + i * squareSize;\n            context.fillRect(xOffset, yOffset, squareSize, squareSize);\n            context.fillRect(150 - xOffset, yOffset, squareSize, squareSize);\n            context.fillRect(xOffset, 150 - yOffset, squareSize, squareSize);\n            context.fillRect(150 - xOffset, 150 - yOffset, squareSize, squareSize);\n        }\n    }\n};\nconst heatMapColorforValue = (value, offset = 1) => {\n    var h = (1.0 - value) * 240 + offset;\n    //return `rgba(0,0,0,${value})`\n    return \"hsl(\" + h + \", 100%, 50%)\";\n};\nconst renderMemo = (data, mapcolors = 2, context) => {\n    let min = 1000;\n    let max = 0;\n    const memo = JSON.parse(JSON.stringify(data));\n    for (let i = 0; i < 8; i++) {\n        for (let j = 0; j < 8; j++) {\n            memo[i][j] =\n                memo[15 - i][j] =\n                    memo[i][15 - j] =\n                        memo[15 - i][15 - j] =\n                            memo[i][j] + memo[15 - i][j] + memo[i][15 - j] + memo[15 - i][15 - j];\n            const val = memo[i][j];\n            if (val < min)\n                min = val;\n            if (val > max)\n                max = val;\n        }\n    }\n    for (let i = 0; i < 16; i++) {\n        for (let j = 0; j < 16; j++) {\n            context.fillStyle = heatMapColorforValue(Math.floor(((memo[i][j] - min) * mapcolors) / max) / mapcolors, max * max);\n            let xOffset = boardTopx + j * squareSize;\n            let yOffset = boardTopy + i * squareSize;\n            context.fillRect(xOffset, yOffset, squareSize, squareSize);\n        }\n    }\n};\nexports.default = {\n    renderFingerprint: (fp, canvas, steps = 32) => {\n        let step = createFromFingerprint(fp.replaceAll(\" \", \"\"));\n        let memo = step?.map((line) => line.split(\"\").map((c) => parseInt(c)));\n        const context = canvas.getContext(\"2d\");\n        if (!context || !memo)\n            return;\n        for (let t = 0; t < steps; t++) {\n            step = nextstep(step, memo);\n        }\n        renderMemo(memo, 3, context);\n        return canvas;\n    },\n    animateFingerprint: async (fp, canvas, steps = 32, speed = 500) => {\n        let step = createFromFingerprint(fp.replaceAll(\" \", \"\"));\n        let memo = step?.map((line) => line.split(\"\").map((c) => parseInt(c)));\n        const context = canvas.getContext(\"2d\");\n        if (!context || !memo)\n            return;\n        for (let t = 0; t < steps; t++) {\n            step = nextstep(step, memo);\n            renderMemo(memo, 3, context);\n            await new Promise((resolve) => setTimeout(resolve, speed));\n        }\n        renderMemo(memo, 3, context);\n        return canvas;\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Challenger_1 = __importDefault(require(\"./Challenger\"));\nconst Fido2Manager_1 = __importDefault(require(\"./Fido2Manager\"));\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst MemoryChannel_1 = require(\"./MemoryChannel\");\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst VaultysId_1 = __importDefault(require(\"./VaultysId\"));\nconst crypto_1 = require(\"./crypto\");\nconst Fido2PRFManager_1 = __importDefault(require(\"./Fido2PRFManager\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst buffer_1 = require(\"buffer/\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst PQManager_1 = __importDefault(require(\"./PQManager\"));\n// \"vaultys/encryption/\" + version = 0x01\nconst ENCRYPTION_HEADER = buffer_1.Buffer.from(\"7661756c7479732f656e6372797074696f6e2f01\", \"hex\");\nconst PRF_NONCE_LENGTH = 32;\nconst getSignatureType = (challenge) => {\n    if (challenge.startsWith(\"vaultys://connect?\")) {\n        return \"LOGIN\";\n    }\n    else if (challenge.startsWith(\"vaultys://signfile?\")) {\n        return \"DOCUMENT\";\n    }\n    else {\n        return \"UNKNOWN\";\n    }\n};\nconst instanciateContact = (c) => {\n    let vaultysId;\n    if (c.type === 3) {\n        vaultysId = new VaultysId_1.default(Fido2Manager_1.default.instantiate(c.keyManager), c.certificate, c.type);\n    }\n    else if (c.type === 4) {\n        vaultysId = new VaultysId_1.default(Fido2PRFManager_1.default.instantiate(c.keyManager), c.certificate, c.type);\n    }\n    else {\n        if (c.keyManager.signer.publicKey.length === 1952) {\n            vaultysId = new VaultysId_1.default(PQManager_1.default.instantiate(c.keyManager), c.certificate, c.type);\n        }\n        else {\n            vaultysId = new VaultysId_1.default(KeyManager_1.default.instantiate(c.keyManager), c.certificate, c.type);\n        }\n    }\n    return vaultysId;\n};\nconst instanciateApp = (a) => {\n    return VaultysId_1.default.fromId(buffer_1.Buffer.from(a.serverId, \"base64\"), a.certificate);\n};\nclass IdManager {\n    constructor(vaultysId, store) {\n        this.protocol_version = 0;\n        // alias since this is symetric key encryption\n        this.acceptEncryptFile = this.acceptDecryptFile;\n        this.vaultysId = vaultysId;\n        this.store = store;\n        if (!this.store.get(\"metadata\")) {\n            this.store.set(\"metadata\", {});\n        }\n        if (this.vaultysId.keyManager.entropy)\n            this.store.set(\"entropy\", this.vaultysId.keyManager.entropy);\n        else\n            this.store.set(\"secret\", this.vaultysId.getSecret());\n        this.store.save();\n    }\n    setProtocolVersion(version) {\n        this.protocol_version = version;\n    }\n    static async fromStore(store) {\n        const entropy = store.get(\"entropy\");\n        const secret = store.get(\"secret\");\n        if (secret) {\n            if (entropy) {\n                const secretBuffer = buffer_1.Buffer.from(secret, \"base64\");\n                const type = secretBuffer[0];\n                const vaultysId = await VaultysId_1.default.fromEntropy(entropy, type);\n                return new IdManager(vaultysId, store);\n            }\n            else {\n                const vaultysId = VaultysId_1.default.fromSecret(secret);\n                return new IdManager(vaultysId, store);\n            }\n        }\n        else if (entropy) {\n            const vaultysId = await VaultysId_1.default.machineFromEntropy(entropy);\n            return new IdManager(vaultysId, store);\n        }\n        else {\n            const vaultysId = await VaultysId_1.default.generateMachine();\n            return new IdManager(vaultysId, store);\n        }\n    }\n    merge(otherStore, master = true) {\n        // TODO: check if same profile ?\n        // TODO: revamp contact metadata and sync\n        const master_store = master ? otherStore : this.store;\n        const slave_store = master ? this.store : otherStore;\n        this.store.set(\"metadata\", { ...slave_store.get(\"metadata\"), ...master_store.get(\"metadata\") });\n        [\"signatures\", \"wot\"].forEach((table) => {\n            const other = otherStore.substore(table);\n            const me = this.store.substore(table);\n            other.list().forEach((k) => {\n                if (!me.get(k)) {\n                    me.set(k, other.get(k));\n                }\n            });\n        });\n        const other = otherStore.substore(\"contacts\");\n        const me = this.store.substore(\"contacts\");\n        const m = master ? other : me;\n        const s = master ? me : other;\n        other.list().forEach((did) => {\n            if (!me.get(did)) {\n                me.set(did, other.get(did));\n            }\n            else {\n                const contact = me.get(did);\n                contact.metadata = { ...s.get(did).metadata, ...m.get(did).metadata };\n                me.set(did, contact);\n            }\n        });\n        this.store.save();\n    }\n    isHardware() {\n        return this.vaultysId.isHardware();\n    }\n    async signIn() {\n        if (!this.vaultysId.isHardware())\n            return true;\n        await window.CredentialUserInteractionRequest();\n        const challenge = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);\n        const keyManager = this.vaultysId.keyManager;\n        const creds = (await navigator.credentials.get({\n            publicKey: {\n                challenge,\n                allowCredentials: [\n                    {\n                        type: \"public-key\",\n                        id: keyManager.fid,\n                        transports: keyManager.transports,\n                    },\n                ],\n                userVerification: \"discouraged\",\n            },\n        }));\n        if (creds == null)\n            return false;\n        const response = creds.response;\n        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);\n        if (challenge.toString(\"base64\") !== extractedChallenge) {\n            return false;\n        }\n        return keyManager.verifyCredentials(creds);\n    }\n    get contacts() {\n        const s = this.store.substore(\"contacts\");\n        return s\n            .list()\n            .map((did) => s.get(did))\n            .map(instanciateContact)\n            .map((contact) => contact.toVersion(this.vaultysId.version));\n    }\n    get apps() {\n        const s = this.store.substore(\"registrations\");\n        return s\n            .list()\n            .map((did) => s.get(did))\n            .map(instanciateApp)\n            .map((app) => app.toVersion(this.vaultysId.version));\n    }\n    getContact(did) {\n        const c = this.store.substore(\"contacts\").get(did);\n        if (!c)\n            return null;\n        return instanciateContact(c).toVersion(this.vaultysId.version);\n    }\n    getApp(did) {\n        const app = this.store.substore(\"registrations\").get(did);\n        if (!app)\n            return null;\n        return instanciateApp(app).toVersion(this.vaultysId.version);\n    }\n    setContactMetadata(did, name, value) {\n        const c = this.store.substore(\"contacts\").get(did);\n        if (c) {\n            if (!c.metadata) {\n                c.metadata = {};\n            }\n            c.metadata[name] = value;\n        }\n    }\n    getContactMetadata(did, name) {\n        const c = this.store.substore(\"contacts\").get(did);\n        if (c && c.metadata) {\n            return c.metadata[name];\n        }\n        return null;\n    }\n    getContactMetadatas(did) {\n        const c = this.store.substore(\"contacts\").get(did);\n        if (c && c.metadata) {\n            return c.metadata;\n        }\n        return null;\n    }\n    async verifyRelationshipCertificate(did) {\n        const c = this.store.substore(\"contacts\").get(did) || this.store.substore(\"registrations\").get(did);\n        return Challenger_1.default.verifyCertificate(c.certificate);\n    }\n    set name(n) {\n        this.store.get(\"metadata\").name = n;\n    }\n    get name() {\n        return this.store.get(\"metadata\").name;\n    }\n    get displayName() {\n        const metadata = this.store.get(\"metadata\");\n        const result = metadata.firstname ? metadata.firstname + \" \" + (metadata.name ?? \"\") : metadata.name;\n        return result?.length > 0 ? result : \"Anonymous \" + this.vaultysId.fingerprint?.slice(-4);\n    }\n    set phone(n) {\n        this.store.get(\"metadata\").phone = n;\n    }\n    get phone() {\n        return this.store.get(\"metadata\").phone;\n    }\n    set email(n) {\n        this.store.get(\"metadata\").email = n;\n    }\n    get email() {\n        return this.store.get(\"metadata\").email;\n    }\n    // set avatar(n) {\n    //   this.store.get(\"metadata\").avatar = {\n    //     data: Buffer.from(n.data).toString(\"base64\"),\n    //     type: n.type,\n    //   };\n    // }\n    // get avatar() {\n    //   const temp = this.store.get(\"metadata\").avatar;\n    //   if (!temp) return null;\n    //   return {\n    //     data: Buffer.from(temp.data, \"base64\"),\n    //     type: temp.type,\n    //   };\n    // }\n    async signChallenge(challenge) {\n        const signature = await this.vaultysId.signChallenge(challenge);\n        this.store.substore(\"signatures\").set(\"\" + Date.now(), {\n            signature,\n            challenge,\n        });\n        this.store.save();\n        return signature;\n    }\n    async signFile(file) {\n        const h = (0, crypto_1.hash)(\"sha256\", file.arrayBuffer).toString(\"hex\");\n        const challenge = buffer_1.Buffer.from(`vaultys://signfile?hash=${h}&timestamp=${Date.now()}`, \"utf-8\");\n        const payload = {\n            challenge,\n            signature: await this.vaultysId.signChallenge(challenge),\n        };\n        this.store.substore(\"signatures\").set(Date.now() + \"\", payload);\n        this.store.save();\n        return payload;\n    }\n    verifyFile(file, fileSignature, contactId, userVerifiation = true) {\n        const data = fileSignature.challenge.toString(\"utf8\");\n        if (!data.startsWith(\"vaultys://signfile?\")) {\n            return false;\n        }\n        const h = (0, crypto_1.hash)(\"sha256\", file.arrayBuffer).toString(\"hex\");\n        const url = new URL(data);\n        const fileHash = url.searchParams.get(\"hash\");\n        if (h !== fileHash) {\n            return false;\n        }\n        if (url.search.match(/[a-z\\d]+=[a-z\\d]+/gi)?.length === 2 && url.searchParams.get(\"timestamp\")) {\n            return contactId.verifyChallenge(fileSignature.challenge, fileSignature.signature, userVerifiation);\n        }\n        return false;\n    }\n    async decryptFile(toDecrypt, channel) {\n        // Extract nonce and ciphertext from arrayBuffer\n        const data = new Uint8Array(toDecrypt.arrayBuffer);\n        const header = data.slice(0, ENCRYPTION_HEADER.length);\n        if (buffer_1.Buffer.from(header).toString(\"hex\") !== ENCRYPTION_HEADER.toString(\"hex\")) {\n            throw new Error(\"Invalid header for encrypted file\");\n        }\n        const prfNonceBytes = data.slice(ENCRYPTION_HEADER.length, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);\n        const nonceBytes = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);\n        const ciphertext = data.slice(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + tweetnacl_1.default.secretbox.nonceLength);\n        const prf = channel ? await this.requestPRF(channel, \"encryption/\" + buffer_1.Buffer.from(prfNonceBytes).toString(\"hex\") + \"/encryption\") : await this.vaultysId.hmac(\"prf|encryption/\" + buffer_1.Buffer.from(prfNonceBytes).toString(\"hex\") + \"/encryption|prf\");\n        if (prf?.length !== PRF_NONCE_LENGTH) {\n            throw new Error(\"Invalid PRF generated\");\n        }\n        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)\n        const secretKey = (0, crypto_1.hash)(\"sha256\", prf);\n        (0, crypto_1.secureErase)(prf);\n        // Decrypt using nacl.secretbox.open\n        const decrypted = tweetnacl_1.default.secretbox.open(ciphertext, nonceBytes, secretKey);\n        (0, crypto_1.secureErase)(secretKey);\n        if (!decrypted) {\n            throw new Error(\"Decryption failed\");\n        }\n        return {\n            name: toDecrypt.name,\n            type: toDecrypt.type,\n            arrayBuffer: buffer_1.Buffer.from(decrypted),\n        };\n    }\n    async encryptFile(toEncrypt, channel) {\n        // Generate a secure random nonce for both the PRF and the secretbox\n        const prfNonceBytes = (0, crypto_1.randomBytes)(PRF_NONCE_LENGTH);\n        const prf = channel ? await this.requestPRF(channel, \"encryption/\" + buffer_1.Buffer.from(prfNonceBytes).toString(\"hex\") + \"/encryption\") : await this.vaultysId.hmac(\"prf|encryption/\" + prfNonceBytes.toString(\"hex\") + \"/encryption|prf\");\n        if (prf?.length !== PRF_NONCE_LENGTH) {\n            return null;\n        }\n        // Use sha256 hash of the PRF as the secretbox key (must be 32 bytes)\n        const secretKey = (0, crypto_1.hash)(\"sha256\", prf);\n        (0, crypto_1.secureErase)(prf);\n        // Generate a random nonce for secretbox encryption\n        const nonceBytes = tweetnacl_1.default.randomBytes(tweetnacl_1.default.secretbox.nonceLength);\n        // Encrypt using nacl.secretbox\n        const ciphertext = tweetnacl_1.default.secretbox(new Uint8Array(toEncrypt.arrayBuffer), nonceBytes, secretKey);\n        (0, crypto_1.secureErase)(secretKey);\n        // Combine encryption nonce and ciphertext into a single buffer\n        const result = new Uint8Array(ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length + ciphertext.length);\n        result.set(ENCRYPTION_HEADER);\n        result.set(prfNonceBytes, ENCRYPTION_HEADER.length);\n        result.set(nonceBytes, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH);\n        result.set(ciphertext, ENCRYPTION_HEADER.length + PRF_NONCE_LENGTH + nonceBytes.length);\n        return {\n            name: toEncrypt.name,\n            type: toEncrypt.type,\n            arrayBuffer: buffer_1.Buffer.from(result), // Buffer contains secretbox nonce + ciphertext\n        };\n    }\n    getSignatures() {\n        const store = this.store.substore(\"signatures\");\n        return store\n            .list()\n            .sort()\n            .map((date) => {\n            const payload = store.get(date);\n            const challenge = buffer_1.Buffer.from(payload.challenge).toString(\"utf-8\");\n            return {\n                date,\n                payload,\n                challenge,\n                type: getSignatureType(challenge),\n            };\n        });\n    }\n    migrate(version) {\n        this.vaultysId.toVersion(version);\n        const s = this.store.substore(\"contacts\");\n        for (const did of s.list()) {\n            const data = s.get(did);\n            const contact = instanciateContact(data);\n            const newContact = contact.toVersion(version);\n            if (newContact.did !== did) {\n                s.set(newContact.did, { ...contact, ...newContact, metadata: data.metadata, oldDid: did });\n                s.delete(did);\n                //console.log(did, \"->\", newContact.did);\n            }\n        }\n        const apps = this.store.substore(\"registrations\");\n        for (const did of apps.list()) {\n            const data = apps.get(did);\n            const site = instanciateApp(data);\n            if (site) {\n                const newSite = site.toVersion(version);\n                if (newSite.did !== did) {\n                    const name = data.site === did ? newSite.did : data.site;\n                    apps.set(newSite.did, { site: name, oldDid: did, serverId: newSite.id.toString(\"base64\"), certificate: data.certificate, timestamp: data.timestamp });\n                    apps.delete(did);\n                    // console.log(did, \"->\", newSite.did);\n                }\n            }\n        }\n        this.store.save();\n    }\n    async verifyChallenge(challenge, signature) {\n        return this.vaultysId.verifyChallenge(challenge, signature, true);\n    }\n    async upload(channel, stream) {\n        const challenger = await this.startSRP(channel, \"p2p\", \"transfer\");\n        if (challenger.isComplete()) {\n            const { upload } = (0, MemoryChannel_1.StreamChannel)(channel);\n            await upload(stream);\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async download(channel, stream) {\n        const challenger = await this.acceptSRP(channel, \"p2p\", \"transfer\");\n        if (challenger.isComplete()) {\n            const { download } = (0, MemoryChannel_1.StreamChannel)(channel);\n            await download(stream);\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async requestDecrypt(channel, toDecrypt) {\n        const challenger = await this.acceptSRP(channel, \"p2p\", \"decrypt\");\n        if (challenger.isComplete()) {\n            channel.send(toDecrypt);\n            const new_encrypted = await channel.receive();\n            const decrypted = await this.vaultysId.dhiesDecrypt(new_encrypted, challenger.getContactId().id);\n            return decrypted;\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async acceptDecrypt(channel, accept) {\n        const challenger = await this.startSRP(channel, \"p2p\", \"decrypt\", {}, accept);\n        if (challenger.isComplete()) {\n            const toDecrypt = await channel.receive();\n            const decrypted = await this.vaultysId.decrypt(toDecrypt.toString(\"utf-8\"));\n            if (decrypted) {\n                const encrypted = await this.vaultysId.dhiesEncrypt(decrypted, challenger.getContactId().id);\n                channel.send(encrypted ?? buffer_1.Buffer.from([0]));\n            }\n            else\n                channel.send(buffer_1.Buffer.from([0]));\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async requestDecryptFile(channel, toDecrypt) {\n        return this.decryptFile(toDecrypt, channel);\n    }\n    async requestEncryptFile(channel, toEncrypt) {\n        return this.encryptFile(toEncrypt, channel);\n    }\n    async acceptDecryptFile(channel, accept) {\n        let result_contact = null;\n        await this.acceptPRF(channel, (contact, appid) => {\n            if (appid.length > 63 && appid.startsWith(\"encryption/\") && appid.endsWith(\"/encryption\")) {\n                result_contact = contact;\n                //TODO: maybe by default should be in web of trust?\n                return accept?.(contact) || Promise.resolve(true);\n            }\n            else\n                return Promise.resolve(false);\n        });\n        return result_contact;\n    }\n    async requestSignFile(channel, file) {\n        const challenger = await this.acceptSRP(channel, \"p2p\", \"signfile\");\n        if (challenger.isComplete()) {\n            channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(file)));\n            const result = await channel.receive();\n            const fileSignature = (0, msgpack_1.decode)(result);\n            if (this.verifyFile(file, fileSignature, challenger.getContactId().toVersion(1))) {\n                return fileSignature;\n            }\n            else\n                return undefined;\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async acceptSignFile(channel, accept) {\n        const challenger = await this.startSRP(channel, \"p2p\", \"signfile\");\n        if (challenger.isComplete()) {\n            const result = await channel.receive();\n            const file = (0, msgpack_1.decode)(result);\n            if (!accept || (await accept(challenger.getContactId(), file))) {\n                const result = await this.signFile(file);\n                channel.send(buffer_1.Buffer.from((0, msgpack_1.encode)(result)));\n            }\n            else\n                channel.send(buffer_1.Buffer.from([0]));\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async requestPRF(channel, appid) {\n        if (appid.length < 3) {\n            throw new Error(\"appid is too short, less than 3 characters\");\n        }\n        if (appid.split(\"|\").length > 1) {\n            throw new Error(\"appid contains illegal character |\");\n        }\n        const challenger = await this.acceptSRP(channel, \"p2p\", \"prf\");\n        if (challenger.isComplete()) {\n            channel.send(buffer_1.Buffer.from(appid, \"utf-8\"));\n            const prf = await channel.receive();\n            return buffer_1.Buffer.from(prf);\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    async acceptPRF(channel, accept) {\n        const challenger = await this.startSRP(channel, \"p2p\", \"prf\");\n        if (challenger.isComplete()) {\n            const result = await channel.receive();\n            const appid = result.toString(\"utf-8\");\n            if (appid.length < 3 || appid.split(\"|\").length > 1) {\n                // error if appid is too short or contains illegal character\n                channel.send(buffer_1.Buffer.from([0]));\n            }\n            else if (!accept || (await accept(challenger.getContactId(), appid))) {\n                const hmac = (await this.vaultysId.hmac(\"prf|\" + appid + \"|prf\")) ?? buffer_1.Buffer.from([0]);\n                channel.send(hmac);\n                (0, crypto_1.secureErase)(hmac);\n            }\n            else\n                channel.send(buffer_1.Buffer.from([0]));\n        }\n        else\n            channel.send(buffer_1.Buffer.from([0]));\n    }\n    /***************************/\n    /*   SIGNING PARTY HERE!   */\n    /***************************/\n    listCertificates() {\n        const wot = this.store.substore(\"wot\");\n        return wot.list().map((timestamp) => {\n            const c = wot.get(timestamp);\n            if (c.timestamp) {\n                return c;\n            }\n            else {\n                const result = {\n                    ...Challenger_1.default.deserializeCertificate(wot.get(timestamp)),\n                    raw: c,\n                };\n                wot.set(timestamp, result);\n                return result;\n            }\n        });\n    }\n    async startSRP(channel, protocol, service, metadata = {}, accept) {\n        const challenger = new Challenger_1.default(this.vaultysId);\n        challenger.createChallenge(protocol, service, this.protocol_version, metadata);\n        //console.log(challenger);\n        const cert = challenger.getCertificate();\n        if (!cert) {\n            channel.close();\n            channel.send(buffer_1.Buffer.from([0]));\n            throw new Error(\"Error processing challenge\");\n        }\n        channel.send(cert);\n        try {\n            const message = await channel.receive();\n            // console.log(\"startSRP\", message)\n            const contact = Challenger_1.default.deserializeCertificate(message).pk2;\n            if (!contact) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"Contact pk2 is not sent\");\n            }\n            if (accept && !(await accept(VaultysId_1.default.fromId(contact)))) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"Contact refused\");\n            }\n            await challenger.update(message);\n        }\n        catch (error) {\n            channel.send(buffer_1.Buffer.from([0]));\n            throw new Error(error);\n        }\n        if (challenger.isComplete()) {\n            const certificate = challenger.getCertificate();\n            if (!certificate) {\n                channel.close();\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"Error processing challenge\");\n            }\n            // there is a caveat here, we are not sure that the last bit of information has been received\n            channel.send(certificate);\n            this.store.substore(\"wot\").set(Date.now() + \"\", certificate);\n            // TODO create/update merkle tree + sign it\n            return challenger;\n        }\n        else {\n            channel.send(buffer_1.Buffer.from([0]));\n            throw new Error(\"Can't add a new contact if the protocol is not complete\");\n        }\n    }\n    async acceptSRP(channel, protocol, service, metadata = {}, accept) {\n        const challenger = new Challenger_1.default(this.vaultysId);\n        try {\n            const message = await channel.receive();\n            const chal = Challenger_1.default.deserializeCertificate(message);\n            if (!chal.pk1) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"Contact pk1 is not sent\");\n            }\n            if (chal.protocol !== protocol) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"protocol is not the one expected: \" + chal.protocol + \" !=\" + protocol);\n            }\n            if (chal.service !== service) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"service is not the one expected: \" + chal.service + \" !=\" + service);\n            }\n            if (accept && !(await accept(VaultysId_1.default.fromId(chal.pk1)))) {\n                channel.send(buffer_1.Buffer.from([0]));\n                throw new Error(\"Contact refused\");\n            }\n            await challenger.update(message, metadata);\n        }\n        catch (error) {\n            channel.send(buffer_1.Buffer.from([0]));\n            throw new Error(error);\n        }\n        const cert = challenger.getCertificate();\n        if (!cert) {\n            channel.send(buffer_1.Buffer.from([0]));\n            await channel.close();\n            throw new Error(\"Error processing challenge\");\n        }\n        // console.log(\"acceptSRP sending 1\")\n        channel.send(cert);\n        // console.log(\"acceptSRP sending 2\")\n        try {\n            const message = await channel.receive();\n            // console.log(\"acceptSRP 2\", message)\n            await challenger.update(message);\n        }\n        catch (error) {\n            await channel.close();\n            //console.log(challenger);\n            throw new Error(error);\n        }\n        if (challenger.isComplete()) {\n            const certificate = challenger.getCertificate();\n            this.store.substore(\"wot\").set(Date.now() + \"\", certificate);\n            // TODO create/update merkle tree + sign it\n            return challenger;\n        }\n        else {\n            await channel.close();\n            throw new Error(\"Can't add a new contact if the protocol is not complete\");\n        }\n    }\n    saveApp(app, name) {\n        app.toVersion(this.vaultysId.version);\n        if (!app.isMachine()) {\n            this.saveContact(app);\n        }\n        else {\n            const appstore = this.store.substore(\"registrations\");\n            if (!appstore.get(app.did)) {\n                appstore.set(app.did, {\n                    site: name ?? app.did,\n                    serverId: app.id.toString(\"base64\"),\n                    certificate: app.certificate,\n                });\n            }\n        }\n    }\n    saveContact(contact) {\n        contact.toVersion(this.vaultysId.version);\n        if (contact.isMachine()) {\n            this.saveApp(contact);\n        }\n        else {\n            const contactstore = this.store.substore(\"contacts\");\n            if (!contactstore.get(contact.did)) {\n                contactstore.set(contact.did, contact);\n                this.store.save();\n            }\n        }\n    }\n    async askContact(channel, metadata = {}, accept) {\n        const challenger = await this.startSRP(channel, \"p2p\", \"auth\", metadata, accept);\n        const contact = challenger.getContactId();\n        this.saveContact(contact);\n        return contact;\n    }\n    async acceptContact(channel, metadata = {}, accept) {\n        const challenger = await this.acceptSRP(channel, \"p2p\", \"auth\", metadata, accept);\n        const contact = challenger.getContactId();\n        this.saveContact(contact);\n        return contact;\n    }\n}\nexports.default = IdManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DHIES = void 0;\nconst saltpack_1 = require(\"@vaultys/saltpack\");\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst ed25519_1 = require(\"@noble/curves/ed25519\");\ned25519_1.ed25519.CURVE = { ...ed25519_1.ed25519.CURVE };\n// @ts-ignore hack to get compatibility with former @stricahq/bip32ed25519 lib\ned25519_1.ed25519.CURVE.adjustScalarBytes = (bytes) => {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 63; // 0b0001_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n};\n////@ts-expect-error fix for wrong way of exporting bip32ed25519\n//const bip32 = bip32fix.default ?? bip32fix;\nconst LEVEL_ROOT = 1;\nconst LEVEL_DERIVED = 2;\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nconst serializeID_v0 = (km) => {\n    const encodeBinary = (data) => {\n        if (data.length <= 65535) {\n            // bin16: binary data whose length is upto (2^16)-1 bytes\n            return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);\n        }\n        else {\n            // bin32: binary data whose length is upto (2^32)-1 bytes\n            return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);\n        }\n    };\n    const version = buffer_1.Buffer.from([0x84, 0xa1, 0x76, 0]);\n    const proof = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x70]), encodeBinary(km.proof)]);\n    const sign = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x78]), encodeBinary(km.signer.publicKey)]);\n    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);\n    return buffer_1.Buffer.concat([version, proof, sign, cypher]);\n};\n/**\n * DHIES (Diffie-Hellman Integrated Encryption Scheme) for KeyManager\n * Provides authenticated encryption using Diffie-Hellman key exchange\n */\nclass DHIES {\n    constructor(keyManager) {\n        this.keyManager = keyManager;\n    }\n    /**\n     * Encrypts a message for a recipient using DHIES\n     *\n     * @param message The plaintext message to encrypt\n     * @param recipientPublicKey The recipient's public key\n     * @returns Encrypted message with ephemeral public key and authentication tag, or null if encryption fails\n     */\n    async encrypt(message, recipientPublicKey) {\n        if (this.keyManager.capability === \"public\") {\n            console.error(\"Cannot encrypt with DHIES using a public KeyManager\");\n            return null;\n        }\n        const cypher = await this.keyManager.getCypher();\n        // Convert message to Buffer if it's a string\n        const messageBuffer = typeof message === \"string\" ? buffer_1.Buffer.from(message, \"utf8\") : message;\n        try {\n            const ephemeralKey = (0, crypto_1.randomBytes)(32); // Generate a random 32-byte key for ephemeral key\n            // Derive shared secret using recipient's public key and sender secret key\n            const dh = await cypher.diffieHellman(recipientPublicKey);\n            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));\n            // Key derivation: derive encryption and MAC keys from shared secret\n            const kdfOutput = this.kdf(sharedSecret, this.keyManager.cypher.publicKey, recipientPublicKey);\n            const encryptionKey = kdfOutput.encryptionKey;\n            const macKey = kdfOutput.macKey;\n            // Encrypt the message using XChaCha20-Poly1305\n            const nonce = (0, crypto_1.randomBytes)(24); // 24 bytes nonce for XChaCha20-Poly1305\n            const ciphertext = buffer_1.Buffer.from(tweetnacl_1.default.secretbox(messageBuffer, nonce, encryptionKey));\n            // Compute MAC (Message Authentication Code)\n            const dataToAuthenticate = buffer_1.Buffer.concat([this.keyManager.cypher.publicKey, nonce, ciphertext]);\n            const mac = this.computeMAC(macKey, dataToAuthenticate);\n            // Construct the final encrypted message: nonce + ephemeralKey + ciphertext + MAC\n            const encryptedMessage = buffer_1.Buffer.concat([nonce, ephemeralKey, ciphertext, mac]);\n            // Securely erase sensitive data\n            (0, crypto_1.secureErase)(sharedSecret);\n            (0, crypto_1.secureErase)(dh);\n            (0, crypto_1.secureErase)(encryptionKey);\n            (0, crypto_1.secureErase)(macKey);\n            return encryptedMessage;\n        }\n        catch (error) {\n            console.error(\"DHIES encryption failed:\", error);\n            return null;\n        }\n    }\n    /**\n     * Decrypts a message encrypted with DHIES\n     *\n     * @param encryptedMessage The complete encrypted message from the encrypt method\n     * @returns Decrypted message as a Buffer, or null if decryption fails\n     */\n    async decrypt(encryptedMessage, senderPublicKey) {\n        if (this.keyManager.capability === \"public\") {\n            console.error(\"Cannot decrypt with DHIES using a public KeyManager\");\n            return null;\n        }\n        try {\n            // Extract components from the encrypted message\n            // Format: nonce (24 bytes) + ephemeralKey (32 bytes) + ciphertext + MAC (32 bytes)\n            const nonce = encryptedMessage.slice(0, 24);\n            const ephemeralKey = encryptedMessage.slice(24, 56);\n            const mac = encryptedMessage.slice(encryptedMessage.length - 32);\n            const ciphertext = encryptedMessage.slice(56, encryptedMessage.length - 32);\n            const cypher = await this.keyManager.getCypher();\n            // Derive shared secret using sender public key and recipient secret key\n            const dh = await cypher.diffieHellman(senderPublicKey);\n            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));\n            // Key derivation: derive encryption and MAC keys\n            const kdfOutput = this.kdf(sharedSecret, senderPublicKey, this.keyManager.cypher.publicKey);\n            const encryptionKey = kdfOutput.encryptionKey;\n            const macKey = kdfOutput.macKey;\n            // Verify MAC\n            const dataToAuthenticate = buffer_1.Buffer.concat([senderPublicKey, nonce, ciphertext]);\n            const computedMac = this.computeMAC(macKey, dataToAuthenticate);\n            if (!this.constantTimeEqual(mac, computedMac)) {\n                //console.log(mac, computedMac);\n                console.error(\"DHIES: MAC verification failed\");\n                return null;\n            }\n            // Decrypt the ciphertext\n            const plaintext = tweetnacl_1.default.secretbox.open(ciphertext, nonce, encryptionKey);\n            if (!plaintext) {\n                console.error(\"DHIES: Decryption failed\");\n                return null;\n            }\n            const result = buffer_1.Buffer.from(plaintext);\n            // Securely erase sensitive data\n            (0, crypto_1.secureErase)(sharedSecret);\n            (0, crypto_1.secureErase)(encryptionKey);\n            (0, crypto_1.secureErase)(macKey);\n            return result;\n        }\n        catch (error) {\n            console.error(\"DHIES decryption failed:\", error);\n            return null;\n        }\n    }\n    /**\n     * Key Derivation Function: Derives encryption and MAC keys from the shared secret\n     */\n    kdf(sharedSecret, ephemeralPublicKey, staticPublicKey) {\n        // Create a context for the KDF to ensure different keys for different uses\n        const context = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"DHIES-KDF\"), ephemeralPublicKey, staticPublicKey]);\n        // Derive encryption key: HKDF-like construction\n        const encryptionKeyMaterial = (0, crypto_1.hash)(\"sha512\", buffer_1.Buffer.concat([\n            sharedSecret,\n            context,\n            buffer_1.Buffer.from([0x01]), // Domain separation byte\n        ]));\n        // Derive MAC key (using a different domain separation byte)\n        const macKeyMaterial = (0, crypto_1.hash)(\"sha512\", buffer_1.Buffer.concat([\n            sharedSecret,\n            context,\n            buffer_1.Buffer.from([0x02]), // Domain separation byte\n        ]));\n        // Use first 32 bytes of each as the actual keys (for NaCl's secretbox)\n        return {\n            encryptionKey: encryptionKeyMaterial.slice(0, 32),\n            macKey: macKeyMaterial.slice(0, 32),\n        };\n    }\n    /**\n     * Computes MAC for authenticated encryption\n     */\n    computeMAC(macKey, data) {\n        return (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([macKey, data]));\n    }\n    /**\n     * Constant-time comparison of two buffers to prevent timing attacks\n     */\n    constantTimeEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        let result = 0;\n        for (let i = 0; i < a.length; i++) {\n            result |= a[i] ^ b[i];\n        }\n        return result === 0;\n    }\n}\nexports.DHIES = DHIES;\nclass KeyManager {\n    constructor() {\n        this.level = 1;\n        this.version = 1;\n        this.capability = \"private\";\n        this.authType = \"Ed25519VerificationKey2020\";\n        this.encType = \"X25519KeyAgreementKey2019\";\n    }\n    static async create_Id25519_fromEntropy(entropy, swapIndex = 0) {\n        const km = new KeyManager();\n        km.entropy = entropy;\n        km.level = LEVEL_ROOT;\n        km.capability = \"private\";\n        const seed = sha512(entropy);\n        // const derivedKey = privateDerivePath(await bip32.Bip32PrivateKey.fromEntropy(seed.slice(0, 32)), `m/1'/0'/${swapIndex}'`);\n        km.proofKey = {\n            publicKey: buffer_1.Buffer.from([]), //deprecated\n        };\n        km.swapIndex = swapIndex;\n        km.proof = (0, crypto_1.hash)(\"sha256\", km.proofKey.publicKey);\n        // const privateKey = privateDerivePath(derivedKey, \"/0'\");\n        km.signer = {\n            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(seed.slice(0, 32))),\n            secretKey: seed.slice(0, 32),\n        };\n        const swapIndexBuffer = buffer_1.Buffer.alloc(8);\n        swapIndexBuffer.writeBigInt64LE(BigInt(swapIndex), 0);\n        const seed2 = sha256(buffer_1.Buffer.concat([seed.slice(32, 64), swapIndexBuffer]));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static generate_Id25519() {\n        return KeyManager.create_Id25519_fromEntropy((0, crypto_1.randomBytes)(32));\n    }\n    get id() {\n        if (this.version == 0)\n            return serializeID_v0(this);\n        else\n            return buffer_1.Buffer.from((0, msgpack_1.encode)({\n                v: this.version,\n                p: this.proof,\n                x: this.signer.publicKey,\n                e: this.cypher.publicKey,\n            }));\n    }\n    async getCypher() {\n        // todo fetch secretKey here\n        const cypher = this.cypher;\n        return {\n            hmac: (message) => (cypher.secretKey ? (0, crypto_1.hmac)(\"sha256\", buffer_1.Buffer.from(cypher.secretKey), \"VaultysID/\" + message + \"/end\") : undefined),\n            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),\n            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),\n            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),\n        };\n    }\n    getSigner() {\n        // todo fetch secretKey here\n        const secretKey = this.signer.secretKey;\n        const sign = (data) => Promise.resolve(buffer_1.Buffer.from(ed25519_1.ed25519.sign(data, secretKey)));\n        //console.log(secretKey.toString(\"hex\"), new bip32.PrivateKey(secretKey).toPublicKey().toBytes().toString(\"hex\"), Buffer.from(ed25519.getPublicKey(secretKey)).toString(\"hex\"));\n        return Promise.resolve({ sign });\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            p: this.proof,\n            x: this.signer.secretKey,\n            e: this.cypher.secretKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const km = new KeyManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"private\";\n        km.proof = data.p;\n        km.signer = {\n            secretKey: data.x.slice(0, 32),\n            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(data.x.slice(0, 32))),\n        };\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static instantiate(obj) {\n        const km = new KeyManager();\n        km.version = obj.version ?? 0;\n        km.level = obj.level;\n        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);\n        km.signer = {\n            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),\n        };\n        km.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return km;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const km = new KeyManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"public\";\n        km.proof = data.p;\n        km.signer = {\n            publicKey: data.x,\n        };\n        km.cypher = {\n            publicKey: data.e,\n        };\n        // console.log(km)\n        return km;\n    }\n    async sign(data) {\n        if (this.capability == \"public\")\n            return null;\n        const signer = await this.getSigner();\n        return signer.sign(data);\n    }\n    verify(data, signature, userVerificationIgnored) {\n        return ed25519_1.ed25519.verify(signature, data, this.signer.publicKey);\n    }\n    // async createRevocationCertificate(newId) {\n    //   if (this.level == LEVEL_ROOT) {\n    //     const seed = sha512(this.entropy);\n    //     let node = derivePath(\n    //       await Bip32PrivateKey.fromEntropy(seed.slice(0, 32)),\n    //       \"m/1'/0'/1'\",\n    //     );\n    //     const proof = hash(\"sha256\", node.toBip32PublicKey().toBytes());\n    //     if (this.proof.toString(\"hex\") == proof.toString(\"hex\")) {\n    //       const revocationCertificate = {\n    //         xpub: node.toBytes(),\n    //         id: this.id,\n    //         newId,\n    //       };\n    //       revocationCertificate.signature = node.toPrivateKey().sign(revocationCertificate);\n    //       return revocationCertificate;\n    //     } else return null;\n    //   } else return null;\n    // }\n    // async createSwapingCertificate() {\n    //   if (this.level === LEVEL_ROOT && this.entropy) {\n    //     const newKey = await KeyManager.create_Id25519_fromEntropy(this.entropy, this.swapIndex + 1);\n    //     const hiscp: HISCP = {\n    //       newId: newKey.id,\n    //       proofKey: this.proofKey.publicKey,\n    //       timestamp: Date.now(),\n    //       signature: Buffer.from([]),\n    //     };\n    //     const timestampBuffer = Buffer.alloc(8);\n    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);\n    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);\n    //     hiscp.signature = new bip32.Bip32PrivateKey(this.proofKey.secretKey!).toPrivateKey().sign(hiscpBuffer);\n    //     return hiscp;\n    //   }\n    //   return null;\n    // }\n    // async verifySwapingCertificate(hiscp: HISCP) {\n    //   const proof = hash(\"sha256\", hiscp.proofKey).toString(\"hex\");\n    //   if (proof === this.proof.toString(\"hex\")) {\n    //     const timestampBuffer = Buffer.alloc(8);\n    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);\n    //     const newKey = KeyManager.fromId(hiscp.newId);\n    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);\n    //     const proofVerifier = bip32.Bip32PublicKey.fromBytes(hiscp.proofKey);\n    //     return proofVerifier.toPublicKey().verify(hiscpBuffer, hiscp.signature);\n    //   } else {\n    //     return false;\n    //   }\n    // }\n    cleanSecureData() {\n        if (this.cypher?.secretKey) {\n            (0, crypto_1.secureErase)(this.cypher.secretKey);\n            delete this.cypher.secretKey;\n        }\n        if (this.signer?.secretKey) {\n            (0, crypto_1.secureErase)(this.signer.secretKey);\n            delete this.signer.secretKey;\n        }\n        if (this.entropy) {\n            (0, crypto_1.secureErase)(this.entropy);\n            delete this.entropy;\n        }\n    }\n    /**\n     * Performs a Diffie-Hellman key exchange with another KeyManager instance\n     * @param otherKeyManager The other party's KeyManager instance\n     * @returns A shared secret that can be used for symmetric encryption\n     */\n    async performDiffieHellman(otherKeyManager) {\n        if (this.capability === \"public\") {\n            console.error(\"Cannot perform DH key exchange with a public key capability\");\n            return null;\n        }\n        const cypher = await this.getCypher();\n        const otherKey = otherKeyManager.cypher.publicKey;\n        // Perform the X25519 scalar multiplication to derive the shared secret\n        const sharedSecret = await cypher.diffieHellman(otherKey);\n        // Hash the shared secret for better security (to derive a symmetric key)\n        const derivedKey = sha256(sharedSecret);\n        // Securely erase the shared secret from memory\n        (0, crypto_1.secureErase)(sharedSecret);\n        return derivedKey;\n    }\n    /**\n     * Static method to perform a Diffie-Hellman key exchange between two KeyManager instances\n     * @param keyManager1 First KeyManager instance\n     * @param keyManager2 Second KeyManager instance\n     * @returns A shared secret that both parties can derive\n     */\n    static async diffieHellman(keyManager1, keyManager2) {\n        return keyManager1.performDiffieHellman(keyManager2);\n    }\n    /**\n     * Encrypt a message using DHIES for a recipient\n     * @param message Message to encrypt\n     * @param recipientId Recipient's KeyManager ID\n     * @returns Encrypted message or null if encryption fails\n     */\n    async dhiesEncrypt(message, recipientId) {\n        const recipientKM = KeyManager.fromId(recipientId);\n        //console.log(recipientKM.cypher.publicKey, this.cypher.publicKey);\n        const dhies = new DHIES(this);\n        return dhies.encrypt(message, recipientKM.cypher.publicKey);\n    }\n    /**\n     * Decrypt a message encrypted with DHIES\n     * @param encryptedMessage Encrypted message from dhiesEncrypt\n     * @returns Decrypted message or null if decryption fails\n     */\n    async dhiesDecrypt(encryptedMessage, senderId) {\n        const senderKM = KeyManager.fromId(senderId);\n        //console.log(senderKM.cypher.publicKey, this.cypher.publicKey);\n        const dhies = new DHIES(this);\n        return dhies.decrypt(encryptedMessage, senderKM.cypher.publicKey);\n    }\n    static async encrypt(plaintext, recipientIds) {\n        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);\n        return await (0, saltpack_1.encryptAndArmor)(plaintext, null, publicKeys);\n    }\n    async signcrypt(plaintext, recipientIds) {\n        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);\n        const cypher = await this.getCypher();\n        return await cypher.signcrypt(plaintext, publicKeys);\n    }\n    async decrypt(encryptedMessage, senderId = null) {\n        const cypher = await this.getCypher();\n        const senderKey = senderId ? KeyManager.fromId(senderId).cypher.publicKey : null;\n        const message = await cypher.decrypt(encryptedMessage, senderKey);\n        return message.toString();\n    }\n    // use better hash to prevent attack\n    getSecretHash(data) {\n        const toHash = buffer_1.Buffer.concat([data, buffer_1.Buffer.from(\"secrethash\"), this.cypher.secretKey]);\n        return (0, crypto_1.hash)(\"sha256\", toHash);\n    }\n}\nexports.default = KeyManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemoryChannel = void 0;\nexports.pipeChannels = pipeChannels;\nexports.unpipeChannels = unpipeChannels;\nexports.StreamChannel = StreamChannel;\nexports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;\nexports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;\nconst cryptoChannel_1 = __importDefault(require(\"./cryptoChannel\"));\nconst stream_1 = require(\"stream\");\nconst buffer_1 = require(\"buffer/\");\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n/**\n * Pipes two channels together, creating a bidirectional flow where\n * messages sent to one channel are automatically forwarded to the other.\n * @param channel1 The first channel to connect\n * @param channel2 The second channel to connect\n * @returns A Promise that resolves when both channels close\n */\nfunction pipeChannels(channel1, channel2) {\n    let running = true;\n    // Start both piping directions\n    const pipe1to2 = async () => {\n        try {\n            await channel1.start();\n            await channel2.start();\n            console.log(\"pipe1to2\");\n            while (running) {\n                try {\n                    const data = await channel1.receive();\n                    console.log(\"pipe1to2\", data);\n                    if (!running || data.length === 0)\n                        break;\n                    channel2.send(data);\n                }\n                catch (error) {\n                    if (running)\n                        console.error(\"Error in pipe1to2:\", error);\n                    break;\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Fatal error in pipe1to2:\", error);\n        }\n    };\n    const pipe2to1 = async () => {\n        try {\n            while (running) {\n                console.log(\"pipe2to1\");\n                try {\n                    const data = await channel2.receive();\n                    console.log(\"pipe2to1\", data);\n                    if (!running || data.length === 0)\n                        break;\n                    channel1.send(data);\n                }\n                catch (error) {\n                    if (running)\n                        console.error(\"Error in pipe2to1:\", error);\n                    break;\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Fatal error in pipe2to1:\", error);\n        }\n    };\n    // Start the pipes\n    pipe1to2();\n    pipe2to1();\n    // Return function to stop piping\n    return async () => {\n        running = false;\n        await Promise.all([channel1.close(), channel2.close()]);\n    };\n}\n/**\n * Utility function that stops an active channel pipe\n * @param channel1 The first channel in the pipe\n * @param channel2 The second channel in the pipe\n */\nasync function unpipeChannels(channel1, channel2) {\n    await Promise.all([channel1.close(), channel2.close()]);\n}\nfunction StreamChannel(channel) {\n    const onData = async (callback) => {\n        let message = await channel.receive();\n        while (message) {\n            callback(message);\n            if (message.toString(\"utf-8\") === \"EOF\") {\n                return;\n            }\n            message = await channel.receive();\n        }\n    };\n    const getWriteStream = () => {\n        const stream = new stream_1.Stream.Writable({\n            write: (chunk, encoding, done) => {\n                channel.send(chunk);\n                done();\n            },\n        });\n        return stream;\n    };\n    const upload = async (stream) => {\n        return new Promise((resolve) => {\n            const writeStream = getWriteStream();\n            stream.pipe(writeStream).once(\"finish\", () => {\n                channel.send(buffer_1.Buffer.from(\"EOF\", \"utf-8\"));\n                writeStream.end();\n                resolve();\n            });\n        });\n    };\n    const uploadData = async (data) => {\n        const stream = stream_1.Readable.from(data);\n        await upload(stream);\n    };\n    const download = async (stream) => {\n        const readStream = getReadStream();\n        const result = new Promise((resolve) => readStream.on(\"end\", () => {\n            resolve();\n        }));\n        readStream.pipe(stream);\n        await result;\n    };\n    const downloadData = async () => {\n        const readStream = getReadStream();\n        const chunks = [];\n        const result = new Promise((resolve) => readStream.on(\"end\", () => {\n            resolve(buffer_1.Buffer.concat(chunks));\n        }));\n        const stream = new stream_1.Stream.Writable({\n            write: (chunk, encoding, done) => {\n                chunks.push(chunk);\n                done();\n            },\n        });\n        readStream.pipe(stream);\n        return result;\n    };\n    const getReadStream = () => {\n        let push;\n        let temp;\n        const stream = new stream_1.Stream.Readable({\n            read() {\n                push = (data) => this.push(data);\n            },\n        });\n        onData((buf) => {\n            if (buf.length === 3 && buf.toString(\"utf-8\") === \"EOF\" && push) {\n                temp && push(temp);\n                push(null);\n                stream.destroy();\n            }\n            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;\n            if (push) {\n                !push(temp) && (push = null);\n                temp = null;\n            }\n        });\n        return stream;\n    };\n    return {\n        getReadStream,\n        getWriteStream,\n        upload,\n        uploadData,\n        download,\n        downloadData,\n    };\n}\nfunction convertWebWritableStreamToNodeWritable(webWritableStream) {\n    const writer = webWritableStream.getWriter();\n    return new stream_1.Writable({\n        async write(chunk, encoding, callback) {\n            try {\n                // Get a writer from the Web WritableStream\n                await writer.write(chunk);\n                writer.releaseLock(); // Release the lock on the writer after writing\n                callback(); // Signal that the chunk has been processed\n            }\n            catch (error) {\n                callback(); // Signal an error if it occurred\n            }\n        },\n        async final(callback) {\n            try {\n                // Close the Web WritableStream\n                const writer = webWritableStream.getWriter();\n                await writer.close();\n                writer.releaseLock(); // Release the lock on the writer after closing\n                callback(); // Signal that the stream is finished\n            }\n            catch (error) {\n                callback(); // Signal an error if it occurred during close\n            }\n        },\n        async destroy(error, callback) {\n            try {\n                // Abort the Web WritableStream in case of an error\n                const writer = webWritableStream.getWriter();\n                await writer.abort(error);\n                writer.releaseLock(); // Release the lock on the writer after aborting\n                callback(error); // Signal that the stream is destroyed\n            }\n            catch (abortError) {\n                callback(null); // Signal an error if it occurred during abort\n            }\n        },\n    });\n}\nfunction convertWebReadableStreamToNodeReadable(webReadableStream) {\n    const reader = webReadableStream.getReader();\n    return new stream_1.Readable({\n        async read() {\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    //console.log(value);\n                    if (done) {\n                        this.push(null); // Signal the end of the stream\n                        break;\n                    }\n                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer\n                }\n            }\n            catch (error) {\n                this.destroy();\n            }\n        },\n    });\n}\nclass MemoryChannel {\n    constructor() {\n        this.messageQueue = [];\n        this.waitingResolvers = [];\n        this.connected = false;\n        this.connectedCallbacks = [];\n        this.closed = false;\n    }\n    setChannel(chan, name) {\n        this.name = name;\n        this.otherend = chan;\n    }\n    static createBidirectionnal() {\n        const input = new MemoryChannel();\n        const output = new MemoryChannel();\n        input.setChannel(output);\n        output.setChannel(input);\n        return input;\n    }\n    onConnected(callback) {\n        if (this.connected) {\n            callback();\n        }\n        else {\n            this.connectedCallbacks.push(callback);\n        }\n    }\n    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {\n        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);\n        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);\n        input.setChannel(output);\n        output.setChannel(input);\n        return input;\n    }\n    getConnectionString() {\n        return \"vaultys://memory\";\n    }\n    fromConnectionString(string) {\n        return string === \"vaultys://memory\" ? new MemoryChannel() : null;\n    }\n    setLogger(logger) {\n        this.logger = logger;\n    }\n    setInjector(injector) {\n        this.injector = injector;\n    }\n    async start() {\n        this.connected = true;\n        this.connectedCallbacks.forEach((callback) => callback());\n        this.connectedCallbacks = []; // Clear callbacks after calling them\n    }\n    async send(data) {\n        if (this.closed) {\n            throw new Error(\"Cannot send on closed channel\");\n        }\n        if (!this.otherend) {\n            throw new Error(\"No other end connected to this channel\");\n        }\n        // Log the data if a logger is set\n        if (this.logger) {\n            this.logger(data);\n        }\n        // Process data through injector if present\n        let processedData = data;\n        if (this.injector) {\n            processedData = await this.injector(data);\n        }\n        // // Signal that this end is connected\n        if (!this.connected) {\n            await this.start();\n        }\n        // Deliver the message to the other end\n        this.otherend.deliverMessage(processedData);\n    }\n    deliverMessage(data) {\n        // If there are waiting receivers, deliver directly to the first one\n        if (this.waitingResolvers.length > 0) {\n            const resolver = this.waitingResolvers.shift();\n            resolver(data);\n        }\n        else {\n            // Otherwise queue the message\n            this.messageQueue.push(data);\n        }\n    }\n    async receive() {\n        if (this.closed) {\n            throw new Error(\"Cannot receive on closed channel\");\n        }\n        //console.log(this);\n        // If there are queued messages, return the first one\n        if (this.messageQueue.length > 0) {\n            return this.messageQueue.shift();\n        }\n        // Otherwise, wait for a message to arrive\n        return new Promise((resolve) => {\n            this.waitingResolvers.push(resolve);\n        });\n    }\n    async close() {\n        this.closed = true;\n        // Clear any waiting receivers with an error\n        while (this.waitingResolvers.length > 0) {\n            const resolver = this.waitingResolvers.shift();\n            // Resolve with empty buffer to indicate channel closed\n            resolver(buffer_1.Buffer.alloc(0));\n        }\n        // Clear the message queue\n        this.messageQueue = [];\n    }\n}\nexports.MemoryChannel = MemoryChannel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst replacer = (key, value) => {\n    //if(key==\"1686045792046\") console.log(value);\n    if (!value)\n        return value;\n    if (key === \"certificate\")\n        return \"__C__\" + buffer_1.Buffer.from(value).toString(\"base64\");\n    if (value.type === \"Buffer\") {\n        return \"_bx_\" + buffer_1.Buffer.from(value.data).toString(\"base64\");\n    }\n    if (value.constructor.name === \"Array\") {\n        return \"_bx_\" + buffer_1.Buffer.from(value).toString(\"base64\");\n    }\n    return value;\n};\nconst reviver = (key, value) => {\n    if (value && key === \"certificate\") {\n        if (typeof value === \"string\" && value.startsWith(\"__C__\")) {\n            return buffer_1.Buffer.from(value.slice(5), \"base64\");\n        }\n        else\n            return buffer_1.Buffer.from(value);\n    }\n    if (typeof value === \"string\" && value.startsWith(\"_bx_\")) {\n        return buffer_1.Buffer.from(value.slice(4), \"base64\");\n    }\n    return value;\n};\nconst serialize = (data) => JSON.stringify(data, replacer);\nexports.serialize = serialize;\nconst deserialize = (string) => JSON.parse(string, reviver);\nexports.deserialize = deserialize;\nconst MemoryStorage = (save) => {\n    let data = {};\n    if (!save)\n        save = () => (0, exports.serialize)(data);\n    return storagify(data, save, () => \"\");\n};\nexports.MemoryStorage = MemoryStorage;\nconst LocalStorage = (key = \"vaultysStorage\") => {\n    let data = {};\n    const _id = Math.random();\n    //console.log(key);\n    if (!localStorage[key])\n        localStorage[key] = \"{}\";\n    else\n        data = (0, exports.deserialize)(localStorage[key]);\n    return storagify(data, () => {\n        //console.log(\"save !!!!!\", key, _id);\n        localStorage.setItem(key, (0, exports.serialize)(data));\n    }, () => localStorage.removeItem(key));\n};\nexports.LocalStorage = LocalStorage;\nconst storagify = (object, save, destroy) => {\n    return {\n        destroy,\n        save,\n        toString: () => (0, exports.serialize)(object),\n        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),\n        _raw: object,\n        set: (key, value) => (object[key] = value),\n        delete: (key) => delete object[key],\n        get: (key) => object[key],\n        list: () => Object.keys(object).filter((k) => !k.startsWith(\"!\")),\n        listSubstores: () => Object.keys(object)\n            .filter((k) => k.startsWith(\"!\"))\n            .map((k) => k.slice(1)),\n        deleteSubstore: (key) => delete object[\"!\" + key],\n        renameSubstore: (oldname, newname) => {\n            if (oldname === newname || !!object[\"!\" + newname])\n                return;\n            object[\"!\" + newname] = object[\"!\" + oldname];\n            delete object[\"!\" + oldname];\n        },\n        substore: (key) => {\n            if (!object[\"!\" + key])\n                object[\"!\" + key] = {};\n            return storagify(object[\"!\" + key], save, destroy);\n        },\n    };\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst LEVEL_ROOT = 1;\nconst LEVEL_DERIVED = 2;\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nclass PQManager extends KeyManager_1.default {\n    constructor() {\n        super();\n        this.authType = \"DilithiumVerificationKey2025\";\n    }\n    static async create_PQ_fromEntropy(entropy, swapIndex = 0) {\n        const km = new PQManager();\n        km.entropy = entropy;\n        km.level = LEVEL_ROOT;\n        km.capability = \"private\";\n        km.seed = sha512(entropy);\n        km.swapIndex = swapIndex;\n        km.proof = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from([]));\n        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));\n        const seed2 = sha256(km.seed.slice(32, 64));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static generate_PQ() {\n        return PQManager.create_PQ_fromEntropy((0, crypto_1.randomBytes)(32));\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            p: this.proof,\n            s: this.seed,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const km = new PQManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"private\";\n        km.proof = data.p;\n        km.seed = buffer_1.Buffer.from(data.s);\n        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));\n        const seed2 = sha256(km.seed.slice(32, 64));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static instantiate(obj) {\n        const km = new PQManager();\n        km.version = obj.version ?? 0;\n        km.level = obj.level;\n        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);\n        km.signer = {\n            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),\n        };\n        km.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return km;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const km = new PQManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"public\";\n        km.proof = data.p;\n        km.signer = {\n            publicKey: data.x,\n        };\n        km.cypher = {\n            publicKey: data.e,\n        };\n        // console.log(km)\n        return km;\n    }\n    async sign(data) {\n        if (this.capability == \"public\")\n            return null;\n        return (0, pqCrypto_1.signDilithium)(data, this.signer.secretKey);\n    }\n    verify(data, signature, userVerificationIgnored) {\n        return (0, pqCrypto_1.verifyDilithium)(data, signature, this.signer.publicKey);\n    }\n}\nexports.default = PQManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst Fido2Manager_1 = __importDefault(require(\"./Fido2Manager\"));\nconst Fido2PRFManager_1 = __importDefault(require(\"./Fido2PRFManager\"));\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst webauthn_1 = require(\"./platform/webauthn\");\nconst buffer_1 = require(\"buffer/\");\nconst PQManager_1 = __importDefault(require(\"./PQManager\"));\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst TYPE_MACHINE = 0;\nconst TYPE_PERSON = 1;\nconst TYPE_ORGANIZATION = 2;\nconst TYPE_FIDO2 = 3;\nconst TYPE_FIDO2PRF = 4;\nclass VaultysId {\n    constructor(keyManager, certificate, type = TYPE_MACHINE) {\n        this.encrypt = VaultysId.encrypt;\n        this.type = type;\n        this.keyManager = keyManager;\n        this.certificate = certificate;\n    }\n    // // Set the index of the proof in case of previous key for this protocol/service have been compromised\n    // setProofIndex(protocol, service, index) {\n    //   this.proofIndices[`${protocol}-${service}`] = index;\n    // }\n    // createSwapingCertificate(protocol, service) {\n    //   let proofIndex = this.proofIndices[`${protocol}-${service}`]\n    //     ? this.proofIndices[`${protocol}-${service}`]\n    //     : 0;\n    //   const pk = this.getKey({\n    //     protocol,\n    //     service,\n    //     proofIndex,\n    //   });\n    //   const newPk = this.getKey({\n    //     protocol,\n    //     service,\n    //     proofIndex: proofIndex + 1,\n    //   });\n    //   const xPub = this.device.getProofXPub({\n    //     protocol,\n    //     service,\n    //     index,\n    //   });\n    //   const derivation = PDM.getProofDerivation(protocol, service, index);\n    //   const revocationCertificate = `vaultys://p2p/revocation?pk=${pk}&npk=${newPk}&xpub=${xpub}&index=${derivation}`;\n    // }\n    static fromId(id, certificate, encoding = \"hex\") {\n        let cleanId = id;\n        if (id.data) {\n            // Buffer thing\n            cleanId = buffer_1.Buffer.from(id.data);\n        }\n        if (id instanceof Uint8Array) {\n            // Buffer thing\n            cleanId = buffer_1.Buffer.from(id);\n        }\n        if (typeof id === \"string\") {\n            cleanId = buffer_1.Buffer.from(id, encoding);\n        }\n        const type = cleanId[0];\n        if (type === TYPE_FIDO2) {\n            const f2m = Fido2Manager_1.default.fromId(cleanId.slice(1));\n            return new VaultysId(f2m, certificate, type);\n        }\n        else if (type === TYPE_FIDO2PRF) {\n            const f2m = Fido2PRFManager_1.default.fromId(cleanId.slice(1));\n            return new VaultysId(f2m, certificate, type);\n        }\n        else {\n            if (cleanId.length > 1952) {\n                const pqm = PQManager_1.default.fromId(cleanId.slice(1));\n                return new VaultysId(pqm, certificate, type);\n            }\n            else {\n                const km = KeyManager_1.default.fromId(cleanId.slice(1));\n                return new VaultysId(km, certificate, type);\n            }\n        }\n    }\n    static async fromEntropy(entropy, type, pqc = false) {\n        const cleanedEntropy = entropy;\n        if (pqc) {\n            const km = await PQManager_1.default.create_PQ_fromEntropy(cleanedEntropy);\n            return new VaultysId(km, undefined, type);\n        }\n        else {\n            const km = await KeyManager_1.default.create_Id25519_fromEntropy(cleanedEntropy);\n            return new VaultysId(km, undefined, type);\n        }\n    }\n    static async createWebauthn(passkey = true, onPRFEnabled) {\n        const options = VaultysId.createPublicKeyCredentialCreationOptions(passkey);\n        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n        const attestation = await webAuthn.create(options);\n        if (!attestation)\n            return null;\n        else\n            return VaultysId.fido2FromAttestation(attestation, onPRFEnabled);\n    }\n    static async createPQC() {\n        const options = VaultysId.createPublicKeyCredentialOptionsPQC();\n        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n        const attestation = await webAuthn.create(options);\n        //console.log(attestation);\n        if (!attestation)\n            return null;\n        else\n            return VaultysId.fido2FromAttestation(attestation);\n    }\n    static async fido2FromAttestation(attestation, onPRFEnabled) {\n        // should be somehow valid.\n        SoftCredentials_1.default.verifyPackedAttestation(attestation.response, true);\n        //console.log(SoftCredentials.verifyPackedAttestation(attestation.response as AuthenticatorAttestationResponse, true));\n        if (attestation.getClientExtensionResults().prf?.enabled && (!onPRFEnabled || (await onPRFEnabled()))) {\n            const f2m = await Fido2PRFManager_1.default.createFromAttestation(attestation);\n            return new VaultysId(f2m, undefined, TYPE_FIDO2PRF);\n        }\n        else {\n            const f2m = await Fido2Manager_1.default.createFromAttestation(attestation);\n            return new VaultysId(f2m, undefined, TYPE_FIDO2);\n        }\n    }\n    static async machineFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_MACHINE);\n    }\n    static async organizationFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_ORGANIZATION);\n    }\n    static async personFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_PERSON);\n    }\n    static fromSecret(secret, encoding = \"hex\") {\n        const secretBuffer = buffer_1.Buffer.from(secret, encoding);\n        const type = secretBuffer[0];\n        if (type == TYPE_FIDO2) {\n            const f2m = Fido2Manager_1.default.fromSecret(secretBuffer.slice(1));\n            return new VaultysId(f2m, undefined, type);\n        }\n        else if (type == TYPE_FIDO2PRF) {\n            const f2m = Fido2PRFManager_1.default.fromSecret(secretBuffer.slice(1));\n            return new VaultysId(f2m, undefined, type);\n        }\n        else {\n            //console.log(secretBuffer.length);\n            if (secretBuffer.length === 109) {\n                const pqm = PQManager_1.default.fromSecret(secretBuffer.slice(1));\n                return new VaultysId(pqm, undefined, type);\n            }\n            else {\n                const km = KeyManager_1.default.fromSecret(secretBuffer.slice(1));\n                return new VaultysId(km, undefined, type);\n            }\n        }\n    }\n    static async generatePerson(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_PERSON);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_PERSON);\n        }\n    }\n    static async generateOrganization(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_ORGANIZATION);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_ORGANIZATION);\n        }\n    }\n    static async generateMachine(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_MACHINE);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_MACHINE);\n        }\n    }\n    get relationshipCertificate() {\n        return this.certificate;\n    }\n    getSecret(encoding = \"hex\") {\n        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.getSecret()]).toString(encoding);\n    }\n    get fingerprint() {\n        const t = buffer_1.Buffer.from([this.type]).toString(\"hex\");\n        const fp = t + (0, crypto_1.hash)(\"SHA224\", this.keyManager.id).toString(\"hex\");\n        return fp\n            .slice(0, 40)\n            .toUpperCase()\n            .match(/.{1,4}/g)\n            .join(\" \");\n    }\n    get did() {\n        const t = buffer_1.Buffer.from([this.type]).toString(\"hex\");\n        const fp = t + (0, crypto_1.hash)(\"SHA224\", this.keyManager.id).toString(\"hex\");\n        return `did:vaultys:${fp.slice(0, 40)}`;\n    }\n    get didDocument() {\n        return {\n            \"@context\": [\"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\"],\n            id: this.did,\n            authentication: [\n                {\n                    id: `${this.did}#keys-1`,\n                    type: this.keyManager.authType,\n                    controller: this.did,\n                    publicKeyMultibase: \"m\" + buffer_1.Buffer.from(this.keyManager.signer.publicKey).toString(\"base64\"),\n                },\n            ],\n            keyAgreement: [\n                {\n                    id: `${this.did}#keys-2`,\n                    type: this.keyManager.encType,\n                    controller: this.did,\n                    publicKeyMultibase: \"m\" + buffer_1.Buffer.from(this.keyManager.cypher.publicKey).toString(\"base64\"),\n                },\n            ],\n        };\n    }\n    get id() {\n        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.id]);\n    }\n    toVersion(v) {\n        this.keyManager.version = v;\n        return this;\n    }\n    get version() {\n        return this.keyManager.version;\n    }\n    isHardware() {\n        return this.type === TYPE_FIDO2 || this.type === TYPE_FIDO2PRF;\n    }\n    isMachine() {\n        return this.type === TYPE_MACHINE;\n    }\n    isPerson() {\n        return this.type === TYPE_PERSON;\n    }\n    getOTPHmac(timelock = 1 * 3600000) {\n        const otp = Math.floor(new Date().getTime() / timelock);\n        return this.keyManager.getSecretHash(buffer_1.Buffer.from(`OTP-${otp}`)).toString(\"hex\");\n    }\n    // Need to think about insecure use of this function\n    getOTP(prefix = \"password\", timelock = 24 * 3600000) {\n        if (this.certificate) {\n            const otp = Math.floor(new Date().getTime() / timelock);\n            const toHash = buffer_1.Buffer.concat([buffer_1.Buffer.from(prefix, \"utf-8\"), buffer_1.Buffer.from(this.certificate), buffer_1.Buffer.from([otp])]);\n            return (0, crypto_1.hash)(\"SHA256\", toHash).toString(\"hex\");\n        }\n        throw new Error(\"no certificate, cannot derive OTP\");\n    }\n    async performDiffieHellman(otherVaultysId) {\n        return this.keyManager.performDiffieHellman(otherVaultysId.keyManager);\n    }\n    /**\n     * Static method to perform a Diffie-Hellman key exchange between two VaultysId instances\n     * @param vaultysId1 First VaultysId instance\n     * @param vaultysId2 Second VaultysId instance\n     * @returns A shared secret that both parties can derive\n     */\n    static async diffieHellman(vaultysId1, vaultysId2) {\n        return vaultysId1.performDiffieHellman(vaultysId2);\n    }\n    /**\n     * Encrypt a message using DHIES for a recipient\n     * @param message Message to encrypt\n     * @param recipientId Recipient's VaultysId ID\n     * @returns Encrypted message or null if encryption fails\n     */\n    async dhiesEncrypt(message, recipientId) {\n        let cleanId;\n        if (typeof recipientId === \"string\") {\n            cleanId = buffer_1.Buffer.from(recipientId.slice(2), \"hex\");\n        }\n        else {\n            cleanId = recipientId.slice(1);\n        }\n        return this.keyManager.dhiesEncrypt(message, cleanId);\n    }\n    /**\n     * Decrypt a message encrypted with DHIES\n     * @param encryptedMessage Encrypted message from dhiesEncrypt\n     * @returns Decrypted message as Buffer or null if decryption fails\n     */\n    async dhiesDecrypt(encryptedMessage, senderId) {\n        let cleanId;\n        if (typeof senderId === \"string\") {\n            cleanId = buffer_1.Buffer.from(senderId.slice(2), \"hex\");\n        }\n        else {\n            cleanId = senderId.slice(1);\n        }\n        return this.keyManager.dhiesDecrypt(encryptedMessage, cleanId);\n    }\n    async signChallenge(challenge) {\n        if (typeof challenge == \"string\") {\n            challenge = buffer_1.Buffer.from(challenge, \"hex\");\n        }\n        const result = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([this.id, challenge]));\n        const signature = await this.keyManager.sign(result);\n        if (!signature)\n            throw new Error(\"Could not sign challenge\");\n        else\n            return signature;\n    }\n    verifyChallenge(challenge, signature, userVerification) {\n        if (typeof challenge == \"string\") {\n            challenge = buffer_1.Buffer.from(challenge, \"hex\");\n        }\n        if (typeof signature == \"string\") {\n            signature = buffer_1.Buffer.from(signature, \"hex\");\n        }\n        const result = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([this.id, challenge]));\n        return this.keyManager.verify(result, signature, userVerification);\n    }\n    async signcrypt(plaintext, recipientIds) {\n        return this.keyManager.signcrypt(plaintext, recipientIds.map((id) => {\n            if (typeof id === \"string\")\n                return buffer_1.Buffer.from(id.slice(2), \"hex\");\n            else\n                return id.slice(1);\n        }));\n    }\n    static async encrypt(plaintext, recipientIds) {\n        return KeyManager_1.default.encrypt(plaintext, recipientIds.map((id) => {\n            if (typeof id === \"string\")\n                return buffer_1.Buffer.from(id.slice(2), \"hex\");\n            else\n                return id.slice(1);\n        }));\n    }\n    async decrypt(encryptedMessage, senderId) {\n        let cleanId;\n        if (senderId) {\n            if (typeof senderId === \"string\")\n                cleanId = buffer_1.Buffer.from(senderId.slice(2));\n            // @ts-ignore\n            else\n                cleanId = senderId.subarray(1);\n        }\n        return this.keyManager.decrypt(encryptedMessage, cleanId);\n    }\n    async hmac(message) {\n        const cypher = await this.keyManager.getCypher();\n        return cypher.hmac(message);\n    }\n}\nVaultysId.createPublicKeyCredentialOptionsPQC = () => {\n    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);\n    const hint = \"security-key\";\n    const options = {\n        challenge: (0, crypto_1.randomBytes)(32),\n        rp: {\n            name: \"Vaultys ID\",\n        },\n        user: {\n            id: (0, crypto_1.randomBytes)(16),\n            name: \"Vaultys ID\",\n            displayName: \"Vaultys Wallet ID\",\n        },\n        attestation: safari ? \"none\" : \"direct\", // SAFARI Dead, they removed direct attestation\n        authenticatorSelection: {\n            authenticatorAttachment: \"cross-platform\",\n            residentKey: \"discouraged\",\n            userVerification: \"preferred\",\n        },\n        // @ts-ignore not yet in dom types\n        hints: [hint],\n        extensions: {\n            prf: {\n                eval: {\n                    first: buffer_1.Buffer.from(\"VaultysID salt\", \"utf-8\"),\n                },\n            },\n        },\n        pubKeyCredParams: [{ type: \"public-key\", alg: pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 }],\n    };\n    return options;\n};\nVaultysId.createPublicKeyCredentialCreationOptions = (passkey) => {\n    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);\n    const hint = passkey ? \"client-device\" : \"security-key\";\n    const options = {\n        challenge: (0, crypto_1.randomBytes)(32),\n        rp: {\n            name: \"Vaultys ID\",\n        },\n        user: {\n            id: (0, crypto_1.randomBytes)(16),\n            name: \"Vaultys ID\",\n            displayName: \"Vaultys Wallet ID\",\n        },\n        attestation: safari ? \"none\" : \"direct\", // SAFARI Dead, they removed direct attestation\n        authenticatorSelection: {\n            authenticatorAttachment: passkey ? \"platform\" : \"cross-platform\",\n            residentKey: passkey ? \"required\" : \"discouraged\",\n            userVerification: \"preferred\",\n        },\n        // @ts-ignore not yet in dom types\n        hints: [hint],\n        extensions: {\n            prf: {\n                eval: {\n                    first: buffer_1.Buffer.from(\"VaultysID salt\", \"utf-8\"),\n                },\n            },\n        },\n        pubKeyCredParams: [\n            {\n                type: \"public-key\",\n                alg: -7, // SECP256/ECDSA, Ed25519/EdDSA (-8) not supported natively on mobile or yubikey (crying)\n            },\n            {\n                type: \"public-key\",\n                alg: -8, // Ed25519/EdDSA prefered\n            },\n            {\n                type: \"public-key\",\n                alg: -257, // RS256\n            },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -36\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -37\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -38\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -39\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -258\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -259\n            // }\n        ],\n    };\n    return options;\n};\nexports.default = VaultysId;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hmac = exports.hash = exports.Buffer = void 0;\nconst tweetnacl_1 = __importStar(require(\"tweetnacl\"));\nconst buffer_1 = require(\"buffer/\");\nObject.defineProperty(exports, \"Buffer\", { enumerable: true, get: function () { return buffer_1.Buffer; } });\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst getAlgorithm = (alg) => {\n    const cleanAlg = alg.replaceAll(\"-\", \"\").toLowerCase();\n    if (cleanAlg === \"sha256\")\n        return sha2_1.sha256;\n    if (cleanAlg === \"sha512\")\n        return sha2_1.sha512;\n    if (cleanAlg === \"sha224\")\n        return sha2_1.sha224;\n    return sha2_1.sha256;\n};\nconst _randomBytes = (size) => buffer_1.Buffer.from((0, tweetnacl_1.randomBytes)(size));\nexports.randomBytes = _randomBytes;\nconst hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).create().update(buffer).digest());\nexports.hash = hash;\nconst _hmac = (alg, key, data) => buffer_1.Buffer.from((0, hmac_1.hmac)(getAlgorithm(alg), key, data));\nexports.hmac = _hmac;\nconst secretbox = tweetnacl_1.default.secretbox;\nexports.secretbox = secretbox;\nconst toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"base64\");\nexports.toBase64 = toBase64;\nconst toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"hex\");\nexports.toHex = toHex;\nconst toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"utf-8\");\nexports.toUTF8 = toUTF8;\nconst fromBase64 = (string) => buffer_1.Buffer.from(string, \"base64\");\nexports.fromBase64 = fromBase64;\nconst fromHex = (string) => buffer_1.Buffer.from(string, \"hex\");\nexports.fromHex = fromHex;\nconst fromUTF8 = (string) => buffer_1.Buffer.from(string, \"utf-8\");\nexports.fromUTF8 = fromUTF8;\nconst secureErase = (buffer) => {\n    for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = 0;\n    }\n};\nexports.secureErase = secureErase;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = void 0;\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);\nconst encrypt = (buffer, key) => {\n    //console.log(\"encrypting: \", buffer, key)\n    const keyUint8Array = key;\n    const nonce = newNonce();\n    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);\n    const fullMessage = new Uint8Array(nonce.length + box.length);\n    fullMessage.set(nonce);\n    fullMessage.set(box, nonce.length);\n    return buffer_1.Buffer.from(fullMessage);\n};\nexports.encrypt = encrypt;\nconst decrypt = (messageWithNonce, key) => {\n    //console.log(\"decrypting: \", messageWithNonce, key)\n    const keyUint8Array = key;\n    const messageWithNonceAsUint8Array = messageWithNonce;\n    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);\n    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);\n    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);\n    if (!decrypted) {\n        throw new Error(\"Could not decrypt message\");\n    }\n    return buffer_1.Buffer.from(decrypted);\n};\nexports.decrypt = decrypt;\n// upgrading a channel api with an encrypting layer. The API shoud be\n// - send(Buffer):null\n// - async receive():Buffer\nconst encryptChannel = (channel, key) => {\n    const sendHandler = {\n        apply(target, that, args) {\n            return target.call(that, (0, exports.encrypt)(args[0], key));\n        },\n    };\n    const receiveHandler = {\n        async apply(target, that, args) {\n            const result = await target.call(that);\n            return (0, exports.decrypt)(result, key);\n        },\n    };\n    channel.send = new Proxy(channel.send, sendHandler);\n    channel.receive = new Proxy(channel.receive, receiveHandler);\n    return channel;\n};\nconst generateKey = () => (0, crypto_1.randomBytes)(32);\nexports.default = {\n    decrypt: exports.decrypt,\n    encrypt: exports.encrypt,\n    encryptChannel,\n    generateKey,\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: to revamp and optimize\n// import crypto from \"crypto\";\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"../crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst ed25519_1 = require(\"@noble/curves/ed25519\");\nconst p256_1 = require(\"@noble/curves/p256\");\nconst p384_1 = require(\"@noble/curves/p384\");\nconst p521_1 = require(\"@noble/curves/p521\");\n// import { BasicConstraintsExtension, X509Certificate } from \"@peculiar/x509\";\nconst pqCrypto_1 = require(\"../pqCrypto\");\nconst credentials = {};\n//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;\nconst COSEKEYS = {\n    kty: 1,\n    alg: 3,\n    crv: -1,\n    x: -2,\n    y: -3,\n    n: -1,\n    e: -2,\n};\nconst COSEKTY = {\n    OKP: 1,\n    EC2: 2,\n    RSA: 3,\n    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,\n};\nconst COSERSASCHEME = {\n    \"-3\": \"pss-sha256\",\n    \"-39\": \"pss-sha512\",\n    \"-38\": \"pss-sha384\",\n    \"-65535\": \"pkcs1-sha1\",\n    \"-257\": \"pkcs1-sha256\",\n    \"-258\": \"pkcs1-sha384\",\n    \"-259\": \"pkcs1-sha512\",\n};\nconst COSECRV = {\n    1: p256_1.p256,\n    2: p384_1.p384,\n    3: p521_1.p521,\n};\nconst COSEALGHASH = {\n    \"-257\": \"SHA-256\",\n    \"-258\": \"SHA-384\",\n    \"-259\": \"SHA-512\",\n    \"-65535\": \"SHA-1\",\n    \"-39\": \"SHA-512\",\n    \"-38\": \"SHA-384\",\n    \"-37\": \"SHA-256\",\n    \"-260\": \"SHA-256\",\n    \"-261\": \"SHA-512\",\n    \"-7\": \"SHA-256\",\n    \"-36\": \"SHA-512\",\n    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: \"SHA-256\", // DILITHIUM2 uses SHA-256 for hashing\n};\nconst hash = (alg, message) => (0, crypto_1.hash)(alg.replace(\"-\", \"\"), message);\nconst base64ToPem = (b64cert) => {\n    let pemcert = \"\";\n    for (let i = 0; i < b64cert.length; i += 64)\n        pemcert += b64cert.slice(i, i + 64) + \"\\n\";\n    return \"-----BEGIN CERTIFICATE-----\\n\" + pemcert + \"-----END CERTIFICATE-----\";\n};\n// const getCertificateInfo = (certificate: Buffer) => {\n//   const x509 = new X509Certificate(certificate);\n//   const subjectString = x509.subject;\n//   const issuer = x509.issuer;\n//   const issuerName = x509.issuerName.toString();\n//   const subjectParts = subjectString.split(\",\");\n//   const subject: Record<string, string> = {};\n//   for (const field of subjectParts) {\n//     const kv = field.split(\"=\");\n//     subject[kv[0].trim()] = kv[1];\n//   }\n//   // console.log(subject);\n//   const { Version } = x509.toTextObject().Data as unknown as { Version: string };\n//   const bc = x509.getExtension(BasicConstraintsExtension);\n//   const basicConstraintsCA = bc ? bc.ca : false;\n//   return {\n//     issuer,\n//     issuerName,\n//     subject,\n//     version: Version,\n//     basicConstraintsCA,\n//   };\n// };\nconst parseAuthData = (buffer) => {\n    const rpIdHash = buffer.slice(0, 32);\n    buffer = buffer.slice(32);\n    const flagsBuf = buffer.slice(0, 1);\n    buffer = buffer.slice(1);\n    const flagsInt = flagsBuf[0];\n    const flags = {\n        up: !!(flagsInt & 0x01),\n        uv: !!(flagsInt & 0x04),\n        at: !!(flagsInt & 0x40),\n        ed: !!(flagsInt & 0x80),\n        flagsInt,\n    };\n    const counterBuf = buffer.slice(0, 4);\n    buffer = buffer.slice(4);\n    const counter = counterBuf.readUInt32BE(0);\n    let aaguid = undefined;\n    let credID = undefined;\n    let COSEPublicKey = undefined;\n    if (flags.at) {\n        aaguid = buffer.slice(0, 16);\n        buffer = buffer.slice(16);\n        const credIDLenBuf = buffer.slice(0, 2);\n        buffer = buffer.slice(2);\n        const credIDLen = credIDLenBuf.readUInt16BE(0);\n        credID = buffer.slice(0, credIDLen);\n        buffer = buffer.slice(credIDLen);\n        COSEPublicKey = buffer;\n    }\n    //console.log(aaguid);\n    return {\n        rpIdHash,\n        flagsBuf,\n        flags,\n        counter,\n        counterBuf,\n        aaguid,\n        credID,\n        COSEPublicKey,\n    };\n};\nconst verifyPackedAttestation = (response, userVerification = false) => {\n    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);\n    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];\n    if (attestationStruct.fmt == \"none\")\n        return false;\n    const authDataStruct = parseAuthData(attestationStruct.authData);\n    // check if user has actually touched the device\n    if (!authDataStruct.flags.up)\n        return false;\n    // check if did enter PIN code\n    if (userVerification && !authDataStruct.flags.uv)\n        return false;\n    const clientDataHashBuf = hash(\"sha256\", buffer_1.Buffer.from(response.clientDataJSON));\n    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);\n    const signature = attestationStruct.attStmt.sig;\n    let signatureIsValid = false;\n    /* ----- Verify FULL attestation ----- */\n    // if (attestationStruct.attStmt.x5c) {\n    //   const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString(\"base64\"));\n    //   const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);\n    //   const subject = certInfo.subject as {\n    //     OU: string;\n    //     O: string;\n    //     C: string;\n    //     CN: string;\n    //   };\n    //   // console.log(certInfo);\n    //   if (subject.OU !== \"Authenticator Attestation\") throw new Error('Batch certificate OU MUST be set strictly to \"Authenticator Attestation\"!');\n    //   if (!subject.CN) throw new Error(\"Batch certificate CN MUST no be empty!\");\n    //   if (!subject.O) throw new Error(\"Batch certificate O MUST no be empty!\");\n    //   if (!subject.C || subject.C.length !== 2) throw new Error(\"Batch certificate C MUST be set to two character ISO 3166 code!\");\n    //   if (certInfo.basicConstraintsCA) throw new Error(\"Batch certificate basic constraints CA MUST be false!\");\n    //   if (certInfo.version !== \"v3 (2)\") throw new Error(\"Batch certificate version MUST be 3(ASN1 2)!\");\n    //   signatureIsValid = crypto.createVerify(\"sha256\").update(dataBuffer).verify(leafCert, signature);\n    //   /* ----- Verify FULL attestation ENDS ----- */\n    // } else\n    if (attestationStruct.attStmt.ecdaaKeyId) {\n        throw new Error(\"ECDAA IS NOT SUPPORTED!\");\n    }\n    else {\n        /* ----- Verify SURROGATE attestation ----- */\n        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];\n        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];\n        const data = hash(hashAlg, dataBuffer);\n        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {\n            // ECDSA\n            const x = pubKeyCose.get(COSEKEYS.x);\n            const y = pubKeyCose.get(COSEKEYS.y);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);\n            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];\n            const sig = ec.Signature.fromDER(signature);\n            signatureIsValid = ec.verify(sig, data, pubKey);\n        }\n        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {\n            // EdDSA\n            const x = pubKeyCose.get(COSEKEYS.x);\n            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);\n        }\n        else {\n            return false;\n        }\n        /* ----- Verify SURROGATE attestation ENDS ----- */\n    }\n    if (!signatureIsValid)\n        throw new Error(\"Failed to verify the signature!\");\n    return true;\n};\nclass MyPublicKeyCredential {\n    constructor(creds) {\n        this.type = \"public-key\";\n        this.clientExtensionResults = {};\n        const keys = [\"id\", \"rawId\", \"response\"];\n        this.id = creds.id;\n        this.rawId = buffer_1.Buffer.from(creds.rawId);\n        this.response = creds.response;\n    }\n    getClientExtensionResults() {\n        return {};\n    }\n}\nconst verifyECDSA = (data, publicKey, signature) => {\n    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);\n};\nconst verifyEdDSA = (data, publicKey, signature) => {\n    return ed25519_1.ed25519.verify(signature, data, publicKey);\n};\n// Webauthn Partial Implementation for testing\nclass SoftCredentials {\n    constructor() {\n        this.signCount = 0;\n        this.rawId = (0, crypto_1.randomBytes)(32);\n        this.aaguid = buffer_1.Buffer.alloc(16);\n    }\n    // credentials request payload\n    static createRequest(alg, prf = false) {\n        const challenge = buffer_1.Buffer.from((0, crypto_1.randomBytes)(32).toString(\"base64\"));\n        const result = {\n            publicKey: {\n                challenge,\n                rp: {\n                    name: \"Vaultys ID\",\n                    id: \"Vaultys ID\",\n                },\n                user: {\n                    id: buffer_1.Buffer.from(\"Vaultys Wallet ID\", \"utf8\"),\n                    name: \"Vaultys Wallet ID\",\n                    displayName: \"Vaultys Wallet ID\",\n                },\n                pubKeyCredParams: [\n                    {\n                        type: \"public-key\",\n                        alg,\n                    },\n                ],\n            },\n        };\n        if (prf) {\n            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_1.randomBytes)(32) } } };\n        }\n        return result;\n    }\n    // static getCertificateInfo(response: AuthenticatorAttestationResponse) {\n    //   const attestationBuffer = Buffer.from(response.attestationObject);\n    //   const attestationStruct = cbor.decodeAllSync(attestationBuffer)[0];\n    //   if (attestationStruct.attStmt.x5c) {\n    //     return getCertificateInfo(attestationStruct.attStmt.x5c[0]);\n    //   } else {\n    //     return null;\n    //   }\n    // }\n    static async create(options, origin = \"test\") {\n        const credential = new SoftCredentials();\n        const publicKey = options.publicKey;\n        credential.options = publicKey;\n        credential.rpId = publicKey.rp.id || publicKey.rp.name;\n        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), \"base64\");\n        credentials[credential.rawId.toString(\"base64\")] = credential; // erase previous instance\n        // Get the algorithm from pubKeyCredParams\n        const pubKeyCredParams = publicKey.pubKeyCredParams;\n        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)\n        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);\n        // Set algorithm, prioritizing DILITHIUM if it's supported\n        if (supportsDilithium) {\n            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;\n        }\n        else {\n            credential.alg = publicKey.pubKeyCredParams[0].alg;\n        }\n        if (credential.alg === -8) {\n            const random = ed25519_1.ed25519.utils.randomPrivateKey();\n            credential.keyPair = {\n                privateKey: random,\n                publicKey: ed25519_1.ed25519.getPublicKey(random),\n                algorithm: \"EdDSA\",\n            };\n            credential.coseKey = new Map();\n            credential.coseKey.set(1, 1);\n            credential.coseKey.set(3, -8);\n            credential.coseKey.set(-1, 6);\n            const x = credential.keyPair.publicKey.slice(0, 32);\n            credential.coseKey.set(-2, x);\n        }\n        else if (credential.alg === -7) {\n            const random = p256_1.p256.utils.randomPrivateKey();\n            credential.keyPair = {\n                privateKey: random,\n                publicKey: p256_1.p256.getPublicKey(random, false),\n                algorithm: \"ES256\",\n            };\n            credential.coseKey = new Map();\n            credential.coseKey.set(1, 2);\n            credential.coseKey.set(3, -7);\n            credential.coseKey.set(-1, 6);\n            const x = credential.keyPair.publicKey.slice(1, 33);\n            const y = credential.keyPair.publicKey.slice(33);\n            credential.coseKey.set(-2, x);\n            credential.coseKey.set(-3, y);\n            // console.log(extpk,x,y)\n        }\n        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {\n            // Generate DILITHIUM key pair\n            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            //console.log(\"PQC\", dilithiumPk, dilithiumSk);\n            credential.keyPair = {\n                privateKey: dilithiumSk,\n                publicKey: dilithiumPk,\n                algorithm: \"DILITHIUM2\",\n                isDILITHIUM: true,\n            };\n            // Create COSE key representation\n            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);\n            //console.log(\"PQC\", credential);\n        }\n        const clientData = {\n            type: \"webauthn.create\",\n            challenge: publicKey.challenge,\n            origin,\n        };\n        const rpIdHash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(credential.rpId, \"ascii\"));\n        const flags = buffer_1.Buffer.from(\"41\", \"hex\"); // attested_data + user_present\n        const signCount = buffer_1.Buffer.allocUnsafe(4);\n        signCount.writeUInt32BE(credential.signCount, 0);\n        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);\n        rawIdLength.writeUInt16BE(credential.rawId.length, 0);\n        const coseKey = cbor_1.default.encode(credential.coseKey);\n        const attestationObject = {\n            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),\n            fmt: \"none\",\n            attStmt: {},\n        };\n        const pkCredentials = {\n            id: credential.rawId.toString(\"base64\"),\n            rawId: credential.rawId,\n            authenticatorAttachment: null,\n            type: \"public-key\",\n            getClientExtensionResults: () => {\n                if (publicKey.extensions?.prf?.eval?.first) {\n                    return { prf: { enabled: true } };\n                }\n                else {\n                    return {};\n                }\n            },\n            toJSON() { },\n            response: {\n                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), \"utf-8\"),\n                attestationObject: cbor_1.default.encode(attestationObject),\n                getTransports: () => [\"usb\", \"hybrid\"],\n                getAuthenticatorData: () => attestationObject.authData,\n                getPublicKey: () => coseKey,\n                getPublicKeyAlgorithm: () => -7,\n            },\n        };\n        return pkCredentials;\n    }\n    static simpleVerify(COSEPublicKey, response, userVerification = false) {\n        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;\n        const rpIdHash = response.authenticatorData.slice(0, 32);\n        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];\n        const counter = response.authenticatorData.slice(33, 37);\n        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);\n        if (!goodflags)\n            return false;\n        const hash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(response.clientDataJSON));\n        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);\n        if (ckey.get(3) == -7) {\n            data = (0, crypto_1.hash)(\"sha256\", data);\n        }\n        if (ckey.get(1) == 1) {\n            // EdDSA\n            const x = ckey.get(-2);\n            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));\n        }\n        else if (ckey.get(1) == 2) {\n            // ECDSA\n            const x = ckey.get(-2);\n            const y = ckey.get(-3);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), x, y]);\n            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));\n        }\n        else if (ckey.get(1) === COSEKTY.DILITHIUM) {\n            // DILITHIUM\n            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);\n            // Verify DILITHIUM signature asynchronously\n            //console.log(data, publicKey, Buffer.from(response.signature));\n            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);\n        }\n        return false;\n    }\n    static getCOSEPublicKey(attestation) {\n        const response = attestation.response;\n        const ato = cbor_1.default.decode(response.attestationObject);\n        //console.log(\"getCOSEPublicKey\", ato, parseAuthData(ato.authData));\n        return parseAuthData(ato.authData).COSEPublicKey;\n    }\n    static verifyPackedAttestation(attestation, userVerification = false) {\n        return verifyPackedAttestation(attestation, userVerification);\n    }\n    static async verify(attestation, assertion, userVerifiation = false) {\n        //if (assertion.id !== attestation.id) return false;\n        const hash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(assertion.response.clientDataJSON));\n        const ass = assertion.response;\n        const att = attestation.response;\n        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);\n        const ato = cbor_1.default.decode(att.attestationObject);\n        const authData = parseAuthData(ato.authData);\n        // check if user has actually touched the device\n        if (!authData.flags.up)\n            return false;\n        // check if the user has entered his PIN code or used biometric sensor\n        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)\n            return false;\n        const ckey = cbor_1.default.decode(authData.COSEPublicKey);\n        // Hash data for ES256\n        if (ckey.get(3) == -7) {\n            data = (0, crypto_1.hash)(\"sha256\", data);\n        }\n        // Get key type\n        const keyType = ckey.get(1);\n        if (keyType === 1) {\n            // EdDSA\n            const x = ckey.get(-2);\n            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));\n        }\n        else if (keyType === 2) {\n            // ECDSA\n            const x = ckey.get(-2);\n            const y = ckey.get(-3);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), x, y]);\n            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));\n        }\n        else if (keyType === COSEKTY.DILITHIUM) {\n            // DILITHIUM\n            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);\n            // Verify DILITHIUM signature asynchronously\n            //console.log(data, publicKey, Buffer.from(ass.signature));\n            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);\n        }\n        return false;\n    }\n    static extractChallenge(clientDataJSON) {\n        const clientData = JSON.parse(clientDataJSON.toString());\n        const m = clientData.challenge.length % 4;\n        return clientData.challenge\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), \"=\");\n    }\n    static async get({ publicKey }, origin = \"test\") {\n        if (!publicKey.allowCredentials)\n            throw new Error();\n        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString(\"base64\");\n        const credential = credentials[id];\n        credential.signCount += 1;\n        // prepare signature\n        const clientData = {\n            type: \"webauthn.get\",\n            challenge: buffer_1.Buffer.from(publicKey.challenge).toString(\"base64\"),\n            origin,\n        };\n        const clientDataHash = (0, crypto_1.hash)(\"sha256\", (0, crypto_1.fromUTF8)(JSON.stringify(clientData)));\n        const rpIdHash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(credential.rpId, \"utf-8\"));\n        const flags = buffer_1.Buffer.from(\"05\", \"hex\"); // user verification\n        const signCount = buffer_1.Buffer.allocUnsafe(4);\n        signCount.writeUInt32BE(credential.signCount, 0);\n        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);\n        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);\n        let signature = new Uint8Array();\n        if (credential.alg === -7) {\n            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();\n        }\n        else if (credential.alg === -8) {\n            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);\n        }\n        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {\n            // DILITHIUM signing - this returns a Promise so we need to await it\n            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);\n        }\n        const pkCredentials = {\n            id,\n            rawId: buffer_1.Buffer.from(id, \"base64\").buffer,\n            type: \"public-key\",\n            authenticatorAttachment: null,\n            getClientExtensionResults: () => {\n                if (publicKey.extensions?.prf?.eval?.first) {\n                    // unsafe and not following w3c recommendation. for testing purpose only\n                    return { prf: { results: { first: hash(\"sha256\", publicKey.extensions?.prf?.eval?.first) } } };\n                }\n                else {\n                    return {};\n                }\n            },\n            toJSON() { },\n            response: {\n                authenticatorData,\n                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), \"utf-8\"),\n                signature: signature,\n                userHandle: credential.userHandle,\n            },\n        };\n        return pkCredentials;\n    }\n}\nexports.default = SoftCredentials;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeWebAuthn = exports.BrowserWebAuthn = void 0;\nexports.getWebAuthnProvider = getWebAuthnProvider;\nexports.createCredentialRequest = createCredentialRequest;\nconst SoftCredentials_1 = __importDefault(require(\"./SoftCredentials\"));\n// Browser implementation\nclass BrowserWebAuthn {\n    isAvailable() {\n        return typeof window !== \"undefined\" && typeof window.PublicKeyCredential !== \"undefined\";\n    }\n    async create(options) {\n        if (!this.isAvailable()) {\n            throw new Error(\"WebAuthn is not available in this environment\");\n        }\n        return (await navigator.credentials.create({ publicKey: options }));\n    }\n    async get(options) {\n        if (!this.isAvailable()) {\n            throw new Error(\"WebAuthn is not available in this environment\");\n        }\n        return (await navigator.credentials.get({ publicKey: options }));\n    }\n}\nexports.BrowserWebAuthn = BrowserWebAuthn;\n// Node.js implementation using SoftCredentials\nclass NodeWebAuthn {\n    constructor(origin = \"test\") {\n        this.origin = origin;\n    }\n    isAvailable() {\n        return true; // Always available in mock mode\n    }\n    async create(options) {\n        return await SoftCredentials_1.default.create({\n            publicKey: options,\n        }, this.origin);\n    }\n    async get(options) {\n        return await SoftCredentials_1.default.get({\n            publicKey: options,\n        }, this.origin);\n    }\n}\nexports.NodeWebAuthn = NodeWebAuthn;\n// Factory function\nfunction getWebAuthnProvider(options) {\n    if (typeof window !== \"undefined\") {\n        return new BrowserWebAuthn();\n    }\n    return new NodeWebAuthn(options?.origin);\n}\n// Helper to create credential request\nfunction createCredentialRequest(alg, prf = false) {\n    return SoftCredentials_1.default.createRequest(alg, prf);\n}\n","\"use strict\";\n/**\n * Post-Quantum Cryptography Operations\n *\n * This file contains implementations for post-quantum cryptographic algorithms\n * starting with DILITHIUM for digital signatures.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;\nexports.generateDilithiumKeyPair = generateDilithiumKeyPair;\nexports.signDilithium = signDilithium;\nexports.verifyDilithium = verifyDilithium;\nexports.createDilithiumCoseKey = createDilithiumCoseKey;\nexports.getDilithiumKeyInfo = getDilithiumKeyInfo;\nconst ml_dsa_js_1 = require(\"@noble/post-quantum/ml-dsa.js\");\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"./crypto\");\n/**\n * COSE algorithm identifiers for post-quantum algorithms\n * Note: These values are provisional and may need to be updated as standards evolve\n */\nexports.PQ_COSE_ALG = {\n    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)\n    DILITHIUM2: -46, // Level 2 (128-bit security)\n    DILITHIUM3: -47, // Level 3 (192-bit security)\n    DILITHIUM5: -48, // Level 5 (256-bit security)\n};\n/**\n * COSE key type for DILITHIUM\n */\nexports.PQ_COSE_KEY_TYPE = {\n    DILITHIUM: 4, // Custom key type for DILITHIUM\n};\n/**\n * COSE key parameter identifiers for DILITHIUM\n */\nexports.PQ_COSE_KEY_PARAMS = {\n    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)\n    DILITHIUM_PK: -101, // Public key\n    DILITHIUM_SK: -102, // Secret key\n};\n/**\n * Generate a DILITHIUM Level 2 key pair\n * @returns Promise resolving to an object containing the key pair\n */\nfunction generateDilithiumKeyPair(seed) {\n    if (!seed)\n        seed = (0, crypto_1.randomBytes)(32);\n    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);\n    return {\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey),\n        secretKey: buffer_1.Buffer.from(keyPair.secretKey),\n    };\n}\n/**\n * Sign a message using DILITHIUM Level 2\n * @param message - The message to sign\n * @param privateKey - The DILITHIUM private key\n * @returns Promise resolving to signature as Uint8Array\n */\nfunction signDilithium(message, secretKey) {\n    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));\n}\n/**\n * Verify a DILITHIUM Level 2 signature\n * @param message - The original message\n * @param signature - The signature to verify\n * @param publicKey - The DILITHIUM public key\n * @returns Promise resolving to boolean indicating if signature is valid\n */\nfunction verifyDilithium(message, signature, publicKey) {\n    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);\n}\n/**\n * Create a COSE key representation for a DILITHIUM public key\n * @param publicKey - The DILITHIUM public key\n * @returns Map representing the COSE key\n */\nfunction createDilithiumCoseKey(publicKey) {\n    const coseKey = new Map();\n    // Standard COSE key parameters\n    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type\n    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm\n    // DILITHIUM-specific parameters\n    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2\n    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);\n    return coseKey;\n}\n/**\n * Get key size information for DILITHIUM\n * @returns Object with key size information\n */\nfunction getDilithiumKeyInfo() {\n    return {\n        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key\n        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key\n        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature\n    };\n}\n","import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nexport class CachedKeyDecoder {\n    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n        this.hit = 0;\n        this.miss = 0;\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (let i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    canBeCached(byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    }\n    find(bytes, inputOffset, byteLength) {\n        const records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (const record of records) {\n            const recordBytes = record.bytes;\n            for (let j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    }\n    store(bytes, value) {\n        const records = this.caches[bytes.length - 1];\n        const record = { bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    }\n    decode(bytes, inputOffset, byteLength) {\n        const cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    }\n}\n//# sourceMappingURL=CachedKeyDecoder.mjs.map","export class DecodeError extends Error {\n    constructor(message) {\n        super(message);\n        // fix the prototype chain in a cross-platform way\n        const proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(this, proto);\n        Object.defineProperty(this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n    }\n}\n//# sourceMappingURL=DecodeError.mjs.map","import { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8Decode } from \"./utils/utf8.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\nconst mapKeyConverter = (key) => {\n    if (typeof key === \"string\" || typeof key === \"number\") {\n        return key;\n    }\n    throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\nclass StackPool {\n    constructor() {\n        this.stack = [];\n        this.stackHeadPosition = -1;\n    }\n    get length() {\n        return this.stackHeadPosition + 1;\n    }\n    top() {\n        return this.stack[this.stackHeadPosition];\n    }\n    pushArrayState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_ARRAY;\n        state.position = 0;\n        state.size = size;\n        state.array = new Array(size);\n    }\n    pushMapState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_MAP_KEY;\n        state.readCount = 0;\n        state.size = size;\n        state.map = {};\n    }\n    getUninitializedStateFromPool() {\n        this.stackHeadPosition++;\n        if (this.stackHeadPosition === this.stack.length) {\n            const partialState = {\n                type: undefined,\n                size: 0,\n                array: undefined,\n                position: 0,\n                readCount: 0,\n                map: undefined,\n                key: null,\n            };\n            this.stack.push(partialState);\n        }\n        return this.stack[this.stackHeadPosition];\n    }\n    release(state) {\n        const topStackState = this.stack[this.stackHeadPosition];\n        if (topStackState !== state) {\n            throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n        }\n        if (state.type === STATE_ARRAY) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.array = undefined;\n            partialState.position = 0;\n            partialState.type = undefined;\n        }\n        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.map = undefined;\n            partialState.readCount = 0;\n            partialState.type = undefined;\n        }\n        this.stackHeadPosition--;\n    }\n    reset() {\n        this.stack.length = 0;\n        this.stackHeadPosition = -1;\n    }\n}\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nconst MORE_DATA = new RangeError(\"Insufficient data\");\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\nexport class Decoder {\n    constructor(options) {\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = new StackPool();\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.rawStrings = options?.rawStrings ?? false;\n        this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n        this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n        this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n        this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n        this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n        this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n    }\n    clone() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Decoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            rawStrings: this.rawStrings,\n            maxStrLength: this.maxStrLength,\n            maxBinLength: this.maxBinLength,\n            maxArrayLength: this.maxArrayLength,\n            maxMapLength: this.maxMapLength,\n            maxExtLength: this.maxExtLength,\n            keyDecoder: this.keyDecoder,\n        });\n    }\n    reinitializeState() {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.reset();\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    }\n    setBuffer(buffer) {\n        const bytes = ensureUint8Array(buffer);\n        this.bytes = bytes;\n        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        this.pos = 0;\n    }\n    appendBuffer(buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            const remainingData = this.bytes.subarray(this.pos);\n            const newData = ensureUint8Array(buffer);\n            // concat remainingData + newData\n            const newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    }\n    hasRemaining(size) {\n        return this.view.byteLength - this.pos >= size;\n    }\n    createExtraByteError(posToShow) {\n        const { view, pos } = this;\n        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n    }\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    decode(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decode(buffer);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            const object = this.doDecodeSync();\n            if (this.hasRemaining(1)) {\n                throw this.createExtraByteError(this.pos);\n            }\n            return object;\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    *decodeMulti(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMulti(buffer);\n            return;\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            while (this.hasRemaining(1)) {\n                yield this.doDecodeSync();\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    async decodeAsync(stream) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decodeAsync(stream);\n        }\n        try {\n            this.entered = true;\n            let decoded = false;\n            let object;\n            for await (const buffer of stream) {\n                if (decoded) {\n                    this.entered = false;\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                try {\n                    object = this.doDecodeSync();\n                    decoded = true;\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n            if (decoded) {\n                if (this.hasRemaining(1)) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                return object;\n            }\n            const { headByte, pos, totalPos } = this;\n            throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    decodeArrayStream(stream) {\n        return this.decodeMultiAsync(stream, true);\n    }\n    decodeStream(stream) {\n        return this.decodeMultiAsync(stream, false);\n    }\n    async *decodeMultiAsync(stream, isArray) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMultiAsync(stream, isArray);\n            return;\n        }\n        try {\n            this.entered = true;\n            let isArrayHeaderRequired = isArray;\n            let arrayItemsLeft = -1;\n            for await (const buffer of stream) {\n                if (isArray && arrayItemsLeft === 0) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                if (isArrayHeaderRequired) {\n                    arrayItemsLeft = this.readArraySize();\n                    isArrayHeaderRequired = false;\n                    this.complete();\n                }\n                try {\n                    while (true) {\n                        yield this.doDecodeSync();\n                        if (--arrayItemsLeft === 0) {\n                            break;\n                        }\n                    }\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doDecodeSync() {\n        DECODE: while (true) {\n            const headByte = this.readHeadByte();\n            let object;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    const size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    const size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    const byteLength = headByte - 0xa0;\n                    object = this.decodeString(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                const byteLength = this.lookU8();\n                object = this.decodeString(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                const byteLength = this.lookU16();\n                object = this.decodeString(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                const byteLength = this.lookU32();\n                object = this.decodeString(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                const size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                const size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                const size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                const size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                const size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                const size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n            }\n            this.complete();\n            const stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                const state = stack.top();\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        object = state.array;\n                        stack.release(state);\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (object === \"__proto__\") {\n                        throw new DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = this.mapKeyConverter(object);\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        object = state.map;\n                        stack.release(state);\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    }\n    readHeadByte() {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    }\n    complete() {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    }\n    readArraySize() {\n        const headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n                }\n            }\n        }\n    }\n    pushMapState(size) {\n        if (size > this.maxMapLength) {\n            throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n        }\n        this.stack.pushMapState(size);\n    }\n    pushArrayState(size) {\n        if (size > this.maxArrayLength) {\n            throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n        }\n        this.stack.pushArrayState(size);\n    }\n    decodeString(byteLength, headerOffset) {\n        if (!this.rawStrings || this.stateIsMapKey()) {\n            return this.decodeUtf8String(byteLength, headerOffset);\n        }\n        return this.decodeBinary(byteLength, headerOffset);\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeUtf8String(byteLength, headerOffset) {\n        if (byteLength > this.maxStrLength) {\n            throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headerOffset;\n        let object;\n        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = utf8Decode(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    }\n    stateIsMapKey() {\n        if (this.stack.length > 0) {\n            const state = this.stack.top();\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeBinary(byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headOffset;\n        const object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    }\n    decodeExtension(size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n        }\n        const extType = this.view.getInt8(this.pos + headOffset);\n        const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    }\n    lookU8() {\n        return this.view.getUint8(this.pos);\n    }\n    lookU16() {\n        return this.view.getUint16(this.pos);\n    }\n    lookU32() {\n        return this.view.getUint32(this.pos);\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readI8() {\n        const value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readI16() {\n        const value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readI32() {\n        const value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readU64() {\n        const value = getUint64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64() {\n        const value = getInt64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readU64AsBigInt() {\n        const value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64AsBigInt() {\n        const value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readF32() {\n        const value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readF64() {\n        const value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n}\n//# sourceMappingURL=Decoder.mjs.map","import { utf8Count, utf8Encode } from \"./utils/utf8.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { setInt64, setUint64 } from \"./utils/int.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nexport class Encoder {\n    constructor(options) {\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = options?.sortKeys ?? false;\n        this.forceFloat32 = options?.forceFloat32 ?? false;\n        this.ignoreUndefined = options?.ignoreUndefined ?? false;\n        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    clone() {\n        // Because of slightly special argument `context`,\n        // type assertion is needed.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Encoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            maxDepth: this.maxDepth,\n            initialBufferSize: this.initialBufferSize,\n            sortKeys: this.sortKeys,\n            forceFloat32: this.forceFloat32,\n            ignoreUndefined: this.ignoreUndefined,\n            forceIntegerToFloat: this.forceIntegerToFloat,\n        });\n    }\n    reinitializeState() {\n        this.pos = 0;\n    }\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    encodeSharedRef(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encodeSharedRef(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.subarray(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    encode(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encode(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.slice(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doEncode(object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(`Too deep objects in depth ${depth}`);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    }\n    ensureBufferSizeToWrite(sizeToWrite) {\n        const requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    }\n    resizeBuffer(newSize) {\n        const newBuffer = new ArrayBuffer(newSize);\n        const newBytes = new Uint8Array(newBuffer);\n        const newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    }\n    encodeNil() {\n        this.writeU8(0xc0);\n    }\n    encodeBoolean(object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    }\n    encodeNumber(object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    }\n    encodeNumberAsFloat(object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    }\n    encodeBigInt64(object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    }\n    writeStringHeader(byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n        }\n    }\n    encodeString(object) {\n        const maxHeaderSize = 1 + 4;\n        const byteLength = utf8Count(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        utf8Encode(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    }\n    encodeObject(object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        const ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n        }\n    }\n    encodeBinary(object) {\n        const size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large binary: ${size}`);\n        }\n        const bytes = ensureUint8Array(object);\n        this.writeU8a(bytes);\n    }\n    encodeArray(object, depth) {\n        const size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large array: ${size}`);\n        }\n        for (const item of object) {\n            this.doEncode(item, depth + 1);\n        }\n    }\n    countWithoutUndefined(object, keys) {\n        let count = 0;\n        for (const key of keys) {\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    }\n    encodeMap(object, depth) {\n        const keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large map object: ${size}`);\n        }\n        for (const key of keys) {\n            const value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    }\n    encodeExtension(ext) {\n        if (typeof ext.data === \"function\") {\n            const data = ext.data(this.pos + 6);\n            const size = data.length;\n            if (size >= 0x100000000) {\n                throw new Error(`Too large extension object: ${size}`);\n            }\n            this.writeU8(0xc9);\n            this.writeU32(size);\n            this.writeI8(ext.type);\n            this.writeU8a(data);\n            return;\n        }\n        const size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large extension object: ${size}`);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    }\n    writeU8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    }\n    writeU8a(values) {\n        const size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    }\n    writeI8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    }\n    writeU16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    }\n    writeI16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    }\n    writeU32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    }\n    writeI32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    }\n    writeU64(value) {\n        this.ensureBufferSizeToWrite(8);\n        setUint64(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeI64(value) {\n        this.ensureBufferSizeToWrite(8);\n        setInt64(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeBigUint64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    }\n    writeBigInt64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    }\n}\n//# sourceMappingURL=Encoder.mjs.map","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n}\n//# sourceMappingURL=ExtData.mjs.map","// ExtensionCodec to handle MessagePack extensions\nimport { ExtData } from \"./ExtData.mjs\";\nimport { timestampExtension } from \"./timestamp.mjs\";\nexport class ExtensionCodec {\n    constructor() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(timestampExtension);\n    }\n    register({ type, encode, decode, }) {\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            const index = -1 - type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    }\n    tryToEncode(object, context) {\n        // built-in extensions\n        for (let i = 0; i < this.builtInEncoders.length; i++) {\n            const encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = -1 - i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (let i = 0; i < this.encoders.length; i++) {\n            const encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    }\n    decode(data, type, context) {\n        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new ExtData(type, data);\n        }\n    }\n}\nExtensionCodec.defaultCodec = new ExtensionCodec();\n//# sourceMappingURL=ExtensionCodec.mjs.map","import { Decoder } from \"./Decoder.mjs\";\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode(buffer, options) {\n    const decoder = new Decoder(options);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti(buffer, options) {\n    const decoder = new Decoder(options);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map","import { Decoder } from \"./Decoder.mjs\";\nimport { ensureAsyncIterable } from \"./utils/stream.mjs\";\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport async function decodeAsync(streamLike, options) {\n    const stream = ensureAsyncIterable(streamLike);\n    const decoder = new Decoder(options);\n    return decoder.decodeAsync(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeArrayStream(streamLike, options) {\n    const stream = ensureAsyncIterable(streamLike);\n    const decoder = new Decoder(options);\n    return decoder.decodeArrayStream(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream(streamLike, options) {\n    const stream = ensureAsyncIterable(streamLike);\n    const decoder = new Decoder(options);\n    return decoder.decodeStream(stream);\n}\n//# sourceMappingURL=decodeAsync.mjs.map","import { Encoder } from \"./Encoder.mjs\";\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode(value, options) {\n    const encoder = new Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map","// Main Functions:\nimport { encode } from \"./encode.mjs\";\nexport { encode };\nimport { decode, decodeMulti } from \"./decode.mjs\";\nexport { decode, decodeMulti };\nimport { decodeAsync, decodeArrayStream, decodeMultiStream } from \"./decodeAsync.mjs\";\nexport { decodeAsync, decodeArrayStream, decodeMultiStream };\nimport { Decoder } from \"./Decoder.mjs\";\nexport { Decoder };\nimport { DecodeError } from \"./DecodeError.mjs\";\nexport { DecodeError };\nimport { Encoder } from \"./Encoder.mjs\";\nexport { Encoder };\n// Utilities for Extension Types:\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nexport { ExtensionCodec };\nimport { ExtData } from \"./ExtData.mjs\";\nexport { ExtData };\nimport { EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension, } from \"./timestamp.mjs\";\nexport { EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension, };\n//# sourceMappingURL=index.mjs.map","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.mjs\";\nimport { getInt64, setInt64 } from \"./utils/int.mjs\";\nexport const EXT_TIMESTAMP = -1;\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nexport function encodeTimeSpecToTimestamp({ sec, nsec }) {\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            const rv = new Uint8Array(4);\n            const view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            const secHigh = sec / 0x100000000;\n            const secLow = sec & 0xffffffff;\n            const rv = new Uint8Array(8);\n            const view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        const rv = new Uint8Array(12);\n        const view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        setInt64(view, 4, sec);\n        return rv;\n    }\n}\nexport function encodeDateToTimeSpec(date) {\n    const msec = date.getTime();\n    const sec = Math.floor(msec / 1e3);\n    const nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    const nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nexport function encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        const timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nexport function decodeTimestampToTimeSpec(data) {\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            const sec = view.getUint32(0);\n            const nsec = 0;\n            return { sec, nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            const nsec30AndSecHigh2 = view.getUint32(0);\n            const secLow32 = view.getUint32(4);\n            const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            const nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec, nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            const sec = getInt64(view, 4);\n            const nsec = view.getUint32(0);\n            return { sec, nsec };\n        }\n        default:\n            throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n    }\n}\nexport function decodeTimestampExtension(data) {\n    const timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nexport const timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map","// Integer Utility\nexport const UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nexport function setUint64(view, offset, value) {\n    const high = value / 4294967296;\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function setInt64(view, offset, value) {\n    const high = Math.floor(value / 4294967296);\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function getInt64(view, offset) {\n    const high = view.getInt32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nexport function getUint64(view, offset) {\n    const high = view.getUint32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map","export function prettyByte(byte) {\n    return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n//# sourceMappingURL=prettyByte.mjs.map","// utility for whatwg streams\nexport function isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nexport async function* asyncIterableFromStream(stream) {\n    const reader = stream.getReader();\n    try {\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n                return;\n            }\n            yield value;\n        }\n    }\n    finally {\n        reader.releaseLock();\n    }\n}\nexport function ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map","function isArrayBufferLike(buffer) {\n    return (buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer));\n}\nexport function ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (isArrayBufferLike(buffer)) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\n//# sourceMappingURL=typedArrays.mjs.map","export function utf8Count(str) {\n    const strLength = str.length;\n    let byteLength = 0;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nexport function utf8EncodeJs(str, output, outputOffset) {\n    const strLength = str.length;\n    let offset = outputOffset;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nconst sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\nexport function utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nexport function utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nconst CHUNK_SIZE = 4096;\nexport function utf8DecodeJs(bytes, inputOffset, byteLength) {\n    let offset = inputOffset;\n    const end = offset + byteLength;\n    const units = [];\n    let result = \"\";\n    while (offset < end) {\n        const byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            const byte4 = bytes[offset++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode(...units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode(...units);\n    }\n    return result;\n}\nconst sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\nexport function utf8DecodeTD(bytes, inputOffset, byteLength) {\n    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nexport function utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst weierstrass_ts_1 = require(\"./abstract/weierstrass.js\");\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return { hash };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.negateCt = negateCt;\nexports.normalizeZ = normalizeZ;\nexports.wNAF = wNAF;\nexports.mulEndoUnsafe = mulEndoUnsafe;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\nexports._createCurveFields = _createCurveFields;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nfunction normalizeZ(c, property, points) {\n    const getz = property === 'pz' ? (p) => p.pz : (p) => p.ez;\n    const toInv = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(getz));\n    // @ts-ignore\n    const affined = points.map((p, i) => p.toAffine(toInv[i]));\n    return affined.map(c.fromAffine);\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate: negateCt,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(negateCt(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(negateCt(isNeg, precomputes[offset]));\n                }\n            }\n            assert0(n);\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            assert0(n);\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    // Doing transform outside of if brings 15% perf hit\n                    if (typeof transform === 'function')\n                        comp = transform(comp);\n                    pointPrecomputes.set(P, comp);\n                }\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nfunction mulEndoUnsafe(c, point, k1, k2) {\n    let acc = point;\n    let p1 = c.ZERO;\n    let p2 = c.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */\nfunction validateBasic(curve) {\n    (0, modular_ts_1.validateField)(curve.Fp);\n    (0, utils_ts_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nfunction createField(order, field) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        (0, modular_ts_1.validateField)(field);\n        return field;\n    }\n    else {\n        return (0, modular_ts_1.Field)(order);\n    }\n}\n/** Validates CURVE opts and creates fields */\nfunction _createCurveFields(type, CURVE, curveOpts = {}) {\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp);\n    const Fn = createField(CURVE.n, curveOpts.Fn);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    return { Fp, Fn };\n}\n//# sourceMappingURL=curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edwards = edwards;\nexports.eddsa = eddsa;\nexports.twistedEdwards = twistedEdwards;\n/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst curve_ts_1 = require(\"./curve.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nfunction edwards(CURVE, curveOpts = {}) {\n    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('edwards', CURVE, curveOpts);\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0, utils_ts_1._validateObject)(curveOpts, {}, { uvRatio: 'function' });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n    const modP = (n) => Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = curveOpts.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    // Validate whether the passed curve params are valid.\n    // equation ax + y = 1 + dxy should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */\n    function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = acoord('x', ex);\n            this.ey = acoord('y', ey);\n            this.ez = acoord('z', ez, true);\n            this.et = acoord('t', et);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            acoord('x', x);\n            acoord('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            return (0, curve_ts_1.normalizeZ)(Point, 'ez', points);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.setWindowSize(this, windowSize);\n            if (!isLazy)\n                this.multiply(_2n); // random number\n            return this;\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            (0, utils_ts_1.aInRange)('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            (0, utils_ts_1.aInRange)('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return Point.ZERO;\n            if (this.is0() || n === _1n)\n                return this;\n            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        static fromBytes(bytes, zip215 = false) {\n            (0, utils_ts_1.abytes)(bytes);\n            return this.fromHex(bytes, zip215);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0, utils_ts_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            (0, utils_ts_1.abool)('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = (0, utils_ts_1.bytesToNumberLE)(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            (0, utils_ts_1.aInRange)('pointHex.y', y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateScalar(scalar) {\n            return Point.BASE.multiply(scalar);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = (0, utils_ts_1.numberToBytesLE)(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        /** @deprecated use `toBytes` */\n        toRawBytes() {\n            return this.toBytes();\n        }\n        toHex() {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // fields\n    Point.Fp = Fp;\n    Point.Fn = Fn;\n    const wnaf = (0, curve_ts_1.wNAF)(Point, Fn.BYTES * 8); // Fn.BITS?\n    return Point;\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nfunction eddsa(Point, eddsaOpts) {\n    (0, utils_ts_1._validateObject)(eddsaOpts, {\n        hash: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        randomBytes: 'function',\n        domain: 'function',\n        prehash: 'function',\n        mapToCurve: 'function',\n    });\n    const { prehash, hash: cHash } = eddsaOpts;\n    const { BASE: G, Fp, Fn } = Point;\n    const CURVE_ORDER = Fn.ORDER;\n    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1.randomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = eddsaOpts.domain ||\n        ((data, ctx, phflag) => {\n            (0, utils_ts_1.abool)('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    function modN(a) {\n        return Fn.create(a);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n        return modN((0, utils_ts_1.bytesToNumberLE)(hash));\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = Fp.BYTES;\n        key = (0, utils_ts_1.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    // Convenience method that creates public key from scalar. RFC8032 5.1.5\n    function getExtendedPublicKey(key) {\n        const { head, prefix, scalar } = getPrivateScalar(key);\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = (0, utils_ts_1.concatBytes)(...msgs);\n        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0, utils_ts_1.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        (0, utils_ts_1.aInRange)('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const L = Fp.BYTES;\n        const res = (0, utils_ts_1.concatBytes)(R, (0, utils_ts_1.numberToBytesLE)(s, L));\n        return (0, utils_ts_1.ensureBytes)('result', res, L * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0, utils_ts_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0, utils_ts_1.ensureBytes)('message', msg);\n        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, len);\n        if (zip215 !== undefined)\n            (0, utils_ts_1.abool)('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = (0, utils_ts_1.bytesToNumberLE)(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n        randomPrivateKey: () => randomBytes_(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return { getPublicKey, sign, verify, utils, Point };\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);\n    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };\n    const eddsaOpts = {\n        hash: c.hash,\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve,\n    };\n    return { CURVE, curveOpts, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n//# sourceMappingURL=edwards.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_ts_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_ts_1._validateObject)(options, {\n        p: 'bigint',\n        m: 'number',\n        k: 'number',\n        hash: 'function',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    if (!(0, utils_ts_1.isBytes)(_DST) && typeof _DST !== 'string')\n        throw new Error('DST must be string or uint8array');\n    if (!(0, utils_ts_1.isHash)(options.hash))\n        throw new Error('expected valid hash');\n    (0, utils_ts_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nfunction createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve(msg, options) {\n            const dst = defaults.DST ? defaults.DST : {};\n            const opts = Object.assign({}, defaults, dst, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve(msg, options) {\n            const dst = defaults.encodeDST ? defaults.encodeDST : {};\n            const opts = Object.assign({}, defaults, dst, options);\n            const u = hash_to_field(msg, 1, opts);\n            return clear(map(u[0]));\n        },\n        /** See {@link H2CHasher} */\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\nconst _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    (0, utils_ts_1._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        (0, utils_ts_1.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_ts_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.montgomery = montgomery;\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    (0, utils_ts_1._validateObject)(curve, {\n        adjustScalarBytes: 'function',\n        powPminus2: 'function',\n    });\n    return Object.freeze({ ...curve });\n}\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === 'x25519';\n    if (!is25519 && type !== 'x448')\n        throw new Error('invalid type');\n    const randomBytes_ = rand || utils_ts_1.randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519\n        ? BigInt(8) * _2n ** BigInt(251) - _1n\n        : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n) => (0, modular_ts_1.mod)(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519)\n            _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP((0, utils_ts_1.bytesToNumberLE)(_u));\n    }\n    function decodeScalar(scalar) {\n        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('invalid private or public key received');\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return { x_2, x_3 };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        (0, utils_ts_1.aInRange)('u', u, _0n, P);\n        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => randomBytes_(fieldLen) },\n        GuBytes: GuBytes.slice(),\n    };\n}\n//# sourceMappingURL=montgomery.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DER = exports.DERErr = void 0;\nexports._legacyHelperEquat = _legacyHelperEquat;\nexports._legacyHelperNormPriv = _legacyHelperNormPriv;\nexports.weierstrassN = weierstrassN;\nexports.weierstrassPoints = weierstrassPoints;\nexports.ecdsa = ecdsa;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_js_1 = require(\"@noble/hashes/hmac.js\");\nconst utils_ts_1 = require(\"../utils.js\");\nconst curve_ts_1 = require(\"./curve.js\");\nconst modular_ts_1 = require(\"./modular.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0, utils_ts_1.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0, utils_ts_1.abool)('prehash', opts.prehash);\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';\n            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return (0, utils_ts_1.bytesToNumberBE)(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = (0, utils_ts_1.ensureBytes)('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// TODO: remove\nfunction _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {\n    const { BYTES: expected } = Fn;\n    // Validates if priv key is valid and converts it to bigint.\n    function normPrivateKeyToScalar(key) {\n        let num;\n        if (typeof key === 'bigint') {\n            num = key;\n        }\n        else {\n            let bytes = (0, utils_ts_1.ensureBytes)('private key', key);\n            if (allowedPrivateKeyLengths) {\n                if (!allowedPrivateKeyLengths.includes(bytes.length * 2))\n                    throw new Error('invalid private key');\n                const padded = new Uint8Array(expected);\n                padded.set(bytes, padded.length - bytes.length);\n                bytes = padded;\n            }\n            try {\n                num = Fn.fromBytes(bytes);\n            }\n            catch (error) {\n                throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n            }\n        }\n        if (wrapPrivateKey)\n            num = Fn.create(num); // disabled by default, enabled for BLS\n        if (!Fn.isValidNot0(num))\n            throw new Error('invalid private key: out of range [1..N-1]');\n        return num;\n    }\n    return normPrivateKeyToScalar;\n}\nfunction weierstrassN(CURVE, curveOpts = {}) {\n    const { Fp, Fn } = (0, curve_ts_1._createCurveFields)('weierstrass', CURVE, curveOpts);\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0, utils_ts_1._validateObject)(curveOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = curveOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        (0, utils_ts_1.abool)('isCompressed', isCompressed);\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);\n        }\n        else {\n            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        (0, utils_ts_1.abytes)(bytes);\n        const L = Fp.BYTES;\n        const LC = L + 1; // length compressed, e.g. 33 for 32-byte field\n        const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === LC && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === LU && head === 0x04) {\n            // TODO: more checks\n            const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));\n            const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);\n        }\n    }\n    const toBytes = curveOpts.toBytes || pointToBytes;\n    const fromBytes = curveOpts.fromBytes || pointFromBytes;\n    const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (curveOpts.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);\n        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);\n        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(px, py, pz) {\n            this.px = acoord('x', px);\n            this.py = acoord('y', py, true);\n            this.pz = acoord('z', pz);\n            Object.freeze(this);\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static normalizeZ(points) {\n            return (0, curve_ts_1.normalizeZ)(Point, 'pz', points);\n        }\n        static fromBytes(bytes) {\n            (0, utils_ts_1.abytes)(bytes);\n            return Point.fromHex(bytes);\n        }\n        /** Converts hash string or Uint8Array to Point. */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        /** Multiplies generator point by privateKey. */\n        static fromPrivateKey(privateKey) {\n            const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        /** Multiscalar Multiplication */\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.setWindowSize(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        /** \"Private method\", don't use it directly */\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = curveOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.wNAFCached(this, n, Point.normalizeZ);\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = curveOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasPrecomputes(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n                // `wNAFCachedUnsafe` is 30% slower\n                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.wNAFCachedUnsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = curveOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = curveOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes(isCompressed = true) {\n            (0, utils_ts_1.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        /** @deprecated use `toBytes` */\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // fields\n    Point.Fp = Fp;\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = (0, curve_ts_1.wNAF)(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);\n    return Point;\n}\n// _legacyWeierstrass\n/** @deprecated use `weierstrassN` */\nfunction weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\nfunction ecdsa(Point, ecdsaOpts, curveOpts = {}) {\n    (0, utils_ts_1._validateObject)(ecdsaOpts, { hash: 'function' }, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;\n    const hmac_ = ecdsaOpts.hmac ||\n        ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1.concatBytes)(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;\n    }\n    function aValidRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            aValidRS('r', r); // r in [1..N-1]\n            aValidRS('s', s); // s in [1..N-1]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const L = Fn.BYTES;\n            const b = (0, utils_ts_1.ensureBytes)('compactSignature', hex, L * 2);\n            return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        // ProjPointType<bigint>\n        recoverPublicKey(msgHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromHex((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toBytes(format) {\n            if (format === 'compact')\n                return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));\n            if (format === 'der')\n                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));\n            throw new Error('invalid format');\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));\n        }\n    }\n    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const n = CURVE_ORDER;\n            return (0, modular_ts_1.mapHashToField)(randomBytes_((0, modular_ts_1.getMinHashLength)(n)), n);\n        },\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const arr = (0, utils_ts_1.ensureBytes)('key', item);\n        const length = arr.length;\n        const L = Fp.BYTES;\n        const LC = L + 1; // e.g. 33 for 32\n        const LU = 2 * L + 1; // e.g. 65 for 32\n        if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {\n            return undefined;\n        }\n        else {\n            return length === LC || length === LU;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicB) === false)\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function (bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash } = ecdsaOpts;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0, utils_ts_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };\n    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = (0, utils_ts_1.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE.precompute(8);\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);\n        // Verify opts\n        validateSigVerOpts(opts);\n        const { lowS, prehash, format } = opts;\n        // TODO: remove\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && !['compact', 'der', 'js'].includes(format))\n            throw new Error('format must be \"compact\", \"der\" or \"js\"');\n        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        // deduce signature format\n        try {\n            // if (format === 'js') {\n            //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);\n            // } else if (format === 'compact') {\n            //   _sig = Signature.fromCompact(sg);\n            // } else if (format === 'der') {\n            //   _sig = Signature.fromDER(sg);\n            // } else {\n            //   throw new Error('invalid format');\n            // }\n            if (isObj) {\n                if (format === undefined || format === 'js') {\n                    _sig = new Signature(sg.r, sg.s);\n                }\n                else {\n                    throw new Error('invalid format');\n                }\n            }\n            if (isHex) {\n                // TODO: remove this malleable check\n                // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).\n                // Since DER can also be 2*Fn.BYTES bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        // todo: optional.hash => hash\n        if (prehash)\n            msgHash = ecdsaOpts.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = Fn.inv(s); // s^-1\n        const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n        const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\n        if (R.is0())\n            return false;\n        const v = Fn.create(R.x); // v = r.x mod n\n        return v === r;\n    }\n    // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?\n    // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);\n    return Object.freeze({\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        utils,\n        Point,\n        Signature,\n    });\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength);\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        wrapPrivateKey: c.wrapPrivateKey,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hash: c.hash,\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, ecdsaOpts };\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    // TODO: remove\n    function isWithinCurveOrder(num) {\n        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, ecdsa) {\n    return Object.assign({}, ecdsa, {\n        ProjectivePoint: ecdsa.Point,\n        CURVE: c,\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, ecdsaOpts, curveOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_ts_1.validateField)(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;\nexports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;\nexports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha2_js_1 = require(\"@noble/hashes/sha2.js\");\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nconst curve_ts_1 = require(\"./abstract/curve.js\");\nconst edwards_ts_1 = require(\"./abstract/edwards.js\");\nconst hash_to_curve_ts_1 = require(\"./abstract/hash-to-curve.js\");\nconst modular_ts_1 = require(\"./abstract/modular.js\");\nconst montgomery_ts_1 = require(\"./abstract/montgomery.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// 2n**255n - 19n\n// Removing Fp.create() will still work, and is 10% faster on sign\n//     a: Fp.create(BigInt(-1)),\n// d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n// Finite field 2n**255n - 19n\n// Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\nconst ed25519_CURVE = {\n    p: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'),\n    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n    h: _8n,\n    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n};\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE.p;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE.p;\n    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v\n    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0, modular_ts_1.isNegativeLE)(x, P))\n        x = (0, modular_ts_1.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n/** Weird / bogus points, useful for debugging. */\nexports.ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    ...ed25519_CURVE,\n    Fp,\n    hash: sha2_js_1.sha512,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\nexports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: sha2_js_1.sha512,\n})))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexports.x25519 = (() => {\n    const P = ed25519_CURVE.p;\n    return (0, montgomery_ts_1.montgomery)({\n        P,\n        type: 'x25519',\n        powPminus2: (x) => {\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes,\n    });\n})();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const bpub = (0, utils_ts_1.ensureBytes)('pub', edwardsPub);\n    const { y } = exports.ed25519.Point.fromHex(bpub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true); // batch division\n    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\nexports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha2_js_1.sha512,\n}))();\nexports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();\nexports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();\nfunction aristp(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = exports.ed25519.CURVE;\n    const P = exports.ed25519.CURVE.Fp.ORDER;\n    const mod = exports.ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0, modular_ts_1.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(exports.ed25519.Point.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n     * the [website](https://ristretto.group/formulas/elligator.html).\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    static fromBytes(bytes) {\n        (0, utils_js_1.abytes)(bytes);\n        return this.fromHex(bytes);\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = exports.ed25519.CURVE;\n        const P = Fp.ORDER;\n        const mod = Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0, modular_ts_1.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new exports.ed25519.Point(x, y, _1n, t));\n    }\n    static msm(points, scalars) {\n        const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);\n        return (0, curve_ts_1.pippenger)(RistPoint, Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */\n    toBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = Fp.ORDER;\n        const mod = Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0, modular_ts_1.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0, modular_ts_1.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0, utils_ts_1.numberToBytesLE)(s, 32); // 11\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes() {\n        return this.toBytes();\n    }\n    toHex() {\n        return (0, utils_ts_1.bytesToHex)(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */\n    equals(other) {\n        aristp(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        aristp(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        aristp(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\n/**\n * Wrapper over Edwards Point for ristretto255 from\n * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nexports.RistrettoPoint = (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);\n    return RistPoint;\n})();\n/**\n * hash-to-curve for ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).\n */\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0, utils_js_1.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nexports.hashToRistretto255 = hashToRistretto255;\n/** @deprecated */\nexports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.p521_hasher = exports.secp521r1 = exports.p521 = exports.p384_hasher = exports.secp384r1 = exports.p384 = exports.p256_hasher = exports.secp256r1 = exports.p256 = void 0;\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha2_js_1 = require(\"@noble/hashes/sha2.js\");\nconst _shortw_utils_ts_1 = require(\"./_shortw_utils.js\");\nconst hash_to_curve_ts_1 = require(\"./abstract/hash-to-curve.js\");\nconst modular_ts_1 = require(\"./abstract/modular.js\");\nconst weierstrass_ts_1 = require(\"./abstract/weierstrass.js\");\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE = {\n    p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    h: BigInt(1),\n    a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n    b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'),\n    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n    h: BigInt(1),\n    a: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'),\n    b: BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'),\n    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n};\n// p = 2n**521n - 1n\nconst p521_CURVE = {\n    p: BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),\n    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),\n    h: BigInt(1),\n    a: BigInt('0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'),\n    b: BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'),\n    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),\n    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),\n};\nconst Fp256 = (0, modular_ts_1.Field)(p256_CURVE.p);\nconst Fp384 = (0, modular_ts_1.Field)(p384_CURVE.p);\nconst Fp521 = (0, modular_ts_1.Field)(p521_CURVE.p);\nfunction createSWU(field, opts) {\n    const map = (0, weierstrass_ts_1.mapToCurveSimpleSWU)(field, opts);\n    return (scalars) => map(scalars[0]);\n}\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */\nexports.p256 = (0, _shortw_utils_ts_1.createCurve)({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha2_js_1.sha256);\n/** Alias to p256. */\nexports.secp256r1 = exports.p256;\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexports.p256_hasher = (() => {\n    return (0, hash_to_curve_ts_1.createHasher)(exports.p256.Point, createSWU(Fp256, {\n        A: p256_CURVE.a,\n        B: p256_CURVE.b,\n        Z: Fp256.create(BigInt('-10')),\n    }), {\n        DST: 'P256_XMD:SHA-256_SSWU_RO_',\n        encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n        p: p256_CURVE.p,\n        m: 1,\n        k: 128,\n        expand: 'xmd',\n        hash: sha2_js_1.sha256,\n    });\n})();\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */\nexports.p384 = (0, _shortw_utils_ts_1.createCurve)({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha2_js_1.sha384);\n/** Alias to p384. */\nexports.secp384r1 = exports.p384;\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexports.p384_hasher = (() => {\n    return (0, hash_to_curve_ts_1.createHasher)(exports.p384.Point, createSWU(Fp384, {\n        A: p384_CURVE.a,\n        B: p384_CURVE.b,\n        Z: Fp384.create(BigInt('-12')),\n    }), {\n        DST: 'P384_XMD:SHA-384_SSWU_RO_',\n        encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n        p: p384_CURVE.p,\n        m: 1,\n        k: 192,\n        expand: 'xmd',\n        hash: sha2_js_1.sha384,\n    });\n})();\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */\nexports.p521 = (0, _shortw_utils_ts_1.createCurve)({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha2_js_1.sha512);\n/** Alias to p521. */\nexports.secp521r1 = exports.p521;\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexports.p521_hasher = (() => {\n    return (0, hash_to_curve_ts_1.createHasher)(exports.p521.Point, createSWU(Fp521, {\n        A: p521_CURVE.a,\n        B: p521_CURVE.b,\n        Z: Fp521.create(BigInt('-4')),\n    }), {\n        DST: 'P521_XMD:SHA-512_SSWU_RO_',\n        encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n        p: p521_CURVE.p,\n        m: 1,\n        k: 256,\n        expand: 'xmd',\n        hash: sha2_js_1.sha512,\n    });\n})();\n//# sourceMappingURL=nist.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.secp256r1 = exports.p256 = void 0;\nconst nist_ts_1 = require(\"./nist.js\");\nexports.p256 = nist_ts_1.p256;\nexports.secp256r1 = nist_ts_1.p256;\nexports.hashToCurve = (() => nist_ts_1.p256_hasher.hashToCurve)();\nexports.encodeToCurve = (() => nist_ts_1.p256_hasher.encodeToCurve)();\n//# sourceMappingURL=p256.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.secp384r1 = exports.p384 = void 0;\nconst nist_ts_1 = require(\"./nist.js\");\nexports.p384 = nist_ts_1.p384;\nexports.secp384r1 = nist_ts_1.p384;\nexports.hashToCurve = (() => nist_ts_1.p384_hasher.hashToCurve)();\nexports.encodeToCurve = (() => nist_ts_1.p384_hasher.encodeToCurve)();\n/** @deprecated Use `import { p384_hasher } from \"@noble/curves/nist\"` module. */\n//# sourceMappingURL=p384.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.secp521r1 = exports.p521 = void 0;\nconst nist_ts_1 = require(\"./nist.js\");\nexports.p521 = nist_ts_1.p521;\nexports.secp521r1 = nist_ts_1.p521;\nexports.hashToCurve = (() => nist_ts_1.p521_hasher.hashToCurve)();\nexports.encodeToCurve = (() => nist_ts_1.p521_hasher.encodeToCurve)();\n//# sourceMappingURL=p521.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.equalBytes = equalBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.isHash = isHash;\nexports._validateObject = _validateObject;\nexports.memoized = memoized;\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nvar utils_js_2 = require(\"@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"abytes\", { enumerable: true, get: function () { return utils_js_2.abytes; } });\nObject.defineProperty(exports, \"anumber\", { enumerable: true, get: function () { return utils_js_2.anumber; } });\nObject.defineProperty(exports, \"bytesToHex\", { enumerable: true, get: function () { return utils_js_2.bytesToHex; } });\nObject.defineProperty(exports, \"bytesToUtf8\", { enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } });\nObject.defineProperty(exports, \"concatBytes\", { enumerable: true, get: function () { return utils_js_2.concatBytes; } });\nObject.defineProperty(exports, \"hexToBytes\", { enumerable: true, get: function () { return utils_js_2.hexToBytes; } });\nObject.defineProperty(exports, \"isBytes\", { enumerable: true, get: function () { return utils_js_2.isBytes; } });\nObject.defineProperty(exports, \"randomBytes\", { enumerable: true, get: function () { return utils_js_2.randomBytes; } });\nObject.defineProperty(exports, \"utf8ToBytes\", { enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } });\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0, utils_js_1.abytes)(bytes);\n    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = (0, utils_js_1.hexToBytes)(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if ((0, utils_js_1.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0, utils_js_1.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = require(\"./utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports.default = u64;\n//# sourceMappingURL=_u64.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nconst utils_ts_1 = require(\"./utils.js\");\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = require(\"./_md.js\");\nconst u64 = require(\"./_u64.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;\nexports.keccakP = keccakP;\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nconst _u64_ts_1 = require(\"./_u64.js\");\n// prettier-ignore\nconst utils_ts_1 = require(\"./utils.js\");\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0, utils_ts_1.clean)(B);\n}\n/** Keccak sponge function. */\nclass Keccak extends utils_ts_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0, utils_ts_1.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_ts_1.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, utils_ts_1.aexists)(this, false);\n        (0, utils_ts_1.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_ts_1.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map","\"use strict\";\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XOF256 = exports.XOF128 = exports.genCrystals = void 0;\n/**\n * Internal methods for lattice-based ML-KEM and ML-DSA.\n * @module\n */\n/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nconst sha3_1 = require(\"@noble/hashes/sha3\");\nconst utils_ts_1 = require(\"./utils.js\");\n// TODO: benchmark\nfunction bitReversal(n, bits = 8) {\n    const padded = n.toString(2).padStart(8, '0');\n    const sliced = padded.slice(-bits).padStart(7, '0');\n    const revrsd = sliced.split('').reverse().join('');\n    return Number.parseInt(revrsd, 2);\n}\nconst genCrystals = (opts) => {\n    // isKyber: true means Kyber, false means Dilithium\n    const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits, isKyber } = opts;\n    const mod = (a, modulo = Q) => {\n        const result = a % modulo | 0;\n        return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;\n    };\n    // -(Q-1)/2 < a <= (Q-1)/2\n    const smod = (a, modulo = Q) => {\n        const r = mod(a, modulo) | 0;\n        return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;\n    };\n    // Generate zettas\n    function getZettas() {\n        const out = newPoly(N);\n        for (let i = 0; i < N; i++) {\n            const b = bitReversal(i, brvBits);\n            const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);\n            out[i] = Number(p) | 0;\n        }\n        return out;\n    }\n    const nttZetas = getZettas();\n    // Number-Theoretic Transform\n    // Explained: https://electricdusk.com/ntt.html\n    // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,\n    // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.\n    // TODO: there should be less ugly way to define this.\n    const LEN1 = isKyber ? 128 : N;\n    const LEN2 = isKyber ? 1 : 0;\n    const NTT = {\n        encode: (r) => {\n            for (let k = 1, len = 128; len > LEN2; len >>= 1) {\n                for (let start = 0; start < N; start += 2 * len) {\n                    const zeta = nttZetas[k++];\n                    for (let j = start; j < start + len; j++) {\n                        const t = mod(zeta * r[j + len]);\n                        r[j + len] = mod(r[j] - t) | 0;\n                        r[j] = mod(r[j] + t) | 0;\n                    }\n                }\n            }\n            return r;\n        },\n        decode: (r) => {\n            for (let k = LEN1 - 1, len = 1 + LEN2; len < LEN1 + LEN2; len <<= 1) {\n                for (let start = 0; start < N; start += 2 * len) {\n                    const zeta = nttZetas[k--];\n                    for (let j = start; j < start + len; j++) {\n                        const t = r[j];\n                        r[j] = mod(t + r[j + len]);\n                        r[j + len] = mod(zeta * (r[j + len] - t));\n                    }\n                }\n            }\n            for (let i = 0; i < r.length; i++)\n                r[i] = mod(F * r[i]);\n            return r;\n        },\n    };\n    // Encode polynominal as bits\n    const bitsCoder = (d, c) => {\n        const mask = (0, utils_ts_1.getMask)(d);\n        const bytesLen = d * (N / 8);\n        return {\n            bytesLen,\n            encode: (poly) => {\n                const r = new Uint8Array(bytesLen);\n                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {\n                    buf |= (c.encode(poly[i]) & mask) << bufLen;\n                    bufLen += d;\n                    for (; bufLen >= 8; bufLen -= 8, buf >>= 8)\n                        r[pos++] = buf & (0, utils_ts_1.getMask)(bufLen);\n                }\n                return r;\n            },\n            decode: (bytes) => {\n                const r = newPoly(N);\n                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {\n                    buf |= bytes[i] << bufLen;\n                    bufLen += 8;\n                    for (; bufLen >= d; bufLen -= d, buf >>= d)\n                        r[pos++] = c.decode(buf & mask);\n                }\n                return r;\n            },\n        };\n    };\n    return { mod, smod, nttZetas, NTT, bitsCoder };\n};\nexports.genCrystals = genCrystals;\nconst createXofShake = (shake) => (seed, blockLen) => {\n    if (!blockLen)\n        blockLen = shake.blockLen;\n    // Optimizations that won't mater:\n    // - cached seed update (two .update(), on start and on the end)\n    // - another cache which cloned into working copy\n    // Faster than multiple updates, since seed less than blockLen\n    const _seed = new Uint8Array(seed.length + 2);\n    _seed.set(seed);\n    const seedLen = seed.length;\n    const buf = new Uint8Array(blockLen); // == shake128.blockLen\n    let h = shake.create({});\n    let calls = 0;\n    let xofs = 0;\n    return {\n        stats: () => ({ calls, xofs }),\n        get: (x, y) => {\n            _seed[seedLen + 0] = x;\n            _seed[seedLen + 1] = y;\n            h.destroy();\n            h = shake.create({}).update(_seed);\n            calls++;\n            return () => {\n                xofs++;\n                return h.xofInto(buf);\n            };\n        },\n        clean: () => {\n            h.destroy();\n            buf.fill(0);\n            _seed.fill(0);\n        },\n    };\n};\nexports.XOF128 = createXofShake(sha3_1.shake128);\nexports.XOF256 = createXofShake(sha3_1.shake256);\n//# sourceMappingURL=_crystals.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ml_dsa87 = exports.ml_dsa65 = exports.ml_dsa44 = exports.PARAMS = void 0;\n/**\n * ML-DSA: Module Lattice-based Digital Signature Algorithm from\n * [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd). A.k.a. CRYSTALS-Dilithium.\n *\n * Has similar internals to ML-KEM, but their keys and params are different.\n * Check out [official site](https://www.pq-crystals.org/dilithium/index.shtml),\n * [repo](https://github.com/pq-crystals/dilithium).\n * @module\n */\n/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nconst sha3_1 = require(\"@noble/hashes/sha3\");\nconst _crystals_ts_1 = require(\"./_crystals.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n// Constants\nconst N = 256;\n// 2**23  2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints\nconst Q = 8380417;\nconst ROOT_OF_UNITY = 1753;\n// f = 256**1 mod q, pow(256, -1, q) = 8347681 (python3)\nconst F = 8347681;\nconst D = 13;\n// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.\nconst GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;\nconst GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;\n/** Internal params for different versions of ML-DSA  */\n// prettier-ignore\nexports.PARAMS = {\n    2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },\n    3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },\n    5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },\n};\nconst newPoly = (n) => new Int32Array(n);\nconst { mod, smod, NTT, bitsCoder } = (0, _crystals_ts_1.genCrystals)({\n    N,\n    Q,\n    F,\n    ROOT_OF_UNITY,\n    newPoly,\n    isKyber: false,\n    brvBits: 8,\n});\nconst id = (n) => n;\nconst polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {\n    encode: (i) => compress(verify(i)),\n    decode: (i) => verify(compress(i)),\n});\nconst polyAdd = (a, b) => {\n    for (let i = 0; i < a.length; i++)\n        a[i] = mod(a[i] + b[i]);\n    return a;\n};\nconst polySub = (a, b) => {\n    for (let i = 0; i < a.length; i++)\n        a[i] = mod(a[i] - b[i]);\n    return a;\n};\nconst polyShiftl = (p) => {\n    for (let i = 0; i < N; i++)\n        p[i] <<= D;\n    return p;\n};\nconst polyChknorm = (p, B) => {\n    // Not very sure about this, but FIPS204 doesn't provide any function for that :(\n    for (let i = 0; i < N; i++)\n        if (Math.abs(smod(p[i])) >= B)\n            return true;\n    return false;\n};\nconst MultiplyNTTs = (a, b) => {\n    // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,\n    // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,\n    // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).\n    // Barrett reduction is slower than mod :(\n    const c = newPoly(N);\n    for (let i = 0; i < a.length; i++)\n        c[i] = mod(a[i] * b[i]);\n    return c;\n};\n// Return poly in NTT representation\nfunction RejNTTPoly(xof) {\n    // Samples a polynomial  Tq.\n    const r = newPoly(N);\n    // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(\n    for (let j = 0; j < N;) {\n        const b = xof();\n        if (b.length % 3)\n            throw new Error('RejNTTPoly: unaligned block');\n        for (let i = 0; j < N && i <= b.length - 3; i += 3) {\n            const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes\n            if (t < Q)\n                r[j++] = t;\n        }\n    }\n    return r;\n}\nfunction getDilithium(opts) {\n    const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;\n    const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256 } = opts;\n    if (![2, 4].includes(ETA))\n        throw new Error('Wrong ETA');\n    if (![1 << 17, 1 << 19].includes(GAMMA1))\n        throw new Error('Wrong GAMMA1');\n    if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))\n        throw new Error('Wrong GAMMA2');\n    const BETA = TAU * ETA;\n    const decompose = (r) => {\n        // Decomposes r into (r1, r0) such that r  r1(22) + r0 mod q.\n        const rPlus = mod(r);\n        const r0 = smod(rPlus, 2 * GAMMA2) | 0;\n        if (rPlus - r0 === Q - 1)\n            return { r1: 0 | 0, r0: (r0 - 1) | 0 };\n        const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;\n        return { r1, r0 }; // r1 = HighBits, r0 = LowBits\n    };\n    const HighBits = (r) => decompose(r).r1;\n    const LowBits = (r) => decompose(r).r0;\n    const MakeHint = (z, r) => {\n        // Compute hint bit indicating whether adding z to r alters the high bits of r.\n        // From dilithium code\n        const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;\n        // from FIPS204:\n        // // const r1 = HighBits(r);\n        // // const v1 = HighBits(r + z);\n        // // const res1 = +(r1 !== v1);\n        // But they return different results! However, decompose is same.\n        // So, either there is a bug in Dilithium ref implementation or in FIPS204.\n        // For now, lets use dilithium one, so test vectors can be passed.\n        // See\n        // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints\n        return res0;\n    };\n    const UseHint = (h, r) => {\n        // Returns the high bits of r adjusted according to hint h\n        const m = Math.floor((Q - 1) / (2 * GAMMA2));\n        const { r1, r0 } = decompose(r);\n        // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m\n        // 4: if h = 1 and r0  0 return (r1  1) mod m\n        if (h === 1)\n            return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;\n        return r1 | 0;\n    };\n    const Power2Round = (r) => {\n        // Decomposes r into (r1, r0) such that r  r1*(2**d) + r0 mod q.\n        const rPlus = mod(r);\n        const r0 = smod(rPlus, 2 ** D) | 0;\n        return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };\n    };\n    const hintCoder = {\n        bytesLen: OMEGA + K,\n        encode: (h) => {\n            if (h === false)\n                throw new Error('hint.encode: hint is false'); // should never happen\n            const res = new Uint8Array(OMEGA + K);\n            for (let i = 0, k = 0; i < K; i++) {\n                for (let j = 0; j < N; j++)\n                    if (h[i][j] !== 0)\n                        res[k++] = j;\n                res[OMEGA + i] = k;\n            }\n            return res;\n        },\n        decode: (buf) => {\n            const h = [];\n            let k = 0;\n            for (let i = 0; i < K; i++) {\n                const hi = newPoly(N);\n                if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA)\n                    return false;\n                for (let j = k; j < buf[OMEGA + i]; j++) {\n                    if (j > k && buf[j] <= buf[j - 1])\n                        return false;\n                    hi[buf[j]] = 1;\n                }\n                k = buf[OMEGA + i];\n                h.push(hi);\n            }\n            for (let j = k; j < OMEGA; j++)\n                if (buf[j] !== 0)\n                    return false;\n            return h;\n        },\n    };\n    const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i) => ETA - i, (i) => {\n        if (!(-ETA <= i && i <= ETA))\n            throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);\n        return i;\n    });\n    const T0Coder = polyCoder(13, (i) => (1 << (D - 1)) - i);\n    const T1Coder = polyCoder(10);\n    // Requires smod. Need to fix!\n    const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i) => smod(GAMMA1 - i));\n    const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);\n    const W1Vec = (0, utils_ts_1.vecCoder)(W1Coder, K);\n    // Main structures\n    const publicCoder = (0, utils_ts_1.splitCoder)(32, (0, utils_ts_1.vecCoder)(T1Coder, K));\n    const secretCoder = (0, utils_ts_1.splitCoder)(32, 32, TR_BYTES, (0, utils_ts_1.vecCoder)(ETACoder, L), (0, utils_ts_1.vecCoder)(ETACoder, K), (0, utils_ts_1.vecCoder)(T0Coder, K));\n    const sigCoder = (0, utils_ts_1.splitCoder)(C_TILDE_BYTES, (0, utils_ts_1.vecCoder)(ZCoder, L), hintCoder);\n    const CoefFromHalfByte = ETA === 2\n        ? (n) => (n < 15 ? 2 - (n % 5) : false)\n        : (n) => (n < 9 ? 4 - n : false);\n    // Return poly in NTT representation\n    function RejBoundedPoly(xof) {\n        // Samples an element a  Rq with coeffcients in [, ] computed via rejection sampling from .\n        const r = newPoly(N);\n        for (let j = 0; j < N;) {\n            const b = xof();\n            for (let i = 0; j < N && i < b.length; i += 1) {\n                // half byte. Should be superfast with vector instructions. But very slow with js :(\n                const d1 = CoefFromHalfByte(b[i] & 0x0f);\n                const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);\n                if (d1 !== false)\n                    r[j++] = d1;\n                if (j < N && d2 !== false)\n                    r[j++] = d2;\n            }\n        }\n        return r;\n    }\n    const SampleInBall = (seed) => {\n        // Samples a polynomial c  Rq with coeffcients from {1, 0, 1} and Hamming weight \n        const pre = newPoly(N);\n        const s = sha3_1.shake256.create({}).update(seed);\n        const buf = new Uint8Array(sha3_1.shake256.blockLen);\n        s.xofInto(buf);\n        const masks = buf.slice(0, 8);\n        for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {\n            let b = i + 1;\n            for (; b > i;) {\n                b = buf[pos++];\n                if (pos < sha3_1.shake256.blockLen)\n                    continue;\n                s.xofInto(buf);\n                pos = 0;\n            }\n            pre[i] = pre[b];\n            pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);\n            if (maskBit >= 8) {\n                maskPos++;\n                maskBit = 0;\n            }\n        }\n        return pre;\n    };\n    const polyPowerRound = (p) => {\n        const res0 = newPoly(N);\n        const res1 = newPoly(N);\n        for (let i = 0; i < p.length; i++) {\n            const { r0, r1 } = Power2Round(p[i]);\n            res0[i] = r0;\n            res1[i] = r1;\n        }\n        return { r0: res0, r1: res1 };\n    };\n    const polyUseHint = (u, h) => {\n        for (let i = 0; i < N; i++)\n            u[i] = UseHint(h[i], u[i]);\n        return u;\n    };\n    const polyMakeHint = (a, b) => {\n        const v = newPoly(N);\n        let cnt = 0;\n        for (let i = 0; i < N; i++) {\n            const h = MakeHint(a[i], b[i]);\n            v[i] = h;\n            cnt += h;\n        }\n        return { v, cnt };\n    };\n    const signRandBytes = 32;\n    const seedCoder = (0, utils_ts_1.splitCoder)(32, 64, 32);\n    // API & argument positions are exactly as in FIPS204.\n    const internal = {\n        signRandBytes,\n        keygen: (seed) => {\n            // H(||IntegerToBytes(, 1)||IntegerToBytes(, 1), 128) 2:  expand seed\n            const seedDst = new Uint8Array(32 + 2);\n            const randSeed = seed === undefined;\n            if (randSeed)\n                seed = (0, utils_ts_1.randomBytes)(32);\n            (0, utils_ts_1.ensureBytes)(seed, 32);\n            seedDst.set(seed);\n            if (randSeed)\n                seed.fill(0);\n            seedDst[32] = K;\n            seedDst[33] = L;\n            const [rho, rhoPrime, K_] = seedCoder.decode((0, sha3_1.shake256)(seedDst, { dkLen: seedCoder.bytesLen }));\n            const xofPrime = XOF256(rhoPrime);\n            const s1 = [];\n            for (let i = 0; i < L; i++)\n                s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));\n            const s2 = [];\n            for (let i = L; i < L + K; i++)\n                s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));\n            const s1Hat = s1.map((i) => NTT.encode(i.slice()));\n            const t0 = [];\n            const t1 = [];\n            const xof = XOF128(rho);\n            const t = newPoly(N);\n            for (let i = 0; i < K; i++) {\n                // t  NTT1(A*NTT(s1)) + s2\n                t.fill(0); // don't-reallocate\n                for (let j = 0; j < L; j++) {\n                    const aij = RejNTTPoly(xof.get(j, i)); // super slow!\n                    polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));\n                }\n                NTT.decode(t);\n                const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0)  Power2Round(t, d)\n                t0.push(r0);\n                t1.push(r1);\n            }\n            const publicKey = publicCoder.encode([rho, t1]); // pk  pkEncode(, t1)\n            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // tr  H(BytesToBits(pk), 512)\n            const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk  skEncode(, K,tr, s1, s2, t0)\n            xof.clean();\n            xofPrime.clean();\n            // STATS\n            // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }\n            // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }\n            (0, utils_ts_1.cleanBytes)(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);\n            return { publicKey, secretKey };\n        },\n        // NOTE: random is optional.\n        sign: (secretKey, msg, random, externalMu = false) => {\n            // This part can be pre-cached per secretKey, but there is only minor performance improvement,\n            // since we re-use a lot of variables to computation.\n            const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (, K,tr, s1, s2, t0)  skDecode(sk)\n            // Cache matrix to avoid re-compute later\n            const A = []; // A  ExpandA()\n            const xof = XOF128(rho);\n            for (let i = 0; i < K; i++) {\n                const pv = [];\n                for (let j = 0; j < L; j++)\n                    pv.push(RejNTTPoly(xof.get(j, i)));\n                A.push(pv);\n            }\n            xof.clean();\n            for (let i = 0; i < L; i++)\n                NTT.encode(s1[i]); // s1  NTT(s1)\n            for (let i = 0; i < K; i++) {\n                NTT.encode(s2[i]); // s2  NTT(s2)\n                NTT.encode(t0[i]); // t0  NTT(t0)\n            }\n            // This part is per msg\n            const mu = externalMu\n                ? msg\n                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6:   H(tr||M, 512)  Compute message representative \n            // Compute private random seed\n            const rnd = random ? random : new Uint8Array(32);\n            (0, utils_ts_1.ensureBytes)(rnd);\n            const rhoprime = sha3_1.shake256\n                .create({ dkLen: CRH_BYTES })\n                .update(_K)\n                .update(rnd)\n                .update(mu)\n                .digest(); //  H(K||rnd||, 512)\n            (0, utils_ts_1.ensureBytes)(rhoprime, CRH_BYTES);\n            const x256 = XOF256(rhoprime, ZCoder.bytesLen);\n            //  Rejection sampling loop\n            main_loop: for (let kappa = 0;;) {\n                const y = [];\n                // y  ExpandMask( , )\n                for (let i = 0; i < L; i++, kappa++)\n                    y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));\n                const z = y.map((i) => NTT.encode(i.slice()));\n                const w = [];\n                for (let i = 0; i < K; i++) {\n                    // w  NTT1(A  NTT(y))\n                    const wi = newPoly(N);\n                    for (let j = 0; j < L; j++)\n                        polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));\n                    NTT.decode(wi);\n                    w.push(wi);\n                }\n                const w1 = w.map((j) => j.map(HighBits)); // w1  HighBits(w)\n                // Commitment hash: c {0, 1 2 }  H(||w1Encode(w1), 2)\n                const cTilde = sha3_1.shake256\n                    .create({ dkLen: C_TILDE_BYTES })\n                    .update(mu)\n                    .update(W1Vec.encode(w1))\n                    .digest();\n                // Verifers challenge\n                const cHat = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1); c  NTT(c)\n                // cs1  NTT1(c s1)\n                const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));\n                for (let i = 0; i < L; i++) {\n                    polyAdd(NTT.decode(cs1[i]), y[i]); // z  y + cs1\n                    if (polyChknorm(cs1[i], GAMMA1 - BETA))\n                        continue main_loop; // ||z||  1  \n                }\n                // cs1 is now z ( Signers response)\n                let cnt = 0;\n                const h = [];\n                for (let i = 0; i < K; i++) {\n                    const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // cs2  NTT1(c s2)\n                    const r0 = polySub(w[i], cs2).map(LowBits); // r0  LowBits(w  cs2)\n                    if (polyChknorm(r0, GAMMA2 - BETA))\n                        continue main_loop; // ||r0||  2  \n                    const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // ct0  NTT1(c t0)\n                    if (polyChknorm(ct0, GAMMA2))\n                        continue main_loop;\n                    polyAdd(r0, ct0);\n                    //  Signers hint\n                    const hint = polyMakeHint(r0, w1[i]); // h  MakeHint(ct0, w cs2 + ct0)\n                    h.push(hint.v);\n                    cnt += hint.cnt;\n                }\n                if (cnt > OMEGA)\n                    continue; // the number of 1s in h is greater than \n                x256.clean();\n                const res = sigCoder.encode([cTilde, cs1, h]); //   sigEncode(c, z modq, h)\n                // rho, _K, tr is subarray of secretKey, cannot clean.\n                (0, utils_ts_1.cleanBytes)(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);\n                return res;\n            }\n            // @ts-ignore\n            throw new Error('Unreachable code path reached, report this error');\n        },\n        verify: (publicKey, msg, sig, externalMu = false) => {\n            // ML-DSA.Verify(pk, M, ): Verifes a signature  for a message M.\n            const [rho, t1] = publicCoder.decode(publicKey); // (, t1)  pkDecode(pk)\n            const tr = (0, sha3_1.shake256)(publicKey, { dkLen: TR_BYTES }); // 6: tr  H(BytesToBits(pk), 512)\n            if (sig.length !== sigCoder.bytesLen)\n                return false; // return false instead of exception\n            const [cTilde, z, h] = sigCoder.decode(sig); // (c, z, h)  sigDecode(),  Signers commitment hash c , response z and hint\n            if (h === false)\n                return false; // if h =  then return false\n            for (let i = 0; i < L; i++)\n                if (polyChknorm(z[i], GAMMA1 - BETA))\n                    return false;\n            const mu = externalMu\n                ? msg\n                : sha3_1.shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7:   H(tr||M, 512)\n            // Compute verifers challenge from c\n            const c = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1)\n            const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)\n            for (let i = 0; i < L; i++)\n                NTT.encode(zNtt[i]);\n            const wTick1 = [];\n            const xof = XOF128(rho);\n            for (let i = 0; i < K; i++) {\n                const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)\n                const Az = newPoly(N); // // A * z\n                for (let j = 0; j < L; j++) {\n                    const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace\n                    polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));\n                }\n                // wApprox = A*z - c*t1 * (2**d)\n                const wApprox = NTT.decode(polySub(Az, ct12d));\n                // Reconstruction of signers commitment\n                wTick1.push(polyUseHint(wApprox, h[i])); // w   UseHint(h, w'approx )\n            }\n            xof.clean();\n            // c H (||w1Encode(w1), 2),  Hash it; this should match c\n            const c2 = sha3_1.shake256\n                .create({ dkLen: C_TILDE_BYTES })\n                .update(mu)\n                .update(W1Vec.encode(wTick1))\n                .digest();\n            // Additional checks in FIPS-204:\n            // [[ ||z|| < 1   ]] and [[c  = c]] and [[number of 1s in h is  ]]\n            for (const t of h) {\n                const sum = t.reduce((acc, i) => acc + i, 0);\n                if (!(sum <= OMEGA))\n                    return false;\n            }\n            for (const t of z)\n                if (polyChknorm(t, GAMMA1 - BETA))\n                    return false;\n            return (0, utils_ts_1.equalBytes)(cTilde, c2);\n        },\n    };\n    return {\n        internal,\n        keygen: internal.keygen,\n        signRandBytes: internal.signRandBytes,\n        sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {\n            const M = (0, utils_ts_1.getMessage)(msg, ctx);\n            const res = internal.sign(secretKey, M, random);\n            M.fill(0);\n            return res;\n        },\n        verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {\n            return internal.verify(publicKey, (0, utils_ts_1.getMessage)(msg, ctx), sig);\n        },\n        prehash: (hashName) => ({\n            sign: (secretKey, msg, ctx = utils_ts_1.EMPTY, random) => {\n                const M = (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx);\n                const res = internal.sign(secretKey, M, random);\n                M.fill(0);\n                return res;\n            },\n            verify: (publicKey, msg, sig, ctx = utils_ts_1.EMPTY) => {\n                return internal.verify(publicKey, (0, utils_ts_1.getMessagePrehash)(hashName, msg, ctx), sig);\n            },\n        }),\n    };\n}\n/** ML-DSA-44 for 128-bit security level. Not recommended after 2030, as per ASD. */\nexports.ml_dsa44 = getDilithium({\n    ...exports.PARAMS[2],\n    CRH_BYTES: 64,\n    TR_BYTES: 64,\n    C_TILDE_BYTES: 32,\n    XOF128: _crystals_ts_1.XOF128,\n    XOF256: _crystals_ts_1.XOF256,\n});\n/** ML-DSA-65 for 192-bit security level. Not recommended after 2030, as per ASD. */\nexports.ml_dsa65 = getDilithium({\n    ...exports.PARAMS[3],\n    CRH_BYTES: 64,\n    TR_BYTES: 64,\n    C_TILDE_BYTES: 48,\n    XOF128: _crystals_ts_1.XOF128,\n    XOF256: _crystals_ts_1.XOF256,\n});\n/** ML-DSA-87 for 256-bit security level. OK after 2030, as per ASD. */\nexports.ml_dsa87 = getDilithium({\n    ...exports.PARAMS[5],\n    CRH_BYTES: 64,\n    TR_BYTES: 64,\n    C_TILDE_BYTES: 64,\n    XOF128: _crystals_ts_1.XOF128,\n    XOF256: _crystals_ts_1.XOF256,\n});\n//# sourceMappingURL=ml-dsa.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EMPTY = exports.utf8ToBytes = exports.concatBytes = exports.randomBytes = exports.ensureBytes = void 0;\nexports.equalBytes = equalBytes;\nexports.splitCoder = splitCoder;\nexports.vecCoder = vecCoder;\nexports.cleanBytes = cleanBytes;\nexports.getMask = getMask;\nexports.getMessage = getMessage;\nexports.getMessagePrehash = getMessagePrehash;\n/**\n * Utilities for hex, bytearray and number handling.\n * @module\n */\n/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nconst sha3_1 = require(\"@noble/hashes/sha3\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nObject.defineProperty(exports, \"concatBytes\", { enumerable: true, get: function () { return utils_1.concatBytes; } });\nObject.defineProperty(exports, \"utf8ToBytes\", { enumerable: true, get: function () { return utils_1.utf8ToBytes; } });\nexports.ensureBytes = utils_1.abytes;\nexports.randomBytes = utils_1.randomBytes;\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\nfunction splitCoder(...lengths) {\n    const getLength = (c) => (typeof c === 'number' ? c : c.bytesLen);\n    const bytesLen = lengths.reduce((sum, a) => sum + getLength(a), 0);\n    return {\n        bytesLen,\n        encode: (bufs) => {\n            const res = new Uint8Array(bytesLen);\n            for (let i = 0, pos = 0; i < lengths.length; i++) {\n                const c = lengths[i];\n                const l = getLength(c);\n                const b = typeof c === 'number' ? bufs[i] : c.encode(bufs[i]);\n                (0, exports.ensureBytes)(b, l);\n                res.set(b, pos);\n                if (typeof c !== 'number')\n                    b.fill(0); // clean\n                pos += l;\n            }\n            return res;\n        },\n        decode: (buf) => {\n            (0, exports.ensureBytes)(buf, bytesLen);\n            const res = [];\n            for (const c of lengths) {\n                const l = getLength(c);\n                const b = buf.subarray(0, l);\n                res.push(typeof c === 'number' ? b : c.decode(b));\n                buf = buf.subarray(l);\n            }\n            return res;\n        },\n    };\n}\n// nano-packed.array (fixed size)\nfunction vecCoder(c, vecLen) {\n    const bytesLen = vecLen * c.bytesLen;\n    return {\n        bytesLen,\n        encode: (u) => {\n            if (u.length !== vecLen)\n                throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);\n            const res = new Uint8Array(bytesLen);\n            for (let i = 0, pos = 0; i < u.length; i++) {\n                const b = c.encode(u[i]);\n                res.set(b, pos);\n                b.fill(0); // clean\n                pos += b.length;\n            }\n            return res;\n        },\n        decode: (a) => {\n            (0, exports.ensureBytes)(a, bytesLen);\n            const r = [];\n            for (let i = 0; i < a.length; i += c.bytesLen)\n                r.push(c.decode(a.subarray(i, i + c.bytesLen)));\n            return r;\n        },\n    };\n}\n// cleanBytes(new Uint8Array(), [new Uint16Array(), new Uint32Array()])\nfunction cleanBytes(...list) {\n    for (const t of list) {\n        if (Array.isArray(t))\n            for (const b of t)\n                b.fill(0);\n        else\n            t.fill(0);\n    }\n}\nfunction getMask(bits) {\n    return (1 << bits) - 1; // 4 -> 0b1111\n}\nexports.EMPTY = new Uint8Array(0);\nfunction getMessage(msg, ctx = exports.EMPTY) {\n    (0, exports.ensureBytes)(msg);\n    (0, exports.ensureBytes)(ctx);\n    if (ctx.length > 255)\n        throw new Error('context should be less than 255 bytes');\n    return (0, utils_1.concatBytes)(new Uint8Array([0, ctx.length]), ctx, msg);\n}\n// OIDS from https://csrc.nist.gov/projects/computer-security-objects-register/algorithm-registration\n// TODO: maybe add 'OID' property to hashes themselves to improve tree-shaking?\nconst HASHES = {\n    'SHA2-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040201'), hash: sha2_1.sha256 },\n    'SHA2-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040202'), hash: sha2_1.sha384 },\n    'SHA2-512': { oid: (0, utils_1.hexToBytes)('0609608648016503040203'), hash: sha2_1.sha512 },\n    'SHA2-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040204'), hash: sha2_1.sha224 },\n    'SHA2-512/224': { oid: (0, utils_1.hexToBytes)('0609608648016503040205'), hash: sha2_1.sha512_224 },\n    'SHA2-512/256': { oid: (0, utils_1.hexToBytes)('0609608648016503040206'), hash: sha2_1.sha512_256 },\n    'SHA3-224': { oid: (0, utils_1.hexToBytes)('0609608648016503040207'), hash: sha3_1.sha3_224 },\n    'SHA3-256': { oid: (0, utils_1.hexToBytes)('0609608648016503040208'), hash: sha3_1.sha3_256 },\n    'SHA3-384': { oid: (0, utils_1.hexToBytes)('0609608648016503040209'), hash: sha3_1.sha3_384 },\n    'SHA3-512': { oid: (0, utils_1.hexToBytes)('060960864801650304020A'), hash: sha3_1.sha3_512 },\n    'SHAKE-128': {\n        oid: (0, utils_1.hexToBytes)('060960864801650304020B'),\n        hash: (msg) => (0, sha3_1.shake128)(msg, { dkLen: 32 }),\n    },\n    'SHAKE-256': {\n        oid: (0, utils_1.hexToBytes)('060960864801650304020C'),\n        hash: (msg) => (0, sha3_1.shake256)(msg, { dkLen: 64 }),\n    },\n};\nfunction getMessagePrehash(hashName, msg, ctx = exports.EMPTY) {\n    (0, exports.ensureBytes)(msg);\n    (0, exports.ensureBytes)(ctx);\n    if (ctx.length > 255)\n        throw new Error('context should be less than 255 bytes');\n    if (!HASHES[hashName])\n        throw new Error('unknown hash: ' + hashName);\n    const { oid, hash } = HASHES[hashName];\n    const hashed = hash(msg);\n    return (0, utils_1.concatBytes)(new Uint8Array([1, ctx.length]), ctx, oid, hashed);\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DearmorStream = exports.ArmorStream = exports.MessageType = exports.debug = void 0;\nexports.armor = armor;\nexports.dearmor = dearmor;\nexports.encodeBlock = encodeBlock;\nexports.decodeBlock = decodeBlock;\nexports.efficientCharsSizes = efficientCharsSizes;\nconst message_header_1 = require(\"./message-header\");\nconst util_1 = require(\"./util\");\nconst stream_1 = require(\"stream\");\nconst lodash_chunk_1 = __importDefault(require(\"lodash.chunk\"));\nexports.debug = false;\n/** The Base62 alphabet */\nconst BASE62_ALPHABET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n/** The Base64 alphabet */\nconst BASE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n/** The Base85 alphabet */\nconst BASE85_ALPHABET = \"!\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstu\";\n// Also accept message type \"MESSAGE\"\n// (should really be \"ENCRYPTED MESSAGE\", \"SIGNED MESSAGE\" or \"DETACHED SIGNATURE\")\nconst HEADER_REGEX = /^[>\\n\\r\\t ]*BEGIN[>\\n\\r\\t ]+(([a-zA-Z0-9]+)[>\\n\\r\\t ]+)?SALTPACK[>\\n\\r\\t ]+(MESSAGE|ENCRYPTED[>\\n\\r\\t ]+MESSAGE|SIGNED[>\\n\\r\\t ]+MESSAGE|DETACHED[>\\n\\r\\t ]+SIGNATURE)[>\\n\\r\\t ]*$/;\nconst FOOTER_REGEX = /^[>\\n\\r\\t ]*END[>\\n\\r\\t ]+(([a-zA-Z0-9]+)[>\\n\\r\\t ]+)?SALTPACK[>\\n\\r\\t ]+(MESSAGE|ENCRYPTED[>\\n\\r\\t ]+MESSAGE|SIGNED[>\\n\\r\\t ]+MESSAGE|DETACHED[>\\n\\r\\t ]+SIGNATURE)[>\\n\\r\\t ]*$/;\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ENCRYPTED_MESSAGE\"] = \"ENCRYPTED MESSAGE\";\n    MessageType[\"SIGNED_MESSAGE\"] = \"SIGNED MESSAGE\";\n    MessageType[\"DETACHED_SIGNATURE\"] = \"DETACHED SIGNATURE\";\n    /** @private */\n    // MESSAGE = 'MESSAGE',\n})(MessageType || (exports.MessageType = MessageType = {}));\nfunction modeToStringType(type) {\n    switch (type) {\n        case message_header_1.MessageType.ENCRYPTION:\n            return MessageType.ENCRYPTED_MESSAGE;\n        case message_header_1.MessageType.ATTACHED_SIGNING:\n            return MessageType.SIGNED_MESSAGE;\n        case message_header_1.MessageType.DETACHED_SIGNING:\n            return MessageType.DETACHED_SIGNATURE;\n        case message_header_1.MessageType.SIGNCRYPTION:\n            return MessageType.ENCRYPTED_MESSAGE;\n        default:\n            return \"MESSAGE\";\n    }\n}\n/** The default options used by the armor/dearmor methods. */\nconst DEFAULT_OPTIONS = {\n    alphabet: BASE62_ALPHABET,\n    block_size: 32,\n    char_block_size: 43,\n    raw: false,\n    shift: false,\n    message_type: \"MESSAGE\",\n    app_name: null, // Application name (e.g. \"KEYBASE\")\n};\n/** Return the index of the specified +char+ in +alphabet+, raising an appropriate error if it is not found. */\nfunction getCharIndex(alphabet, char) {\n    const rval = alphabet.indexOf(char);\n    if (rval === -1) {\n        throw new Error(\"Could not find \" + char + \" in alphabet \" + alphabet);\n    }\n    return rval;\n}\n/** Return the minimum number of characters needed to encode +bytes_size+ bytes using the given +alphabet+. */\nfunction characterBlockSize(alphabet_size, bytes_size) {\n    return Math.ceil((8 * bytes_size) / Math.log2(alphabet_size));\n}\n/** Return the maximum number of bytes needed to encode +chars_size+ characters using the given +alphabet+. */\nfunction maxBytesSize(alphabet_size, chars_size) {\n    return Math.floor((Math.log2(alphabet_size) / 8) * chars_size);\n}\n/**\n * Return the number of bits left over after using an alphabet of the specified +alphabet_size+ to encode a\n * payload of +bytes_size+ with +chars_size+ characters.\n */\nfunction extraBits(alphabet_size, chars_size, bytes_size) {\n    const total_bits = Math.floor(Math.log2(alphabet_size) * chars_size);\n    return total_bits - 8 * bytes_size;\n}\nfunction armor(input, _options) {\n    const options = Object.assign({}, DEFAULT_OPTIONS, _options);\n    if (typeof options.message_type === \"number\")\n        options.message_type = modeToStringType(options.message_type);\n    const chunks = (0, util_1.chunkBuffer)(input, options.block_size);\n    let output = \"\";\n    for (const chunk of chunks) {\n        output += encodeBlock(chunk, options.alphabet, options.shift);\n    }\n    if (options.raw) {\n        const out_chunks = (0, util_1.chunkString)(output, 43);\n        return out_chunks.join(\" \");\n    }\n    const word_chunks = (0, util_1.chunkString)(output, 15);\n    const sentences = (0, lodash_chunk_1.default)(word_chunks, 200);\n    const joined = sentences.map((words) => words.join(\" \")).join(\"\\n\");\n    const app = options.app_name ? \" \" + options.app_name : \"\";\n    const header = \"BEGIN\" + app + \" SALTPACK \" + options.message_type + \". \";\n    const footer = \". END\" + app + \" SALTPACK \" + options.message_type + \".\";\n    return header + joined + footer;\n}\nclass ArmorStream extends stream_1.Transform {\n    constructor(options) {\n        super();\n        this.in_buffer = Buffer.alloc(0);\n        this.out_buffer = \"\";\n        this.words = 0;\n        this.i = 0;\n        this.armor_options = Object.assign({}, DEFAULT_OPTIONS, options);\n        if (typeof this.armor_options.message_type === \"number\") {\n            // @ts-expect-error\n            this.armor_options.message_type = modeToStringType(this.armor_options.message_type);\n        }\n        const app = this.armor_options.app_name ? \" \" + this.armor_options.app_name : \"\";\n        this.armor_header = \"BEGIN\" + app + \" SALTPACK \" + this.armor_options.message_type + \". \";\n        this.armor_footer = \". END\" + app + \" SALTPACK \" + this.armor_options.message_type + \".\";\n        if (!this.armor_options.raw) {\n            this.push(this.armor_header);\n        }\n    }\n    _transform(data, encoding, callback) {\n        if (exports.debug)\n            console.log(\"Processing chunk #%d: %O\", this.i++, data);\n        this.in_buffer = Buffer.concat([this.in_buffer, data]);\n        while (this.in_buffer.length > this.armor_options.block_size) {\n            const block = this.in_buffer.slice(0, this.armor_options.block_size);\n            this.in_buffer = this.in_buffer.slice(this.armor_options.block_size);\n            this.out_buffer += encodeBlock(block, this.armor_options.alphabet, this.armor_options.shift);\n        }\n        if (this.armor_options.raw) {\n            while (this.out_buffer.length > 43) {\n                this.push(this.out_buffer.substr(0, 43) + \" \");\n                this.out_buffer = this.out_buffer.substr(43);\n            }\n        }\n        else {\n            while (this.out_buffer.length > 15) {\n                const word = this.out_buffer.substr(0, 15);\n                this.out_buffer = this.out_buffer.substr(15);\n                this.words++;\n                if (this.words >= 200) {\n                    this.push(word + \"\\n\");\n                    this.words = 0;\n                }\n                else {\n                    this.push(word + \" \");\n                }\n            }\n        }\n        callback();\n    }\n    _flush(callback) {\n        if (this.in_buffer.length > 0) {\n            this.out_buffer += encodeBlock(this.in_buffer, this.armor_options.alphabet, this.armor_options.shift);\n            this.in_buffer = Buffer.alloc(0);\n        }\n        if (this.armor_options.raw) {\n            while (this.out_buffer.length > 43) {\n                this.push(this.out_buffer.substr(0, 43) + \" \");\n                this.out_buffer = this.out_buffer.substr(43);\n            }\n        }\n        else {\n            while (this.out_buffer.length > 15) {\n                const word = this.out_buffer.substr(0, 15);\n                this.out_buffer = this.out_buffer.substr(15);\n                this.words++;\n                if (this.words >= 200) {\n                    this.push(word + \"\\n\");\n                    this.words = 0;\n                }\n                else {\n                    this.push(word + \" \");\n                }\n            }\n        }\n        this.push(this.out_buffer);\n        if (!this.armor_options.raw) {\n            this.push(this.armor_footer);\n        }\n        callback();\n    }\n}\nexports.ArmorStream = ArmorStream;\nfunction dearmor(input, _options) {\n    var _a;\n    const options = Object.assign({}, DEFAULT_OPTIONS, _options);\n    let header, header_info = null, footer, remaining = null, match;\n    if (!options.raw) {\n        [header, input, footer, remaining] = input.split(\".\", 4);\n        remaining = Buffer.from(remaining);\n        if (!(match = header.match(HEADER_REGEX))) {\n            throw new Error(\"Invalid header\");\n        }\n        header_info = {\n            message_type: match[3],\n            app_name: (_a = match[2]) !== null && _a !== void 0 ? _a : null,\n        };\n        if (!(match = footer.match(FOOTER_REGEX))) {\n            throw new Error(\"Invalid footer\");\n        }\n        if (header_info.message_type !== match[3] || header_info.app_name != match[2]) {\n            throw new Error(\"Footer doesn't match header\");\n        }\n    }\n    input = input.replace(/[>\\n\\r\\t ]/g, \"\");\n    const chunks = (0, util_1.chunkString)(input, options.char_block_size);\n    const output_chunks = chunks.map((chunk) => decodeBlock(chunk, options.alphabet, options.shift));\n    const output = Buffer.concat(output_chunks);\n    return Object.assign(output, {\n        remaining: remaining,\n        header_info: header_info,\n    });\n}\nclass DearmorStream extends stream_1.Transform {\n    get header() {\n        if (this.armor_options.raw)\n            throw new Error(\"Header isn't available when decoding raw armored data\");\n        if (!this.armor_header)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.armor_header;\n    }\n    get footer() {\n        if (this.armor_options.raw)\n            throw new Error(\"Footer isn't available when decoding raw armored data\");\n        if (!this.armor_footer)\n            throw new Error(\"Footer hasn't been decoded yet\");\n        return this.armor_footer;\n    }\n    get info() {\n        if (this.armor_options.raw)\n            throw new Error(\"Header isn't available when decoding raw armored data\");\n        if (!this.armor_header_info)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.armor_header_info;\n    }\n    constructor(options) {\n        super();\n        this.in_buffer = Buffer.alloc(0);\n        this.out_buffer = \"\";\n        this.armor_header_info = null;\n        this.armor_header = null;\n        this.armor_footer = null;\n        this.words = 0;\n        this.i = 0;\n        this.armor_options = Object.assign({}, DEFAULT_OPTIONS, options);\n    }\n    _transform(data, encoding, callback) {\n        var _a;\n        if (exports.debug)\n            console.log(\"Processing chunk #%d: %O\", this.i++, data);\n        if (!this.armor_options.raw && this.armor_header === null) {\n            this.in_buffer = Buffer.concat([this.in_buffer, data]);\n            const index = this.in_buffer.indexOf(\".\");\n            if (index === -1)\n                return callback();\n            this.armor_header = this.in_buffer.slice(0, index).toString();\n            data = this.in_buffer.slice(index + 1);\n            const header_match = this.armor_header.match(HEADER_REGEX);\n            if (!header_match) {\n                const err = new Error(\"Invalid header\");\n                callback(err);\n                throw err;\n            }\n            this.armor_header_info = {\n                message_type: header_match[3],\n                app_name: (_a = header_match[2]) !== null && _a !== void 0 ? _a : null,\n            };\n            if (exports.debug)\n                console.log(\"Read header: %s\", this.armor_header);\n        }\n        if (!this.armor_options.raw && this.armor_footer !== null) {\n            this.armor_footer += data.toString();\n            const remaining_index = this.armor_footer.indexOf(\".\");\n            if (remaining_index !== -1) {\n                this.armor_footer = this.armor_footer.substr(0, remaining_index);\n                return callback();\n            }\n        }\n        if (!this.armor_options.raw && this.armor_footer === null) {\n            const index = data.indexOf(\".\");\n            if (index !== -1) {\n                this.armor_footer = data.slice(index + 1).toString();\n                data = data.slice(0, index);\n                this.out_buffer = data.toString().replace(/[>\\n\\r\\t ]/g, \"\");\n                const remaining_index = this.armor_footer.indexOf(\".\");\n                if (remaining_index !== -1) {\n                    this.armor_footer = this.armor_footer.substr(0, remaining_index);\n                    return callback();\n                }\n                return callback();\n            }\n        }\n        if (this.armor_options.raw || this.armor_footer === null) {\n            this.out_buffer += data.toString().replace(/[>\\n\\r\\t ]/g, \"\");\n            while (this.out_buffer.length > this.armor_options.char_block_size) {\n                const block = this.out_buffer.substr(0, this.armor_options.char_block_size);\n                this.out_buffer = this.out_buffer.substr(this.armor_options.char_block_size);\n                this.push(decodeBlock(block, this.armor_options.alphabet, this.armor_options.shift));\n            }\n        }\n        callback();\n    }\n    _flush(callback) {\n        var _a;\n        while (this.out_buffer.length > this.armor_options.char_block_size) {\n            const block = this.out_buffer.substr(0, this.armor_options.char_block_size);\n            this.out_buffer = this.out_buffer.substr(this.armor_options.char_block_size);\n            this.push(decodeBlock(block, this.armor_options.alphabet, this.armor_options.shift));\n        }\n        if (this.out_buffer.length > 0) {\n            this.push(decodeBlock(this.out_buffer, this.armor_options.alphabet, this.armor_options.shift));\n            this.out_buffer = \"\";\n        }\n        if (!this.armor_options.raw && this.armor_footer === null) {\n            const err = new Error(\"Input stream doesn't contain a valid header and footer\");\n            callback(err);\n            throw err;\n        }\n        if (!this.armor_options.raw) {\n            const footer_match = (_a = this.armor_footer) === null || _a === void 0 ? void 0 : _a.match(FOOTER_REGEX);\n            if (!footer_match) {\n                throw new Error(\"Invalid footer\");\n            }\n            if (this.armor_header_info.message_type !== footer_match[3] || this.armor_header_info.app_name != footer_match[2]) {\n                throw new Error(\"Footer doesn't match header\");\n            }\n            if (exports.debug)\n                console.log(\"Read footer: %s\", this.armor_footer);\n        }\n        callback();\n    }\n}\nexports.DearmorStream = DearmorStream;\n/**\n * Encode a single block of ascii-armored output from +bytes_block+ using the specified +alphabet+ and +shift+.\n */\nfunction encodeBlock(bytes_block, alphabet = BASE62_ALPHABET, shift = false) {\n    const block_size = characterBlockSize(alphabet.length, bytes_block.length);\n    const extra = extraBits(alphabet.length, block_size, bytes_block.length);\n    // Convert the bytes into an integer, big-endian\n    let bytes_int = BigInt(\"0x\" + bytes_block.toString(\"hex\"));\n    if (shift) {\n        bytes_int <<= BigInt(extra);\n    }\n    const alphabet_size = BigInt(alphabet.length);\n    const places = [];\n    for (let i = 0; i < block_size; i++) {\n        const rem = parseInt((bytes_int % alphabet_size).toString());\n        places.unshift(rem);\n        bytes_int = bytes_int / alphabet_size;\n    }\n    return places.map((i) => alphabet[i]).join(\"\");\n}\n/**\n * Decode the specified ascii-armored +chars_block+ using the specified +alphabet+ and +shift+.\n */\nfunction decodeBlock(chars_block, alphabet = BASE62_ALPHABET, shift = false) {\n    const bytes_size = maxBytesSize(alphabet.length, chars_block.length);\n    const expected_block_size = characterBlockSize(alphabet.length, bytes_size);\n    if (chars_block.length !== expected_block_size) {\n        throw new TypeError(\"Illegal block size \" + chars_block.length + \", expected \" + expected_block_size);\n    }\n    const extra = extraBits(alphabet.length, chars_block.length, bytes_size);\n    let bytes_int = BigInt(getCharIndex(alphabet, chars_block[0]));\n    for (let i = 1; i < chars_block.length; i++) {\n        bytes_int = bytes_int * BigInt(alphabet.length);\n        bytes_int = bytes_int + BigInt(getCharIndex(alphabet, chars_block[i]));\n    }\n    if (shift) {\n        bytes_int >>= BigInt(extra);\n    }\n    return Buffer.from(bytes_int\n        .toString(16)\n        .padStart(bytes_size * 2, \"0\")\n        .slice(0, bytes_size * 2), \"hex\");\n}\nfunction efficientCharsSizes(alphabet_size, chars_size_upper_bound = 50) {\n    const out = [];\n    let max_efficiency = 0;\n    for (let chars_size = 1; chars_size < chars_size_upper_bound; chars_size++) {\n        const bytes_size = maxBytesSize(alphabet_size, chars_size);\n        const efficiency = bytes_size / chars_size;\n        if (efficiency > max_efficiency) {\n            out.push([chars_size, bytes_size, efficiency]);\n            max_efficiency = efficiency;\n        }\n    }\n    return out;\n}\n//# sourceMappingURL=armor.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_header_1 = __importStar(require(\"../message-header\"));\nconst recipient_1 = __importDefault(require(\"./recipient\"));\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst util_1 = require(\"../util\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nclass EncryptedMessageHeader extends message_header_1.default {\n    constructor(public_key, sender_secretbox, recipients) {\n        super();\n        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {\n            throw new TypeError(\"public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(sender_secretbox) || sender_secretbox.length !== 48) {\n            throw new TypeError(\"sender_secretbox must be a 48 byte Uint8Array\");\n        }\n        this.public_key = public_key;\n        this.sender_secretbox = sender_secretbox;\n        this.recipients = recipients;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded outer header data */\n    get encoded() {\n        return this.encoded_data[1];\n    }\n    /** The SHA512 hash of the MessagePack encoded inner header data */\n    get hash() {\n        return this.encoded_data[0];\n    }\n    static create(public_key, payload_key, sender_public_key, recipients) {\n        if (!(0, util_1.isBufferOrUint8Array)(sender_public_key) || sender_public_key.length !== 32) {\n            throw new TypeError(\"sender_public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(payload_key) || payload_key.length !== 32) {\n            throw new TypeError(\"payload_key must be a 32 byte Uint8Array\");\n        }\n        // 3. Encrypt the sender's long-term public key using crypto_secretbox with the payload key and the nonce saltpack_sender_key_sbox, to create the sender secretbox.\n        // const sender_secretbox = sodium_crypto_secretbox($sender_public_key, self::SENDER_KEY_SECRETBOX_NONCE, $payload_key);\n        const sender_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(sender_public_key), Uint8Array.from(EncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));\n        return new this(public_key, sender_secretbox, recipients);\n    }\n    encode() {\n        return EncryptedMessageHeader.encodeHeader(this.public_key, this.sender_secretbox, this.recipients);\n    }\n    static encodeHeader(public_key, sender, recipients) {\n        const data = [\n            \"saltpack\",\n            [2, 0],\n            message_header_1.MessageType.ENCRYPTION,\n            public_key,\n            sender,\n            recipients.map((recipient) => {\n                // [\n                //     recipient public key,\n                //     payload key box,\n                // ]\n                return [recipient.anonymous ? null : recipient.public_key, recipient.encrypted_payload_key];\n            }),\n        ];\n        const encoded = (0, msgpack_1.encode)(data);\n        const header_hash = Buffer.from(sha2_1.sha512.create().update(encoded).digest());\n        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];\n    }\n    static decode(encoded, unwrapped = false) {\n        const [header_hash, data] = super.decode1(encoded, unwrapped);\n        if (data[2] !== message_header_1.MessageType.ENCRYPTION)\n            throw new Error(\"Invalid data\");\n        const [, , , public_key, sender_secretbox, recipients] = data;\n        if (!(recipients instanceof Array))\n            throw new Error(\"Invalid data\");\n        return new this(public_key, sender_secretbox, recipients.map((recipient, index) => {\n            if (!(recipient instanceof Array) || recipient.length < 2) {\n                throw new TypeError(\"Invalid data\");\n            }\n            return recipient_1.default.from(recipient[0], recipient[1], index);\n        }));\n    }\n    /**\n     * Decrypts and returns the payload key and recipient.\n     */\n    decryptPayloadKey(keypair) {\n        // 5. Precompute the ephemeral shared secret using crypto_box_beforenm with the ephemeral public key and\n        // the recipient's private key.\n        const shared_secret = tweetnacl_1.box.before(this.public_key, keypair.secretKey);\n        // 6. Try to open each of the payload key boxes in the recipients list using crypto_box_open_afternm,\n        // the precomputed secret from #5, and the nonce saltpack_recipsbXXXXXXXX. XXXXXXXX is 8-byte big-endian\n        // unsigned recipient index, where the first recipient is index 0. Successfully opening one gives the\n        // payload key.\n        for (const recipient of this.recipients) {\n            if (recipient.public_key) {\n                // If the recipient's public key is shown in the recipients list (that is, if the recipient is\n                // not anonymous), clients may skip all the other payload key boxes in step #6.\n                if (!Buffer.from(recipient.public_key).equals(keypair.publicKey))\n                    continue;\n            }\n            const payload_key = recipient.decryptPayloadKey(this.public_key, keypair.secretKey, shared_secret);\n            if (!payload_key)\n                continue;\n            recipient.setPublicKey(keypair.publicKey);\n            return [payload_key, recipient];\n        }\n        throw new Error(\"keypair is not an intended recipient\");\n    }\n    decryptSender(payload_key) {\n        const sender_public_key = tweetnacl_1.secretbox.open(Uint8Array.from(this.sender_secretbox), Uint8Array.from(EncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));\n        if (!sender_public_key) {\n            throw new Error(\"Failed to decrypt sender public key\");\n        }\n        return sender_public_key;\n    }\n}\nEncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE = Buffer.from(\"saltpack_sender_key_sbox\");\nexports.default = EncryptedMessageHeader;\n//# sourceMappingURL=header.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecryptStream = exports.EncryptStream = void 0;\nexports.debugSetKey = debugSetKey;\nexports.debugSetKeypair = debugSetKeypair;\nexports.encrypt = encrypt;\nexports.decrypt = decrypt;\nconst header_1 = __importDefault(require(\"./header\"));\nconst recipient_1 = __importDefault(require(\"./recipient\"));\nconst payload_1 = __importDefault(require(\"./payload\"));\nconst util_1 = require(\"../util\");\nconst stream_1 = require(\"stream\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst CHUNK_LENGTH = 1024 * 1024;\nlet debug = false;\nlet debug_fix_key = null;\nlet debug_fix_keypair = null;\nfunction debugSetKey(key) {\n    debug_fix_key = key;\n}\nfunction debugSetKeypair(keypair) {\n    debug_fix_keypair = keypair;\n}\nfunction encrypt(data, keypair, recipients_keys) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const chunks = (0, util_1.chunkBuffer)(data, CHUNK_LENGTH);\n        // 1. Generate a random 32-byte payload key.\n        const payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));\n        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.\n        const ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();\n        keypair = keypair !== null && keypair !== void 0 ? keypair : ephemeral_keypair;\n        const recipients = recipients_keys.map((key, index) => {\n            return recipient_1.default.create(key, ephemeral_keypair.secretKey, payload_key, index);\n        });\n        const header = header_1.default.create(ephemeral_keypair.publicKey, payload_key, keypair.publicKey, recipients);\n        for (const recipient of recipients) {\n            recipient.generateMacKeyForSender(header.hash, ephemeral_keypair.secretKey, keypair.secretKey);\n        }\n        const payloads = [];\n        for (const i in chunks) {\n            const chunk = chunks[i];\n            const final = chunks.length === parseInt(i) + 1;\n            const payload = payload_1.default.create(header, payload_key, chunk, BigInt(i), final);\n            payloads.push(payload);\n        }\n        return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);\n    });\n}\nclass EncryptStream extends stream_1.Transform {\n    constructor(keypair, recipients_keys) {\n        super();\n        this.in_buffer = Buffer.alloc(0);\n        this.payload_index = BigInt(0);\n        this.i = 0;\n        // 1. Generate a random 32-byte payload key.\n        this.payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));\n        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.\n        this.ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();\n        this.keypair = keypair !== null && keypair !== void 0 ? keypair : this.ephemeral_keypair;\n        const recipients = recipients_keys.map((key, index) => {\n            return recipient_1.default.create(key, this.ephemeral_keypair.secretKey, this.payload_key, index);\n        });\n        this.header = header_1.default.create(this.ephemeral_keypair.publicKey, this.payload_key, this.keypair.publicKey, recipients);\n        this.push(this.header.encoded);\n        for (const recipient of recipients) {\n            recipient.generateMacKeyForSender(this.header.hash, this.ephemeral_keypair.secretKey, this.keypair.secretKey);\n        }\n    }\n    _transform(data, encoding, callback) {\n        if (debug)\n            console.log(\"Processing chunk #%d: %s\", this.i++, data);\n        this.in_buffer = Buffer.concat([this.in_buffer, data]);\n        while (this.in_buffer.length > CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);\n            // This is never the final payload as there must be additional data in `in_buffer`\n            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, /* final */ false);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n    _flush(callback) {\n        while (this.in_buffer.length >= CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        if (this.in_buffer.length) {\n            const chunk = this.in_buffer;\n            this.in_buffer = Buffer.alloc(0);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.payload_key, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n}\nexports.EncryptStream = EncryptStream;\nfunction decrypt(encrypted, keypair, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, e_1, _b, _c;\n        const stream = new stream_1.Readable();\n        stream.push(encrypted);\n        stream.push(null);\n        const items = [];\n        try {\n            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const item = _c;\n                items.push(item);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        const header_data = items.shift();\n        const header = header_1.default.decode(header_data, true);\n        const [payload_key, recipient] = header.decryptPayloadKey(keypair);\n        const sender_public_key = header.decryptSender(payload_key);\n        if (sender && !Buffer.from(sender_public_key).equals(sender)) {\n            throw new Error(\"Sender public key doesn't match\");\n        }\n        recipient.generateMacKeyForRecipient(header.hash, header.public_key, sender_public_key, keypair.secretKey);\n        let output = Buffer.alloc(0);\n        for (const i in items) {\n            const message = items[i];\n            const payload = payload_1.default.decode(message, true);\n            const final = items.length === parseInt(i) + 1;\n            if (payload.final && !final) {\n                throw new Error(\"Found payload with invalid final flag, message extended?\");\n            }\n            if (!payload.final && final) {\n                throw new Error(\"Found payload with invalid final flag, message truncated?\");\n            }\n            output = Buffer.concat([output, payload.decrypt(header, recipient, payload_key, BigInt(i))]);\n        }\n        if (!items.length) {\n            throw new Error(\"No encrypted payloads, message truncated?\");\n        }\n        return Object.assign(output, {\n            sender_public_key,\n        });\n    });\n}\nclass DecryptStream extends stream_1.Transform {\n    constructor(keypair, sender) {\n        super();\n        this.keypair = keypair;\n        this.decoder = new msgpack_1.Decoder({ extensionCodec: undefined });\n        this.header_data = null;\n        this.last_payload = null;\n        this.payload_index = BigInt(-1);\n        this.i = 0;\n        this.sender = sender !== null && sender !== void 0 ? sender : null;\n    }\n    get header() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[0];\n    }\n    get payload_key() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[1];\n    }\n    get recipient() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[2];\n    }\n    get sender_public_key() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[3];\n    }\n    _transform(data, encoding, callback) {\n        // @ts-ignore\n        this.decoder.appendBuffer(data);\n        try {\n            let message;\n            // @ts-ignore\n            while ((message = this.decoder.doDecodeSync())) {\n                // @ts-ignore\n                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);\n                // @ts-ignore\n                this.decoder.setBuffer(remaining);\n                this._handleMessage(message);\n            }\n        }\n        catch (err) { }\n        callback();\n    }\n    _handleMessage(data) {\n        if (debug)\n            console.log(\"Processing chunk #%d: %s\", this.i++, data);\n        if (!this.header_data) {\n            const header = header_1.default.decode(data, true);\n            const [payload_key, recipient] = header.decryptPayloadKey(this.keypair);\n            const sender_public_key = header.decryptSender(payload_key);\n            if (this.sender && !Buffer.from(sender_public_key).equals(this.sender)) {\n                throw new Error(\"Sender public key doesn't match\");\n            }\n            recipient.generateMacKeyForRecipient(header.hash, header.public_key, sender_public_key, this.keypair.secretKey);\n            this.header_data = [header, payload_key, recipient, sender_public_key];\n        }\n        else {\n            this.payload_index++;\n            if (this.last_payload) {\n                if (this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message extended?\");\n                }\n                this.push(this.last_payload.decrypt(this.header, this.recipient, this.payload_key, this.payload_index - BigInt(1)));\n            }\n            const payload = payload_1.default.decode(data, true);\n            this.last_payload = payload;\n        }\n    }\n    _flush(callback) {\n        try {\n            if (this.last_payload) {\n                if (!this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message truncated?\");\n                }\n                this.push(this.last_payload.decrypt(this.header, this.recipient, this.payload_key, this.payload_index));\n            }\n            if (!this.last_payload) {\n                throw new Error(\"No encrypted payloads, message truncated?\");\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n        callback();\n    }\n}\nexports.DecryptStream = DecryptStream;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\n// [\n//     final flag,\n//     authenticators list,\n//     payload secretbox,\n// ]\nclass EncryptedMessagePayload {\n    constructor(final, authenticators, payload_secretbox) {\n        this.final = final;\n        this.authenticators = authenticators;\n        this.payload_secretbox = payload_secretbox;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded payload data */\n    get encoded() {\n        return this.encoded_data;\n    }\n    static create(header, payload_key, data, index, final = false) {\n        const index_buffer = Buffer.alloc(8);\n        index_buffer.writeBigUInt64BE(index);\n        const nonce = Buffer.concat([this.PAYLOAD_NONCE_PREFIX, index_buffer]);\n        const payload_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(data), Uint8Array.from(nonce), Uint8Array.from(payload_key));\n        const authenticator_hash = this.generateAuthenticatorHash(header.hash, payload_secretbox, nonce, final);\n        return new this(final, header.recipients.map((recipient, i) => {\n            if (!recipient.mac_key) {\n                throw new Error(\"Recipient #\" + i + \" doesn't have a MAC key set\");\n            }\n            // 3. For each recipient, compute the crypto_auth (HMAC-SHA512, truncated to 32 bytes) of the hash\n            // from #2, using that recipient's MAC key.\n            // return substr(sodium_crypto_auth($authenticator_hash, $recipient->mac_key), 0, 32);\n            return Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, recipient.mac_key, authenticator_hash).slice(0, 32));\n        }), payload_secretbox);\n    }\n    static generateAuthenticatorHash(header_hash, payload_secretbox, payload_secretbox_nonce, final) {\n        // 1. Concatenate the header hash, the nonce for the payload secretbox, the final flag byte (0x00 or 0x01),\n        // and the payload secretbox itself.\n        // 2. Compute the crypto_hash (SHA512) of the bytes from #1.\n        return Buffer.from(sha2_1.sha512\n            .create()\n            .update(header_hash)\n            .update(payload_secretbox_nonce)\n            .update(final ? \"\\x01\" : \"\\x00\")\n            .update(payload_secretbox)\n            .digest());\n    }\n    encode() {\n        return EncryptedMessagePayload.encodePayload(this.final, this.authenticators, this.payload_secretbox);\n    }\n    static encodePayload(final, authenticators, payload_secretbox) {\n        const data = [final, authenticators, payload_secretbox];\n        return Buffer.from((0, msgpack_1.encode)(data));\n    }\n    static decode(encoded, unpacked = false) {\n        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);\n        if (data.length < 3)\n            throw new Error(\"Invalid data\");\n        const [final, authenticators, payload_secretbox] = data;\n        return new this(final, authenticators, payload_secretbox);\n    }\n    decrypt(header, recipient, payload_key, index) {\n        if (!recipient.mac_key) {\n            throw new Error(\"Recipient doesn't have a MAC key set\");\n        }\n        // @ts-expect-error\n        const authenticator = this.authenticators[recipient.index];\n        const index_buffer = Buffer.alloc(8);\n        index_buffer.writeBigUInt64BE(index);\n        const nonce = Buffer.concat([EncryptedMessagePayload.PAYLOAD_NONCE_PREFIX, index_buffer]);\n        const authenticator_hash = EncryptedMessagePayload.generateAuthenticatorHash(header.hash, this.payload_secretbox, nonce, this.final);\n        // 3. For each recipient, compute the crypto_auth (HMAC-SHA512, truncated to 32 bytes) of the hash\n        // from #2, using that recipient's MAC key.\n        // const our_authenticator = substr(sodium_crypto_auth($authenticator_hash, $recipient->mac_key), 0, 32);\n        const our_authenticator = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, recipient.mac_key, authenticator_hash).slice(0, 32));\n        if (!authenticator || !our_authenticator.equals(authenticator)) {\n            throw new Error(\"Invalid authenticator\");\n        }\n        const decrypted = tweetnacl_1.secretbox.open(Uint8Array.from(this.payload_secretbox), Uint8Array.from(nonce), Uint8Array.from(payload_key));\n        if (!decrypted) {\n            throw new Error(\"Failed to decrypt data\");\n        }\n        return decrypted;\n    }\n}\nEncryptedMessagePayload.PAYLOAD_NONCE_PREFIX = Buffer.from(\"saltpack_ploadsb\");\nexports.default = EncryptedMessagePayload;\n//# sourceMappingURL=payload.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst util_1 = require(\"../util\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nclass EncryptedMessageRecipient {\n    constructor(public_key, encrypted_payload_key, index, anonymous = false) {\n        /** The MAC key for this recipient (this is used to generate the per-payload authenticators for this recipient) */\n        this.mac_key = null;\n        if (public_key !== null && (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32)) {\n            throw new TypeError(\"recipient_public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(encrypted_payload_key) || encrypted_payload_key.length !== 48) {\n            throw new TypeError(\"payload_key_box must be a 48 byte Uint8Array\");\n        }\n        if (typeof index !== \"bigint\") {\n            throw new TypeError(\"index must be a bigint\");\n        }\n        if (typeof anonymous !== \"boolean\") {\n            throw new TypeError(\"anonymous must be a boolean\");\n        }\n        this.public_key = public_key;\n        this.encrypted_payload_key = encrypted_payload_key;\n        this.index = index;\n        this.recipient_index = EncryptedMessageRecipient.generateRecipientIndex(index);\n        this.anonymous = anonymous;\n    }\n    /** @private */\n    setPublicKey(public_key) {\n        // @ts-expect-error\n        this.public_key = public_key;\n    }\n    static create(public_key, ephemeral_private_key, payload_key, index, anonymous = false) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        const recipient_index = this.generateRecipientIndex(index);\n        // 4. For each recipient, encrypt the payload key using crypto_box with the recipient's public key, the ephemeral private key, and the nonce saltpack_recipsbXXXXXXXX. XXXXXXXX is 8-byte big-endian unsigned recipient index, where the first recipient is index zero. Pair these with the recipients' public keys, or null for anonymous recipients, and collect the pairs into the recipients list.\n        const encrypted_payload_key = (0, tweetnacl_1.box)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key));\n        return new this(public_key, encrypted_payload_key, index, anonymous);\n    }\n    static from(public_key, encrypted_payload_key, index) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        return new this(public_key, encrypted_payload_key, index, public_key === null);\n    }\n    static generateRecipientIndex(index) {\n        const buffer = Buffer.alloc(8);\n        buffer.writeBigUInt64BE(index);\n        return Buffer.concat([this.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2, buffer]);\n    }\n    /**\n     * Decrypts the payload key, returns null if wrong recipient.\n     */\n    decryptPayloadKey(ephemeral_public_key, recipient_private_key, secret = null) {\n        const payload_key = secret\n            ? tweetnacl_1.box.open.after(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(secret))\n            : tweetnacl_1.box.open(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(ephemeral_public_key), Uint8Array.from(recipient_private_key));\n        if (!payload_key)\n            return null;\n        return payload_key;\n    }\n    generateMacKeyForSender(header_hash, ephemeral_private_key, sender_private_key, public_key = null) {\n        if (!public_key && this.public_key)\n            public_key = this.public_key;\n        if (!public_key)\n            throw new Error(\"Generating MAC key requires the recipient's public key\");\n        // 9. Concatenate the first 16 bytes of the header hash from step 7 above, with the recipient index from\n        // step 4 above. This is the basis of each recipient's MAC nonce.\n        const index_buffer = Buffer.alloc(8);\n        index_buffer.writeBigUInt64BE(this.index);\n        const nonce = Buffer.concat([header_hash.slice(0, 16), index_buffer]);\n        // 10. Clear the least significant bit of byte 15. That is: nonce[15] &= 0xfe.\n        nonce[15] &= 0xfe;\n        // 11. Encrypt 32 zero bytes using crypto_box with the recipient's public key, the sender's long-term\n        // private key, and the nonce from the previous step.\n        const box_1 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(nonce), Uint8Array.from(public_key), Uint8Array.from(sender_private_key));\n        // 12. Modify the nonce from step 10 by setting the least significant bit of byte\n        // 12.1. That is: nonce[15] |= 0x01.\n        nonce[15] |= 0x01;\n        // 13. Encrypt 32 zero bytes again, as in step 11, but using the ephemeral private key rather than the\n        // sender's long term private key.\n        const box_2 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(nonce), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key));\n        // 14. Concatenate the last 32 bytes each box from steps 11 and 13. Take the SHA512 hash of that\n        // concatenation. The recipient's MAC Key is the first 32 bytes of that hash.\n        const mac_key = sha2_1.sha512.create().update(box_1.slice(-32)).update(box_2.slice(-32)).digest().slice(0, 32);\n        // @ts-expect-error\n        this.mac_key = mac_key;\n        return Buffer.from(mac_key);\n    }\n    generateMacKeyForRecipient(header_hash, ephemeral_public_key, sender_public_key, private_key) {\n        // 9. Concatenate the first 16 bytes of the header hash from step 7 above, with the recipient index from\n        // step 4 above. This is the basis of each recipient's MAC nonce.\n        const index_buffer = Buffer.alloc(8);\n        index_buffer.writeBigUInt64BE(this.index);\n        const nonce = Buffer.concat([header_hash.slice(0, 16), index_buffer]);\n        // 10. Clear the least significant bit of byte 15. That is: nonce[15] &= 0xfe.\n        nonce[15] &= 0xfe;\n        // 11. Encrypt 32 zero bytes using crypto_box with the recipient's public key, the sender's long-term\n        // private key, and the nonce from the previous step.\n        const box_1 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(nonce), Uint8Array.from(sender_public_key), Uint8Array.from(private_key));\n        // 12. Modify the nonce from step 10 by setting the least significant bit of byte\n        // 12.1. That is: nonce[15] |= 0x01.\n        nonce[15] |= 0x01;\n        // 13. Encrypt 32 zero bytes again, as in step 11, but using the ephemeral private key rather than the\n        // sender's long term private key.\n        const box_2 = (0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(nonce), Uint8Array.from(ephemeral_public_key), Uint8Array.from(private_key));\n        // 14. Concatenate the last 32 bytes each box from steps 11 and 13. Take the SHA512 hash of that\n        // concatenation. The recipient's MAC Key is the first 32 bytes of that hash.\n        const mac_key = sha2_1.sha512.create().update(box_1.slice(-32)).update(box_2.slice(-32)).digest().slice(0, 32);\n        // @ts-expect-error\n        this.mac_key = mac_key;\n        return Buffer.from(mac_key);\n    }\n}\nEncryptedMessageRecipient.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2 = Buffer.from(\"saltpack_recipsb\");\nexports.default = EncryptedMessageRecipient;\n//# sourceMappingURL=recipient.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DearmorAndDesigncryptStream = exports.SigncryptAndArmorStream = exports.dearmorAndDesigncrypt = exports.signcryptAndArmor = exports.verifyDetachedArmored = exports.signDetachedAndArmor = exports.DearmorAndVerifyStream = exports.SignAndArmorStream = exports.verifyArmored = exports.signAndArmor = exports.DearmorAndDecryptStream = exports.EncryptAndArmorStream = exports.dearmorAndDecrypt = exports.encryptAndArmor = exports.SymmetricKeyRecipient = exports.DesigncryptStream = exports.designcrypt = exports.SigncryptStream = exports.signcrypt = exports.verifyDetached = exports.signDetached = exports.VerifyStream = exports.verify = exports.SignStream = exports.sign = exports.DecryptStream = exports.decrypt = exports.EncryptStream = exports.encrypt = exports.MessageType = exports.DearmorStream = exports.dearmor = exports.ArmorStream = exports.armor = void 0;\nvar armor_1 = require(\"./armor\");\nObject.defineProperty(exports, \"armor\", { enumerable: true, get: function () { return armor_1.armor; } });\nObject.defineProperty(exports, \"ArmorStream\", { enumerable: true, get: function () { return armor_1.ArmorStream; } });\nObject.defineProperty(exports, \"dearmor\", { enumerable: true, get: function () { return armor_1.dearmor; } });\nObject.defineProperty(exports, \"DearmorStream\", { enumerable: true, get: function () { return armor_1.DearmorStream; } });\nvar message_header_1 = require(\"./message-header\");\nObject.defineProperty(exports, \"MessageType\", { enumerable: true, get: function () { return message_header_1.MessageType; } });\nvar encryption_1 = require(\"./encryption\");\nObject.defineProperty(exports, \"encrypt\", { enumerable: true, get: function () { return encryption_1.encrypt; } });\nObject.defineProperty(exports, \"EncryptStream\", { enumerable: true, get: function () { return encryption_1.EncryptStream; } });\nObject.defineProperty(exports, \"decrypt\", { enumerable: true, get: function () { return encryption_1.decrypt; } });\nObject.defineProperty(exports, \"DecryptStream\", { enumerable: true, get: function () { return encryption_1.DecryptStream; } });\nvar signing_1 = require(\"./signing\");\nObject.defineProperty(exports, \"sign\", { enumerable: true, get: function () { return signing_1.sign; } });\nObject.defineProperty(exports, \"SignStream\", { enumerable: true, get: function () { return signing_1.SignStream; } });\nObject.defineProperty(exports, \"verify\", { enumerable: true, get: function () { return signing_1.verify; } });\nObject.defineProperty(exports, \"VerifyStream\", { enumerable: true, get: function () { return signing_1.VerifyStream; } });\nObject.defineProperty(exports, \"signDetached\", { enumerable: true, get: function () { return signing_1.signDetached; } });\nObject.defineProperty(exports, \"verifyDetached\", { enumerable: true, get: function () { return signing_1.verifyDetached; } });\nvar signcryption_1 = require(\"./signcryption\");\nObject.defineProperty(exports, \"signcrypt\", { enumerable: true, get: function () { return signcryption_1.signcrypt; } });\nObject.defineProperty(exports, \"SigncryptStream\", { enumerable: true, get: function () { return signcryption_1.SigncryptStream; } });\nObject.defineProperty(exports, \"designcrypt\", { enumerable: true, get: function () { return signcryption_1.designcrypt; } });\nObject.defineProperty(exports, \"DesigncryptStream\", { enumerable: true, get: function () { return signcryption_1.DesigncryptStream; } });\nvar recipient_1 = require(\"./signcryption/recipient\");\nObject.defineProperty(exports, \"SymmetricKeyRecipient\", { enumerable: true, get: function () { return recipient_1.SymmetricKeyRecipient; } });\nvar with_armor_1 = require(\"./with-armor\");\nObject.defineProperty(exports, \"encryptAndArmor\", { enumerable: true, get: function () { return with_armor_1.encryptAndArmor; } });\nObject.defineProperty(exports, \"dearmorAndDecrypt\", { enumerable: true, get: function () { return with_armor_1.dearmorAndDecrypt; } });\nObject.defineProperty(exports, \"EncryptAndArmorStream\", { enumerable: true, get: function () { return with_armor_1.EncryptAndArmorStream; } });\nObject.defineProperty(exports, \"DearmorAndDecryptStream\", { enumerable: true, get: function () { return with_armor_1.DearmorAndDecryptStream; } });\nObject.defineProperty(exports, \"signAndArmor\", { enumerable: true, get: function () { return with_armor_1.signAndArmor; } });\nObject.defineProperty(exports, \"verifyArmored\", { enumerable: true, get: function () { return with_armor_1.verifyArmored; } });\nObject.defineProperty(exports, \"SignAndArmorStream\", { enumerable: true, get: function () { return with_armor_1.SignAndArmorStream; } });\nObject.defineProperty(exports, \"DearmorAndVerifyStream\", { enumerable: true, get: function () { return with_armor_1.DearmorAndVerifyStream; } });\nObject.defineProperty(exports, \"signDetachedAndArmor\", { enumerable: true, get: function () { return with_armor_1.signDetachedAndArmor; } });\nObject.defineProperty(exports, \"verifyDetachedArmored\", { enumerable: true, get: function () { return with_armor_1.verifyDetachedArmored; } });\nObject.defineProperty(exports, \"signcryptAndArmor\", { enumerable: true, get: function () { return with_armor_1.signcryptAndArmor; } });\nObject.defineProperty(exports, \"dearmorAndDesigncrypt\", { enumerable: true, get: function () { return with_armor_1.dearmorAndDesigncrypt; } });\nObject.defineProperty(exports, \"SigncryptAndArmorStream\", { enumerable: true, get: function () { return with_armor_1.SigncryptAndArmorStream; } });\nObject.defineProperty(exports, \"DearmorAndDesigncryptStream\", { enumerable: true, get: function () { return with_armor_1.DearmorAndDesigncryptStream; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageType = void 0;\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"ENCRYPTION\"] = 0] = \"ENCRYPTION\";\n    MessageType[MessageType[\"ATTACHED_SIGNING\"] = 1] = \"ATTACHED_SIGNING\";\n    MessageType[MessageType[\"DETACHED_SIGNING\"] = 2] = \"DETACHED_SIGNING\";\n    MessageType[MessageType[\"SIGNCRYPTION\"] = 3] = \"SIGNCRYPTION\";\n})(MessageType || (exports.MessageType = MessageType = {}));\nclass Header {\n    static decode1(encoded, unwrapped = false) {\n        // 1-3\n        const data = unwrapped ? encoded : (0, msgpack_1.decode)(encoded);\n        const header_hash = sha2_1.sha512.create().update(data).digest();\n        const inner = (0, msgpack_1.decode)(data);\n        // 4\n        if (!(inner instanceof Array) || inner.length < 3) {\n            throw new Error(\"Invalid data\");\n        }\n        const [format_name, version, mode] = inner;\n        if (format_name !== \"saltpack\")\n            throw new Error(\"Invalid data\");\n        if (!(version instanceof Array) || version.length !== 2) {\n            throw new Error(\"Invalid data\");\n        }\n        if (version[0] !== 2)\n            throw new Error(\"Unsupported version\");\n        if (version[1] !== 0)\n            throw new Error(\"Unsupported version\");\n        if (typeof mode !== \"number\")\n            throw new Error(\"Invalid data\");\n        return [header_hash, inner];\n    }\n}\nexports.default = Header;\n//# sourceMappingURL=message-header.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_header_1 = __importStar(require(\"../message-header\"));\nconst recipient_1 = __importDefault(require(\"./recipient\"));\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst util_1 = require(\"../util\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nclass SigncryptedMessageHeader extends message_header_1.default {\n    constructor(public_key, sender_secretbox, recipients) {\n        super();\n        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {\n            throw new TypeError(\"public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(sender_secretbox) || sender_secretbox.length !== 48) {\n            throw new TypeError(\"sender_secretbox must be a 48 byte Uint8Array\");\n        }\n        this.public_key = public_key;\n        this.sender_secretbox = sender_secretbox;\n        this.recipients = recipients;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded outer header data */\n    get encoded() {\n        return this.encoded_data[1];\n    }\n    /** The SHA512 hash of the MessagePack encoded inner header data */\n    get hash() {\n        return this.encoded_data[0];\n    }\n    static create(public_key, payload_key, sender_public_key, recipients) {\n        if (sender_public_key !== null && (!(0, util_1.isBufferOrUint8Array)(sender_public_key) || sender_public_key.length !== 32)) {\n            throw new TypeError(\"sender_public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(payload_key) || payload_key.length !== 32) {\n            throw new TypeError(\"payload_key must be a 32 byte Uint8Array\");\n        }\n        // If Alice wants to be anonymous to recipients as well, she can supply an all-zero signing public key in\n        // step #3.\n        if (!sender_public_key)\n            sender_public_key = Buffer.alloc(32);\n        // 3. Encrypt the sender's long-term public key signing key using crypto_secretbox with the payload key and\n        // the nonce saltpack_sender_key_sbox, to create the sender secretbox.\n        const sender_secretbox = (0, tweetnacl_1.secretbox)(Uint8Array.from(sender_public_key), Uint8Array.from(SigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));\n        return new this(public_key, sender_secretbox, recipients);\n    }\n    encode() {\n        return SigncryptedMessageHeader.encodeHeader(this.public_key, this.sender_secretbox, this.recipients);\n    }\n    static encodeHeader(public_key, sender, recipients) {\n        const data = [\n            \"saltpack\",\n            [2, 0],\n            message_header_1.MessageType.SIGNCRYPTION,\n            public_key,\n            sender,\n            recipients.map((recipient) => {\n                // [\n                //     recipient identifier,\n                //     payload key box,\n                // ]\n                return [recipient.recipient_identifier, recipient.encrypted_payload_key];\n            }),\n        ];\n        const encoded = (0, msgpack_1.encode)(data);\n        const header_hash = sha2_1.sha512.create().update(encoded).digest();\n        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];\n    }\n    static decode(encoded, unwrapped = false) {\n        const [header_hash, data] = super.decode1(encoded, unwrapped);\n        if (data[2] !== message_header_1.MessageType.SIGNCRYPTION)\n            throw new Error(\"Invalid data\");\n        const [, , , public_key, sender_secretbox, recipients] = data;\n        if (!(recipients instanceof Array))\n            throw new Error(\"Invalid data\");\n        return new this(public_key, sender_secretbox, recipients.map((recipient, index) => {\n            if (!(recipient instanceof Array) || recipient.length < 2) {\n                throw new TypeError(\"Invalid data\");\n            }\n            return recipient_1.default.from(recipient[0], recipient[1], index);\n        }));\n    }\n    /**\n     * Decrypts and returns the payload key and recipient.\n     */\n    decryptPayloadKeyWithCurve25519Keypair(private_key) {\n        // 5. Check to see if any of the recipient's Curve25519 private keys are in the recipients' list. For each\n        // private key available, and for each recipient entry in the list, compute the identifier as in step #4\n        // in the previous section. If any of the recipient entries match, decrypt the payload key and proceed to\n        // step #7.\n        for (const recipient of this.recipients) {\n            const { recipient_identifier, shared_symmetric_key } = recipient_1.default.generateRecipientIdentifierForRecipient(this.public_key, private_key, recipient.recipient_index);\n            if (!recipient_identifier.equals(recipient.recipient_identifier))\n                continue;\n            const payload_key = recipient.decryptPayloadKey(shared_symmetric_key);\n            if (!payload_key) {\n                throw new Error(\"Invalid shared symmetric key\");\n            }\n            return [payload_key, recipient];\n        }\n        return null;\n    }\n    decryptPayloadKeyWithSymmetricKey(shared_symmetric_key, recipient_identifier) {\n        // 6. If no Curve25519 keys matched in the previous step, check whether any of the recipient's symmetric\n        // keys are in the message. The identifiers in this step are up to the application, and if the space of\n        // possible keys is very large, the recipient might use server assistance to look up identifiers. If any\n        // of the recipient entries match, decrypt the payload key. If not, decryption fails, and the client should\n        // report that the current user isn't a recipient of this message.\n        const derived_key = (0, hmac_1.hmac)(sha2_1.sha512, recipient_1.default.HMAC_KEY_SYMMETRIC, Buffer.concat([this.public_key, shared_symmetric_key])).slice(0, 32);\n        const identifier = recipient_identifier ? Buffer.from(recipient_identifier) : null;\n        for (const recipient of this.recipients) {\n            if (identifier && !identifier.equals(recipient.recipient_identifier))\n                continue;\n            const payload_key = recipient.decryptPayloadKey(derived_key);\n            if (!payload_key)\n                continue;\n            return [payload_key, recipient];\n        }\n        return null;\n    }\n    decryptSender(payload_key) {\n        const sender_public_key = tweetnacl_1.secretbox.open(Uint8Array.from(this.sender_secretbox), Uint8Array.from(SigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE), Uint8Array.from(payload_key));\n        if (!sender_public_key) {\n            throw new Error(\"Failed to decrypt sender public key\");\n        }\n        if (Buffer.alloc(32).equals(sender_public_key)) {\n            return null;\n        }\n        return sender_public_key;\n    }\n}\nSigncryptedMessageHeader.SENDER_KEY_SECRETBOX_NONCE = Buffer.from(\"saltpack_sender_key_sbox\");\nexports.default = SigncryptedMessageHeader;\n//# sourceMappingURL=header.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DesigncryptStream = exports.SigncryptStream = void 0;\nexports.debugSetKey = debugSetKey;\nexports.debugSetKeypair = debugSetKeypair;\nexports.signcrypt = signcrypt;\nexports.designcrypt = designcrypt;\nconst header_1 = __importDefault(require(\"./header\"));\nconst recipient_1 = __importStar(require(\"./recipient\"));\nconst payload_1 = __importDefault(require(\"./payload\"));\nconst util_1 = require(\"../util\");\nconst stream_1 = require(\"stream\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst CHUNK_LENGTH = 1024 * 1024;\nlet debug = false;\nlet debug_fix_key = null;\nlet debug_fix_keypair = null;\nfunction debugSetKey(key) {\n    debug_fix_key = key;\n}\nfunction debugSetKeypair(keypair) {\n    debug_fix_keypair = keypair;\n}\nfunction signcrypt(data, keypair, recipients_keys) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const chunks = (0, util_1.chunkBuffer)(data, CHUNK_LENGTH);\n        // 1. Generate a random 32-byte payload key.\n        const payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : (0, tweetnacl_1.randomBytes)(32);\n        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.\n        const ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();\n        const recipients = recipients_keys.map((key, index) => key instanceof recipient_1.SymmetricKeyRecipient\n            ? recipient_1.default.createSymmetric(key.key, key.recipient_identifier, ephemeral_keypair.publicKey, payload_key, index)\n            : recipient_1.default.create(key, ephemeral_keypair.secretKey, payload_key, index));\n        const header = header_1.default.create(ephemeral_keypair.publicKey, payload_key, (_a = keypair === null || keypair === void 0 ? void 0 : keypair.publicKey) !== null && _a !== void 0 ? _a : null, recipients);\n        const payloads = [];\n        for (const i in chunks) {\n            const chunk = chunks[i];\n            const final = chunks.length === parseInt(i) + 1;\n            const payload = payload_1.default.create(header, payload_key, (_b = keypair === null || keypair === void 0 ? void 0 : keypair.secretKey) !== null && _b !== void 0 ? _b : null, chunk, BigInt(i), final);\n            payloads.push(payload);\n        }\n        return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);\n    });\n}\nclass SigncryptStream extends stream_1.Transform {\n    constructor(keypair, recipients_keys) {\n        var _a, _b;\n        super();\n        this.in_buffer = Buffer.alloc(0);\n        this.payload_index = BigInt(0);\n        this.i = 0;\n        // 1. Generate a random 32-byte payload key.\n        this.payload_key = debug_fix_key !== null && debug_fix_key !== void 0 ? debug_fix_key : Buffer.from((0, tweetnacl_1.randomBytes)(32));\n        // 2. Generate a random ephemeral keypair, using crypto_box_keypair.\n        this.ephemeral_keypair = debug_fix_keypair !== null && debug_fix_keypair !== void 0 ? debug_fix_keypair : tweetnacl_1.box.keyPair();\n        this.keypair = keypair;\n        const recipients = recipients_keys.map((key, index) => key instanceof recipient_1.SymmetricKeyRecipient\n            ? recipient_1.default.createSymmetric(key.key, key.recipient_identifier, this.ephemeral_keypair.publicKey, this.payload_key, index)\n            : recipient_1.default.create(key, this.ephemeral_keypair.secretKey, this.payload_key, index));\n        this.header = header_1.default.create(this.ephemeral_keypair.publicKey, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.publicKey) !== null && _b !== void 0 ? _b : null, recipients);\n        this.push(this.header.encoded);\n    }\n    _transform(data, encoding, callback) {\n        var _a, _b;\n        if (debug)\n            console.log(\"Processing chunk #%d: %s\", this.i++, data);\n        this.in_buffer = Buffer.concat([this.in_buffer, data]);\n        while (this.in_buffer.length > CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);\n            // This is never the final payload as there must be additional data in `in_buffer`\n            const payload = payload_1.default.create(this.header, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.secretKey) !== null && _b !== void 0 ? _b : null, chunk, this.payload_index, /* final */ false);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n    _flush(callback) {\n        var _a, _b, _c, _d;\n        while (this.in_buffer.length >= CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(CHUNK_LENGTH);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.payload_key, (_b = (_a = this.keypair) === null || _a === void 0 ? void 0 : _a.secretKey) !== null && _b !== void 0 ? _b : null, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        if (this.in_buffer.length) {\n            const chunk = this.in_buffer;\n            this.in_buffer = Buffer.alloc(0);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.payload_key, (_d = (_c = this.keypair) === null || _c === void 0 ? void 0 : _c.secretKey) !== null && _d !== void 0 ? _d : null, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n}\nexports.SigncryptStream = SigncryptStream;\nfunction designcrypt(signcrypted, recipient_keys, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, e_1, _b, _c;\n        const stream = new stream_1.Readable();\n        stream.push(signcrypted);\n        stream.push(null);\n        const items = [];\n        try {\n            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const item = _c;\n                items.push(item);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        const header_data = items.shift();\n        const header = header_1.default.decode(header_data, true);\n        const payload_key_and_recipient = recipient_keys instanceof recipient_1.SymmetricKeyRecipient\n            ? header.decryptPayloadKeyWithSymmetricKey(recipient_keys.key, recipient_keys.recipient_identifier)\n            : header.decryptPayloadKeyWithCurve25519Keypair(recipient_keys.secretKey);\n        if (!payload_key_and_recipient)\n            throw new Error(\"keypair is not an intended recipient\");\n        const [payload_key] = payload_key_and_recipient;\n        const sender_public_key = header.decryptSender(payload_key);\n        if (sender && (!sender_public_key || !Buffer.from(sender_public_key).equals(Buffer.from(sender)))) {\n            throw new Error(\"Sender public key doesn't match\");\n        }\n        let output = Buffer.alloc(0);\n        for (const i in items) {\n            const message = items[i];\n            const payload = payload_1.default.decode(message, true);\n            const final = items.length === parseInt(i) + 1;\n            if (payload.final && !final) {\n                throw new Error(\"Found payload with invalid final flag, message extended?\");\n            }\n            if (!payload.final && final) {\n                throw new Error(\"Found payload with invalid final flag, message truncated?\");\n            }\n            output = Buffer.concat([output, payload.decrypt(header, sender_public_key, payload_key, BigInt(i))]);\n        }\n        if (!items.length) {\n            throw new Error(\"No signcrypted payloads, message truncated?\");\n        }\n        return Object.assign(output, {\n            sender_public_key,\n        });\n    });\n}\nclass DesigncryptStream extends stream_1.Transform {\n    constructor(recipient_keys, sender) {\n        super();\n        this.recipient_keys = recipient_keys;\n        this.decoder = new msgpack_1.Decoder();\n        this.header_data = null;\n        this.last_payload = null;\n        this.payload_index = BigInt(-1);\n        this.i = 0;\n        this.sender = sender !== null && sender !== void 0 ? sender : null;\n    }\n    get header() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[0];\n    }\n    get payload_key() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[1];\n    }\n    get recipient() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[2];\n    }\n    get sender_public_key() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data[3];\n    }\n    _transform(data, encoding, callback) {\n        // @ts-ignore\n        this.decoder.appendBuffer(data);\n        try {\n            let message;\n            // @ts-ignore\n            while ((message = this.decoder.doDecodeSync())) {\n                // @ts-ignore\n                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);\n                // @ts-ignore\n                this.decoder.setBuffer(remaining);\n                this._handleMessage(message);\n            }\n        }\n        catch (err) { }\n        callback();\n    }\n    _handleMessage(data) {\n        if (debug)\n            console.log(\"Processing chunk #%d: %s\", this.i++, data);\n        if (!this.header_data) {\n            const header = header_1.default.decode(data, true);\n            const payload_key_and_recipient = this.recipient_keys instanceof recipient_1.SymmetricKeyRecipient\n                ? header.decryptPayloadKeyWithSymmetricKey(this.recipient_keys.key, this.recipient_keys.recipient_identifier)\n                : header.decryptPayloadKeyWithCurve25519Keypair(this.recipient_keys.secretKey);\n            if (!payload_key_and_recipient)\n                throw new Error(\"keypair is not an intended recipient\");\n            const [payload_key, recipient] = payload_key_and_recipient;\n            const sender_public_key = header.decryptSender(payload_key);\n            if (this.sender && (!sender_public_key || !Buffer.from(sender_public_key).equals(Buffer.from(this.sender)))) {\n                throw new Error(\"Sender public key doesn't match\");\n            }\n            this.header_data = [header, payload_key, recipient, sender_public_key];\n        }\n        else {\n            this.payload_index++;\n            if (this.last_payload) {\n                if (this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message extended?\");\n                }\n                this.push(this.last_payload.decrypt(this.header, this.sender_public_key, this.payload_key, this.payload_index - BigInt(1)));\n            }\n            const payload = payload_1.default.decode(data, true);\n            this.last_payload = payload;\n        }\n    }\n    _flush(callback) {\n        try {\n            if (this.last_payload) {\n                if (!this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message truncated?\");\n                }\n                this.push(this.last_payload.decrypt(this.header, this.sender_public_key, this.payload_key, this.payload_index));\n            }\n            if (!this.last_payload) {\n                throw new Error(\"No signcrypted payloads, message truncated?\");\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n        callback();\n    }\n}\nexports.DesigncryptStream = DesigncryptStream;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\n// [\n//     signcrypted chunk,\n//     final flag,\n// ]\nclass SigncryptedMessagePayload {\n    constructor(payload_secretbox, final) {\n        this.payload_secretbox = payload_secretbox;\n        this.final = final;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded payload data */\n    get encoded() {\n        return this.encoded_data;\n    }\n    static create(header, payload_key, private_key, data, index, final = false) {\n        const nonce = this.generateNonce(header.hash, index, final);\n        // 3. Sign the signature input with the sender's long-term private signing key, producing a 64-byte\n        // Ed25519 signature. If the sender is anonymous, the signature is 64 zero bytes instead.\n        const signature = private_key ? tweetnacl_1.sign.detached(Uint8Array.from(this.generateSignatureData(header.hash, nonce, final, data)), Uint8Array.from(private_key)) : Buffer.alloc(64);\n        // 4. Prepend that signature onto the front of the plaintext chunk.\n        // 5. Encrypt the attached signature from #4 using the payload key and the packet nonce.\n        const payload_secretbox = Buffer.from((0, tweetnacl_1.secretbox)(Uint8Array.from(Buffer.concat([signature, data])), Uint8Array.from(nonce), Uint8Array.from(payload_key)));\n        return new this(payload_secretbox, final);\n    }\n    static generateNonce(header_hash, index, final) {\n        // 1. Compute the packet nonce. Take the first 16 bytes of the header hash. If this is the final packet,\n        // set the least significant bit of the last of those bytes to one (nonce[15] |= 0x01), otherwise set it\n        // to zero (nonce[15] &= 0xfe). Finally, append the 8-byte unsigned big-endian packet number, where the\n        // first payload packet is zero.\n        const nonce = Buffer.alloc(24, Buffer.from(header_hash));\n        nonce[15] = final ? nonce[15] | 0x01 : nonce[15] & 0xfe;\n        nonce.writeBigUInt64BE(index, 16);\n        return nonce;\n    }\n    static generateSignatureData(header_hash, nonce, final, data) {\n        // 2. Concatenate several values to form the signature input:\n        //     - the constant string saltpack encrypted signature\n        //     - a null byte, 0x00\n        //     - the header hash\n        //     - the packet nonce computed above\n        //     - the final flag byte, 0x00 for false and 0x01 for true\n        //     - the SHA512 hash of the plaintext\n        return Buffer.concat([Buffer.from(\"saltpack encrypted signature\"), Buffer.from([0x00]), header_hash, nonce, Buffer.from([final ? 0x01 : 0x00]), sha2_1.sha512.create().update(data).digest()]);\n    }\n    encode() {\n        return SigncryptedMessagePayload.encodePayload(this.payload_secretbox, this.final);\n    }\n    static encodePayload(payload_secretbox, final) {\n        const data = [payload_secretbox, final];\n        return Buffer.from((0, msgpack_1.encode)(data));\n    }\n    static decode(encoded, unpacked = false) {\n        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);\n        if (data.length < 2)\n            throw new Error(\"Invalid data\");\n        const [payload_secretbox, final] = data;\n        return new this(payload_secretbox, final);\n    }\n    decrypt(header, public_key, payload_key, index) {\n        // 1. Compute the packet nonce as above.\n        const nonce = SigncryptedMessagePayload.generateNonce(header.hash, index, this.final);\n        // 2. Decrypt the chunk using the payload key and the packet nonce.\n        const signature_data = tweetnacl_1.secretbox.open(Uint8Array.from(this.payload_secretbox), Uint8Array.from(nonce), Uint8Array.from(payload_key));\n        if (!signature_data) {\n            throw new Error(\"Failed to decrypt data\");\n        }\n        // 3. Take the first 64 bytes of the plaintext as the detached signature, and the rest as the payload chunk.\n        const data = signature_data.slice(64);\n        if (public_key) {\n            const signature = signature_data.slice(0, 64);\n            // 4. Compute the signature input as above.\n            const sign_data = SigncryptedMessagePayload.generateSignatureData(header.hash, nonce, this.final, data);\n            // 5. Verify the detached signature from step #3 against the signature input. If the sender's public key\n            // is all zero bytes, however, then the sender is anonymous, and verification is skipped.\n            if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(signature), Uint8Array.from(public_key))) {\n                throw new Error(\"Invalid signature\");\n            }\n        }\n        // 6. If the signature was valid, output the payload chunk.\n        return data;\n    }\n}\nSigncryptedMessagePayload.PAYLOAD_NONCE_PREFIX = Buffer.from(\"saltpack_ploadsb\");\nexports.default = SigncryptedMessagePayload;\n//# sourceMappingURL=payload.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SymmetricKeyRecipient = void 0;\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst util_1 = require(\"../util\");\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nclass SymmetricKeyRecipient {\n    constructor(recipient_identifier, key) {\n        this.recipient_identifier = recipient_identifier;\n        this.key = key;\n    }\n}\nexports.SymmetricKeyRecipient = SymmetricKeyRecipient;\nclass SigncryptedMessageRecipient {\n    constructor(recipient_identifier /*shared_symmetric_key: Uint8Array | null,*/, encrypted_payload_key, index) {\n        if (!(0, util_1.isBufferOrUint8Array)(recipient_identifier) || recipient_identifier.length !== 32) {\n            throw new TypeError(\"recipient_identifier must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(encrypted_payload_key) || encrypted_payload_key.length !== 48) {\n            throw new TypeError(\"payload_key_box must be a 48 byte Uint8Array\");\n        }\n        if (typeof index !== \"bigint\") {\n            throw new TypeError(\"index must be a bigint\");\n        }\n        this.recipient_identifier = recipient_identifier;\n        // this.shared_symmetric_key = shared_symmetric_key;\n        this.encrypted_payload_key = encrypted_payload_key;\n        this.index = index;\n        this.recipient_index = SigncryptedMessageRecipient.generateRecipientIndex(index);\n    }\n    static create(public_key, ephemeral_private_key, payload_key, index) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        const recipient_index = this.generateRecipientIndex(index);\n        const { shared_symmetric_key, recipient_identifier } = this.generateRecipientIdentifierForSender(public_key, ephemeral_private_key, recipient_index);\n        // Secretbox the payload key using this derived symmetric key, with the nonce saltpack_recipsbXXXXXXXX,\n        // where XXXXXXXX is the 8-byte big-endian unsigned recipient index.\n        const encrypted_payload_key = (0, tweetnacl_1.secretbox)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(shared_symmetric_key));\n        return new this(recipient_identifier, /*shared_symmetric_key,*/ encrypted_payload_key, index);\n    }\n    static createSymmetric(shared_symmetric_key, recipient_identifier, ephemeral_public_key, payload_key, index) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        // For recipient symmetric keys, first derive a shared symmetric key. Concatenate the ephemeral\n        // public Curve25519 key and the recipient symmetric key, and HMAC-SHA512 them under the key saltpack\n        // signcryption derived symmetric key. The derived key is the first 32 bytes of that HMAC.\n        const derived_key = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY_SYMMETRIC, Buffer.concat([ephemeral_public_key, shared_symmetric_key])).slice(0, 32));\n        const recipient_index = this.generateRecipientIndex(index);\n        // Secretbox the payload key using this derived symmetric key, with the nonce saltpack_recipsbXXXXXXXX,\n        // where XXXXXXXX is the 8-byte big-endian unsigned recipient index.\n        const encrypted_payload_key = (0, tweetnacl_1.secretbox)(Uint8Array.from(payload_key), Uint8Array.from(recipient_index), Uint8Array.from(derived_key));\n        return new this(recipient_identifier, encrypted_payload_key, index);\n    }\n    static from(recipient_identifier, encrypted_payload_key, index) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        return new this(recipient_identifier, /*null,*/ encrypted_payload_key, index);\n    }\n    static generateRecipientIndex(index) {\n        const buffer = Buffer.alloc(8);\n        buffer.writeBigUInt64BE(index);\n        return Buffer.concat([this.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2, buffer]);\n    }\n    /**\n     * Decrypts the payload key.\n     */\n    decryptPayloadKey(shared_symmetric_key) {\n        return tweetnacl_1.secretbox.open(Uint8Array.from(this.encrypted_payload_key), Uint8Array.from(this.recipient_index), Uint8Array.from(shared_symmetric_key));\n    }\n    static generateRecipientIdentifierForSender(public_key, ephemeral_private_key, recipient_index) {\n        // For Curve25519 recipient public keys, first derive a shared symmetric key by boxing 32 zero bytes with\n        // the recipient public key, the ephemeral private key, and the nonce saltpack_derived_sboxkey, and taking\n        // the last 32 bytes of the resulting box.\n        const shared_symmetric_key = Buffer.from((0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(this.SHARED_KEY_NONCE), Uint8Array.from(public_key), Uint8Array.from(ephemeral_private_key))).slice(-32);\n        // To compute the recipient identifier, concatenate the derived symmetric key and the\n        // saltpack_recipsbXXXXXXXX nonce together, and HMAC-SHA512 them under the key saltpack signcryption box\n        // key identifier. The identifier is the first 32 bytes of that HMAC.\n        const recipient_identifier = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY, Buffer.concat([shared_symmetric_key, recipient_index])).slice(0, 32));\n        return { shared_symmetric_key, recipient_identifier };\n    }\n    static generateRecipientIdentifierForRecipient(ephemeral_public_key, private_key, recipient_index) {\n        // For Curve25519 recipient public keys, first derive a shared symmetric key by boxing 32 zero bytes with\n        // the recipient public key, the ephemeral private key, and the nonce saltpack_derived_sboxkey, and taking\n        // the last 32 bytes of the resulting box.\n        const shared_symmetric_key = Buffer.from((0, tweetnacl_1.box)(Uint8Array.from(Buffer.alloc(32).fill(\"\\0\")), Uint8Array.from(this.SHARED_KEY_NONCE), Uint8Array.from(ephemeral_public_key), Uint8Array.from(private_key))).slice(-32);\n        // To compute the recipient identifier, concatenate the derived symmetric key and the\n        // saltpack_recipsbXXXXXXXX nonce together, and HMAC-SHA512 them under the key saltpack signcryption box\n        // key identifier. The identifier is the first 32 bytes of that HMAC.\n        const recipient_identifier = Buffer.from((0, hmac_1.hmac)(sha2_1.sha512, this.HMAC_KEY, Buffer.concat([shared_symmetric_key, recipient_index])).slice(0, 32));\n        return { shared_symmetric_key, recipient_identifier };\n    }\n}\nSigncryptedMessageRecipient.SHARED_KEY_NONCE = Buffer.from(\"saltpack_derived_sboxkey\");\nSigncryptedMessageRecipient.HMAC_KEY = Buffer.from(\"saltpack signcryption box key identifier\");\nSigncryptedMessageRecipient.HMAC_KEY_SYMMETRIC = Buffer.from(\"saltpack signcryption derived symmetric key\");\nSigncryptedMessageRecipient.PAYLOAD_KEY_BOX_NONCE_PREFIX_V2 = Buffer.from(\"saltpack_recipsb\");\nexports.default = SigncryptedMessageRecipient;\n//# sourceMappingURL=recipient.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst message_header_1 = __importStar(require(\"../message-header\"));\nconst util_1 = require(\"../util\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\n// [\n//     format name,\n//     version,\n//     mode,\n//     sender public key,\n//     nonce,\n// ]\nclass SignedMessageHeader extends message_header_1.default {\n    constructor(public_key, nonce, attached = true) {\n        super();\n        if (!(0, util_1.isBufferOrUint8Array)(public_key) || public_key.length !== 32) {\n            throw new TypeError(\"public_key must be a 32 byte Uint8Array\");\n        }\n        if (!(0, util_1.isBufferOrUint8Array)(nonce) || nonce.length !== 32) {\n            throw new TypeError(\"nonce must be a 32 byte Uint8Array\");\n        }\n        if (typeof attached !== \"boolean\") {\n            throw new TypeError(\"attached must be a boolean\");\n        }\n        this.public_key = public_key;\n        this.nonce = nonce;\n        this.attached = attached;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded outer header data */\n    get encoded() {\n        return this.encoded_data[1];\n    }\n    /** The SHA512 hash of the MessagePack encoded inner header data */\n    get hash() {\n        return this.encoded_data[0];\n    }\n    static create(public_key, attached = true) {\n        var _a;\n        const nonce = (_a = this.debug_fix_nonce) !== null && _a !== void 0 ? _a : (0, tweetnacl_1.randomBytes)(32);\n        return new this(public_key, nonce, attached);\n    }\n    encode() {\n        return SignedMessageHeader.encodeHeader(this.public_key, this.nonce, this.attached);\n    }\n    static encodeHeader(public_key, nonce, attached) {\n        const data = [\"saltpack\", [2, 0], attached ? message_header_1.MessageType.ATTACHED_SIGNING : message_header_1.MessageType.DETACHED_SIGNING, public_key, nonce];\n        const encoded = (0, msgpack_1.encode)(data);\n        const header_hash = sha2_1.sha512.create().update(encoded).digest();\n        return [header_hash, Buffer.from((0, msgpack_1.encode)(encoded))];\n    }\n    static decode(encoded, unwrapped = false) {\n        const [, data] = super.decode1(encoded, unwrapped);\n        if (data[2] !== message_header_1.MessageType.ATTACHED_SIGNING && data[2] !== message_header_1.MessageType.DETACHED_SIGNING)\n            throw new Error(\"Invalid data\");\n        const [, , , public_key, nonce] = data;\n        return new this(public_key, nonce, data[2] === message_header_1.MessageType.ATTACHED_SIGNING);\n    }\n    signDetached(data, private_key) {\n        if (this.attached) {\n            throw new Error(\"Header attached is true\");\n        }\n        const hash = sha2_1.sha512.create().update(this.hash).update(data).digest();\n        const sign_data = Buffer.concat([SignedMessageHeader.DETACHED_SIGNATURE_PREFIX, hash]);\n        return Buffer.from(tweetnacl_1.sign.detached(Uint8Array.from(sign_data), Uint8Array.from(private_key)));\n    }\n    verifyDetached(signature, data, public_key) {\n        if (this.attached) {\n            throw new Error(\"Header attached is true\");\n        }\n        const hash = sha2_1.sha512.create().update(this.hash).update(data).digest();\n        const sign_data = Buffer.concat([SignedMessageHeader.DETACHED_SIGNATURE_PREFIX, hash]);\n        if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(signature), Uint8Array.from(public_key))) {\n            throw new Error(\"Invalid signature\");\n        }\n    }\n}\nSignedMessageHeader.DETACHED_SIGNATURE_PREFIX = Buffer.from(\"saltpack detached signature\\0\");\nSignedMessageHeader.debug_fix_nonce = process.env.TEST ? Buffer.alloc(32).fill(0) : null;\nexports.default = SignedMessageHeader;\n//# sourceMappingURL=header.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VerifyStream = exports.SignStream = exports.CHUNK_LENGTH = void 0;\nexports.sign = sign;\nexports.verify = verify;\nexports.signDetached = signDetached;\nexports.verifyDetached = verifyDetached;\nconst header_1 = __importDefault(require(\"./header\"));\nconst payload_1 = __importDefault(require(\"./payload\"));\nconst util_1 = require(\"../util\");\nconst stream_1 = require(\"stream\");\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nlet debug = false;\nexports.CHUNK_LENGTH = 1024 * 1024;\nfunction sign(data, keypair) {\n    const chunks = (0, util_1.chunkBuffer)(data, exports.CHUNK_LENGTH);\n    const header = header_1.default.create(keypair.publicKey, true);\n    const payloads = [];\n    for (const i in chunks) {\n        const chunk = chunks[i];\n        const final = chunks.length === parseInt(i) + 1;\n        const payload = payload_1.default.create(header, keypair.secretKey, chunk, BigInt(i), final);\n        payloads.push(payload);\n    }\n    return Buffer.concat([header.encoded, Buffer.concat(payloads.map((payload) => payload.encoded))]);\n}\nclass SignStream extends stream_1.Transform {\n    constructor(keypair) {\n        super();\n        this.keypair = keypair;\n        this.in_buffer = Buffer.alloc(0);\n        this.payload_index = BigInt(0);\n        this.header = header_1.default.create(keypair.publicKey, true);\n        this.push(this.header.encoded);\n    }\n    _transform(data, encoding, callback) {\n        if (debug)\n            console.log(\"Processing chunk #d: %s\", -1, data);\n        this.in_buffer = Buffer.concat([this.in_buffer, data]);\n        while (this.in_buffer.length > exports.CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, exports.CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(exports.CHUNK_LENGTH);\n            // This is never the final payload as there must be additional data in `in_buffer`\n            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, /* final */ false);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n    _flush(callback) {\n        while (this.in_buffer.length >= exports.CHUNK_LENGTH) {\n            const chunk = this.in_buffer.slice(0, exports.CHUNK_LENGTH);\n            this.in_buffer = this.in_buffer.slice(exports.CHUNK_LENGTH);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        if (this.in_buffer.length) {\n            const chunk = this.in_buffer;\n            this.in_buffer = Buffer.alloc(0);\n            const final = !this.in_buffer.length;\n            const payload = payload_1.default.create(this.header, this.keypair.secretKey, chunk, this.payload_index, final);\n            this.push(payload.encoded);\n            this.payload_index++;\n        }\n        callback();\n    }\n}\nexports.SignStream = SignStream;\nfunction verify(signed, public_key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, e_1, _b, _c;\n        const stream = new stream_1.Readable();\n        stream.push(signed);\n        stream.push(null);\n        const items = [];\n        try {\n            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const item = _c;\n                items.push(item);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        const header_data = items.shift();\n        const header = header_1.default.decode(header_data, true);\n        if (public_key && !Buffer.from(header.public_key).equals(public_key)) {\n            throw new Error(\"Sender public key doesn't match\");\n        }\n        let output = Buffer.alloc(0);\n        for (const i in items) {\n            const message = items[i];\n            const final = items.length === parseInt(i) + 1;\n            const payload = payload_1.default.decode(message, true);\n            payload.verify(header, header.public_key, BigInt(i));\n            if (payload.final && !final) {\n                throw new Error(\"Found payload with invalid final flag, message extended?\");\n            }\n            if (!payload.final && final) {\n                throw new Error(\"Found payload with invalid final flag, message truncated?\");\n            }\n            output = Buffer.concat([output, payload.data]);\n        }\n        if (!items.length) {\n            throw new Error(\"No signed payloads, message truncated?\");\n        }\n        return Object.assign(output, {\n            public_key: new Uint8Array(header.public_key),\n        });\n    });\n}\nclass VerifyStream extends stream_1.Transform {\n    constructor(public_key) {\n        super();\n        this.decoder = new msgpack_1.Decoder();\n        this.header_data = null;\n        this.last_payload = null;\n        this.payload_index = BigInt(-1);\n        this.i = 0;\n        this._public_key = public_key !== null && public_key !== void 0 ? public_key : null;\n    }\n    get header() {\n        if (!this.header_data)\n            throw new Error(\"Header hasn't been decoded yet\");\n        return this.header_data;\n    }\n    get public_key() {\n        return this.header.public_key;\n    }\n    _transform(data, encoding, callback) {\n        // @ts-ignore\n        this.decoder.appendBuffer(data);\n        try {\n            let message;\n            // @ts-ignore\n            while ((message = this.decoder.doDecodeSync())) {\n                // @ts-ignore\n                const remaining = Buffer.from(this.decoder.bytes).slice(this.decoder.pos);\n                // @ts-ignore\n                this.decoder.setBuffer(remaining);\n                this._handleMessage(message);\n            }\n        }\n        catch (err) { }\n        callback();\n    }\n    _handleMessage(data) {\n        if (debug)\n            console.log(\"Processing chunk #%d: %O\", this.i++, data);\n        if (!this.header_data) {\n            const header = header_1.default.decode(data, true);\n            if (this._public_key && !Buffer.from(header.public_key).equals(this._public_key)) {\n                throw new Error(\"Sender public key doesn't match\");\n            }\n            this.header_data = header;\n            // @ts-expect-error\n            header.public_key = new Uint8Array(header.public_key);\n        }\n        else {\n            this.payload_index++;\n            if (this.last_payload) {\n                if (this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message extended?\");\n                }\n                this.push(this.last_payload.data);\n            }\n            const payload = payload_1.default.decode(data, true);\n            payload.verify(this.header, this.header.public_key, this.payload_index);\n            this.last_payload = payload;\n        }\n    }\n    _flush(callback) {\n        try {\n            if (this.last_payload) {\n                if (!this.last_payload.final) {\n                    throw new Error(\"Found payload with invalid final flag, message truncated?\");\n                }\n                this.push(this.last_payload.data);\n            }\n            if (!this.last_payload) {\n                throw new Error(\"No signed payloads, message truncated?\");\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n        callback();\n    }\n}\nexports.VerifyStream = VerifyStream;\nfunction signDetached(data, keypair) {\n    const header = header_1.default.create(keypair.publicKey, false);\n    return Buffer.concat([header.encoded, (0, msgpack_1.encode)(header.signDetached(Buffer.from(data), keypair.secretKey))]);\n}\nfunction verifyDetached(signature, data, public_key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, e_2, _b, _c;\n        const stream = new stream_1.Readable();\n        stream.push(signature);\n        stream.push(null);\n        const items = [];\n        try {\n            for (var _d = true, _e = __asyncValues((0, msgpack_1.decodeMultiStream)(stream)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const item = _c;\n                items.push(item);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        const [header_data, signature_data] = items;\n        const header = header_1.default.decode(header_data, true);\n        if (public_key && !Buffer.from(header.public_key).equals(public_key)) {\n            throw new Error(\"Sender public key doesn't match\");\n        }\n        header.verifyDetached(signature_data, Buffer.from(data), header.public_key);\n        return {\n            public_key: new Uint8Array(header.public_key),\n        };\n    });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst sha2_1 = require(\"@noble/hashes/sha2\");\n// [\n//     final flag,\n//     signature,\n//     payload chunk,\n// ]\nclass SignedMessagePayload {\n    constructor(final, signature, data) {\n        this.final = final;\n        this.signature = signature;\n        this.data = data;\n    }\n    get encoded_data() {\n        return Object.defineProperty(this, \"encoded_data\", {\n            value: this.encode(),\n        }).encoded_data;\n    }\n    /** The MessagePack encoded payload data */\n    get encoded() {\n        return this.encoded_data;\n    }\n    static create(header, private_key, data, index, final = false) {\n        if (typeof index === \"number\")\n            index = BigInt(index);\n        const sign_data = this.generateSignData(header.hash, index, final, data);\n        const signature = tweetnacl_1.sign.detached(Uint8Array.from(sign_data), Uint8Array.from(private_key));\n        return new this(final, signature, data);\n    }\n    static generateSignData(header_hash, index, final, data) {\n        // To make each signature, the sender first takes the SHA512 hash of the concatenation of four values:\n        // the header hash from above\n        // the packet sequence number, as a 64-bit big-endian unsigned integer, where the first payload packet is zero\n        // the final flag, a 0x00 byte for false and a 0x01 byte for true\n        // the payload chunk\n        const index_buffer = Buffer.alloc(8);\n        index_buffer.writeBigUInt64BE(index);\n        return Buffer.concat([\n            this.PAYLOAD_SIGNATURE_PREFIX,\n            sha2_1.sha512\n                .create()\n                .update(header_hash)\n                .update(index_buffer)\n                .update(final ? \"\\x01\" : \"\\x00\")\n                .update(data)\n                .digest(),\n        ]);\n    }\n    encode() {\n        return SignedMessagePayload.encodePayload(this.final, this.signature, this.data);\n    }\n    static encodePayload(final, signature, payload_chunk) {\n        return Buffer.from((0, msgpack_1.encode)([final, signature, payload_chunk]));\n    }\n    static decode(encoded, unpacked = false) {\n        const data = unpacked ? encoded : (0, msgpack_1.decode)(encoded);\n        if (data.length < 3)\n            throw new Error(\"Invalid data\");\n        const [final, signature, payload_chunk] = data;\n        return new this(final, signature, payload_chunk);\n    }\n    verify(header, public_key, index) {\n        const sign_data = SignedMessagePayload.generateSignData(header.hash, index, this.final, this.data);\n        if (!tweetnacl_1.sign.detached.verify(Uint8Array.from(sign_data), Uint8Array.from(this.signature), Uint8Array.from(public_key))) {\n            throw new Error(\"Invalid signature\");\n        }\n    }\n}\nSignedMessagePayload.PAYLOAD_SIGNATURE_PREFIX = Buffer.from(\"saltpack attached signature\\0\");\nexports.default = SignedMessagePayload;\n//# sourceMappingURL=payload.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBufferOrUint8Array = isBufferOrUint8Array;\nexports.chunkBuffer = chunkBuffer;\nexports.chunkString = chunkString;\nfunction isBufferOrUint8Array(buffer) {\n    return buffer instanceof Buffer || buffer instanceof Uint8Array;\n}\nfunction chunkBuffer(_buffer, length) {\n    if (_buffer === undefined)\n        return _buffer;\n    let buffer = _buffer instanceof Buffer ? _buffer : Buffer.from(_buffer);\n    const result = [];\n    while (buffer.length > length) {\n        const chunk = buffer.slice(0, length);\n        buffer = buffer.slice(length);\n        result.push(chunk);\n    }\n    if (buffer.length) {\n        result.push(buffer);\n    }\n    return result;\n}\nfunction chunkString(string, length) {\n    const result = [];\n    while (string.length > length) {\n        const chunk = string.substr(0, length);\n        string = string.substr(length);\n        result.push(chunk);\n    }\n    if (string.length) {\n        result.push(string);\n    }\n    return result;\n}\n//# sourceMappingURL=util.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DearmorAndDesigncryptStream = exports.SigncryptAndArmorStream = exports.DearmorAndVerifyStream = exports.SignAndArmorStream = exports.DearmorAndDecryptStream = exports.EncryptAndArmorStream = void 0;\nexports.encryptAndArmor = encryptAndArmor;\nexports.dearmorAndDecrypt = dearmorAndDecrypt;\nexports.signAndArmor = signAndArmor;\nexports.verifyArmored = verifyArmored;\nexports.signDetachedAndArmor = signDetachedAndArmor;\nexports.verifyDetachedArmored = verifyDetachedArmored;\nexports.signcryptAndArmor = signcryptAndArmor;\nexports.dearmorAndDesigncrypt = dearmorAndDesigncrypt;\nconst encryption_1 = require(\"./encryption\");\nconst signing_1 = require(\"./signing\");\nconst signcryption_1 = require(\"./signcryption\");\nconst armor_1 = require(\"./armor\");\nconst pumpify_1 = __importDefault(require(\"pumpify\"));\nfunction encryptAndArmor(data, keypair, recipients_keys) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const encrypted = yield (0, encryption_1.encrypt)(data, keypair, recipients_keys);\n        return (0, armor_1.armor)(encrypted, { message_type: armor_1.MessageType.ENCRYPTED_MESSAGE });\n    });\n}\nfunction dearmorAndDecrypt(encrypted, keypair, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dearmored = (0, armor_1.dearmor)(encrypted);\n        return Object.assign(yield (0, encryption_1.decrypt)(dearmored, keypair, sender), {\n            remaining: dearmored.remaining,\n            header_info: dearmored.header_info,\n        });\n    });\n}\nclass EncryptAndArmorStream extends pumpify_1.default {\n    constructor(keypair, recipients_keys, armor_options) {\n        const encrypt = new encryption_1.EncryptStream(keypair, recipients_keys);\n        const armor = new armor_1.ArmorStream(Object.assign({\n            message_type: armor_1.MessageType.ENCRYPTED_MESSAGE,\n        }, armor_options));\n        super(encrypt, armor);\n    }\n}\nexports.EncryptAndArmorStream = EncryptAndArmorStream;\nclass DearmorAndDecryptStream extends pumpify_1.default {\n    constructor(keypair, sender, armor_options) {\n        const dearmor = new armor_1.DearmorStream(armor_options);\n        const decrypt = new encryption_1.DecryptStream(keypair, sender);\n        super(dearmor, decrypt);\n        this.dearmor = dearmor;\n        this.decrypt = decrypt;\n    }\n    get info() {\n        return this.dearmor.info;\n    }\n    get sender_public_key() {\n        return this.decrypt.sender_public_key;\n    }\n}\nexports.DearmorAndDecryptStream = DearmorAndDecryptStream;\nfunction signAndArmor(data, keypair) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const signed = (0, signing_1.sign)(data, keypair);\n        return (0, armor_1.armor)(signed, { message_type: armor_1.MessageType.SIGNED_MESSAGE });\n    });\n}\nfunction verifyArmored(signed, public_key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dearmored = (0, armor_1.dearmor)(signed);\n        return Object.assign(yield (0, signing_1.verify)(dearmored, public_key), {\n            remaining: dearmored.remaining,\n            header_info: dearmored.header_info,\n        });\n    });\n}\nclass SignAndArmorStream extends pumpify_1.default {\n    constructor(keypair, armor_options) {\n        const sign = new signing_1.SignStream(keypair);\n        const armor = new armor_1.ArmorStream(Object.assign({\n            message_type: armor_1.MessageType.SIGNED_MESSAGE,\n        }, armor_options));\n        super(sign, armor);\n    }\n}\nexports.SignAndArmorStream = SignAndArmorStream;\nclass DearmorAndVerifyStream extends pumpify_1.default {\n    constructor(public_key, armor_options) {\n        const dearmor = new armor_1.DearmorStream(armor_options);\n        const verify = new signing_1.VerifyStream(public_key);\n        super(dearmor, verify);\n        this.dearmor = dearmor;\n        this.verify = verify;\n    }\n    get info() {\n        return this.dearmor.info;\n    }\n    get public_key() {\n        return this.verify.public_key;\n    }\n}\nexports.DearmorAndVerifyStream = DearmorAndVerifyStream;\nfunction signDetachedAndArmor(data, keypair) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const signed = (0, signing_1.signDetached)(data, keypair);\n        return (0, armor_1.armor)(signed, { message_type: armor_1.MessageType.DETACHED_SIGNATURE });\n    });\n}\nfunction verifyDetachedArmored(signature, data, public_key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dearmored = (0, armor_1.dearmor)(signature);\n        const result = yield (0, signing_1.verifyDetached)(dearmored, data, public_key);\n        return {\n            remaining: dearmored.remaining,\n            header_info: dearmored.header_info,\n            public_key: result.public_key,\n        };\n    });\n}\nfunction signcryptAndArmor(data, keypair, recipients_keys) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const encrypted = yield (0, signcryption_1.signcrypt)(data, keypair, recipients_keys);\n        return (0, armor_1.armor)(encrypted, { message_type: armor_1.MessageType.ENCRYPTED_MESSAGE });\n    });\n}\nfunction dearmorAndDesigncrypt(signcrypted, keypair, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dearmored = (0, armor_1.dearmor)(signcrypted);\n        return Object.assign(yield (0, signcryption_1.designcrypt)(dearmored, keypair, sender), {\n            remaining: dearmored.remaining,\n            header_info: dearmored.header_info,\n        });\n    });\n}\nclass SigncryptAndArmorStream extends pumpify_1.default {\n    constructor(keypair, recipients_keys, armor_options) {\n        const encrypt = new signcryption_1.SigncryptStream(keypair, recipients_keys);\n        const armor = new armor_1.ArmorStream(Object.assign({\n            message_type: armor_1.MessageType.ENCRYPTED_MESSAGE,\n        }, armor_options));\n        super(encrypt, armor);\n    }\n}\nexports.SigncryptAndArmorStream = SigncryptAndArmorStream;\nclass DearmorAndDesigncryptStream extends pumpify_1.default {\n    constructor(keys, armor_options) {\n        const dearmor = new armor_1.DearmorStream(armor_options);\n        const decrypt = new signcryption_1.DesigncryptStream(keys);\n        super(dearmor, decrypt);\n        this.dearmor = dearmor;\n        this.decrypt = decrypt;\n    }\n    get info() {\n        return this.dearmor.info;\n    }\n    get sender_public_key() {\n        return this.decrypt.sender_public_key;\n    }\n}\nexports.DearmorAndDesigncryptStream = DearmorAndDesigncryptStream;\n//# sourceMappingURL=with-armor.js.map","// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b\n\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nvar _require = require('./internal/errors'),\n  _require$codes = _require.codes,\n  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;\nvar AssertionError = require('./internal/assert/assertion_error');\nvar _require2 = require('util/'),\n  inspect = _require2.inspect;\nvar _require$types = require('util/').types,\n  isPromise = _require$types.isPromise,\n  isRegExp = _require$types.isRegExp;\nvar objectAssign = require('object.assign/polyfill')();\nvar objectIs = require('object-is/polyfill')();\nvar RegExpPrototypeTest = require('call-bind/callBound')('RegExp.prototype.test');\nvar errorCache = new Map();\nvar isDeepEqual;\nvar isDeepStrictEqual;\nvar parseExpressionAt;\nvar findNodeAround;\nvar decoder;\nfunction lazyLoadComparison() {\n  var comparison = require('./internal/util/comparisons');\n  isDeepEqual = comparison.isDeepEqual;\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\n}\n\n// Escape control characters but not \\n and \\t to keep the line breaks and\n// indentation intact.\n// eslint-disable-next-line no-control-regex\nvar escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '', '', \"\\\\u000b\", '\\\\f', '', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"];\nvar escapeFn = function escapeFn(str) {\n  return meta[str.charCodeAt(0)];\n};\nvar warned = false;\n\n// The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\nvar NO_EXCEPTION_SENTINEL = {};\n\n// All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided. All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction innerFail(obj) {\n  if (obj.message instanceof Error) throw obj.message;\n  throw new AssertionError(obj);\n}\nfunction fail(actual, expected, message, operator, stackStartFn) {\n  var argsLen = arguments.length;\n  var internalMessage;\n  if (argsLen === 0) {\n    internalMessage = 'Failed';\n  } else if (argsLen === 1) {\n    message = actual;\n    actual = undefined;\n  } else {\n    if (warned === false) {\n      warned = true;\n      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);\n      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');\n    }\n    if (argsLen === 2) operator = '!=';\n  }\n  if (message instanceof Error) throw message;\n  var errArgs = {\n    actual: actual,\n    expected: expected,\n    operator: operator === undefined ? 'fail' : operator,\n    stackStartFn: stackStartFn || fail\n  };\n  if (message !== undefined) {\n    errArgs.message = message;\n  }\n  var err = new AssertionError(errArgs);\n  if (internalMessage) {\n    err.message = internalMessage;\n    err.generatedMessage = true;\n  }\n  throw err;\n}\nassert.fail = fail;\n\n// The AssertionError is defined in internal/error.\nassert.AssertionError = AssertionError;\nfunction innerOk(fn, argLen, value, message) {\n  if (!value) {\n    var generatedMessage = false;\n    if (argLen === 0) {\n      generatedMessage = true;\n      message = 'No value argument passed to `assert.ok()`';\n    } else if (message instanceof Error) {\n      throw message;\n    }\n    var err = new AssertionError({\n      actual: value,\n      expected: true,\n      message: message,\n      operator: '==',\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\n\n// Pure assertion tests whether a value is truthy, as determined\n// by !!value.\nfunction ok() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  innerOk.apply(void 0, [ok, args.length].concat(args));\n}\nassert.ok = ok;\n\n// The equality assertion tests shallow, coercive equality with ==.\n/* eslint-disable no-restricted-properties */\nassert.equal = function equal(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  // eslint-disable-next-line eqeqeq\n  if (actual != expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '==',\n      stackStartFn: equal\n    });\n  }\n};\n\n// The non-equality assertion tests for whether two objects are not\n// equal with !=.\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  // eslint-disable-next-line eqeqeq\n  if (actual == expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '!=',\n      stackStartFn: notEqual\n    });\n  }\n};\n\n// The equivalence assertion tests a deep equality relation.\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (!isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepEqual',\n      stackStartFn: deepEqual\n    });\n  }\n};\n\n// The non-equivalence assertion tests for any deep inequality.\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepEqual',\n      stackStartFn: notDeepEqual\n    });\n  }\n};\n/* eslint-enable */\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (!isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepStrictEqual',\n      stackStartFn: deepStrictEqual\n    });\n  }\n};\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepStrictEqual',\n      stackStartFn: notDeepStrictEqual\n    });\n  }\n}\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (!objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'strictEqual',\n      stackStartFn: strictEqual\n    });\n  }\n};\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notStrictEqual',\n      stackStartFn: notStrictEqual\n    });\n  }\n};\nvar Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {\n  var _this = this;\n  _classCallCheck(this, Comparison);\n  keys.forEach(function (key) {\n    if (key in obj) {\n      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {\n        _this[key] = actual[key];\n      } else {\n        _this[key] = obj[key];\n      }\n    }\n  });\n});\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\n    if (!message) {\n      // Create placeholder objects to create a nice output.\n      var a = new Comparison(actual, keys);\n      var b = new Comparison(expected, keys, actual);\n      var err = new AssertionError({\n        actual: a,\n        expected: b,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.actual = actual;\n      err.expected = expected;\n      err.operator = fn.name;\n      throw err;\n    }\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n  }\n}\nfunction expectedException(actual, expected, msg, fn) {\n  if (typeof expected !== 'function') {\n    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);\n    // assert.doesNotThrow does not accept objects.\n    if (arguments.length === 2) {\n      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);\n    }\n\n    // Handle primitives properly.\n    if (_typeof(actual) !== 'object' || actual === null) {\n      var err = new AssertionError({\n        actual: actual,\n        expected: expected,\n        message: msg,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.operator = fn.name;\n      throw err;\n    }\n    var keys = Object.keys(expected);\n    // Special handle errors to make sure the name and the message are compared\n    // as well.\n    if (expected instanceof Error) {\n      keys.push('name', 'message');\n    } else if (keys.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');\n    }\n    if (isDeepEqual === undefined) lazyLoadComparison();\n    keys.forEach(function (key) {\n      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {\n        return;\n      }\n      compareExceptionKey(actual, expected, key, msg, keys, fn);\n    });\n    return true;\n  }\n  // Guard instanceof against arrow functions as they don't have a prototype.\n  if (expected.prototype !== undefined && actual instanceof expected) {\n    return true;\n  }\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n  return expected.call({}, actual) === true;\n}\nfunction getActual(fn) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);\n  }\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION_SENTINEL;\n}\nfunction checkIsPromise(obj) {\n  // Accept native ES6 promises and promises that are implemented in a similar\n  // way. Do not accept thenables that use a function as `obj` and that have no\n  // `catch` handler.\n\n  // TODO: thenables are checked up until they have the correct methods,\n  // but according to documentation, the `then` method should receive\n  // the `fulfill` and `reject` arguments as well or it may be never resolved.\n\n  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';\n}\nfunction waitForActual(promiseFn) {\n  return Promise.resolve().then(function () {\n    var resultPromise;\n    if (typeof promiseFn === 'function') {\n      // Return a rejected promise if `promiseFn` throws synchronously.\n      resultPromise = promiseFn();\n      // Fail in case no promise is returned.\n      if (!checkIsPromise(resultPromise)) {\n        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);\n      }\n    } else if (checkIsPromise(promiseFn)) {\n      resultPromise = promiseFn;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);\n    }\n    return Promise.resolve().then(function () {\n      return resultPromise;\n    }).then(function () {\n      return NO_EXCEPTION_SENTINEL;\n    }).catch(function (e) {\n      return e;\n    });\n  });\n}\nfunction expectsError(stackStartFn, actual, error, message) {\n  if (typeof error === 'string') {\n    if (arguments.length === 4) {\n      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n    }\n    if (_typeof(actual) === 'object' && actual !== null) {\n      if (actual.message === error) {\n        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error message \\\"\".concat(actual.message, \"\\\" is identical to the message.\"));\n      }\n    } else if (actual === error) {\n      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error \\\"\".concat(actual, \"\\\" is identical to the message.\"));\n    }\n    message = error;\n    error = undefined;\n  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n  }\n  if (actual === NO_EXCEPTION_SENTINEL) {\n    var details = '';\n    if (error && error.name) {\n      details += \" (\".concat(error.name, \")\");\n    }\n    details += message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';\n    innerFail({\n      actual: undefined,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Missing expected \".concat(fnType).concat(details),\n      stackStartFn: stackStartFn\n    });\n  }\n  if (error && !expectedException(actual, error, message, stackStartFn)) {\n    throw actual;\n  }\n}\nfunction expectsNoError(stackStartFn, actual, error, message) {\n  if (actual === NO_EXCEPTION_SENTINEL) return;\n  if (typeof error === 'string') {\n    message = error;\n    error = undefined;\n  }\n  if (!error || expectedException(actual, error)) {\n    var details = message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';\n    innerFail({\n      actual: actual,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Got unwanted \".concat(fnType).concat(details, \"\\n\") + \"Actual message: \\\"\".concat(actual && actual.message, \"\\\"\"),\n      stackStartFn: stackStartFn\n    });\n  }\n  throw actual;\n}\nassert.throws = function throws(promiseFn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n};\nassert.rejects = function rejects(promiseFn) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return waitForActual(promiseFn).then(function (result) {\n    return expectsError.apply(void 0, [rejects, result].concat(args));\n  });\n};\nassert.doesNotThrow = function doesNotThrow(fn) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n};\nassert.doesNotReject = function doesNotReject(fn) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n  return waitForActual(fn).then(function (result) {\n    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n  });\n};\nassert.ifError = function ifError(err) {\n  if (err !== null && err !== undefined) {\n    var message = 'ifError got unwanted exception: ';\n    if (_typeof(err) === 'object' && typeof err.message === 'string') {\n      if (err.message.length === 0 && err.constructor) {\n        message += err.constructor.name;\n      } else {\n        message += err.message;\n      }\n    } else {\n      message += inspect(err);\n    }\n    var newErr = new AssertionError({\n      actual: err,\n      expected: null,\n      operator: 'ifError',\n      message: message,\n      stackStartFn: ifError\n    });\n\n    // Make sure we actually have a stack trace!\n    var origStack = err.stack;\n    if (typeof origStack === 'string') {\n      // This will remove any duplicated frames from the error frames taken\n      // from within `ifError` and add the original error frames to the newly\n      // created ones.\n      var tmp2 = origStack.split('\\n');\n      tmp2.shift();\n      // Filter all frames existing in err.stack.\n      var tmp1 = newErr.stack.split('\\n');\n      for (var i = 0; i < tmp2.length; i++) {\n        // Find the first occurrence of the frame.\n        var pos = tmp1.indexOf(tmp2[i]);\n        if (pos !== -1) {\n          // Only keep new frames.\n          tmp1 = tmp1.slice(0, pos);\n          break;\n        }\n      }\n      newErr.stack = \"\".concat(tmp1.join('\\n'), \"\\n\").concat(tmp2.join('\\n'));\n    }\n    throw newErr;\n  }\n};\n\n// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb\nfunction internalMatch(string, regexp, message, fn, fnName) {\n  if (!isRegExp(regexp)) {\n    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);\n  }\n  var match = fnName === 'match';\n  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    var generatedMessage = !message;\n\n    // 'The input was expected to not match the regular expression ' +\n    message = message || (typeof string !== 'string' ? 'The \"string\" argument must be of type string. Received type ' + \"\".concat(_typeof(string), \" (\").concat(inspect(string), \")\") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + \"\".concat(inspect(regexp), \". Input:\\n\\n\").concat(inspect(string), \"\\n\"));\n    var err = new AssertionError({\n      actual: string,\n      expected: regexp,\n      message: message,\n      operator: fnName,\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\nassert.match = function match(string, regexp, message) {\n  internalMatch(string, regexp, message, match, 'match');\n};\nassert.doesNotMatch = function doesNotMatch(string, regexp, message) {\n  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');\n};\n\n// Expose a strict only variant of assert\nfunction strict() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n  innerOk.apply(void 0, [strict, args.length].concat(args));\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;","// Currently in sync with Node.js lib/internal/assert/assertion_error.js\n// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c\n\n'use strict';\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar _require = require('util/'),\n  inspect = _require.inspect;\nvar _require2 = require('../errors'),\n  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n  return str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\nfunction repeat(str, count) {\n  count = Math.floor(count);\n  if (str.length == 0 || count == 0) return '';\n  var maxCount = str.length * count;\n  count = Math.floor(Math.log(count) / Math.log(2));\n  while (count) {\n    str += str;\n    count--;\n  }\n  str += str.substring(0, maxCount - str.length);\n  return str;\n}\nvar blue = '';\nvar green = '';\nvar red = '';\nvar white = '';\nvar kReadableOperator = {\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\n  strictEqual: 'Expected values to be strictly equal:',\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n  deepEqual: 'Expected values to be loosely deep-equal:',\n  equal: 'Expected values to be loosely equal:',\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notEqual: 'Expected \"actual\" to be loosely unequal to:',\n  notIdentical: 'Values identical but not reference-equal:'\n};\n\n// Comparing short primitives should just show === / !== instead of using the\n// diff.\nvar kMaxShortLength = 10;\nfunction copyError(source) {\n  var keys = Object.keys(source);\n  var target = Object.create(Object.getPrototypeOf(source));\n  keys.forEach(function (key) {\n    target[key] = source[key];\n  });\n  Object.defineProperty(target, 'message', {\n    value: source.message\n  });\n  return target;\n}\nfunction inspectValue(val) {\n  // The util.inspect default values could be changed. This makes sure the\n  // error messages contain the necessary information nevertheless.\n  return inspect(val, {\n    compact: false,\n    customInspect: false,\n    depth: 1000,\n    maxArrayLength: Infinity,\n    // Assert compares only enumerable properties (with a few exceptions).\n    showHidden: false,\n    // Having a long line as error is better than wrapping the line for\n    // comparison for now.\n    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we\n    // have meta information about the inspected properties (i.e., know where\n    // in what line the property starts and ends).\n    breakLength: Infinity,\n    // Assert does not detect proxies currently.\n    showProxy: false,\n    sorted: true,\n    // Inspect getters as we also check them when comparing entries.\n    getters: true\n  });\n}\nfunction createErrDiff(actual, expected, operator) {\n  var other = '';\n  var res = '';\n  var lastPos = 0;\n  var end = '';\n  var skipped = false;\n  var actualInspected = inspectValue(actual);\n  var actualLines = actualInspected.split('\\n');\n  var expectedLines = inspectValue(expected).split('\\n');\n  var i = 0;\n  var indicator = '';\n\n  // In case both values are objects explicitly mark them as not reference equal\n  // for the `strictEqual` operator.\n  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {\n    operator = 'strictEqualObject';\n  }\n\n  // If \"actual\" and \"expected\" fit on a single line and they are not strictly\n  // equal, check further special handling.\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n    var inputLength = actualLines[0].length + expectedLines[0].length;\n    // If the character length of \"actual\" and \"expected\" together is less than\n    // kMaxShortLength and if neither is an object and at least one of them is\n    // not `zero`, use the strict equal comparison to visualize the output.\n    if (inputLength <= kMaxShortLength) {\n      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {\n        // -0 === +0\n        return \"\".concat(kReadableOperator[operator], \"\\n\\n\") + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], \"\\n\");\n      }\n    } else if (operator !== 'strictEqualObject') {\n      // If the stderr is a tty and the input length is lower than the current\n      // columns per line, add a mismatch indicator below the output. If it is\n      // not a tty, use a default value of 80 characters.\n      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;\n      if (inputLength < maxLength) {\n        while (actualLines[0][i] === expectedLines[0][i]) {\n          i++;\n        }\n        // Ignore the first characters.\n        if (i > 2) {\n          // Add position indicator for the first mismatch in case it is a\n          // single line and the input length is less than the column length.\n          indicator = \"\\n  \".concat(repeat(' ', i), \"^\");\n          i = 0;\n        }\n      }\n    }\n  }\n\n  // Remove all ending lines that match (this optimizes the output for\n  // readability by reducing the number of total changed lines).\n  var a = actualLines[actualLines.length - 1];\n  var b = expectedLines[expectedLines.length - 1];\n  while (a === b) {\n    if (i++ < 2) {\n      end = \"\\n  \".concat(a).concat(end);\n    } else {\n      other = a;\n    }\n    actualLines.pop();\n    expectedLines.pop();\n    if (actualLines.length === 0 || expectedLines.length === 0) break;\n    a = actualLines[actualLines.length - 1];\n    b = expectedLines[expectedLines.length - 1];\n  }\n  var maxLines = Math.max(actualLines.length, expectedLines.length);\n  // Strict equal with identical objects that are not identical by reference.\n  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })\n  if (maxLines === 0) {\n    // We have to get the result again. The lines were all removed before.\n    var _actualLines = actualInspected.split('\\n');\n\n    // Only remove lines in case it makes sense to collapse those.\n    // TODO: Accept env to always show the full error.\n    if (_actualLines.length > 30) {\n      _actualLines[26] = \"\".concat(blue, \"...\").concat(white);\n      while (_actualLines.length > 27) {\n        _actualLines.pop();\n      }\n    }\n    return \"\".concat(kReadableOperator.notIdentical, \"\\n\\n\").concat(_actualLines.join('\\n'), \"\\n\");\n  }\n  if (i > 3) {\n    end = \"\\n\".concat(blue, \"...\").concat(white).concat(end);\n    skipped = true;\n  }\n  if (other !== '') {\n    end = \"\\n  \".concat(other).concat(end);\n    other = '';\n  }\n  var printedLines = 0;\n  var msg = kReadableOperator[operator] + \"\\n\".concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white);\n  var skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n  for (i = 0; i < maxLines; i++) {\n    // Only extra expected lines exist\n    var cur = i - lastPos;\n    if (actualLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(expectedLines[i - 2]);\n          printedLines++;\n        }\n        res += \"\\n  \".concat(expectedLines[i - 1]);\n        printedLines++;\n      }\n      // Mark the current line as the last diverging one.\n      lastPos = i;\n      // Add the expected line to the cache.\n      other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]);\n      printedLines++;\n      // Only extra actual lines exist\n    } else if (expectedLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(actualLines[i - 2]);\n          printedLines++;\n        }\n        res += \"\\n  \".concat(actualLines[i - 1]);\n        printedLines++;\n      }\n      // Mark the current line as the last diverging one.\n      lastPos = i;\n      // Add the actual line to the result.\n      res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLines[i]);\n      printedLines++;\n      // Lines diverge\n    } else {\n      var expectedLine = expectedLines[i];\n      var actualLine = actualLines[i];\n      // If the lines diverge, specifically check for lines that only diverge by\n      // a trailing comma. In that case it is actually identical and we should\n      // mark it as such.\n      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);\n      // If the expected line has a trailing comma but is otherwise identical,\n      // add a comma at the end of the actual line. Otherwise the output could\n      // look weird as in:\n      //\n      //   [\n      //     1         // No comma at the end!\n      // +   2\n      //   ]\n      //\n      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {\n        divergingLines = false;\n        actualLine += ',';\n      }\n      if (divergingLines) {\n        // If the last diverging line is more than one line above and the\n        // current line is at least line three, add some of the former lines and\n        // also add dots to indicate skipped entries.\n        if (cur > 1 && i > 2) {\n          if (cur > 4) {\n            res += \"\\n\".concat(blue, \"...\").concat(white);\n            skipped = true;\n          } else if (cur > 3) {\n            res += \"\\n  \".concat(actualLines[i - 2]);\n            printedLines++;\n          }\n          res += \"\\n  \".concat(actualLines[i - 1]);\n          printedLines++;\n        }\n        // Mark the current line as the last diverging one.\n        lastPos = i;\n        // Add the actual line to the result and cache the expected diverging\n        // line so consecutive diverging lines show up as +++--- and not +-+-+-.\n        res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLine);\n        other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLine);\n        printedLines += 2;\n        // Lines are identical\n      } else {\n        // Add all cached information to the result before adding other things\n        // and reset the cache.\n        res += other;\n        other = '';\n        // If the last diverging line is exactly one line above or if it is the\n        // very first line, add the line to the result.\n        if (cur === 1 || i === 0) {\n          res += \"\\n  \".concat(actualLine);\n          printedLines++;\n        }\n      }\n    }\n    // Inspected object to big (Show ~20 rows max)\n    if (printedLines > 20 && i < maxLines - 2) {\n      return \"\".concat(msg).concat(skippedMsg, \"\\n\").concat(res, \"\\n\").concat(blue, \"...\").concat(white).concat(other, \"\\n\") + \"\".concat(blue, \"...\").concat(white);\n    }\n  }\n  return \"\".concat(msg).concat(skipped ? skippedMsg : '', \"\\n\").concat(res).concat(other).concat(end).concat(indicator);\n}\nvar AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {\n  _inherits(AssertionError, _Error);\n  var _super = _createSuper(AssertionError);\n  function AssertionError(options) {\n    var _this;\n    _classCallCheck(this, AssertionError);\n    if (_typeof(options) !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n    var message = options.message,\n      operator = options.operator,\n      stackStartFn = options.stackStartFn;\n    var actual = options.actual,\n      expected = options.expected;\n    var limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    if (message != null) {\n      _this = _super.call(this, String(message));\n    } else {\n      if (process.stderr && process.stderr.isTTY) {\n        // Reset on each call to make sure we handle dynamically set environment\n        // variables correct.\n        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {\n          blue = \"\\x1B[34m\";\n          green = \"\\x1B[32m\";\n          white = \"\\x1B[39m\";\n          red = \"\\x1B[31m\";\n        } else {\n          blue = '';\n          green = '';\n          white = '';\n          red = '';\n        }\n      }\n      // Prevent the error stack from being visible by duplicating the error\n      // in a very close way to the original in case both sides are actually\n      // instances of Error.\n      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {\n        actual = copyError(actual);\n        expected = copyError(expected);\n      }\n      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {\n        _this = _super.call(this, createErrDiff(actual, expected, operator));\n      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {\n        // In case the objects are equal but the operator requires unequal, show\n        // the first object and say A equals B\n        var base = kReadableOperator[operator];\n        var res = inspectValue(actual).split('\\n');\n\n        // In case \"actual\" is an object, it should not be reference equal.\n        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {\n          base = kReadableOperator.notStrictEqualObject;\n        }\n\n        // Only remove lines in case it makes sense to collapse those.\n        // TODO: Accept env to always show the full error.\n        if (res.length > 30) {\n          res[26] = \"\".concat(blue, \"...\").concat(white);\n          while (res.length > 27) {\n            res.pop();\n          }\n        }\n\n        // Only print a single input.\n        if (res.length === 1) {\n          _this = _super.call(this, \"\".concat(base, \" \").concat(res[0]));\n        } else {\n          _this = _super.call(this, \"\".concat(base, \"\\n\\n\").concat(res.join('\\n'), \"\\n\"));\n        }\n      } else {\n        var _res = inspectValue(actual);\n        var other = '';\n        var knownOperators = kReadableOperator[operator];\n        if (operator === 'notDeepEqual' || operator === 'notEqual') {\n          _res = \"\".concat(kReadableOperator[operator], \"\\n\\n\").concat(_res);\n          if (_res.length > 1024) {\n            _res = \"\".concat(_res.slice(0, 1021), \"...\");\n          }\n        } else {\n          other = \"\".concat(inspectValue(expected));\n          if (_res.length > 512) {\n            _res = \"\".concat(_res.slice(0, 509), \"...\");\n          }\n          if (other.length > 512) {\n            other = \"\".concat(other.slice(0, 509), \"...\");\n          }\n          if (operator === 'deepEqual' || operator === 'equal') {\n            _res = \"\".concat(knownOperators, \"\\n\\n\").concat(_res, \"\\n\\nshould equal\\n\\n\");\n          } else {\n            other = \" \".concat(operator, \" \").concat(other);\n          }\n        }\n        _this = _super.call(this, \"\".concat(_res).concat(other));\n      }\n    }\n    Error.stackTraceLimit = limit;\n    _this.generatedMessage = !message;\n    Object.defineProperty(_assertThisInitialized(_this), 'name', {\n      value: 'AssertionError [ERR_ASSERTION]',\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    _this.code = 'ERR_ASSERTION';\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.operator = operator;\n    if (Error.captureStackTrace) {\n      // eslint-disable-next-line no-restricted-syntax\n      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);\n    }\n    // Create error message including the error code in the name.\n    _this.stack;\n    // Reset the name.\n    _this.name = 'AssertionError';\n    return _possibleConstructorReturn(_this);\n  }\n  _createClass(AssertionError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n    }\n  }, {\n    key: _inspect$custom,\n    value: function value(recurseTimes, ctx) {\n      // This limits the `actual` and `expected` property default inspection to\n      // the minimum depth. Otherwise those values would be too verbose compared\n      // to the actual error message which contains a combined view of these two\n      // input values.\n      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {\n        customInspect: false,\n        depth: 0\n      }));\n    }\n  }]);\n  return AssertionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);\nmodule.exports = AssertionError;","// Currently in sync with Node.js lib/internal/errors.js\n// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f\n\n/* eslint node-core/documented-errors: \"error\" */\n/* eslint node-core/alphabetize-errors: \"error\" */\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar codes = {};\n\n// Lazy loaded\nvar assert;\nvar util;\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n  var NodeError = /*#__PURE__*/function (_Base) {\n    _inherits(NodeError, _Base);\n    var _super = _createSuper(NodeError);\n    function NodeError(arg1, arg2, arg3) {\n      var _this;\n      _classCallCheck(this, NodeError);\n      _this = _super.call(this, getMessage(arg1, arg2, arg3));\n      _this.code = code;\n      return _this;\n    }\n    return _createClass(NodeError);\n  }(Base);\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n  return str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\ncreateErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  if (assert === undefined) assert = require('../assert');\n  assert(typeof name === 'string', \"'name' must be a string\");\n\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n  var msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  // TODO(BridgeAR): Improve the output by showing `null` and similar.\n  msg += \". Received type \".concat(_typeof(actual));\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';\n  if (util === undefined) util = require('util/');\n  var inspected = util.inspect(value);\n  if (inspected.length > 128) {\n    inspected = \"\".concat(inspected.slice(0, 128), \"...\");\n  }\n  return \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n}, TypeError, RangeError);\ncreateErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {\n  var type;\n  if (value && value.constructor && value.constructor.name) {\n    type = \"instance of \".concat(value.constructor.name);\n  } else {\n    type = \"type \".concat(_typeof(value));\n  }\n  return \"Expected \".concat(input, \" to be returned from the \\\"\").concat(name, \"\\\"\") + \" function but got \".concat(type, \".\");\n}, TypeError);\ncreateErrorType('ERR_MISSING_ARGS', function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (assert === undefined) assert = require('../assert');\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  var msg = 'The ';\n  var len = args.length;\n  args = args.map(function (a) {\n    return \"\\\"\".concat(a, \"\\\"\");\n  });\n  switch (len) {\n    case 1:\n      msg += \"\".concat(args[0], \" argument\");\n      break;\n    case 2:\n      msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n      break;\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += \", and \".concat(args[len - 1], \" arguments\");\n      break;\n  }\n  return \"\".concat(msg, \" must be specified\");\n}, TypeError);\nmodule.exports.codes = codes;","// Currently in sync with Node.js lib/internal/util/comparisons.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar regexFlagsSupported = /a/g.flags !== undefined;\nvar arrayFromSet = function arrayFromSet(set) {\n  var array = [];\n  set.forEach(function (value) {\n    return array.push(value);\n  });\n  return array;\n};\nvar arrayFromMap = function arrayFromMap(map) {\n  var array = [];\n  map.forEach(function (value, key) {\n    return array.push([key, value]);\n  });\n  return array;\n};\nvar objectIs = Object.is ? Object.is : require('object-is');\nvar objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {\n  return [];\n};\nvar numberIsNaN = Number.isNaN ? Number.isNaN : require('is-nan');\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\nvar hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\nvar propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\nvar objectToString = uncurryThis(Object.prototype.toString);\nvar _require$types = require('util/').types,\n  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,\n  isArrayBufferView = _require$types.isArrayBufferView,\n  isDate = _require$types.isDate,\n  isMap = _require$types.isMap,\n  isRegExp = _require$types.isRegExp,\n  isSet = _require$types.isSet,\n  isNativeError = _require$types.isNativeError,\n  isBoxedPrimitive = _require$types.isBoxedPrimitive,\n  isNumberObject = _require$types.isNumberObject,\n  isStringObject = _require$types.isStringObject,\n  isBooleanObject = _require$types.isBooleanObject,\n  isBigIntObject = _require$types.isBigIntObject,\n  isSymbolObject = _require$types.isSymbolObject,\n  isFloat32Array = _require$types.isFloat32Array,\n  isFloat64Array = _require$types.isFloat64Array;\nfunction isNonIndex(key) {\n  if (key.length === 0 || key.length > 10) return true;\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  }\n  // The maximum size for an array is 2 ** 32 -1.\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\nfunction getOwnNonIndexProperties(value) {\n  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));\n}\n\n// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  var x = a.length;\n  var y = b.length;\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nvar ONLY_ENUMERABLE = undefined;\nvar kStrict = true;\nvar kLoose = false;\nvar kNoIterator = 0;\nvar kIsArray = 1;\nvar kIsSet = 2;\nvar kIsMap = 3;\n\n// Check if they have the same source and flags\nfunction areSimilarRegExps(a, b) {\n  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);\n}\nfunction areSimilarFloatArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (var offset = 0; offset < a.byteLength; offset++) {\n    if (a[offset] !== b[offset]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areSimilarTypedArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n}\nfunction areEqualArrayBuffers(buf1, buf2) {\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n}\nfunction isEqualBoxedPrimitive(val1, val2) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));\n  }\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);\n  }\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);\n  }\n  if (isBigIntObject(val1)) {\n    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);\n  }\n  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);\n}\n\n// Notes: Type tags are historical [[Class]] properties that can be set by\n// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n// and retrieved using Object.prototype.toString.call(obj) in JS\n// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n// for a list of tags pre-defined in the spec.\n// There are some unspecified tags in the wild too (e.g. typed array tags).\n// Since tags can be altered, they only serve fast failures\n//\n// Typed arrays and buffers are checked by comparing the content in their\n// underlying ArrayBuffer. This optimization requires that it's\n// reasonable to interpret their underlying memory in the same way,\n// which is checked by comparing their type tags.\n// (e.g. a Uint8Array and a Uint16Array with the same memory content\n// could still be different because they will be interpreted differently).\n//\n// For strict comparison, objects should have\n// a) The same built-in type tags\n// b) The same prototypes.\n\nfunction innerDeepEqual(val1, val2, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return strict ? objectIs(val1, val2) : true;\n  }\n\n  // Check more closely if val1 and val2 are equal.\n  if (strict) {\n    if (_typeof(val1) !== 'object') {\n      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);\n    }\n    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {\n      return false;\n    }\n    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n      return false;\n    }\n  } else {\n    if (val1 === null || _typeof(val1) !== 'object') {\n      if (val2 === null || _typeof(val2) !== 'object') {\n        // eslint-disable-next-line eqeqeq\n        return val1 == val2;\n      }\n      return false;\n    }\n    if (val2 === null || _typeof(val2) !== 'object') {\n      return false;\n    }\n  }\n  var val1Tag = objectToString(val1);\n  var val2Tag = objectToString(val2);\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (val1.length !== val2.length) {\n      return false;\n    }\n    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n  }\n  // [browserify] This triggers on certain types in IE (Map/Set) so we don't\n  // wan't to early return out of the rest of the checks. However we can check\n  // if the second value is one of these values and the first isn't.\n  if (val1Tag === '[object Object]') {\n    // return keyCheck(val1, val2, strict, memos, kNoIterator);\n    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {\n      return false;\n    }\n  }\n  if (isDate(val1)) {\n    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (val1.message !== val2.message || val1.name !== val2.name) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n      if (!areSimilarFloatArrays(val1, val2)) {\n        return false;\n      }\n    } else if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    }\n    // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n    if (_keys.length !== _keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n    return false;\n  }\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\n}\nfunction getEnumerables(val, keys) {\n  return keys.filter(function (k) {\n    return propertyIsEnumerable(val, k);\n  });\n}\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 5) {\n    aKeys = Object.keys(val1);\n    var bKeys = Object.keys(val2);\n\n    // The pair must have the same number of owned properties.\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  }\n\n  // Cheap key test\n  var i = 0;\n  for (; i < aKeys.length; i++) {\n    if (!hasOwnProperty(val2, aKeys[i])) {\n      return false;\n    }\n  }\n  if (strict && arguments.length === 5) {\n    var symbolKeysA = objectGetOwnPropertySymbols(val1);\n    if (symbolKeysA.length !== 0) {\n      var count = 0;\n      for (i = 0; i < symbolKeysA.length; i++) {\n        var key = symbolKeysA[i];\n        if (propertyIsEnumerable(val1, key)) {\n          if (!propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n          aKeys.push(key);\n          count++;\n        } else if (propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n      var symbolKeysB = objectGetOwnPropertySymbols(val2);\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\n        return false;\n      }\n    } else {\n      var _symbolKeysB = objectGetOwnPropertySymbols(val2);\n      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {\n        return false;\n      }\n    }\n  }\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\n    return true;\n  }\n\n  // Use memos to handle cycles.\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    var val2MemoA = memos.val1.get(val1);\n    if (val2MemoA !== undefined) {\n      var val2MemoB = memos.val2.get(val2);\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n    memos.position++;\n  }\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n  return areEq;\n}\nfunction setHasEqualElement(set, val1, strict, memo) {\n  // Go looking.\n  var setValues = arrayFromSet(set);\n  for (var i = 0; i < setValues.length; i++) {\n    var val2 = setValues[i];\n    if (innerDeepEqual(val1, val2, strict, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n  return false;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n// Sadly it is not possible to detect corresponding values properly in case the\n// type is a string, number, bigint or boolean. The reason is that those values\n// can match lots of different string values (e.g., 1n == '+00001').\nfunction findLooseMatchingPrimitives(prim) {\n  switch (_typeof(prim)) {\n    case 'undefined':\n      return null;\n    case 'object':\n      // Only pass in null as object!\n      return undefined;\n    case 'symbol':\n      return false;\n    case 'string':\n      prim = +prim;\n    // Loose equal entries exist only if the string is possible to convert to\n    // a regular number and not NaN.\n    // Fall through\n    case 'number':\n      if (numberIsNaN(prim)) {\n        return false;\n      }\n  }\n  return true;\n}\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) return altValue;\n  return b.has(altValue) && !a.has(altValue);\n}\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  var curB = b.get(altValue);\n  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\n    return false;\n  }\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\n}\nfunction setEquiv(a, b, strict, memo) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  var set = null;\n  var aValues = arrayFromSet(a);\n  for (var i = 0; i < aValues.length; i++) {\n    var val = aValues[i];\n    // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n    if (_typeof(val) === 'object' && val !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      // If the specified value doesn't exist in the second set its an not null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something thats deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n      set.add(val);\n    } else if (!b.has(val)) {\n      if (strict) return false;\n\n      // Fast path to detect missing string, symbol, undefined and null values.\n      if (!setMightHaveLoosePrim(a, b, val)) {\n        return false;\n      }\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(val);\n    }\n  }\n  if (set !== null) {\n    var bValues = arrayFromSet(b);\n    for (var _i = 0; _i < bValues.length; _i++) {\n      var _val = bValues[_i];\n      // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n      if (_typeof(_val) === 'object' && _val !== null) {\n        if (!setHasEqualElement(set, _val, strict, memo)) return false;\n      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  var setValues = arrayFromSet(set);\n  for (var i = 0; i < setValues.length; i++) {\n    var key2 = setValues[i];\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\n      set.delete(key2);\n      return true;\n    }\n  }\n  return false;\n}\nfunction mapEquiv(a, b, strict, memo) {\n  var set = null;\n  var aEntries = arrayFromMap(a);\n  for (var i = 0; i < aEntries.length; i++) {\n    var _aEntries$i = _slicedToArray(aEntries[i], 2),\n      key = _aEntries$i[0],\n      item1 = _aEntries$i[1];\n    if (_typeof(key) === 'object' && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      var item2 = b.get(key);\n      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\n        if (strict) return false;\n        // Fast path to detect missing string, symbol, undefined and null\n        // keys.\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;\n        if (set === null) {\n          set = new Set();\n        }\n        set.add(key);\n      }\n    }\n  }\n  if (set !== null) {\n    var bEntries = arrayFromMap(b);\n    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {\n      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),\n        _key = _bEntries$_i[0],\n        item = _bEntries$_i[1];\n      if (_typeof(_key) === 'object' && _key !== null) {\n        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;\n      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  var i = 0;\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (hasOwnProperty(a, i)) {\n        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\n          return false;\n        }\n      } else if (hasOwnProperty(b, i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        var keysA = Object.keys(a);\n        for (; i < keysA.length; i++) {\n          var key = keysA[i];\n          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\n            return false;\n          }\n        }\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = 0; i < keys.length; i++) {\n    var _key2 = keys[i];\n    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isDeepEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kLoose);\n}\nfunction isDeepStrictEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kStrict);\n}\nmodule.exports = {\n  isDeepEqual: isDeepEqual,\n  isDeepStrictEqual: isDeepStrictEqual\n};","'use strict';\n\nvar possibleNames = require('possible-typed-array-names');\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\n/** @type {import('.')} */\nmodule.exports = function availableTypedArrays() {\n\tvar /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\t// @ts-expect-error\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict';\n\nvar bind = require('function-bind');\n\nvar $apply = require('./functionApply');\nvar $call = require('./functionCall');\nvar $reflectApply = require('./reflectApply');\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n","'use strict';\n\nvar bind = require('function-bind');\nvar $apply = require('./functionApply');\nvar actualApply = require('./actualApply');\n\n/** @type {import('./applyBind')} */\nmodule.exports = function applyBind() {\n\treturn actualApply(bind, $apply, arguments);\n};\n","'use strict';\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n","'use strict';\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n","'use strict';\n\nvar bind = require('function-bind');\nvar $TypeError = require('es-errors/type');\n\nvar $call = require('./functionCall');\nvar $actualApply = require('./actualApply');\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n","'use strict';\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar setFunctionLength = require('set-function-length');\n\nvar $defineProperty = require('es-define-property');\n\nvar callBindBasic = require('call-bind-apply-helpers');\nvar applyBind = require('call-bind-apply-helpers/applyBind');\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = callBindBasic(arguments);\n\tvar adjustedLength = originalFunction.length - (arguments.length - 1);\n\treturn setFunctionLength(\n\t\tfunc,\n\t\t1 + (adjustedLength > 0 ? adjustedLength : 0),\n\t\ttrue\n\t);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBindBasic = require('call-bind-apply-helpers');\n\n/** @type {(thisArg: string, searchString: string, position?: number) => number} */\nvar $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);\n\n/** @type {import('.')} */\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\t/* eslint no-extra-parens: 0 */\n\n\tvar intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBindBasic(/** @type {const} */ ([intrinsic]));\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nconst Commented = require('./commented');\nconst Diagnose = require('./diagnose');\nconst Decoder = require('./decoder');\nconst Encoder = require('./encoder');\nconst Simple = require('./simple');\nconst Tagged = require('./tagged');\nconst Map = require('./map');\nconst SharedValueEncoder = require('./sharedValueEncoder');\n\nmodule.exports = {\n  Commented,\n  Diagnose,\n  Decoder,\n  Encoder,\n  Simple,\n  Tagged,\n  Map,\n  SharedValueEncoder,\n\n  /**\n   * Convenience name for {@linkcode Commented.comment}.\n   */\n  comment: Commented.comment,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAll}.\n   */\n  decodeAll: Decoder.decodeAll,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirst}.\n   */\n  decodeFirst: Decoder.decodeFirst,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAllSync}.\n   */\n  decodeAllSync: Decoder.decodeAllSync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decodeFirstSync: Decoder.decodeFirstSync,\n\n  /**\n   * Convenience name for {@linkcode Diagnose.diagnose}.\n   */\n  diagnose: Diagnose.diagnose,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encode}.\n   */\n  encode: Encoder.encode,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeCanonical}.\n   */\n  encodeCanonical: Encoder.encodeCanonical,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeOne}.\n   */\n  encodeOne: Encoder.encodeOne,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeAsync}.\n   */\n  encodeAsync: Encoder.encodeAsync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decode: Decoder.decodeFirstSync,\n\n  /**\n   * The codec information for\n   * {@link https://github.com/Level/encoding-down encoding-down}, which is a\n   * codec framework for leveldb.  CBOR is a particularly convenient format for\n   * both keys and values, as it can deal with a lot of types that JSON can't\n   * handle without losing type information.\n   *\n   * @example\n   * const level = require('level')\n   * const cbor = require('cbor')\n   *\n   * async function putget() {\n   *   const db = level('./db', {\n   *     keyEncoding: cbor.leveldb,\n   *     valueEncoding: cbor.leveldb,\n   *   })\n   *\n   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)\n   *   const val = await db.get({a: 1})\n   * }\n   */\n  leveldb: {\n    decode: Decoder.decodeFirstSync,\n    encode: Encoder.encode,\n    buffer: true,\n    name: 'cbor',\n  },\n\n  /**\n   * Reset everything that we can predict a plugin might have altered in good\n   * faith.  For now that includes the default set of tags that decoding and\n   * encoding will use.\n   */\n  reset() {\n    Encoder.reset();\n    Tagged.reset();\n  },\n};\n","'use strict';\n\nconst stream = require('stream');\nconst utils = require('./utils');\nconst Decoder = require('./decoder');\nconst NoFilter = require('nofilter');\nconst {MT, NUMBYTES, SYMS} = require('./constants');\nconst {Buffer} = require('buffer');\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  }\n  return '';\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'number':\n      return {options: {max_depth: opts}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    });\n\n    this.depth = depth;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this);\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    });\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this));\n    }\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true});\n\n    c.on('data', b => this.push(b));\n    c.on('error', er => this.emit('error', er));\n    c.end(v);\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const bs = new NoFilter();\n    const {encoding = 'hex', ...opts} = options;\n    const d = new Commented(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ');\n    this.push(er.toString());\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length;\n    if (ind < 1) {\n      ind = 1;\n    }\n    this.push(new Array(ind + 1).join(' '));\n    this.push('-- ');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, _parent_mt, _pos) {\n    let desc = '';\n\n    this.depth++;\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n        break;\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, _parent_mt, _pos) {\n    let desc = '';\n\n    this.depth++;\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`;\n        break;\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`;\n        break;\n    }\n    this.push(`${desc}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `);\n        break;\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `);\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `);\n        }\n        break;\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`);\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item');\n        }\n        break;\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`);\n        }\n        break;\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`);\n        }\n        break;\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(_mt) {\n    this.depth--;\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n          break;\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity);\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str);\n        this.push('\\n');\n      }\n      this.depth--;\n    } else {\n      this.push(str);\n      this.push('\\n');\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    this.push('\\n');\n  }\n}\n\nmodule.exports = Commented;\n","'use strict';\n\n/**\n * @enum {number}\n */\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7,\n};\n\n/**\n * @enum {number}\n */\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  SET: 258,\n};\n\n/**\n * @enum {number}\n */\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31,\n};\n\n/**\n * @enum {number}\n */\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23,\n};\n\nexports.SYMS = {\n  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),\n  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),\n  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),\n  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),\n  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),\n};\n\nexports.SHIFT32 = 0x100000000;\n\nexports.BI = {\n  MINUS_ONE: BigInt(-1),\n  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),\n  MAXINT32: BigInt('0xffffffff'),\n  MAXINT64: BigInt('0xffffffffffffffff'),\n  SHIFT32: BigInt(exports.SHIFT32),\n};\n\n","'use strict';\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst constants = require('./constants');\nconst {MT, NUMBYTES, SYMS, BI} = constants;\nconst {Buffer} = require('buffer');\n\nconst COUNT = Symbol('count');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`);\n    this.name = 'UnexpectedDataError';\n    this.byte = byte;\n    this.value = value;\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView\n *   |DataView|import('stream').Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferMap=false] If true, prefer to generate Map\n *   instances to plain objects, even if there are no entries in the map\n *   or if all of the keys are strings.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferMap = false,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options;\n\n    super({defaultEncoding: encoding, ...superOpts});\n\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    this.preferMap = preferMap;\n    this.preferWeb = preferWeb;\n    this.extendedResults = extendedResults;\n    this.required = required;\n    this.preventDuplicateKeys = preventDuplicateKeys;\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this));\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter());\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n      case SYMS.UNDEFINED:\n        return undefined;\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found');\n      default:\n        return val;\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options} = normalizeOptions(options));\n    const {encoding = 'hex', ...opts} = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse();\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data');\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b);\n      }\n      state = parser.next(b);\n    }\n\n    let val = null;\n    if (c.extendedResults) {\n      val = state.value;\n      val.unused = s.read();\n    } else {\n      val = Decoder.nullcheck(state.value);\n      if (s.length > 0) {\n        const nextByte = s.read(1);\n\n        s.unshift(nextByte);\n        throw new UnexpectedDataError(nextByte[0], val);\n      }\n    }\n    return val;\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options} = normalizeOptions(options));\n    const {encoding = 'hex', ...opts} = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data');\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b);\n        }\n        state = parser.next(b);\n      }\n      res.push(Decoder.nullcheck(state.value));\n    }\n    return res;\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', required = false, ...opts} = options;\n\n    const c = new Decoder(opts);\n    let v = /** @type {any} */ (NOT_FOUND);\n    const s = utils.guessEncoding(input, encoding);\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice();\n          return resolve(v);\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v;\n        }\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            }\n            return resolve(v);\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined;\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb);\n    }\n    s.pipe(c);\n    return p;\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', ...opts} = options;\n\n    const c = new Decoder(opts);\n    const vals = [];\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)));\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined));\n    }\n    utils.guessEncoding(input, encoding).pipe(c);\n    return p;\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data);\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`);\n      }\n\n      const [octet] = yield 1;\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]));\n        throw new UnexpectedDataError(octet);\n      }\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = (parent == null) ? undefined : parent[MAJOR];\n      const parent_length = (parent == null) ? undefined : parent.length;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          [val] = yield 1;\n          break;\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24);\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf);\n          break;\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error(`Additional info not implemented: ${ai}`);\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n          val = -1;\n          break;\n        default:\n          val = ai;\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break;\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX;\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val;\n          }\n          break;\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              if (mt === MT.UTF8_STRING) {\n                val = '';\n              } else {\n                val = this.preferWeb ?\n                  new Uint8Array(0) :\n                  Buffer.allocUnsafe(0);\n              }\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n              }\n          }\n          break;\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              if (mt === MT.MAP) {\n                val = (this.preferMap) ? new Map() : {};\n              } else {\n                val = [];\n              }\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n          break;\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              );\n            }\n            const hasParent = (parent != null);\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            );\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1;\n        } else if (Array.isArray(parent)) {\n          parent.push(val);\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR];\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false;\n            throw new Error('Invalid major type in indefinite encoding');\n          }\n          parent.write(val);\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true;\n          break;\n        }\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n            case MT.MAP: {\n              let allstrings = !this.preferMap;\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`);\n              }\n              for (\n                let i = 0, len = parent.length;\n                allstrings && (i < len);\n                i += 2\n              ) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false;\n                  break;\n                }\n              }\n              if (allstrings) {\n                val = {};\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map');\n                  }\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map');\n                  }\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n              break;\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1]);\n\n              val = t.convert(this.tags);\n              break;\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                );\n              }\n              break;\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n        this.emit('stop', parent[MAJOR]);\n\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice();\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          };\n\n          this.valueBytes = new NoFilter();\n          return ret;\n        }\n        return val;\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;\n","'use strict';\n\nconst stream = require('stream');\nconst Decoder = require('./decoder');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst {MT, SYMS} = require('./constants');\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    });\n\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    });\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n        return cb();\n      }\n      return cb(er);\n    });\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', ...opts} = options;\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString());\n    } else {\n      this.emit('error', er);\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, _parent_mt, _pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len];\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ');\n        }\n        break;\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ');\n          } else {\n            this.push(', ');\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n    this._fore(parent_mt, pos);\n    const fb = this.float_bytes;\n    this.float_bytes = -1;\n    this.push(utils.cborValueToString(val, fb));\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n      case MT.ARRAY:\n        this.push('[');\n        break;\n      case MT.MAP:\n        this.push('{');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ');\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')');\n        break;\n      case MT.ARRAY:\n        this.push(']');\n        break;\n      case MT.MAP:\n        this.push('}');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')');\n        break;\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator);\n  }\n}\n\nmodule.exports = Diagnose;\n","'use strict';\n\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants;\nconst {Buffer} = require('buffer');\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO;\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR;\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT;\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE;\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE;\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED;\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL;\n\nconst BREAK = Buffer.from([0xff]);\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {};\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {};\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number';\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number';\n    case 'float':\n      return 'float';\n    case 'int':\n    case 'integer':\n      return 'int';\n    case 'string':\n      return 'string';\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`);\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options;\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    });\n\n    this.canonical = canonical;\n    this.encodeUndefined = encodeUndefined;\n    this.disallowUndefinedKeys = disallowUndefinedKeys;\n    this.dateType = parseDateType(dateType);\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined;\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet();\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops;\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet');\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties;\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES};\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1]);\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v);\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} _encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, _encoding, cb) {\n    const ret = this.pushAny(fresh);\n    // Old transformers might not return bool.  undefined !== false\n    cb((ret === false) ? new Error('Push Error') : undefined);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb();\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj);\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n    }\n    let max = Number.MAX_SAFE_INTEGER;\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--;\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32);\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    }\n    return this._pushInt(obj, MT.POS_INT);\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN();\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj);\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj));\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined);\n        if (buf) {\n          return this.push(buf);\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined);\n  }\n\n  /**\n   * @param {null} _obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(_obj) {\n    return this._pushUInt8(NULL);\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT;\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n\n    let str = obj.toString(16);\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    };\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`);\n        } else {\n          this.detectLoops.add(obj);\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR;\n      if (typeof f === 'function') {\n        return f.call(obj, this);\n      }\n      const converter = this.semanticTypes[obj.constructor.name];\n      if (converter) {\n        return converter.call(obj, this, obj);\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k];\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'));\n    });\n    const cbor_keys = {};\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n\n        return a_cbor.compare(b_cbor);\n      });\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n    let ck = null;\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false;\n        }\n      } else if (!this._pushString(k)) {\n        return false;\n      }\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false;\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj);\n    }\n    return true;\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});\n    this.pipe(bs);\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n    this.end();\n    return bs.read();\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name;\n    const old = this.semanticTypes[typeName];\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n      this.semanticTypes[typeName] = fun;\n    } else if (old) {\n      delete this.semanticTypes[typeName];\n    }\n    return old;\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n      case 'bigint':\n        return this._pushJSBigint(obj);\n      case 'string':\n        return this._pushString(obj);\n      case 'boolean':\n        return this._pushBoolean(obj);\n      case 'undefined':\n        return this._pushUndefined(obj);\n      case 'object':\n        return this._pushObject(obj);\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined);\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`);\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        );\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    };\n    const len = obj.length;\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false;\n    }\n    this.detectLoops = new WeakSet();\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString());\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000));\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000);\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000);\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()));\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false;\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    };\n    let entries = [...obj.entries()];\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([_k, v]) => v !== undefined);\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false;\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      });\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark});\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000;\n    let sz = obj.BYTES_PER_ELEMENT;\n    const {name} = obj.constructor;\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000;\n      sz /= 2;\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000;\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100;\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz];\n    if (!gen._pushTag(typ)) {\n      return false;\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    );\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj));\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode');\n      }\n      obj = this;\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options;\n\n    let ret = true;\n    const objType = typeof obj;\n    let buf = null;\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && gen._pushString(obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      });\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      });\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding');\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      });\n    }\n    return ret;\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES;\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val;\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES};\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n});\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;\n}\n\nEncoder.reset();\nmodule.exports = Encoder;\n","'use strict';\n\nconst {Buffer} = require('buffer');\nconst encoder = require('./encoder');\nconst decoder = require('./decoder');\nconst {MT} = require('./constants');\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable);\n  }\n\n  /**\n   * @ignore\n   * @param {unknown} key\n   * @returns {string}\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64');\n  }\n\n  /**\n   * @ignore\n   * @param {string} key\n   * @returns {unknown}\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64');\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key));\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val);\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key));\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key));\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @returns {MapIterator<any>}\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k);\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator<any>} Key value pairs.\n   * @yields {any[]} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]];\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator<any>} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map<any,any>): undefined} fun Function to\n   *   execute for each element, which takes a value, a key, and the Map\n   *   being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg = this) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function');\n    }\n    for (const kv of super.entries()) {\n      fun.call(thisArg, kv[1], CborMap._decode(kv[0]), this);\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {import('./encoder.js')} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false;\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);\n      entries.sort((a, b) => a[0].compare(b[0]));\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n\nmodule.exports = CborMap;\n","'use strict';\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap();\n    this.count = 0;\n    this.recording = true;\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false;\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj);\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1];\n        }\n\n        val[0] = true;\n        return ObjectRecorder.FIRST;\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER;\n      }\n      val.push(this.count++);\n      // Second use while recording\n      return val[1];\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording');\n    }\n    this.map.set(obj, [false]);\n    // First use while recording\n    return ObjectRecorder.NEVER;\n  }\n}\n\nObjectRecorder.NEVER = -1;\nObjectRecorder.FIRST = -2;\n\nmodule.exports = ObjectRecorder;\n","'use strict';\n\nconst Encoder = require('./encoder');\nconst ObjectRecorder = require('./objectRecorder');\nconst {Buffer} = require('buffer');\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts);\n    this.valueSharing = new ObjectRecorder();\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj);\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28);\n          break;\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break;\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared);\n      }\n    }\n    return super._pushObject(obj, opts);\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop();\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear();\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder();\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o);\n    }\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} _objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(..._objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options);\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n    enc.pushAny(obj);\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = [];\n      const enc = new SharedValueEncoder(options);\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {});\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.stopRecording();\n      enc.removeAllListeners('data');\n      enc.on('data', buf => bufs.push(buf));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n}\n\nmodule.exports = SharedValueEncoder;\n","'use strict';\n\nconst {MT, SIMPLE, SYMS} = require('./constants');\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`);\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} _depth How deep are we?\n   * @param {object} _opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](_depth, _opts) {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple;\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false;\n      case SIMPLE.TRUE:\n        return true;\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null;\n        }\n        return SYMS.NULL;\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined;\n        }\n        return SYMS.UNDEFINED;\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK');\n        }\n        return SYMS.BREAK;\n      default:\n        return new Simple(val);\n    }\n  }\n}\n\nmodule.exports = Simple;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON');\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn;\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn);\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn);\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this);\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this);\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex');\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab);\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size];\n\n  const end = byteOffset + byteLength;\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true));\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis;\n    } else {\n      setBuffersToJSON(v, b64urlThis);\n    }\n    return tag;\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this;\n    } else {\n      setBuffersToJSON(v, b64this);\n    }\n    return tag;\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis;\n    } else {\n      setBuffersToJSON(v, hexThis);\n    }\n    return tag;\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters');\n    }\n    const last = v.length % 4;\n    if (last === 1) {\n      throw new Error('Invalid base64url length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag;\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);\n    if (!m) {\n      throw new Error('Invalid base64 characters');\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag;\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n};\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n};\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array;\n  TYPED_ARRAY_TAGS[71] = BigUint64Array;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array;\n  TYPED_ARRAY_TAGS[79] = BigInt64Array;\n}\n\nfunction toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer');\n  }\n  const {tag} = tagged;\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag];\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`);\n  }\n  const little = tag & 0b00000100;\n  const float = (tag & 0b00010000) >> 4;\n  const sz = 2 ** (float + (tag & 0b00000011));\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);\n  return new TypedClass(ab);\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = toTypedArray;\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {};\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`);\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`);\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value);\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    };\n    if (this.err) {\n      ret.err = this.err;\n    }\n    return ret;\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n    return gen.pushAny(this.value);\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag];\n    if (f === null) { // === is intentional. null has semantic meaning as above\n      return this;\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag];\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n    try {\n      return f.call(this, this.value, this);\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message;\n      } else {\n        this.err = error;\n      }\n      return this;\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS;\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val;\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS};\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON;\nTagged.reset();\nmodule.exports = Tagged;\n","'use strict';\n\nconst {Buffer} = require('buffer');\nconst NoFilter = require('nofilter');\nconst stream = require('stream');\nconst constants = require('./constants');\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants;\nconst MAX_SAFE_HIGH = 0x1fffff;\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true});\nexports.utf8 = buf => td.decode(buf);\nexports.utf8.checksUTF8 = true;\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true;\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function');\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView));\n};\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b;\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength);\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b);\n  }\n  return null;\n};\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0);\n      const g = buf.readUInt32BE(4);\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g);\n      }\n      return (f * SHIFT32) + g;\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`);\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0);\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000; // Top bit is sign\n  const exp = (u >> 23) & 0xff; // Then 5 bits of exponent\n  const mant = u & 0x7fffff;\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13);\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false;\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp));\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false;\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16);\n  return true;\n};\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1;\n  const exp = (buf[0] & 0x7C) >> 2;\n  const mant = ((buf[0] & 0x03) << 8) | buf[1];\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity);\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant);\n};\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n    case 4:\n      return buf.readFloatBE(0);\n    case 8:\n      return buf.readDoubleBE(0);\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`);\n  }\n};\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  let start = 0;\n  let end = (s.length % 8) || 8;\n  const chunks = [];\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n  return Buffer.from(chunks);\n};\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true;\n  }\n  if ((a == null) || (b == null)) {\n    return false;\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i]);\n};\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`);\n};\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null';\n        case SYMS.UNDEFINED:\n          return 'undefined';\n        case SYMS.BREAK:\n          return 'BREAK';\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description;\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString();\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/);\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name;\n      }\n      return 'Symbol';\n    }\n    case 'string':\n      return JSON.stringify(val);\n    case 'bigint':\n      return val.toString();\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val);\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s;\n    }\n    case 'object': {\n      if (!val) {\n        return 'null';\n      }\n      const buf = exports.bufferishToBuffer(val);\n      if (buf) {\n        const hex = buf.toString('hex');\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`;\n      }\n      if (val && typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]();\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]';\n      }\n      // This should be all that is left\n      return '{}';\n    }\n  }\n  return String(val);\n};\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding);\n  }\n  const buf = exports.bufferishToBuffer(input);\n  if (buf) {\n    return new NoFilter(buf);\n  }\n  if (isReadable(input)) {\n    return input;\n  }\n  throw new Error('Unknown input type');\n};\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n};\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c]);\n};\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64');\n};\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n};\n","// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict';\n// eslint-disable-next-line n/prefer-node-protocol\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options);\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false;\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true;\n\n    this.bs = new NoFilter();\n    this.__restart();\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} _encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, _encoding, cb) {\n    this.bs.write(fresh);\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null;\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed);\n\n      try {\n        ret = this.__parser.next(chunk);\n      } catch (e) {\n        return cb(e);\n      }\n\n      if (this.__needed) {\n        this.__fresh = false;\n      }\n\n      if (ret.done) {\n        this.push(ret.value);\n        this.__restart();\n      } else {\n        this.__needed = ret.value || Infinity;\n      }\n    }\n\n    return cb();\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass');\n  }\n\n  __restart() {\n    this.__needed = null;\n    this.__parser = this._parse();\n    this.__fresh = true;\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'));\n  }\n}\n\nmodule.exports = BinaryParseStream;\n","'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\n\nvar gopd = require('gopd');\n\n/** @type {import('.')} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar defineDataProperty = require('define-data-property');\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar supportsDescriptors = require('has-property-descriptors')();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object) {\n\t\tif (predicate === true) {\n\t\t\tif (object[name] === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!isFunction(predicate) || !predicate()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (supportsDescriptors) {\n\t\tdefineDataProperty(object, name, value, true);\n\t} else {\n\t\tdefineDataProperty(object, name, value);\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","'use strict';\n\nvar callBind = require('call-bind-apply-helpers');\nvar gOPD = require('gopd');\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n","var stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar noop = function() {}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err, cb) {\n  if (!cb) cb = noop\n  if (this.destroyed) return cb(null)\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n    cb(null)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else if (!this.destroyed) cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending && !this._writableState.destroyed) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","'use strict';\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n","'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n","'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n","'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n","'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n","'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n","'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Object;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\n/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\n/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\n/** @type {(x: unknown) => x is readonly unknown[]} */\nfunction isArray(x) {\n    return toStr.call(x) === '[object Array]';\n}\n\n/** @type {import('.')._internal} */\nmodule.exports = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (isArray(list)) {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $Object = require('es-object-atoms');\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar abs = require('math-intrinsics/abs');\nvar floor = require('math-intrinsics/floor');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar pow = require('math-intrinsics/pow');\nvar round = require('math-intrinsics/round');\nvar sign = require('math-intrinsics/sign');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = require('gopd');\nvar $defineProperty = require('es-define-property');\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = require('get-proto');\nvar $ObjectGPO = require('get-proto/Object.getPrototypeOf');\nvar $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');\n\nvar $apply = require('call-bind-apply-helpers/functionApply');\nvar $call = require('call-bind-apply-helpers/functionCall');\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar $Object = require('es-object-atoms');\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n","'use strict';\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n","'use strict';\n\nvar reflectGetProto = require('./Reflect.getPrototypeOf');\nvar originalGetProto = require('./Object.getPrototypeOf');\n\nvar getDunderProto = require('dunder-proto/get');\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n","'use strict';\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n","'use strict';\n\n/** @type {import('.')} */\nvar $gOPD = require('./gOPD');\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\treturn !!$defineProperty;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!$defineProperty) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bound');\n\nvar $toString = callBound('Object.prototype.toString');\n\n/** @type {import('.')} */\nvar isStandardArguments = function isArguments(value) {\n\tif (\n\t\thasToStringTag\n\t\t&& value\n\t\t&& typeof value === 'object'\n\t\t&& Symbol.toStringTag in value\n\t) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\n/** @type {import('.')} */\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null\n\t\t&& typeof value === 'object'\n\t\t&& 'length' in value\n\t\t&& typeof value.length === 'number'\n\t\t&& value.length >= 0\n\t\t&& $toString(value) !== '[object Array]'\n\t\t&& 'callee' in value\n\t\t&& $toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\n// @ts-expect-error TODO make this not error\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\n/** @type {import('.')} */\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar objectClass = '[object Object]';\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar ddaClass = '[object HTMLAllCollection]'; // IE 11\nvar ddaClass2 = '[object HTML document.all class]';\nvar ddaClass3 = '[object HTMLCollection]'; // IE 9-10\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n\nvar isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing\n\nvar isDDA = function isDocumentDotAll() { return false; };\nif (typeof document === 'object') {\n\t// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly\n\tvar all = document.all;\n\tif (toStr.call(all) === toStr.call(document.all)) {\n\t\tisDDA = function isDocumentDotAll(value) {\n\t\t\t/* globals document: false */\n\t\t\t// in IE 6-8, typeof document.all is \"object\" and it's truthy\n\t\t\tif ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {\n\t\t\t\ttry {\n\t\t\t\t\tvar str = toStr.call(value);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstr === ddaClass\n\t\t\t\t\t\t|| str === ddaClass2\n\t\t\t\t\t\t|| str === ddaClass3 // opera 12.16\n\t\t\t\t\t\t|| str === objectClass // IE 6-8\n\t\t\t\t\t) && value('') == null; // eslint-disable-line eqeqeq\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value) && tryFunctionObject(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\tif (strClass !== fnClass && strClass !== genClass && !(/^\\[object HTML/).test(strClass)) { return false; }\n\t\treturn tryFunctionObject(value);\n\t};\n","'use strict';\n\nvar callBound = require('call-bound');\nvar safeRegexTest = require('safe-regex-test');\nvar isFnRegex = safeRegexTest(/^\\s*(?:function)?\\*/);\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = require('get-proto');\n\nvar toStr = callBound('Object.prototype.toString');\nvar fnToStr = callBound('Function.prototype.toString');\n\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\n/** @type {undefined | false | null | GeneratorFunctionConstructor} */\nvar GeneratorFunction;\n\n/** @type {import('.')} */\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex(fnToStr(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t? /** @type {GeneratorFunctionConstructor} */ (getProto(generatorFunc))\n\t\t\t: false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function isNaN(value) {\n\treturn value !== value;\n};\n","'use strict';\n\nvar callBind = require('call-bind');\nvar define = require('define-properties');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Number);\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\n\t\treturn Number.isNaN;\n\t}\n\treturn implementation;\n};\n","'use strict';\n\nvar define = require('define-properties');\nvar getPolyfill = require('./polyfill');\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function shimNumberIsNaN() {\n\tvar polyfill = getPolyfill();\n\tdefine(Number, { isNaN: polyfill }, {\n\t\tisNaN: function testIsNaN() {\n\t\t\treturn Number.isNaN !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar callBound = require('call-bound');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar hasOwn = require('hasown');\nvar gOPD = require('gopd');\n\n/** @type {import('.')} */\nvar fn;\n\nif (hasToStringTag) {\n\t/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */\n\tvar $exec = callBound('RegExp.prototype.exec');\n\t/** @type {object} */\n\tvar isRegexMarker = {};\n\n\tvar throwRegexMarker = function () {\n\t\tthrow isRegexMarker;\n\t};\n\t/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */\n\tvar badStringifier = {\n\t\ttoString: throwRegexMarker,\n\t\tvalueOf: throwRegexMarker\n\t};\n\n\tif (typeof Symbol.toPrimitive === 'symbol') {\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\n\t}\n\n\t/** @type {import('.')} */\n\t// @ts-expect-error TS can't figure out that the $exec call always throws\n\t// eslint-disable-next-line consistent-return\n\tfn = function isRegex(value) {\n\t\tif (!value || typeof value !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');\n\t\tvar hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');\n\t\tif (!hasLastIndexDataProperty) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));\n\t\t} catch (e) {\n\t\t\treturn e === isRegexMarker;\n\t\t}\n\t};\n} else {\n\t/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */\n\tvar $toString = callBound('Object.prototype.toString');\n\t/** @const @type {'[object RegExp]'} */\n\tvar regexClass = '[object RegExp]';\n\n\t/** @type {import('.')} */\n\tfn = function isRegex(value) {\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $toString(value) === regexClass;\n\t};\n}\n\nmodule.exports = fn;\n","'use strict';\n\nvar whichTypedArray = require('which-typed-array');\n\n/** @type {import('.')} */\nmodule.exports = function isTypedArray(value) {\n\treturn !!whichTypedArray(value);\n};\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Creates an array of elements split into groups the length of `size`.\n * If `array` can't be split evenly, the final chunk will be the remaining\n * elements.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to process.\n * @param {number} [size=1] The length of each chunk\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the new array of chunks.\n * @example\n *\n * _.chunk(['a', 'b', 'c', 'd'], 2);\n * // => [['a', 'b'], ['c', 'd']]\n *\n * _.chunk(['a', 'b', 'c', 'd'], 3);\n * // => [['a', 'b', 'c'], ['d']]\n */\nfunction chunk(array, size, guard) {\n  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n    size = 1;\n  } else {\n    size = nativeMax(toInteger(size), 0);\n  }\n  var length = array ? array.length : 0;\n  if (!length || size < 1) {\n    return [];\n  }\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length / size));\n\n  while (index < length) {\n    result[resIndex++] = baseSlice(array, index, (index += size));\n  }\n  return result;\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = chunk;\n","'use strict';\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n","'use strict';\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n","'use strict';\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n","'use strict';\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n","'use strict';\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n","'use strict';\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n","'use strict';\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n","'use strict';\n\nvar $isNaN = require('./isNaN');\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n","'use strict'\n\nconst stream = require('stream')\nconst {Buffer} = require('buffer')\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n","'use strict';\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n","'use strict';\n\nvar define = require('define-properties');\nvar callBind = require('call-bind');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n","'use strict';\n\nvar getPolyfill = require('./polyfill');\nvar define = require('define-properties');\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\n// modified from https://github.com/es-shims/es6-shim\nvar objectKeys = require('object-keys');\nvar hasSymbols = require('has-symbols/shams')();\nvar callBound = require('call-bound');\nvar $Object = require('es-object-atoms');\nvar $push = callBound('Array.prototype.push');\nvar $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');\nvar originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function assign(target, source1) {\n\tif (target == null) { throw new TypeError('target must be an object'); }\n\tvar to = $Object(target); // step 1\n\tif (arguments.length === 1) {\n\t\treturn to; // step 2\n\t}\n\tfor (var s = 1; s < arguments.length; ++s) {\n\t\tvar from = $Object(arguments[s]); // step 3.a.i\n\n\t\t// step 3.a.ii:\n\t\tvar keys = objectKeys(from);\n\t\tvar getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);\n\t\tif (getSymbols) {\n\t\t\tvar syms = getSymbols(from);\n\t\t\tfor (var j = 0; j < syms.length; ++j) {\n\t\t\t\tvar key = syms[j];\n\t\t\t\tif ($propIsEnumerable(from, key)) {\n\t\t\t\t\t$push(keys, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// step 3.a.iii:\n\t\tfor (var i = 0; i < keys.length; ++i) {\n\t\t\tvar nextKey = keys[i];\n\t\t\tif ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2\n\t\t\t\tvar propValue = from[nextKey]; // step 3.a.iii.2.a\n\t\t\t\tto[nextKey] = propValue; // step 3.a.iii.2.b\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to; // step 4\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nvar lacksProperEnumerationOrder = function () {\n\tif (!Object.assign) {\n\t\treturn false;\n\t}\n\t/*\n\t * v8, specifically in node 4.x, has a bug with incorrect property enumeration order\n\t * note: this does not detect the bug unless there's 20 characters\n\t */\n\tvar str = 'abcdefghijklmnopqrst';\n\tvar letters = str.split('');\n\tvar map = {};\n\tfor (var i = 0; i < letters.length; ++i) {\n\t\tmap[letters[i]] = letters[i];\n\t}\n\tvar obj = Object.assign({}, map);\n\tvar actual = '';\n\tfor (var k in obj) {\n\t\tactual += k;\n\t}\n\treturn str !== actual;\n};\n\nvar assignHasPendingExceptions = function () {\n\tif (!Object.assign || !Object.preventExtensions) {\n\t\treturn false;\n\t}\n\t/*\n\t * Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n\t * which is 72% slower than our shim, and Firefox 40's native implementation.\n\t */\n\tvar thrower = Object.preventExtensions({ 1: 2 });\n\ttry {\n\t\tObject.assign(thrower, 'xy');\n\t} catch (e) {\n\t\treturn thrower[1] === 'y';\n\t}\n\treturn false;\n};\n\nmodule.exports = function getPolyfill() {\n\tif (!Object.assign) {\n\t\treturn implementation;\n\t}\n\tif (lacksProperEnumerationOrder()) {\n\t\treturn implementation;\n\t}\n\tif (assignHasPendingExceptions()) {\n\t\treturn implementation;\n\t}\n\treturn Object.assign;\n};\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = [\n\t'Float16Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int8Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'BigInt64Array',\n\t'BigUint64Array'\n];\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var once = require('once')\nvar eos = require('end-of-stream')\nvar fs\n\ntry {\n  fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\n} catch (e) {}\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n","var pump = require('pump')\nvar inherits = require('inherits')\nvar Duplexify = require('duplexify')\n\nvar toArray = function(args) {\n  if (!args.length) return []\n  return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)\n}\n\nvar define = function(opts) {\n  var Pumpify = function() {\n    var streams = toArray(arguments)\n    if (!(this instanceof Pumpify)) return new Pumpify(streams)\n    Duplexify.call(this, null, null, opts)\n    if (streams.length) this.setPipeline(streams)\n  }\n\n  inherits(Pumpify, Duplexify)\n\n  Pumpify.prototype.setPipeline = function() {\n    var streams = toArray(arguments)\n    var self = this\n    var ended = false\n    var w = streams[0]\n    var r = streams[streams.length-1]\n\n    r = r.readable ? r : null\n    w = w.writable ? w : null\n\n    var onclose = function() {\n      streams[0].emit('error', new Error('stream was destroyed'))\n    }\n\n    this.on('close', onclose)\n    this.on('prefinish', function() {\n      if (!ended) self.cork()\n    })\n\n    pump(streams, function(err) {\n      self.removeListener('close', onclose)\n      if (err) return self.destroy(err.message === 'premature close' ? null : err)\n      ended = true\n      // pump ends after the last stream is not writable *but*\n      // pumpify still forwards the readable part so we need to catch errors\n      // still, so reenable autoDestroy in this case\n      if (self._autoDestroy === false) self._autoDestroy = true\n      self.uncork()\n    })\n\n    if (this.destroyed) return onclose()\n    this.setWritable(w)\n    this.setReadable(r)\n  }\n\n  return Pumpify\n}\n\nmodule.exports = define({autoDestroy:false, destroy:false})\nmodule.exports.obj = define({autoDestroy: false, destroy:false, objectMode:true, highWaterMark:16})\nmodule.exports.ctor = define\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","module.exports = require('events').EventEmitter;\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\n\nvar callBound = require('call-bound');\nvar isRegex = require('is-regex');\n\nvar $exec = callBound('RegExp.prototype.exec');\nvar $TypeError = require('es-errors/type');\n\n/** @type {import('.')} */\nmodule.exports = function regexTester(regex) {\n\tif (!isRegex(regex)) {\n\t\tthrow new $TypeError('`regex` must be a RegExp');\n\t}\n\treturn function test(s) {\n\t\treturn $exec(regex, s) !== null;\n\t};\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar define = require('define-data-property');\nvar hasDescriptors = require('has-property-descriptors')();\nvar gOPD = require('gopd');\n\nvar $TypeError = require('es-errors/type');\nvar $floor = GetIntrinsic('%Math.floor%');\n\n/** @type {import('.')} */\nmodule.exports = function setFunctionLength(fn, length) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new $TypeError('`fn` is not a function');\n\t}\n\tif (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {\n\t\tthrow new $TypeError('`length` must be a positive 32-bit integer');\n\t}\n\n\tvar loose = arguments.length > 2 && !!arguments[2];\n\n\tvar functionLengthIsConfigurable = true;\n\tvar functionLengthIsWritable = true;\n\tif ('length' in fn && gOPD) {\n\t\tvar desc = gOPD(fn, 'length');\n\t\tif (desc && !desc.configurable) {\n\t\t\tfunctionLengthIsConfigurable = false;\n\t\t}\n\t\tif (desc && !desc.writable) {\n\t\t\tfunctionLengthIsWritable = false;\n\t\t}\n\t}\n\n\tif (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n\t\tif (hasDescriptors) {\n\t\t\tdefine(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);\n\t\t} else {\n\t\t\tdefine(/** @type {Parameters<define>[0]} */ (fn), 'length', length);\n\t\t}\n\t}\n\treturn fn;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/lib/_stream_readable.js');\nStream.Writable = require('readable-stream/lib/_stream_writable.js');\nStream.Duplex = require('readable-stream/lib/_stream_duplex.js');\nStream.Transform = require('readable-stream/lib/_stream_transform.js');\nStream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');\nStream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')\nStream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","module.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    var idx = state.bufferIndex || 0\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    } else if (state.buffer.length - idx > 0 && state.buffer[idx]) {\n      return state.buffer[idx].length\n    }\n  }\n\n  return state.length\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = Math.floor((x[j] + 128) / 256);\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  return n;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES,\n\n  gf: gf,\n  D: D,\n  L: L,\n  pack25519: pack25519,\n  unpack25519: unpack25519,\n  M: M,\n  A: A,\n  S: S,\n  Z: Z,\n  pow2523: pow2523,\n  add: add,\n  set25519: set25519,\n  modL: modL,\n  scalarmult: scalarmult,\n  scalarbase: scalarbase,\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!(arguments[i] instanceof Uint8Array))\n      throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto');\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').slice(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.slice(1, -1);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBind = require('call-bind');\nvar callBound = require('call-bound');\nvar gOPD = require('gopd');\nvar getProto = require('get-proto');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\n\n/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n/** @typedef {import('./types').Getter} Getter */\n/** @type {import('./types').Cache} */\nvar cache = { __proto__: null };\nif (hasToStringTag && gOPD && getProto) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr && getProto) {\n\t\t\tvar proto = getProto(arr);\n\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor && proto) {\n\t\t\t\tvar superProto = getProto(proto);\n\t\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(descriptor.get);\n\t\t}\n\t});\n} else {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tvar fn = arr.slice || arr.set;\n\t\tif (fn) {\n\t\t\tcache[\n\t\t\t\t/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)\n\t\t\t] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (\n\t\t\t\t// @ts-expect-error TODO FIXME\n\t\t\t\tcallBind(fn)\n\t\t\t);\n\t\t}\n\t});\n}\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;\n\tforEach(\n\t\t/** @type {Record<`\\$${import('.').TypedArrayName}`, Getter>} */ (cache),\n\t\t/** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */\n\t\tfunction (getter, typedArray) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t\t// @ts-expect-error a throw is fine here\n\t\t\t\t\tif ('$' + getter(value) === typedArray) {\n\t\t\t\t\t\tfound = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar trySlices = function tryAllSlices(value) {\n\t/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;\n\tforEach(\n\t\t/** @type {Record<`\\$${import('.').TypedArrayName}`, Getter>} */(cache),\n\t\t/** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t\t// @ts-expect-error a throw is fine here\n\t\t\t\t\tgetter(value);\n\t\t\t\t\tfound = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {import('.')} */\nmodule.exports = function whichTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\t/** @type {string} */\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\tif ($indexOf(typedArrays, tag) > -1) {\n\t\t\treturn tag;\n\t\t}\n\t\tif (tag !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\t// node < 0.6 hits here on real Typed Arrays\n\t\treturn trySlices(value);\n\t}\n\tif (!gOPD) { return null; } // unknown engine\n\treturn tryTypedArrays(value);\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst webauthn_1 = require(\"./platform/webauthn\");\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst buffer_1 = require(\"buffer/\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nconst lookup = {\n    usb: 1,\n    nfc: 2,\n    ble: 4,\n    internal: 8,\n    hybrid: 16,\n    \"smart-card\": 32,\n};\nconst encodeBinary = (data) => {\n    if (data.length <= 65535) {\n        // bin16: binary data whose length is upto (2^16)-1 bytes\n        return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);\n    }\n    else {\n        // bin32: binary data whose length is upto (2^32)-1 bytes\n        return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);\n    }\n};\nconst serializeID_v0 = (km) => {\n    const version = buffer_1.Buffer.from([0x83, 0xa1, 0x76, km.version]);\n    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);\n    const ckey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x63]), encodeBinary(km.ckey)]);\n    return buffer_1.Buffer.concat([version, ckey, cypher]);\n};\nconst getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);\nconst fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);\nconst getAuthTypeFromCkey = (ckey) => {\n    const type = cbor_1.default.decode(ckey).get(1);\n    if (type === 1) {\n        return \"Ed25519VerificationKey2020\";\n    }\n    else if (type === 2) {\n        return \"P256VerificationKey2020\";\n    }\n    else\n        return \"Unknown\";\n};\nconst getSignerFromCkey = (ckey) => {\n    const k = cbor_1.default.decode(ckey);\n    let publicKey = buffer_1.Buffer.from([]);\n    if (k.get(3) == -7)\n        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), k.get(-2), k.get(-3)]);\n    else if (k.get(3) == -8)\n        publicKey = k.get(-2);\n    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)\n        publicKey = k.get(-101);\n    return { publicKey };\n};\nclass Fido2Manager extends KeyManager_1.default {\n    constructor() {\n        super();\n        this._transports = 0;\n        this.level = 1; // ROOT, no Proof Management\n        this.encType = \"X25519KeyAgreementKey2019\";\n        this.webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n    }\n    get transports() {\n        return getTransports(this._transports);\n    }\n    static async createFromAttestation(attestation) {\n        const f2m = new Fido2Manager();\n        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.fid = buffer_1.Buffer.from(attestation.id, \"base64\");\n        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports\n        const response = attestation.response;\n        const transports = response.getTransports ? response.getTransports() : [\"usb\"];\n        f2m._transports = fromTransports(transports);\n        // signing\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        //encrypting\n        const entropy = (0, crypto_1.randomBytes)(32);\n        const seed = sha512(entropy);\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed.slice(0, 32));\n        f2m.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        f2m.entropy = entropy;\n        return f2m;\n    }\n    get id() {\n        if (this.version == 0)\n            return serializeID_v0(this);\n        else\n            return buffer_1.Buffer.from((0, msgpack_1.encode)({\n                v: this.version,\n                c: this.ckey,\n                e: this.cypher.publicKey,\n            }));\n    }\n    get id_v0() {\n        return serializeID_v0(this);\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            f: this.fid,\n            t: this._transports,\n            c: this.ckey,\n            e: this.cypher.secretKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const f2m = new Fido2Manager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"private\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m._transports = data.t ? data.t : 15;\n        f2m.ckey = data.c;\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.signer = getSignerFromCkey(data.c);\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);\n        f2m.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return f2m;\n    }\n    static instantiate(obj) {\n        const f2m = new Fido2Manager();\n        f2m.version = obj.version ?? 0;\n        f2m.level = obj.level;\n        f2m.fid = typeof obj.fid === \"string\" ? buffer_1.Buffer.from(obj.fid, \"base64\") : obj.fid;\n        f2m._transports = obj.t ? obj.t : 15;\n        f2m.ckey = obj.ckey.data ? buffer_1.Buffer.from(obj.ckey.data) : buffer_1.Buffer.from(obj.ckey);\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return f2m;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const f2m = new Fido2Manager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"public\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m.ckey = data.c;\n        f2m.signer = getSignerFromCkey(data.c);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.cypher = {\n            publicKey: data.e,\n        };\n        return f2m;\n    }\n    async getSigner() {\n        return {\n            sign: async (data) => {\n                if (!navigator.credentials)\n                    return null;\n                // ugly request userinteraction (needed for Safari and iOS)\n                try {\n                    await window?.CredentialUserInteractionRequest();\n                }\n                catch (error) { }\n                const challenge = (0, crypto_1.hash)(\"sha256\", data);\n                const publicKey = {\n                    challenge,\n                    userVerification: \"preferred\",\n                    allowCredentials: [\n                        {\n                            type: \"public-key\",\n                            id: this.fid,\n                            transports: getTransports(this._transports),\n                        },\n                    ],\n                };\n                const { response } = (await this.webAuthn.get(publicKey));\n                const publicKeyResponse = response;\n                const output = {\n                    s: buffer_1.Buffer.from(publicKeyResponse.signature),\n                    c: buffer_1.Buffer.from(publicKeyResponse.clientDataJSON),\n                    a: buffer_1.Buffer.from(publicKeyResponse.authenticatorData),\n                };\n                return buffer_1.Buffer.from((0, msgpack_1.encode)(output));\n            },\n        };\n    }\n    verify(data, signature, userVerification = false) {\n        const signatureBuffer = buffer_1.Buffer.from(signature);\n        const decoded = (0, msgpack_1.decode)(signatureBuffer);\n        const response = {\n            signature: decoded.s,\n            clientDataJSON: decoded.c,\n            authenticatorData: decoded.a,\n            userHandle: buffer_1.Buffer.from([]).buffer,\n        };\n        const challenge = (0, crypto_1.hash)(\"sha256\", data).toString(\"base64\");\n        const extractedChallenge = SoftCredentials_1.default.extractChallenge(response.clientDataJSON);\n        if (challenge !== extractedChallenge) {\n            return false;\n        }\n        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);\n    }\n    verifyCredentials(credentials, userVerification = false) {\n        if (credentials.id !== this.fid.toString(\"base64\")) {\n            return false;\n        }\n        const response = credentials.response;\n        const rpIdHash = buffer_1.Buffer.from(response.authenticatorData.slice(0, 32)).toString(\"hex\");\n        const myIdHash = sha256(buffer_1.Buffer.from(credentials.id, \"base64\")).toString(\"hex\");\n        if (rpIdHash !== myIdHash) {\n            return false;\n        }\n        return SoftCredentials_1.default.simpleVerify(this.ckey, response, userVerification);\n    }\n    async createRevocationCertificate() {\n        // TODO use an external id\n        return null;\n    }\n}\nexports.default = Fido2Manager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst Fido2Manager_1 = __importDefault(require(\"./Fido2Manager\"));\nconst buffer_1 = require(\"buffer/\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst lookup = {\n    usb: 1,\n    nfc: 2,\n    ble: 4,\n    internal: 8,\n    hybrid: 16,\n    \"smart-card\": 32,\n};\nconst getTransports = (num) => Object.keys(lookup).filter((i) => num && lookup[i]);\nconst fromTransports = (transports) => transports.reduceRight((memo, i) => memo + (lookup[i] ? lookup[i] : 0), 0);\nconst getAuthTypeFromCkey = (ckey) => {\n    const decoded = cbor_1.default.decode(ckey, { extendedResults: true });\n    const type = decoded.value.get(1);\n    if (type === 1) {\n        return \"Ed25519VerificationKey2020\";\n    }\n    else if (type === 2) {\n        return \"P256VerificationKey2020\";\n    }\n    else\n        return \"Unknown\";\n};\nconst getSignerFromCkey = (ckey) => {\n    const k = cbor_1.default.decode(ckey, { extendedResults: true }).value;\n    //console.log(\"getSignerFromCkey\", k);\n    let publicKey = buffer_1.Buffer.from([]);\n    if (k.get(3) == -7)\n        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), k.get(-2), k.get(-3)]);\n    else if (k.get(3) == -8)\n        publicKey = k.get(-2);\n    else if (k.get(3) == pqCrypto_1.PQ_COSE_ALG.DILITHIUM2)\n        publicKey = k.get(-101);\n    return { publicKey };\n};\nclass Fido2PRFManager extends Fido2Manager_1.default {\n    constructor() {\n        super();\n        this.prfsalt = buffer_1.Buffer.from(\"VaultysID salt\");\n    }\n    static async createFromAttestation(attestation) {\n        const f2m = new Fido2PRFManager();\n        f2m.ckey = SoftCredentials_1.default.getCOSEPublicKey(attestation);\n        //console.log(attestation, f2m.ckey);\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.fid = buffer_1.Buffer.from(attestation.id, \"base64\");\n        // fix for firefox, getTransports not available ! https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports\n        const response = attestation.response;\n        const transports = response.getTransports ? response.getTransports() : [\"usb\"];\n        f2m._transports = fromTransports(transports);\n        // signing\n        f2m.signer = getSignerFromCkey(f2m.ckey);\n        await f2m.getCypher();\n        delete f2m.cypher.secretKey;\n        return f2m;\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            f: this.fid,\n            t: this._transports,\n            c: this.ckey,\n            e: this.cypher.publicKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const f2m = new Fido2PRFManager();\n        f2m.version = data.v ?? 0;\n        f2m.capability = \"private\";\n        f2m.fid = typeof data.f === \"string\" ? buffer_1.Buffer.from(data.f, \"base64\") : data.f;\n        f2m._transports = data.t ? data.t : 15;\n        f2m.ckey = data.c;\n        f2m.authType = getAuthTypeFromCkey(f2m.ckey);\n        f2m.signer = getSignerFromCkey(data.c);\n        f2m.cypher = { publicKey: data.e };\n        return f2m;\n    }\n    cleanSecureData() {\n        if (this.cypher?.secretKey) {\n            (0, crypto_1.secureErase)(this.cypher.secretKey);\n            delete this.cypher.secretKey;\n        }\n    }\n    async getCypher() {\n        if (!this.cypher?.secretKey) {\n            const publicKey = {\n                challenge: buffer_1.Buffer.from([]),\n                userVerification: \"preferred\",\n                allowCredentials: [\n                    {\n                        type: \"public-key\",\n                        id: this.fid,\n                        transports: getTransports(this._transports),\n                    },\n                ],\n                extensions: {\n                    prf: {\n                        eval: {\n                            // Input the contextual information\n                            first: this.prfsalt,\n                            // There is a \"second\" optional field too\n                            // Though it is intended for key rotation.\n                        },\n                    },\n                },\n            };\n            const result = await this.webAuthn.get(publicKey);\n            const { prf } = result.getClientExtensionResults();\n            const first = prf?.results?.first;\n            if (!first)\n                throw new Error(\"PRF failed\");\n            const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(first));\n            this.cypher = {\n                publicKey: buffer_1.Buffer.from(cypher.publicKey),\n                secretKey: buffer_1.Buffer.from(cypher.secretKey),\n            };\n        }\n        return super.getCypher();\n    }\n    async createRevocationCertificate() {\n        // impossible\n        return null;\n    }\n}\nexports.default = Fido2PRFManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DHIES = void 0;\nconst saltpack_1 = require(\"@vaultys/saltpack\");\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst ed25519_1 = require(\"@noble/curves/ed25519\");\ned25519_1.ed25519.CURVE = { ...ed25519_1.ed25519.CURVE };\n// @ts-ignore hack to get compatibility with former @stricahq/bip32ed25519 lib\ned25519_1.ed25519.CURVE.adjustScalarBytes = (bytes) => {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 63; // 0b0001_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n};\n////@ts-expect-error fix for wrong way of exporting bip32ed25519\n//const bip32 = bip32fix.default ?? bip32fix;\nconst LEVEL_ROOT = 1;\nconst LEVEL_DERIVED = 2;\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nconst serializeID_v0 = (km) => {\n    const encodeBinary = (data) => {\n        if (data.length <= 65535) {\n            // bin16: binary data whose length is upto (2^16)-1 bytes\n            return buffer_1.Buffer.from([0xc5, data.length >> 8, data.length & 0xff, ...data]);\n        }\n        else {\n            // bin32: binary data whose length is upto (2^32)-1 bytes\n            return buffer_1.Buffer.from([0xc6, (data.length >> 24) & 0xff, (data.length >> 16) & 0xff, (data.length >> 8) & 0xff, data.length & 0xff, ...data]);\n        }\n    };\n    const version = buffer_1.Buffer.from([0x84, 0xa1, 0x76, 0]);\n    const proof = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x70]), encodeBinary(km.proof)]);\n    const sign = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x78]), encodeBinary(km.signer.publicKey)]);\n    const cypher = buffer_1.Buffer.concat([buffer_1.Buffer.from([0xa1, 0x65]), encodeBinary(km.cypher.publicKey)]);\n    return buffer_1.Buffer.concat([version, proof, sign, cypher]);\n};\n/**\n * DHIES (Diffie-Hellman Integrated Encryption Scheme) for KeyManager\n * Provides authenticated encryption using Diffie-Hellman key exchange\n */\nclass DHIES {\n    constructor(keyManager) {\n        this.keyManager = keyManager;\n    }\n    /**\n     * Encrypts a message for a recipient using DHIES\n     *\n     * @param message The plaintext message to encrypt\n     * @param recipientPublicKey The recipient's public key\n     * @returns Encrypted message with ephemeral public key and authentication tag, or null if encryption fails\n     */\n    async encrypt(message, recipientPublicKey) {\n        if (this.keyManager.capability === \"public\") {\n            console.error(\"Cannot encrypt with DHIES using a public KeyManager\");\n            return null;\n        }\n        const cypher = await this.keyManager.getCypher();\n        // Convert message to Buffer if it's a string\n        const messageBuffer = typeof message === \"string\" ? buffer_1.Buffer.from(message, \"utf8\") : message;\n        try {\n            const ephemeralKey = (0, crypto_1.randomBytes)(32); // Generate a random 32-byte key for ephemeral key\n            // Derive shared secret using recipient's public key and sender secret key\n            const dh = await cypher.diffieHellman(recipientPublicKey);\n            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));\n            // Key derivation: derive encryption and MAC keys from shared secret\n            const kdfOutput = this.kdf(sharedSecret, this.keyManager.cypher.publicKey, recipientPublicKey);\n            const encryptionKey = kdfOutput.encryptionKey;\n            const macKey = kdfOutput.macKey;\n            // Encrypt the message using XChaCha20-Poly1305\n            const nonce = (0, crypto_1.randomBytes)(24); // 24 bytes nonce for XChaCha20-Poly1305\n            const ciphertext = buffer_1.Buffer.from(tweetnacl_1.default.secretbox(messageBuffer, nonce, encryptionKey));\n            // Compute MAC (Message Authentication Code)\n            const dataToAuthenticate = buffer_1.Buffer.concat([this.keyManager.cypher.publicKey, nonce, ciphertext]);\n            const mac = this.computeMAC(macKey, dataToAuthenticate);\n            // Construct the final encrypted message: nonce + ephemeralKey + ciphertext + MAC\n            const encryptedMessage = buffer_1.Buffer.concat([nonce, ephemeralKey, ciphertext, mac]);\n            // Securely erase sensitive data\n            (0, crypto_1.secureErase)(sharedSecret);\n            (0, crypto_1.secureErase)(dh);\n            (0, crypto_1.secureErase)(encryptionKey);\n            (0, crypto_1.secureErase)(macKey);\n            return encryptedMessage;\n        }\n        catch (error) {\n            console.error(\"DHIES encryption failed:\", error);\n            return null;\n        }\n    }\n    /**\n     * Decrypts a message encrypted with DHIES\n     *\n     * @param encryptedMessage The complete encrypted message from the encrypt method\n     * @returns Decrypted message as a Buffer, or null if decryption fails\n     */\n    async decrypt(encryptedMessage, senderPublicKey) {\n        if (this.keyManager.capability === \"public\") {\n            console.error(\"Cannot decrypt with DHIES using a public KeyManager\");\n            return null;\n        }\n        try {\n            // Extract components from the encrypted message\n            // Format: nonce (24 bytes) + ephemeralKey (32 bytes) + ciphertext + MAC (32 bytes)\n            const nonce = encryptedMessage.slice(0, 24);\n            const ephemeralKey = encryptedMessage.slice(24, 56);\n            const mac = encryptedMessage.slice(encryptedMessage.length - 32);\n            const ciphertext = encryptedMessage.slice(56, encryptedMessage.length - 32);\n            const cypher = await this.keyManager.getCypher();\n            // Derive shared secret using sender public key and recipient secret key\n            const dh = await cypher.diffieHellman(senderPublicKey);\n            const sharedSecret = buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(ephemeralKey, dh));\n            // Key derivation: derive encryption and MAC keys\n            const kdfOutput = this.kdf(sharedSecret, senderPublicKey, this.keyManager.cypher.publicKey);\n            const encryptionKey = kdfOutput.encryptionKey;\n            const macKey = kdfOutput.macKey;\n            // Verify MAC\n            const dataToAuthenticate = buffer_1.Buffer.concat([senderPublicKey, nonce, ciphertext]);\n            const computedMac = this.computeMAC(macKey, dataToAuthenticate);\n            if (!this.constantTimeEqual(mac, computedMac)) {\n                //console.log(mac, computedMac);\n                console.error(\"DHIES: MAC verification failed\");\n                return null;\n            }\n            // Decrypt the ciphertext\n            const plaintext = tweetnacl_1.default.secretbox.open(ciphertext, nonce, encryptionKey);\n            if (!plaintext) {\n                console.error(\"DHIES: Decryption failed\");\n                return null;\n            }\n            const result = buffer_1.Buffer.from(plaintext);\n            // Securely erase sensitive data\n            (0, crypto_1.secureErase)(sharedSecret);\n            (0, crypto_1.secureErase)(encryptionKey);\n            (0, crypto_1.secureErase)(macKey);\n            return result;\n        }\n        catch (error) {\n            console.error(\"DHIES decryption failed:\", error);\n            return null;\n        }\n    }\n    /**\n     * Key Derivation Function: Derives encryption and MAC keys from the shared secret\n     */\n    kdf(sharedSecret, ephemeralPublicKey, staticPublicKey) {\n        // Create a context for the KDF to ensure different keys for different uses\n        const context = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"DHIES-KDF\"), ephemeralPublicKey, staticPublicKey]);\n        // Derive encryption key: HKDF-like construction\n        const encryptionKeyMaterial = (0, crypto_1.hash)(\"sha512\", buffer_1.Buffer.concat([\n            sharedSecret,\n            context,\n            buffer_1.Buffer.from([0x01]), // Domain separation byte\n        ]));\n        // Derive MAC key (using a different domain separation byte)\n        const macKeyMaterial = (0, crypto_1.hash)(\"sha512\", buffer_1.Buffer.concat([\n            sharedSecret,\n            context,\n            buffer_1.Buffer.from([0x02]), // Domain separation byte\n        ]));\n        // Use first 32 bytes of each as the actual keys (for NaCl's secretbox)\n        return {\n            encryptionKey: encryptionKeyMaterial.slice(0, 32),\n            macKey: macKeyMaterial.slice(0, 32),\n        };\n    }\n    /**\n     * Computes MAC for authenticated encryption\n     */\n    computeMAC(macKey, data) {\n        return (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([macKey, data]));\n    }\n    /**\n     * Constant-time comparison of two buffers to prevent timing attacks\n     */\n    constantTimeEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        let result = 0;\n        for (let i = 0; i < a.length; i++) {\n            result |= a[i] ^ b[i];\n        }\n        return result === 0;\n    }\n}\nexports.DHIES = DHIES;\nclass KeyManager {\n    constructor() {\n        this.level = 1;\n        this.version = 1;\n        this.capability = \"private\";\n        this.authType = \"Ed25519VerificationKey2020\";\n        this.encType = \"X25519KeyAgreementKey2019\";\n    }\n    static async create_Id25519_fromEntropy(entropy, swapIndex = 0) {\n        const km = new KeyManager();\n        km.entropy = entropy;\n        km.level = LEVEL_ROOT;\n        km.capability = \"private\";\n        const seed = sha512(entropy);\n        // const derivedKey = privateDerivePath(await bip32.Bip32PrivateKey.fromEntropy(seed.slice(0, 32)), `m/1'/0'/${swapIndex}'`);\n        km.proofKey = {\n            publicKey: buffer_1.Buffer.from([]), //deprecated\n        };\n        km.swapIndex = swapIndex;\n        km.proof = (0, crypto_1.hash)(\"sha256\", km.proofKey.publicKey);\n        // const privateKey = privateDerivePath(derivedKey, \"/0'\");\n        km.signer = {\n            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(seed.slice(0, 32))),\n            secretKey: seed.slice(0, 32),\n        };\n        const swapIndexBuffer = buffer_1.Buffer.alloc(8);\n        swapIndexBuffer.writeBigInt64LE(BigInt(swapIndex), 0);\n        const seed2 = sha256(buffer_1.Buffer.concat([seed.slice(32, 64), swapIndexBuffer]));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static generate_Id25519() {\n        return KeyManager.create_Id25519_fromEntropy((0, crypto_1.randomBytes)(32));\n    }\n    get id() {\n        if (this.version == 0)\n            return serializeID_v0(this);\n        else\n            return buffer_1.Buffer.from((0, msgpack_1.encode)({\n                v: this.version,\n                p: this.proof,\n                x: this.signer.publicKey,\n                e: this.cypher.publicKey,\n            }));\n    }\n    async getCypher() {\n        // todo fetch secretKey here\n        const cypher = this.cypher;\n        return {\n            hmac: (message) => (cypher.secretKey ? (0, crypto_1.hmac)(\"sha256\", buffer_1.Buffer.from(cypher.secretKey), \"VaultysID/\" + message + \"/end\") : undefined),\n            signcrypt: async (plaintext, publicKeys) => (0, saltpack_1.encryptAndArmor)(plaintext, cypher, publicKeys),\n            decrypt: async (encryptedMessage, senderKey) => (0, saltpack_1.dearmorAndDecrypt)(encryptedMessage, cypher, senderKey),\n            diffieHellman: async (publicKey) => buffer_1.Buffer.from(tweetnacl_1.default.scalarMult(cypher.secretKey, publicKey)),\n        };\n    }\n    getSigner() {\n        // todo fetch secretKey here\n        const secretKey = this.signer.secretKey;\n        const sign = (data) => Promise.resolve(buffer_1.Buffer.from(ed25519_1.ed25519.sign(data, secretKey)));\n        //console.log(secretKey.toString(\"hex\"), new bip32.PrivateKey(secretKey).toPublicKey().toBytes().toString(\"hex\"), Buffer.from(ed25519.getPublicKey(secretKey)).toString(\"hex\"));\n        return Promise.resolve({ sign });\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            p: this.proof,\n            x: this.signer.secretKey,\n            e: this.cypher.secretKey,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const km = new KeyManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"private\";\n        km.proof = data.p;\n        km.signer = {\n            secretKey: data.x.slice(0, 32),\n            publicKey: buffer_1.Buffer.from(ed25519_1.ed25519.getPublicKey(data.x.slice(0, 32))),\n        };\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(data.e);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static instantiate(obj) {\n        const km = new KeyManager();\n        km.version = obj.version ?? 0;\n        km.level = obj.level;\n        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);\n        km.signer = {\n            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),\n        };\n        km.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return km;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const km = new KeyManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"public\";\n        km.proof = data.p;\n        km.signer = {\n            publicKey: data.x,\n        };\n        km.cypher = {\n            publicKey: data.e,\n        };\n        // console.log(km)\n        return km;\n    }\n    async sign(data) {\n        if (this.capability == \"public\")\n            return null;\n        const signer = await this.getSigner();\n        return signer.sign(data);\n    }\n    verify(data, signature, userVerificationIgnored) {\n        return ed25519_1.ed25519.verify(signature, data, this.signer.publicKey);\n    }\n    // async createRevocationCertificate(newId) {\n    //   if (this.level == LEVEL_ROOT) {\n    //     const seed = sha512(this.entropy);\n    //     let node = derivePath(\n    //       await Bip32PrivateKey.fromEntropy(seed.slice(0, 32)),\n    //       \"m/1'/0'/1'\",\n    //     );\n    //     const proof = hash(\"sha256\", node.toBip32PublicKey().toBytes());\n    //     if (this.proof.toString(\"hex\") == proof.toString(\"hex\")) {\n    //       const revocationCertificate = {\n    //         xpub: node.toBytes(),\n    //         id: this.id,\n    //         newId,\n    //       };\n    //       revocationCertificate.signature = node.toPrivateKey().sign(revocationCertificate);\n    //       return revocationCertificate;\n    //     } else return null;\n    //   } else return null;\n    // }\n    // async createSwapingCertificate() {\n    //   if (this.level === LEVEL_ROOT && this.entropy) {\n    //     const newKey = await KeyManager.create_Id25519_fromEntropy(this.entropy, this.swapIndex + 1);\n    //     const hiscp: HISCP = {\n    //       newId: newKey.id,\n    //       proofKey: this.proofKey.publicKey,\n    //       timestamp: Date.now(),\n    //       signature: Buffer.from([]),\n    //     };\n    //     const timestampBuffer = Buffer.alloc(8);\n    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);\n    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);\n    //     hiscp.signature = new bip32.Bip32PrivateKey(this.proofKey.secretKey!).toPrivateKey().sign(hiscpBuffer);\n    //     return hiscp;\n    //   }\n    //   return null;\n    // }\n    // async verifySwapingCertificate(hiscp: HISCP) {\n    //   const proof = hash(\"sha256\", hiscp.proofKey).toString(\"hex\");\n    //   if (proof === this.proof.toString(\"hex\")) {\n    //     const timestampBuffer = Buffer.alloc(8);\n    //     timestampBuffer.writeBigUInt64LE(BigInt(hiscp.timestamp) as unknown as number, 0);\n    //     const newKey = KeyManager.fromId(hiscp.newId);\n    //     const hiscpBuffer = Buffer.concat([hiscp.newId, hiscp.proofKey, timestampBuffer]);\n    //     const proofVerifier = bip32.Bip32PublicKey.fromBytes(hiscp.proofKey);\n    //     return proofVerifier.toPublicKey().verify(hiscpBuffer, hiscp.signature);\n    //   } else {\n    //     return false;\n    //   }\n    // }\n    cleanSecureData() {\n        if (this.cypher?.secretKey) {\n            (0, crypto_1.secureErase)(this.cypher.secretKey);\n            delete this.cypher.secretKey;\n        }\n        if (this.signer?.secretKey) {\n            (0, crypto_1.secureErase)(this.signer.secretKey);\n            delete this.signer.secretKey;\n        }\n        if (this.entropy) {\n            (0, crypto_1.secureErase)(this.entropy);\n            delete this.entropy;\n        }\n    }\n    /**\n     * Performs a Diffie-Hellman key exchange with another KeyManager instance\n     * @param otherKeyManager The other party's KeyManager instance\n     * @returns A shared secret that can be used for symmetric encryption\n     */\n    async performDiffieHellman(otherKeyManager) {\n        if (this.capability === \"public\") {\n            console.error(\"Cannot perform DH key exchange with a public key capability\");\n            return null;\n        }\n        const cypher = await this.getCypher();\n        const otherKey = otherKeyManager.cypher.publicKey;\n        // Perform the X25519 scalar multiplication to derive the shared secret\n        const sharedSecret = await cypher.diffieHellman(otherKey);\n        // Hash the shared secret for better security (to derive a symmetric key)\n        const derivedKey = sha256(sharedSecret);\n        // Securely erase the shared secret from memory\n        (0, crypto_1.secureErase)(sharedSecret);\n        return derivedKey;\n    }\n    /**\n     * Static method to perform a Diffie-Hellman key exchange between two KeyManager instances\n     * @param keyManager1 First KeyManager instance\n     * @param keyManager2 Second KeyManager instance\n     * @returns A shared secret that both parties can derive\n     */\n    static async diffieHellman(keyManager1, keyManager2) {\n        return keyManager1.performDiffieHellman(keyManager2);\n    }\n    /**\n     * Encrypt a message using DHIES for a recipient\n     * @param message Message to encrypt\n     * @param recipientId Recipient's KeyManager ID\n     * @returns Encrypted message or null if encryption fails\n     */\n    async dhiesEncrypt(message, recipientId) {\n        const recipientKM = KeyManager.fromId(recipientId);\n        //console.log(recipientKM.cypher.publicKey, this.cypher.publicKey);\n        const dhies = new DHIES(this);\n        return dhies.encrypt(message, recipientKM.cypher.publicKey);\n    }\n    /**\n     * Decrypt a message encrypted with DHIES\n     * @param encryptedMessage Encrypted message from dhiesEncrypt\n     * @returns Decrypted message or null if decryption fails\n     */\n    async dhiesDecrypt(encryptedMessage, senderId) {\n        const senderKM = KeyManager.fromId(senderId);\n        //console.log(senderKM.cypher.publicKey, this.cypher.publicKey);\n        const dhies = new DHIES(this);\n        return dhies.decrypt(encryptedMessage, senderKM.cypher.publicKey);\n    }\n    static async encrypt(plaintext, recipientIds) {\n        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);\n        return await (0, saltpack_1.encryptAndArmor)(plaintext, null, publicKeys);\n    }\n    async signcrypt(plaintext, recipientIds) {\n        const publicKeys = recipientIds.map(KeyManager.fromId).map((km) => km.cypher.publicKey);\n        const cypher = await this.getCypher();\n        return await cypher.signcrypt(plaintext, publicKeys);\n    }\n    async decrypt(encryptedMessage, senderId = null) {\n        const cypher = await this.getCypher();\n        const senderKey = senderId ? KeyManager.fromId(senderId).cypher.publicKey : null;\n        const message = await cypher.decrypt(encryptedMessage, senderKey);\n        return message.toString();\n    }\n    // use better hash to prevent attack\n    getSecretHash(data) {\n        const toHash = buffer_1.Buffer.concat([data, buffer_1.Buffer.from(\"secrethash\"), this.cypher.secretKey]);\n        return (0, crypto_1.hash)(\"sha256\", toHash);\n    }\n}\nexports.default = KeyManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemoryChannel = void 0;\nexports.pipeChannels = pipeChannels;\nexports.unpipeChannels = unpipeChannels;\nexports.StreamChannel = StreamChannel;\nexports.convertWebWritableStreamToNodeWritable = convertWebWritableStreamToNodeWritable;\nexports.convertWebReadableStreamToNodeReadable = convertWebReadableStreamToNodeReadable;\nconst cryptoChannel_1 = __importDefault(require(\"./cryptoChannel\"));\nconst stream_1 = require(\"stream\");\nconst buffer_1 = require(\"buffer/\");\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n/**\n * Pipes two channels together, creating a bidirectional flow where\n * messages sent to one channel are automatically forwarded to the other.\n * @param channel1 The first channel to connect\n * @param channel2 The second channel to connect\n * @returns A Promise that resolves when both channels close\n */\nfunction pipeChannels(channel1, channel2) {\n    let running = true;\n    // Start both piping directions\n    const pipe1to2 = async () => {\n        try {\n            await channel1.start();\n            await channel2.start();\n            console.log(\"pipe1to2\");\n            while (running) {\n                try {\n                    const data = await channel1.receive();\n                    console.log(\"pipe1to2\", data);\n                    if (!running || data.length === 0)\n                        break;\n                    channel2.send(data);\n                }\n                catch (error) {\n                    if (running)\n                        console.error(\"Error in pipe1to2:\", error);\n                    break;\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Fatal error in pipe1to2:\", error);\n        }\n    };\n    const pipe2to1 = async () => {\n        try {\n            while (running) {\n                console.log(\"pipe2to1\");\n                try {\n                    const data = await channel2.receive();\n                    console.log(\"pipe2to1\", data);\n                    if (!running || data.length === 0)\n                        break;\n                    channel1.send(data);\n                }\n                catch (error) {\n                    if (running)\n                        console.error(\"Error in pipe2to1:\", error);\n                    break;\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Fatal error in pipe2to1:\", error);\n        }\n    };\n    // Start the pipes\n    pipe1to2();\n    pipe2to1();\n    // Return function to stop piping\n    return async () => {\n        running = false;\n        await Promise.all([channel1.close(), channel2.close()]);\n    };\n}\n/**\n * Utility function that stops an active channel pipe\n * @param channel1 The first channel in the pipe\n * @param channel2 The second channel in the pipe\n */\nasync function unpipeChannels(channel1, channel2) {\n    await Promise.all([channel1.close(), channel2.close()]);\n}\nfunction StreamChannel(channel) {\n    const onData = async (callback) => {\n        let message = await channel.receive();\n        while (message) {\n            callback(message);\n            if (message.toString(\"utf-8\") === \"EOF\") {\n                return;\n            }\n            message = await channel.receive();\n        }\n    };\n    const getWriteStream = () => {\n        const stream = new stream_1.Stream.Writable({\n            write: (chunk, encoding, done) => {\n                channel.send(chunk);\n                done();\n            },\n        });\n        return stream;\n    };\n    const upload = async (stream) => {\n        return new Promise((resolve) => {\n            const writeStream = getWriteStream();\n            stream.pipe(writeStream).once(\"finish\", () => {\n                channel.send(buffer_1.Buffer.from(\"EOF\", \"utf-8\"));\n                writeStream.end();\n                resolve();\n            });\n        });\n    };\n    const uploadData = async (data) => {\n        const stream = stream_1.Readable.from(data);\n        await upload(stream);\n    };\n    const download = async (stream) => {\n        const readStream = getReadStream();\n        const result = new Promise((resolve) => readStream.on(\"end\", () => {\n            resolve();\n        }));\n        readStream.pipe(stream);\n        await result;\n    };\n    const downloadData = async () => {\n        const readStream = getReadStream();\n        const chunks = [];\n        const result = new Promise((resolve) => readStream.on(\"end\", () => {\n            resolve(buffer_1.Buffer.concat(chunks));\n        }));\n        const stream = new stream_1.Stream.Writable({\n            write: (chunk, encoding, done) => {\n                chunks.push(chunk);\n                done();\n            },\n        });\n        readStream.pipe(stream);\n        return result;\n    };\n    const getReadStream = () => {\n        let push;\n        let temp;\n        const stream = new stream_1.Stream.Readable({\n            read() {\n                push = (data) => this.push(data);\n            },\n        });\n        onData((buf) => {\n            if (buf.length === 3 && buf.toString(\"utf-8\") === \"EOF\" && push) {\n                temp && push(temp);\n                push(null);\n                stream.destroy();\n            }\n            temp = temp ? buffer_1.Buffer.concat([temp, buf]) : buf;\n            if (push) {\n                !push(temp) && (push = null);\n                temp = null;\n            }\n        });\n        return stream;\n    };\n    return {\n        getReadStream,\n        getWriteStream,\n        upload,\n        uploadData,\n        download,\n        downloadData,\n    };\n}\nfunction convertWebWritableStreamToNodeWritable(webWritableStream) {\n    const writer = webWritableStream.getWriter();\n    return new stream_1.Writable({\n        async write(chunk, encoding, callback) {\n            try {\n                // Get a writer from the Web WritableStream\n                await writer.write(chunk);\n                writer.releaseLock(); // Release the lock on the writer after writing\n                callback(); // Signal that the chunk has been processed\n            }\n            catch (error) {\n                callback(); // Signal an error if it occurred\n            }\n        },\n        async final(callback) {\n            try {\n                // Close the Web WritableStream\n                const writer = webWritableStream.getWriter();\n                await writer.close();\n                writer.releaseLock(); // Release the lock on the writer after closing\n                callback(); // Signal that the stream is finished\n            }\n            catch (error) {\n                callback(); // Signal an error if it occurred during close\n            }\n        },\n        async destroy(error, callback) {\n            try {\n                // Abort the Web WritableStream in case of an error\n                const writer = webWritableStream.getWriter();\n                await writer.abort(error);\n                writer.releaseLock(); // Release the lock on the writer after aborting\n                callback(error); // Signal that the stream is destroyed\n            }\n            catch (abortError) {\n                callback(null); // Signal an error if it occurred during abort\n            }\n        },\n    });\n}\nfunction convertWebReadableStreamToNodeReadable(webReadableStream) {\n    const reader = webReadableStream.getReader();\n    return new stream_1.Readable({\n        async read() {\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    //console.log(value);\n                    if (done) {\n                        this.push(null); // Signal the end of the stream\n                        break;\n                    }\n                    this.push(buffer_1.Buffer.from(value)); // Need to convert Uint8Array to Buffer\n                }\n            }\n            catch (error) {\n                this.destroy();\n            }\n        },\n    });\n}\nclass MemoryChannel {\n    constructor() {\n        this.messageQueue = [];\n        this.waitingResolvers = [];\n        this.connected = false;\n        this.connectedCallbacks = [];\n        this.closed = false;\n    }\n    setChannel(chan, name) {\n        this.name = name;\n        this.otherend = chan;\n    }\n    static createBidirectionnal() {\n        const input = new MemoryChannel();\n        const output = new MemoryChannel();\n        input.setChannel(output);\n        output.setChannel(input);\n        return input;\n    }\n    onConnected(callback) {\n        if (this.connected) {\n            callback();\n        }\n        else {\n            this.connectedCallbacks.push(callback);\n        }\n    }\n    static createEncryptedBidirectionnal(key = cryptoChannel_1.default.generateKey()) {\n        const input = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);\n        const output = cryptoChannel_1.default.encryptChannel(new MemoryChannel(), key);\n        input.setChannel(output);\n        output.setChannel(input);\n        return input;\n    }\n    getConnectionString() {\n        return \"vaultys://memory\";\n    }\n    fromConnectionString(string) {\n        return string === \"vaultys://memory\" ? new MemoryChannel() : null;\n    }\n    setLogger(logger) {\n        this.logger = logger;\n    }\n    setInjector(injector) {\n        this.injector = injector;\n    }\n    async start() {\n        this.connected = true;\n        this.connectedCallbacks.forEach((callback) => callback());\n        this.connectedCallbacks = []; // Clear callbacks after calling them\n    }\n    async send(data) {\n        if (this.closed) {\n            throw new Error(\"Cannot send on closed channel\");\n        }\n        if (!this.otherend) {\n            throw new Error(\"No other end connected to this channel\");\n        }\n        // Log the data if a logger is set\n        if (this.logger) {\n            this.logger(data);\n        }\n        // Process data through injector if present\n        let processedData = data;\n        if (this.injector) {\n            processedData = await this.injector(data);\n        }\n        // // Signal that this end is connected\n        if (!this.connected) {\n            await this.start();\n        }\n        // Deliver the message to the other end\n        this.otherend.deliverMessage(processedData);\n    }\n    deliverMessage(data) {\n        // If there are waiting receivers, deliver directly to the first one\n        if (this.waitingResolvers.length > 0) {\n            const resolver = this.waitingResolvers.shift();\n            resolver(data);\n        }\n        else {\n            // Otherwise queue the message\n            this.messageQueue.push(data);\n        }\n    }\n    async receive() {\n        if (this.closed) {\n            throw new Error(\"Cannot receive on closed channel\");\n        }\n        //console.log(this);\n        // If there are queued messages, return the first one\n        if (this.messageQueue.length > 0) {\n            return this.messageQueue.shift();\n        }\n        // Otherwise, wait for a message to arrive\n        return new Promise((resolve) => {\n            this.waitingResolvers.push(resolve);\n        });\n    }\n    async close() {\n        this.closed = true;\n        // Clear any waiting receivers with an error\n        while (this.waitingResolvers.length > 0) {\n            const resolver = this.waitingResolvers.shift();\n            // Resolve with empty buffer to indicate channel closed\n            resolver(buffer_1.Buffer.alloc(0));\n        }\n        // Clear the message queue\n        this.messageQueue = [];\n    }\n}\nexports.MemoryChannel = MemoryChannel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalStorage = exports.MemoryStorage = exports.deserialize = exports.serialize = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst replacer = (key, value) => {\n    //if(key==\"1686045792046\") console.log(value);\n    if (!value)\n        return value;\n    if (key === \"certificate\")\n        return \"__C__\" + buffer_1.Buffer.from(value).toString(\"base64\");\n    if (value.type === \"Buffer\") {\n        return \"_bx_\" + buffer_1.Buffer.from(value.data).toString(\"base64\");\n    }\n    if (value.constructor.name === \"Array\") {\n        return \"_bx_\" + buffer_1.Buffer.from(value).toString(\"base64\");\n    }\n    return value;\n};\nconst reviver = (key, value) => {\n    if (value && key === \"certificate\") {\n        if (typeof value === \"string\" && value.startsWith(\"__C__\")) {\n            return buffer_1.Buffer.from(value.slice(5), \"base64\");\n        }\n        else\n            return buffer_1.Buffer.from(value);\n    }\n    if (typeof value === \"string\" && value.startsWith(\"_bx_\")) {\n        return buffer_1.Buffer.from(value.slice(4), \"base64\");\n    }\n    return value;\n};\nconst serialize = (data) => JSON.stringify(data, replacer);\nexports.serialize = serialize;\nconst deserialize = (string) => JSON.parse(string, reviver);\nexports.deserialize = deserialize;\nconst MemoryStorage = (save) => {\n    let data = {};\n    if (!save)\n        save = () => (0, exports.serialize)(data);\n    return storagify(data, save, () => \"\");\n};\nexports.MemoryStorage = MemoryStorage;\nconst LocalStorage = (key = \"vaultysStorage\") => {\n    let data = {};\n    const _id = Math.random();\n    //console.log(key);\n    if (!localStorage[key])\n        localStorage[key] = \"{}\";\n    else\n        data = (0, exports.deserialize)(localStorage[key]);\n    return storagify(data, () => {\n        //console.log(\"save !!!!!\", key, _id);\n        localStorage.setItem(key, (0, exports.serialize)(data));\n    }, () => localStorage.removeItem(key));\n};\nexports.LocalStorage = LocalStorage;\nconst storagify = (object, save, destroy) => {\n    return {\n        destroy,\n        save,\n        toString: () => (0, exports.serialize)(object),\n        fromString: (string, s, d) => storagify((0, exports.deserialize)(string), s, d),\n        _raw: object,\n        set: (key, value) => (object[key] = value),\n        delete: (key) => delete object[key],\n        get: (key) => object[key],\n        list: () => Object.keys(object).filter((k) => !k.startsWith(\"!\")),\n        listSubstores: () => Object.keys(object)\n            .filter((k) => k.startsWith(\"!\"))\n            .map((k) => k.slice(1)),\n        deleteSubstore: (key) => delete object[\"!\" + key],\n        renameSubstore: (oldname, newname) => {\n            if (oldname === newname || !!object[\"!\" + newname])\n                return;\n            object[\"!\" + newname] = object[\"!\" + oldname];\n            delete object[\"!\" + oldname];\n        },\n        substore: (key) => {\n            if (!object[\"!\" + key])\n                object[\"!\" + key] = {};\n            return storagify(object[\"!\" + key], save, destroy);\n        },\n    };\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst LEVEL_ROOT = 1;\nconst LEVEL_DERIVED = 2;\nconst sha512 = (data) => (0, crypto_1.hash)(\"sha512\", data);\nconst sha256 = (data) => (0, crypto_1.hash)(\"sha256\", data);\nclass PQManager extends KeyManager_1.default {\n    constructor() {\n        super();\n        this.authType = \"DilithiumVerificationKey2025\";\n    }\n    static async create_PQ_fromEntropy(entropy, swapIndex = 0) {\n        const km = new PQManager();\n        km.entropy = entropy;\n        km.level = LEVEL_ROOT;\n        km.capability = \"private\";\n        km.seed = sha512(entropy);\n        km.swapIndex = swapIndex;\n        km.proof = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from([]));\n        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));\n        const seed2 = sha256(km.seed.slice(32, 64));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static generate_PQ() {\n        return PQManager.create_PQ_fromEntropy((0, crypto_1.randomBytes)(32));\n    }\n    getSecret() {\n        return buffer_1.Buffer.from((0, msgpack_1.encode)({\n            v: this.version,\n            p: this.proof,\n            s: this.seed,\n        }));\n    }\n    static fromSecret(secret) {\n        const data = (0, msgpack_1.decode)(secret);\n        const km = new PQManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"private\";\n        km.proof = data.p;\n        km.seed = buffer_1.Buffer.from(data.s);\n        km.signer = (0, pqCrypto_1.generateDilithiumKeyPair)(km.seed.slice(0, 32));\n        const seed2 = sha256(km.seed.slice(32, 64));\n        const cypher = tweetnacl_1.default.box.keyPair.fromSecretKey(seed2);\n        km.cypher = {\n            publicKey: buffer_1.Buffer.from(cypher.publicKey),\n            secretKey: buffer_1.Buffer.from(cypher.secretKey),\n        };\n        return km;\n    }\n    static instantiate(obj) {\n        const km = new PQManager();\n        km.version = obj.version ?? 0;\n        km.level = obj.level;\n        km.proof = obj.proof.data ? buffer_1.Buffer.from(obj.proof.data) : buffer_1.Buffer.from(obj.proof);\n        km.signer = {\n            publicKey: obj.signer.publicKey.data ? buffer_1.Buffer.from(obj.signer.publicKey.data) : buffer_1.Buffer.from(obj.signer.publicKey),\n        };\n        km.cypher = {\n            publicKey: obj.cypher.publicKey.data ? buffer_1.Buffer.from(obj.cypher.publicKey.data) : buffer_1.Buffer.from(obj.cypher.publicKey),\n        };\n        return km;\n    }\n    static fromId(id) {\n        const data = (0, msgpack_1.decode)(id);\n        const km = new PQManager();\n        km.version = data.v ?? 0;\n        km.level = LEVEL_DERIVED;\n        km.capability = \"public\";\n        km.proof = data.p;\n        km.signer = {\n            publicKey: data.x,\n        };\n        km.cypher = {\n            publicKey: data.e,\n        };\n        // console.log(km)\n        return km;\n    }\n    async sign(data) {\n        if (this.capability == \"public\")\n            return null;\n        return (0, pqCrypto_1.signDilithium)(data, this.signer.secretKey);\n    }\n    verify(data, signature, userVerificationIgnored) {\n        return (0, pqCrypto_1.verifyDilithium)(data, signature, this.signer.publicKey);\n    }\n}\nexports.default = PQManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"./crypto\");\nconst Fido2Manager_1 = __importDefault(require(\"./Fido2Manager\"));\nconst Fido2PRFManager_1 = __importDefault(require(\"./Fido2PRFManager\"));\nconst KeyManager_1 = __importDefault(require(\"./KeyManager\"));\nconst SoftCredentials_1 = __importDefault(require(\"./platform/SoftCredentials\"));\nconst webauthn_1 = require(\"./platform/webauthn\");\nconst buffer_1 = require(\"buffer/\");\nconst PQManager_1 = __importDefault(require(\"./PQManager\"));\nconst pqCrypto_1 = require(\"./pqCrypto\");\nconst TYPE_MACHINE = 0;\nconst TYPE_PERSON = 1;\nconst TYPE_ORGANIZATION = 2;\nconst TYPE_FIDO2 = 3;\nconst TYPE_FIDO2PRF = 4;\nclass VaultysId {\n    constructor(keyManager, certificate, type = TYPE_MACHINE) {\n        this.encrypt = VaultysId.encrypt;\n        this.type = type;\n        this.keyManager = keyManager;\n        this.certificate = certificate;\n    }\n    // // Set the index of the proof in case of previous key for this protocol/service have been compromised\n    // setProofIndex(protocol, service, index) {\n    //   this.proofIndices[`${protocol}-${service}`] = index;\n    // }\n    // createSwapingCertificate(protocol, service) {\n    //   let proofIndex = this.proofIndices[`${protocol}-${service}`]\n    //     ? this.proofIndices[`${protocol}-${service}`]\n    //     : 0;\n    //   const pk = this.getKey({\n    //     protocol,\n    //     service,\n    //     proofIndex,\n    //   });\n    //   const newPk = this.getKey({\n    //     protocol,\n    //     service,\n    //     proofIndex: proofIndex + 1,\n    //   });\n    //   const xPub = this.device.getProofXPub({\n    //     protocol,\n    //     service,\n    //     index,\n    //   });\n    //   const derivation = PDM.getProofDerivation(protocol, service, index);\n    //   const revocationCertificate = `vaultys://p2p/revocation?pk=${pk}&npk=${newPk}&xpub=${xpub}&index=${derivation}`;\n    // }\n    static fromId(id, certificate, encoding = \"hex\") {\n        let cleanId = id;\n        if (id.data) {\n            // Buffer thing\n            cleanId = buffer_1.Buffer.from(id.data);\n        }\n        if (id instanceof Uint8Array) {\n            // Buffer thing\n            cleanId = buffer_1.Buffer.from(id);\n        }\n        if (typeof id === \"string\") {\n            cleanId = buffer_1.Buffer.from(id, encoding);\n        }\n        const type = cleanId[0];\n        if (type === TYPE_FIDO2) {\n            const f2m = Fido2Manager_1.default.fromId(cleanId.slice(1));\n            return new VaultysId(f2m, certificate, type);\n        }\n        else if (type === TYPE_FIDO2PRF) {\n            const f2m = Fido2PRFManager_1.default.fromId(cleanId.slice(1));\n            return new VaultysId(f2m, certificate, type);\n        }\n        else {\n            if (cleanId.length > 1952) {\n                const pqm = PQManager_1.default.fromId(cleanId.slice(1));\n                return new VaultysId(pqm, certificate, type);\n            }\n            else {\n                const km = KeyManager_1.default.fromId(cleanId.slice(1));\n                return new VaultysId(km, certificate, type);\n            }\n        }\n    }\n    static async fromEntropy(entropy, type, pqc = false) {\n        const cleanedEntropy = entropy;\n        if (pqc) {\n            const km = await PQManager_1.default.create_PQ_fromEntropy(cleanedEntropy);\n            return new VaultysId(km, undefined, type);\n        }\n        else {\n            const km = await KeyManager_1.default.create_Id25519_fromEntropy(cleanedEntropy);\n            return new VaultysId(km, undefined, type);\n        }\n    }\n    static async createWebauthn(passkey = true, onPRFEnabled) {\n        const options = VaultysId.createPublicKeyCredentialCreationOptions(passkey);\n        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n        const attestation = await webAuthn.create(options);\n        if (!attestation)\n            return null;\n        else\n            return VaultysId.fido2FromAttestation(attestation, onPRFEnabled);\n    }\n    static async createPQC() {\n        const options = VaultysId.createPublicKeyCredentialOptionsPQC();\n        const webAuthn = (0, webauthn_1.getWebAuthnProvider)();\n        const attestation = await webAuthn.create(options);\n        //console.log(attestation);\n        if (!attestation)\n            return null;\n        else\n            return VaultysId.fido2FromAttestation(attestation);\n    }\n    static async fido2FromAttestation(attestation, onPRFEnabled) {\n        // should be somehow valid.\n        SoftCredentials_1.default.verifyPackedAttestation(attestation.response, true);\n        //console.log(SoftCredentials.verifyPackedAttestation(attestation.response as AuthenticatorAttestationResponse, true));\n        if (attestation.getClientExtensionResults().prf?.enabled && (!onPRFEnabled || (await onPRFEnabled()))) {\n            const f2m = await Fido2PRFManager_1.default.createFromAttestation(attestation);\n            return new VaultysId(f2m, undefined, TYPE_FIDO2PRF);\n        }\n        else {\n            const f2m = await Fido2Manager_1.default.createFromAttestation(attestation);\n            return new VaultysId(f2m, undefined, TYPE_FIDO2);\n        }\n    }\n    static async machineFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_MACHINE);\n    }\n    static async organizationFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_ORGANIZATION);\n    }\n    static async personFromEntropy(entropy) {\n        return VaultysId.fromEntropy(entropy, TYPE_PERSON);\n    }\n    static fromSecret(secret, encoding = \"hex\") {\n        const secretBuffer = buffer_1.Buffer.from(secret, encoding);\n        const type = secretBuffer[0];\n        if (type == TYPE_FIDO2) {\n            const f2m = Fido2Manager_1.default.fromSecret(secretBuffer.slice(1));\n            return new VaultysId(f2m, undefined, type);\n        }\n        else if (type == TYPE_FIDO2PRF) {\n            const f2m = Fido2PRFManager_1.default.fromSecret(secretBuffer.slice(1));\n            return new VaultysId(f2m, undefined, type);\n        }\n        else {\n            //console.log(secretBuffer.length);\n            if (secretBuffer.length === 109) {\n                const pqm = PQManager_1.default.fromSecret(secretBuffer.slice(1));\n                return new VaultysId(pqm, undefined, type);\n            }\n            else {\n                const km = KeyManager_1.default.fromSecret(secretBuffer.slice(1));\n                return new VaultysId(km, undefined, type);\n            }\n        }\n    }\n    static async generatePerson(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_PERSON);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_PERSON);\n        }\n    }\n    static async generateOrganization(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_ORGANIZATION);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_ORGANIZATION);\n        }\n    }\n    static async generateMachine(pqc = false) {\n        if (pqc) {\n            const km = await PQManager_1.default.generate_PQ();\n            return new VaultysId(km, undefined, TYPE_MACHINE);\n        }\n        else {\n            const km = await KeyManager_1.default.generate_Id25519();\n            return new VaultysId(km, undefined, TYPE_MACHINE);\n        }\n    }\n    get relationshipCertificate() {\n        return this.certificate;\n    }\n    getSecret(encoding = \"hex\") {\n        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.getSecret()]).toString(encoding);\n    }\n    get fingerprint() {\n        const t = buffer_1.Buffer.from([this.type]).toString(\"hex\");\n        const fp = t + (0, crypto_1.hash)(\"SHA224\", this.keyManager.id).toString(\"hex\");\n        return fp\n            .slice(0, 40)\n            .toUpperCase()\n            .match(/.{1,4}/g)\n            .join(\" \");\n    }\n    get did() {\n        const t = buffer_1.Buffer.from([this.type]).toString(\"hex\");\n        const fp = t + (0, crypto_1.hash)(\"SHA224\", this.keyManager.id).toString(\"hex\");\n        return `did:vaultys:${fp.slice(0, 40)}`;\n    }\n    get didDocument() {\n        return {\n            \"@context\": [\"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\"],\n            id: this.did,\n            authentication: [\n                {\n                    id: `${this.did}#keys-1`,\n                    type: this.keyManager.authType,\n                    controller: this.did,\n                    publicKeyMultibase: \"m\" + buffer_1.Buffer.from(this.keyManager.signer.publicKey).toString(\"base64\"),\n                },\n            ],\n            keyAgreement: [\n                {\n                    id: `${this.did}#keys-2`,\n                    type: this.keyManager.encType,\n                    controller: this.did,\n                    publicKeyMultibase: \"m\" + buffer_1.Buffer.from(this.keyManager.cypher.publicKey).toString(\"base64\"),\n                },\n            ],\n        };\n    }\n    get id() {\n        return buffer_1.Buffer.concat([buffer_1.Buffer.from([this.type]), this.keyManager.id]);\n    }\n    toVersion(v) {\n        this.keyManager.version = v;\n        return this;\n    }\n    get version() {\n        return this.keyManager.version;\n    }\n    isHardware() {\n        return this.type === TYPE_FIDO2 || this.type === TYPE_FIDO2PRF;\n    }\n    isMachine() {\n        return this.type === TYPE_MACHINE;\n    }\n    isPerson() {\n        return this.type === TYPE_PERSON;\n    }\n    getOTPHmac(timelock = 1 * 3600000) {\n        const otp = Math.floor(new Date().getTime() / timelock);\n        return this.keyManager.getSecretHash(buffer_1.Buffer.from(`OTP-${otp}`)).toString(\"hex\");\n    }\n    // Need to think about insecure use of this function\n    getOTP(prefix = \"password\", timelock = 24 * 3600000) {\n        if (this.certificate) {\n            const otp = Math.floor(new Date().getTime() / timelock);\n            const toHash = buffer_1.Buffer.concat([buffer_1.Buffer.from(prefix, \"utf-8\"), buffer_1.Buffer.from(this.certificate), buffer_1.Buffer.from([otp])]);\n            return (0, crypto_1.hash)(\"SHA256\", toHash).toString(\"hex\");\n        }\n        throw new Error(\"no certificate, cannot derive OTP\");\n    }\n    async performDiffieHellman(otherVaultysId) {\n        return this.keyManager.performDiffieHellman(otherVaultysId.keyManager);\n    }\n    /**\n     * Static method to perform a Diffie-Hellman key exchange between two VaultysId instances\n     * @param vaultysId1 First VaultysId instance\n     * @param vaultysId2 Second VaultysId instance\n     * @returns A shared secret that both parties can derive\n     */\n    static async diffieHellman(vaultysId1, vaultysId2) {\n        return vaultysId1.performDiffieHellman(vaultysId2);\n    }\n    /**\n     * Encrypt a message using DHIES for a recipient\n     * @param message Message to encrypt\n     * @param recipientId Recipient's VaultysId ID\n     * @returns Encrypted message or null if encryption fails\n     */\n    async dhiesEncrypt(message, recipientId) {\n        let cleanId;\n        if (typeof recipientId === \"string\") {\n            cleanId = buffer_1.Buffer.from(recipientId.slice(2), \"hex\");\n        }\n        else {\n            cleanId = recipientId.slice(1);\n        }\n        return this.keyManager.dhiesEncrypt(message, cleanId);\n    }\n    /**\n     * Decrypt a message encrypted with DHIES\n     * @param encryptedMessage Encrypted message from dhiesEncrypt\n     * @returns Decrypted message as Buffer or null if decryption fails\n     */\n    async dhiesDecrypt(encryptedMessage, senderId) {\n        let cleanId;\n        if (typeof senderId === \"string\") {\n            cleanId = buffer_1.Buffer.from(senderId.slice(2), \"hex\");\n        }\n        else {\n            cleanId = senderId.slice(1);\n        }\n        return this.keyManager.dhiesDecrypt(encryptedMessage, cleanId);\n    }\n    async signChallenge(challenge) {\n        if (typeof challenge == \"string\") {\n            challenge = buffer_1.Buffer.from(challenge, \"hex\");\n        }\n        const result = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([this.id, challenge]));\n        const signature = await this.keyManager.sign(result);\n        if (!signature)\n            throw new Error(\"Could not sign challenge\");\n        else\n            return signature;\n    }\n    verifyChallenge(challenge, signature, userVerification) {\n        if (typeof challenge == \"string\") {\n            challenge = buffer_1.Buffer.from(challenge, \"hex\");\n        }\n        if (typeof signature == \"string\") {\n            signature = buffer_1.Buffer.from(signature, \"hex\");\n        }\n        const result = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.concat([this.id, challenge]));\n        return this.keyManager.verify(result, signature, userVerification);\n    }\n    async signcrypt(plaintext, recipientIds) {\n        return this.keyManager.signcrypt(plaintext, recipientIds.map((id) => {\n            if (typeof id === \"string\")\n                return buffer_1.Buffer.from(id.slice(2), \"hex\");\n            else\n                return id.slice(1);\n        }));\n    }\n    static async encrypt(plaintext, recipientIds) {\n        return KeyManager_1.default.encrypt(plaintext, recipientIds.map((id) => {\n            if (typeof id === \"string\")\n                return buffer_1.Buffer.from(id.slice(2), \"hex\");\n            else\n                return id.slice(1);\n        }));\n    }\n    async decrypt(encryptedMessage, senderId) {\n        let cleanId;\n        if (senderId) {\n            if (typeof senderId === \"string\")\n                cleanId = buffer_1.Buffer.from(senderId.slice(2));\n            // @ts-ignore\n            else\n                cleanId = senderId.subarray(1);\n        }\n        return this.keyManager.decrypt(encryptedMessage, cleanId);\n    }\n    async hmac(message) {\n        const cypher = await this.keyManager.getCypher();\n        return cypher.hmac(message);\n    }\n}\nVaultysId.createPublicKeyCredentialOptionsPQC = () => {\n    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);\n    const hint = \"security-key\";\n    const options = {\n        challenge: (0, crypto_1.randomBytes)(32),\n        rp: {\n            name: \"Vaultys ID\",\n        },\n        user: {\n            id: (0, crypto_1.randomBytes)(16),\n            name: \"Vaultys ID\",\n            displayName: \"Vaultys Wallet ID\",\n        },\n        attestation: safari ? \"none\" : \"direct\", // SAFARI Dead, they removed direct attestation\n        authenticatorSelection: {\n            authenticatorAttachment: \"cross-platform\",\n            residentKey: \"discouraged\",\n            userVerification: \"preferred\",\n        },\n        // @ts-ignore not yet in dom types\n        hints: [hint],\n        extensions: {\n            prf: {\n                eval: {\n                    first: buffer_1.Buffer.from(\"VaultysID salt\", \"utf-8\"),\n                },\n            },\n        },\n        pubKeyCredParams: [{ type: \"public-key\", alg: pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 }],\n    };\n    return options;\n};\nVaultysId.createPublicKeyCredentialCreationOptions = (passkey) => {\n    const safari = /^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent);\n    const hint = passkey ? \"client-device\" : \"security-key\";\n    const options = {\n        challenge: (0, crypto_1.randomBytes)(32),\n        rp: {\n            name: \"Vaultys ID\",\n        },\n        user: {\n            id: (0, crypto_1.randomBytes)(16),\n            name: \"Vaultys ID\",\n            displayName: \"Vaultys Wallet ID\",\n        },\n        attestation: safari ? \"none\" : \"direct\", // SAFARI Dead, they removed direct attestation\n        authenticatorSelection: {\n            authenticatorAttachment: passkey ? \"platform\" : \"cross-platform\",\n            residentKey: passkey ? \"required\" : \"discouraged\",\n            userVerification: \"preferred\",\n        },\n        // @ts-ignore not yet in dom types\n        hints: [hint],\n        extensions: {\n            prf: {\n                eval: {\n                    first: buffer_1.Buffer.from(\"VaultysID salt\", \"utf-8\"),\n                },\n            },\n        },\n        pubKeyCredParams: [\n            {\n                type: \"public-key\",\n                alg: -7, // SECP256/ECDSA, Ed25519/EdDSA (-8) not supported natively on mobile or yubikey (crying)\n            },\n            {\n                type: \"public-key\",\n                alg: -8, // Ed25519/EdDSA prefered\n            },\n            {\n                type: \"public-key\",\n                alg: -257, // RS256\n            },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -36\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -37\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -38\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -39\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -258\n            // },\n            // {\n            //   \"type\": \"public-key\",\n            //   \"alg\": -259\n            // }\n        ],\n    };\n    return options;\n};\nexports.default = VaultysId;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.secureErase = exports.fromUTF8 = exports.fromHex = exports.fromBase64 = exports.toUTF8 = exports.toHex = exports.toBase64 = exports.secretbox = exports.randomBytes = exports.hmac = exports.hash = exports.Buffer = void 0;\nconst tweetnacl_1 = __importStar(require(\"tweetnacl\"));\nconst buffer_1 = require(\"buffer/\");\nObject.defineProperty(exports, \"Buffer\", { enumerable: true, get: function () { return buffer_1.Buffer; } });\nconst sha2_1 = require(\"@noble/hashes/sha2\");\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst getAlgorithm = (alg) => {\n    const cleanAlg = alg.replaceAll(\"-\", \"\").toLowerCase();\n    if (cleanAlg === \"sha256\")\n        return sha2_1.sha256;\n    if (cleanAlg === \"sha512\")\n        return sha2_1.sha512;\n    if (cleanAlg === \"sha224\")\n        return sha2_1.sha224;\n    return sha2_1.sha256;\n};\nconst _randomBytes = (size) => buffer_1.Buffer.from((0, tweetnacl_1.randomBytes)(size));\nexports.randomBytes = _randomBytes;\nconst hash = (alg, buffer) => buffer_1.Buffer.from(getAlgorithm(alg).create().update(buffer).digest());\nexports.hash = hash;\nconst _hmac = (alg, key, data) => buffer_1.Buffer.from((0, hmac_1.hmac)(getAlgorithm(alg), key, data));\nexports.hmac = _hmac;\nconst secretbox = tweetnacl_1.default.secretbox;\nexports.secretbox = secretbox;\nconst toBase64 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"base64\");\nexports.toBase64 = toBase64;\nconst toHex = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"hex\");\nexports.toHex = toHex;\nconst toUTF8 = (bufferLike) => buffer_1.Buffer.from(bufferLike).toString(\"utf-8\");\nexports.toUTF8 = toUTF8;\nconst fromBase64 = (string) => buffer_1.Buffer.from(string, \"base64\");\nexports.fromBase64 = fromBase64;\nconst fromHex = (string) => buffer_1.Buffer.from(string, \"hex\");\nexports.fromHex = fromHex;\nconst fromUTF8 = (string) => buffer_1.Buffer.from(string, \"utf-8\");\nexports.fromUTF8 = fromUTF8;\nconst secureErase = (buffer) => {\n    for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = 0;\n    }\n};\nexports.secureErase = secureErase;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = void 0;\nconst crypto_1 = require(\"./crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst newNonce = () => (0, crypto_1.randomBytes)(crypto_1.secretbox.nonceLength);\nconst encrypt = (buffer, key) => {\n    //console.log(\"encrypting: \", buffer, key)\n    const keyUint8Array = key;\n    const nonce = newNonce();\n    const box = (0, crypto_1.secretbox)(Uint8Array.from(buffer), nonce, keyUint8Array);\n    const fullMessage = new Uint8Array(nonce.length + box.length);\n    fullMessage.set(nonce);\n    fullMessage.set(box, nonce.length);\n    return buffer_1.Buffer.from(fullMessage);\n};\nexports.encrypt = encrypt;\nconst decrypt = (messageWithNonce, key) => {\n    //console.log(\"decrypting: \", messageWithNonce, key)\n    const keyUint8Array = key;\n    const messageWithNonceAsUint8Array = messageWithNonce;\n    const nonce = messageWithNonceAsUint8Array.slice(0, crypto_1.secretbox.nonceLength);\n    const message = messageWithNonceAsUint8Array.slice(crypto_1.secretbox.nonceLength, messageWithNonce.length);\n    const decrypted = crypto_1.secretbox.open(message, nonce, keyUint8Array);\n    if (!decrypted) {\n        throw new Error(\"Could not decrypt message\");\n    }\n    return buffer_1.Buffer.from(decrypted);\n};\nexports.decrypt = decrypt;\n// upgrading a channel api with an encrypting layer. The API shoud be\n// - send(Buffer):null\n// - async receive():Buffer\nconst encryptChannel = (channel, key) => {\n    const sendHandler = {\n        apply(target, that, args) {\n            return target.call(that, (0, exports.encrypt)(args[0], key));\n        },\n    };\n    const receiveHandler = {\n        async apply(target, that, args) {\n            const result = await target.call(that);\n            return (0, exports.decrypt)(result, key);\n        },\n    };\n    channel.send = new Proxy(channel.send, sendHandler);\n    channel.receive = new Proxy(channel.receive, receiveHandler);\n    return channel;\n};\nconst generateKey = () => (0, crypto_1.randomBytes)(32);\nexports.default = {\n    decrypt: exports.decrypt,\n    encrypt: exports.encrypt,\n    encryptChannel,\n    generateKey,\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: to revamp and optimize\n// import crypto from \"crypto\";\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"../crypto\");\nconst cbor_1 = __importDefault(require(\"cbor\"));\nconst ed25519_1 = require(\"@noble/curves/ed25519\");\nconst p256_1 = require(\"@noble/curves/p256\");\nconst p384_1 = require(\"@noble/curves/p384\");\nconst p521_1 = require(\"@noble/curves/p521\");\n// import { BasicConstraintsExtension, X509Certificate } from \"@peculiar/x509\";\nconst pqCrypto_1 = require(\"../pqCrypto\");\nconst credentials = {};\n//const subtle = crypto.webcrypto ? crypto.webcrypto.subtle : crypto.subtle;\nconst COSEKEYS = {\n    kty: 1,\n    alg: 3,\n    crv: -1,\n    x: -2,\n    y: -3,\n    n: -1,\n    e: -2,\n};\nconst COSEKTY = {\n    OKP: 1,\n    EC2: 2,\n    RSA: 3,\n    DILITHIUM: pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM,\n};\nconst COSERSASCHEME = {\n    \"-3\": \"pss-sha256\",\n    \"-39\": \"pss-sha512\",\n    \"-38\": \"pss-sha384\",\n    \"-65535\": \"pkcs1-sha1\",\n    \"-257\": \"pkcs1-sha256\",\n    \"-258\": \"pkcs1-sha384\",\n    \"-259\": \"pkcs1-sha512\",\n};\nconst COSECRV = {\n    1: p256_1.p256,\n    2: p384_1.p384,\n    3: p521_1.p521,\n};\nconst COSEALGHASH = {\n    \"-257\": \"SHA-256\",\n    \"-258\": \"SHA-384\",\n    \"-259\": \"SHA-512\",\n    \"-65535\": \"SHA-1\",\n    \"-39\": \"SHA-512\",\n    \"-38\": \"SHA-384\",\n    \"-37\": \"SHA-256\",\n    \"-260\": \"SHA-256\",\n    \"-261\": \"SHA-512\",\n    \"-7\": \"SHA-256\",\n    \"-36\": \"SHA-512\",\n    [pqCrypto_1.PQ_COSE_ALG.DILITHIUM2.toString()]: \"SHA-256\", // DILITHIUM2 uses SHA-256 for hashing\n};\nconst hash = (alg, message) => (0, crypto_1.hash)(alg.replace(\"-\", \"\"), message);\nconst base64ToPem = (b64cert) => {\n    let pemcert = \"\";\n    for (let i = 0; i < b64cert.length; i += 64)\n        pemcert += b64cert.slice(i, i + 64) + \"\\n\";\n    return \"-----BEGIN CERTIFICATE-----\\n\" + pemcert + \"-----END CERTIFICATE-----\";\n};\n// const getCertificateInfo = (certificate: Buffer) => {\n//   const x509 = new X509Certificate(certificate);\n//   const subjectString = x509.subject;\n//   const issuer = x509.issuer;\n//   const issuerName = x509.issuerName.toString();\n//   const subjectParts = subjectString.split(\",\");\n//   const subject: Record<string, string> = {};\n//   for (const field of subjectParts) {\n//     const kv = field.split(\"=\");\n//     subject[kv[0].trim()] = kv[1];\n//   }\n//   // console.log(subject);\n//   const { Version } = x509.toTextObject().Data as unknown as { Version: string };\n//   const bc = x509.getExtension(BasicConstraintsExtension);\n//   const basicConstraintsCA = bc ? bc.ca : false;\n//   return {\n//     issuer,\n//     issuerName,\n//     subject,\n//     version: Version,\n//     basicConstraintsCA,\n//   };\n// };\nconst parseAuthData = (buffer) => {\n    const rpIdHash = buffer.slice(0, 32);\n    buffer = buffer.slice(32);\n    const flagsBuf = buffer.slice(0, 1);\n    buffer = buffer.slice(1);\n    const flagsInt = flagsBuf[0];\n    const flags = {\n        up: !!(flagsInt & 0x01),\n        uv: !!(flagsInt & 0x04),\n        at: !!(flagsInt & 0x40),\n        ed: !!(flagsInt & 0x80),\n        flagsInt,\n    };\n    const counterBuf = buffer.slice(0, 4);\n    buffer = buffer.slice(4);\n    const counter = counterBuf.readUInt32BE(0);\n    let aaguid = undefined;\n    let credID = undefined;\n    let COSEPublicKey = undefined;\n    if (flags.at) {\n        aaguid = buffer.slice(0, 16);\n        buffer = buffer.slice(16);\n        const credIDLenBuf = buffer.slice(0, 2);\n        buffer = buffer.slice(2);\n        const credIDLen = credIDLenBuf.readUInt16BE(0);\n        credID = buffer.slice(0, credIDLen);\n        buffer = buffer.slice(credIDLen);\n        COSEPublicKey = buffer;\n    }\n    //console.log(aaguid);\n    return {\n        rpIdHash,\n        flagsBuf,\n        flags,\n        counter,\n        counterBuf,\n        aaguid,\n        credID,\n        COSEPublicKey,\n    };\n};\nconst verifyPackedAttestation = (response, userVerification = false) => {\n    const attestationBuffer = buffer_1.Buffer.from(response.attestationObject);\n    const attestationStruct = cbor_1.default.decodeAllSync(attestationBuffer)[0];\n    if (attestationStruct.fmt == \"none\")\n        return false;\n    const authDataStruct = parseAuthData(attestationStruct.authData);\n    // check if user has actually touched the device\n    if (!authDataStruct.flags.up)\n        return false;\n    // check if did enter PIN code\n    if (userVerification && !authDataStruct.flags.uv)\n        return false;\n    const clientDataHashBuf = hash(\"sha256\", buffer_1.Buffer.from(response.clientDataJSON));\n    const dataBuffer = buffer_1.Buffer.concat([attestationStruct.authData, clientDataHashBuf]);\n    const signature = attestationStruct.attStmt.sig;\n    let signatureIsValid = false;\n    /* ----- Verify FULL attestation ----- */\n    // if (attestationStruct.attStmt.x5c) {\n    //   const leafCert = base64ToPem(attestationStruct.attStmt.x5c[0].toString(\"base64\"));\n    //   const certInfo = getCertificateInfo(attestationStruct.attStmt.x5c[0]);\n    //   const subject = certInfo.subject as {\n    //     OU: string;\n    //     O: string;\n    //     C: string;\n    //     CN: string;\n    //   };\n    //   // console.log(certInfo);\n    //   if (subject.OU !== \"Authenticator Attestation\") throw new Error('Batch certificate OU MUST be set strictly to \"Authenticator Attestation\"!');\n    //   if (!subject.CN) throw new Error(\"Batch certificate CN MUST no be empty!\");\n    //   if (!subject.O) throw new Error(\"Batch certificate O MUST no be empty!\");\n    //   if (!subject.C || subject.C.length !== 2) throw new Error(\"Batch certificate C MUST be set to two character ISO 3166 code!\");\n    //   if (certInfo.basicConstraintsCA) throw new Error(\"Batch certificate basic constraints CA MUST be false!\");\n    //   if (certInfo.version !== \"v3 (2)\") throw new Error(\"Batch certificate version MUST be 3(ASN1 2)!\");\n    //   signatureIsValid = crypto.createVerify(\"sha256\").update(dataBuffer).verify(leafCert, signature);\n    //   /* ----- Verify FULL attestation ENDS ----- */\n    // } else\n    if (attestationStruct.attStmt.ecdaaKeyId) {\n        throw new Error(\"ECDAA IS NOT SUPPORTED!\");\n    }\n    else {\n        /* ----- Verify SURROGATE attestation ----- */\n        const pubKeyCose = cbor_1.default.decodeAllSync(authDataStruct.COSEPublicKey)[0];\n        const hashAlg = COSEALGHASH[pubKeyCose.get(COSEKEYS.alg)];\n        const data = hash(hashAlg, dataBuffer);\n        if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.EC2) {\n            // ECDSA\n            const x = pubKeyCose.get(COSEKEYS.x);\n            const y = pubKeyCose.get(COSEKEYS.y);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([0x04]), x, y]);\n            const ec = COSECRV[pubKeyCose.get(COSEKEYS.crv)];\n            const sig = ec.Signature.fromDER(signature);\n            signatureIsValid = ec.verify(sig, data, pubKey);\n        }\n        else if (pubKeyCose.get(COSEKEYS.kty) === COSEKTY.OKP) {\n            // EdDSA\n            const x = pubKeyCose.get(COSEKEYS.x);\n            signatureIsValid = ed25519_1.ed25519.verify(signature, data, x);\n        }\n        else {\n            return false;\n        }\n        /* ----- Verify SURROGATE attestation ENDS ----- */\n    }\n    if (!signatureIsValid)\n        throw new Error(\"Failed to verify the signature!\");\n    return true;\n};\nclass MyPublicKeyCredential {\n    constructor(creds) {\n        this.type = \"public-key\";\n        this.clientExtensionResults = {};\n        const keys = [\"id\", \"rawId\", \"response\"];\n        this.id = creds.id;\n        this.rawId = buffer_1.Buffer.from(creds.rawId);\n        this.response = creds.response;\n    }\n    getClientExtensionResults() {\n        return {};\n    }\n}\nconst verifyECDSA = (data, publicKey, signature) => {\n    return p256_1.p256.verify(p256_1.p256.Signature.fromDER(signature).toCompactHex(), data, publicKey);\n};\nconst verifyEdDSA = (data, publicKey, signature) => {\n    return ed25519_1.ed25519.verify(signature, data, publicKey);\n};\n// Webauthn Partial Implementation for testing\nclass SoftCredentials {\n    constructor() {\n        this.signCount = 0;\n        this.rawId = (0, crypto_1.randomBytes)(32);\n        this.aaguid = buffer_1.Buffer.alloc(16);\n    }\n    // credentials request payload\n    static createRequest(alg, prf = false) {\n        const challenge = buffer_1.Buffer.from((0, crypto_1.randomBytes)(32).toString(\"base64\"));\n        const result = {\n            publicKey: {\n                challenge,\n                rp: {\n                    name: \"Vaultys ID\",\n                    id: \"Vaultys ID\",\n                },\n                user: {\n                    id: buffer_1.Buffer.from(\"Vaultys Wallet ID\", \"utf8\"),\n                    name: \"Vaultys Wallet ID\",\n                    displayName: \"Vaultys Wallet ID\",\n                },\n                pubKeyCredParams: [\n                    {\n                        type: \"public-key\",\n                        alg,\n                    },\n                ],\n            },\n        };\n        if (prf) {\n            result.publicKey.extensions = { prf: { eval: { first: (0, crypto_1.randomBytes)(32) } } };\n        }\n        return result;\n    }\n    // static getCertificateInfo(response: AuthenticatorAttestationResponse) {\n    //   const attestationBuffer = Buffer.from(response.attestationObject);\n    //   const attestationStruct = cbor.decodeAllSync(attestationBuffer)[0];\n    //   if (attestationStruct.attStmt.x5c) {\n    //     return getCertificateInfo(attestationStruct.attStmt.x5c[0]);\n    //   } else {\n    //     return null;\n    //   }\n    // }\n    static async create(options, origin = \"test\") {\n        const credential = new SoftCredentials();\n        const publicKey = options.publicKey;\n        credential.options = publicKey;\n        credential.rpId = publicKey.rp.id || publicKey.rp.name;\n        credential.userHandle = buffer_1.Buffer.from(publicKey.user.id.toString(), \"base64\");\n        credentials[credential.rawId.toString(\"base64\")] = credential; // erase previous instance\n        // Get the algorithm from pubKeyCredParams\n        const pubKeyCredParams = publicKey.pubKeyCredParams;\n        // Check if DILITHIUM is supported (look for PQ_COSE_ALG.DILITHIUM2 in the params)\n        const supportsDilithium = pubKeyCredParams.some((param) => param.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);\n        // Set algorithm, prioritizing DILITHIUM if it's supported\n        if (supportsDilithium) {\n            credential.alg = pqCrypto_1.PQ_COSE_ALG.DILITHIUM2;\n        }\n        else {\n            credential.alg = publicKey.pubKeyCredParams[0].alg;\n        }\n        if (credential.alg === -8) {\n            const random = ed25519_1.ed25519.utils.randomPrivateKey();\n            credential.keyPair = {\n                privateKey: random,\n                publicKey: ed25519_1.ed25519.getPublicKey(random),\n                algorithm: \"EdDSA\",\n            };\n            credential.coseKey = new Map();\n            credential.coseKey.set(1, 1);\n            credential.coseKey.set(3, -8);\n            credential.coseKey.set(-1, 6);\n            const x = credential.keyPair.publicKey.slice(0, 32);\n            credential.coseKey.set(-2, x);\n        }\n        else if (credential.alg === -7) {\n            const random = p256_1.p256.utils.randomPrivateKey();\n            credential.keyPair = {\n                privateKey: random,\n                publicKey: p256_1.p256.getPublicKey(random, false),\n                algorithm: \"ES256\",\n            };\n            credential.coseKey = new Map();\n            credential.coseKey.set(1, 2);\n            credential.coseKey.set(3, -7);\n            credential.coseKey.set(-1, 6);\n            const x = credential.keyPair.publicKey.slice(1, 33);\n            const y = credential.keyPair.publicKey.slice(33);\n            credential.coseKey.set(-2, x);\n            credential.coseKey.set(-3, y);\n            // console.log(extpk,x,y)\n        }\n        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {\n            // Generate DILITHIUM key pair\n            const { publicKey: dilithiumPk, secretKey: dilithiumSk } = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            //console.log(\"PQC\", dilithiumPk, dilithiumSk);\n            credential.keyPair = {\n                privateKey: dilithiumSk,\n                publicKey: dilithiumPk,\n                algorithm: \"DILITHIUM2\",\n                isDILITHIUM: true,\n            };\n            // Create COSE key representation\n            credential.coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(dilithiumPk);\n            //console.log(\"PQC\", credential);\n        }\n        const clientData = {\n            type: \"webauthn.create\",\n            challenge: publicKey.challenge,\n            origin,\n        };\n        const rpIdHash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(credential.rpId, \"ascii\"));\n        const flags = buffer_1.Buffer.from(\"41\", \"hex\"); // attested_data + user_present\n        const signCount = buffer_1.Buffer.allocUnsafe(4);\n        signCount.writeUInt32BE(credential.signCount, 0);\n        const rawIdLength = buffer_1.Buffer.allocUnsafe(2);\n        rawIdLength.writeUInt16BE(credential.rawId.length, 0);\n        const coseKey = cbor_1.default.encode(credential.coseKey);\n        const attestationObject = {\n            authData: buffer_1.Buffer.concat([rpIdHash, flags, signCount, credential.aaguid, rawIdLength, credential.rawId, coseKey]),\n            fmt: \"none\",\n            attStmt: {},\n        };\n        const pkCredentials = {\n            id: credential.rawId.toString(\"base64\"),\n            rawId: credential.rawId,\n            authenticatorAttachment: null,\n            type: \"public-key\",\n            getClientExtensionResults: () => {\n                if (publicKey.extensions?.prf?.eval?.first) {\n                    return { prf: { enabled: true } };\n                }\n                else {\n                    return {};\n                }\n            },\n            toJSON() { },\n            response: {\n                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), \"utf-8\"),\n                attestationObject: cbor_1.default.encode(attestationObject),\n                getTransports: () => [\"usb\", \"hybrid\"],\n                getAuthenticatorData: () => attestationObject.authData,\n                getPublicKey: () => coseKey,\n                getPublicKeyAlgorithm: () => -7,\n            },\n        };\n        return pkCredentials;\n    }\n    static simpleVerify(COSEPublicKey, response, userVerification = false) {\n        const ckey = cbor_1.default.decode(COSEPublicKey, { extendedResults: true }).value;\n        const rpIdHash = response.authenticatorData.slice(0, 32);\n        const flagsInt = buffer_1.Buffer.from(response.authenticatorData)[32];\n        const counter = response.authenticatorData.slice(33, 37);\n        const goodflags = userVerification ? !!(flagsInt & 0x04) : !!(flagsInt & 0x01);\n        if (!goodflags)\n            return false;\n        const hash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(response.clientDataJSON));\n        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(response.authenticatorData), hash]);\n        if (ckey.get(3) == -7) {\n            data = (0, crypto_1.hash)(\"sha256\", data);\n        }\n        if (ckey.get(1) == 1) {\n            // EdDSA\n            const x = ckey.get(-2);\n            return verifyEdDSA(data, x, buffer_1.Buffer.from(response.signature));\n        }\n        else if (ckey.get(1) == 2) {\n            // ECDSA\n            const x = ckey.get(-2);\n            const y = ckey.get(-3);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), x, y]);\n            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(response.signature));\n        }\n        else if (ckey.get(1) === COSEKTY.DILITHIUM) {\n            // DILITHIUM\n            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);\n            // Verify DILITHIUM signature asynchronously\n            //console.log(data, publicKey, Buffer.from(response.signature));\n            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(response.signature), publicKey);\n        }\n        return false;\n    }\n    static getCOSEPublicKey(attestation) {\n        const response = attestation.response;\n        const ato = cbor_1.default.decode(response.attestationObject);\n        //console.log(\"getCOSEPublicKey\", ato, parseAuthData(ato.authData));\n        return parseAuthData(ato.authData).COSEPublicKey;\n    }\n    static verifyPackedAttestation(attestation, userVerification = false) {\n        return verifyPackedAttestation(attestation, userVerification);\n    }\n    static async verify(attestation, assertion, userVerifiation = false) {\n        //if (assertion.id !== attestation.id) return false;\n        const hash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(assertion.response.clientDataJSON));\n        const ass = assertion.response;\n        const att = attestation.response;\n        let data = buffer_1.Buffer.concat([buffer_1.Buffer.from(ass.authenticatorData), hash]);\n        const ato = cbor_1.default.decode(att.attestationObject);\n        const authData = parseAuthData(ato.authData);\n        // check if user has actually touched the device\n        if (!authData.flags.up)\n            return false;\n        // check if the user has entered his PIN code or used biometric sensor\n        if ((userVerifiation && !authData.flags.uv) || !authData.COSEPublicKey)\n            return false;\n        const ckey = cbor_1.default.decode(authData.COSEPublicKey);\n        // Hash data for ES256\n        if (ckey.get(3) == -7) {\n            data = (0, crypto_1.hash)(\"sha256\", data);\n        }\n        // Get key type\n        const keyType = ckey.get(1);\n        if (keyType === 1) {\n            // EdDSA\n            const x = ckey.get(-2);\n            return verifyEdDSA(data, x, buffer_1.Buffer.from(ass.signature));\n        }\n        else if (keyType === 2) {\n            // ECDSA\n            const x = ckey.get(-2);\n            const y = ckey.get(-3);\n            const pubKey = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"04\", \"hex\"), x, y]);\n            return verifyECDSA(data, pubKey, buffer_1.Buffer.from(ass.signature));\n        }\n        else if (keyType === COSEKTY.DILITHIUM) {\n            // DILITHIUM\n            const publicKey = ckey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK);\n            // Verify DILITHIUM signature asynchronously\n            //console.log(data, publicKey, Buffer.from(ass.signature));\n            return (0, pqCrypto_1.verifyDilithium)(data, buffer_1.Buffer.from(ass.signature), publicKey);\n        }\n        return false;\n    }\n    static extractChallenge(clientDataJSON) {\n        const clientData = JSON.parse(clientDataJSON.toString());\n        const m = clientData.challenge.length % 4;\n        return clientData.challenge\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(clientData.challenge.length + (m === 0 ? 0 : 4 - m), \"=\");\n    }\n    static async get({ publicKey }, origin = \"test\") {\n        if (!publicKey.allowCredentials)\n            throw new Error();\n        const id = buffer_1.Buffer.from(publicKey.allowCredentials[0].id).toString(\"base64\");\n        const credential = credentials[id];\n        credential.signCount += 1;\n        // prepare signature\n        const clientData = {\n            type: \"webauthn.get\",\n            challenge: buffer_1.Buffer.from(publicKey.challenge).toString(\"base64\"),\n            origin,\n        };\n        const clientDataHash = (0, crypto_1.hash)(\"sha256\", (0, crypto_1.fromUTF8)(JSON.stringify(clientData)));\n        const rpIdHash = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(credential.rpId, \"utf-8\"));\n        const flags = buffer_1.Buffer.from(\"05\", \"hex\"); // user verification\n        const signCount = buffer_1.Buffer.allocUnsafe(4);\n        signCount.writeUInt32BE(credential.signCount, 0);\n        const authenticatorData = buffer_1.Buffer.concat([rpIdHash, flags, signCount]);\n        const toSign = buffer_1.Buffer.concat([authenticatorData, clientDataHash]);\n        let signature = new Uint8Array();\n        if (credential.alg === -7) {\n            signature = p256_1.p256.sign(toSign, credential.keyPair.privateKey, { prehash: true }).toDERRawBytes();\n        }\n        else if (credential.alg === -8) {\n            signature = ed25519_1.ed25519.sign(toSign, credential.keyPair.privateKey);\n        }\n        else if (credential.alg === pqCrypto_1.PQ_COSE_ALG.DILITHIUM2) {\n            // DILITHIUM signing - this returns a Promise so we need to await it\n            signature = (0, pqCrypto_1.signDilithium)(toSign, credential.keyPair.privateKey);\n        }\n        const pkCredentials = {\n            id,\n            rawId: buffer_1.Buffer.from(id, \"base64\").buffer,\n            type: \"public-key\",\n            authenticatorAttachment: null,\n            getClientExtensionResults: () => {\n                if (publicKey.extensions?.prf?.eval?.first) {\n                    // unsafe and not following w3c recommendation. for testing purpose only\n                    return { prf: { results: { first: hash(\"sha256\", publicKey.extensions?.prf?.eval?.first) } } };\n                }\n                else {\n                    return {};\n                }\n            },\n            toJSON() { },\n            response: {\n                authenticatorData,\n                clientDataJSON: buffer_1.Buffer.from(JSON.stringify(clientData), \"utf-8\"),\n                signature: signature,\n                userHandle: credential.userHandle,\n            },\n        };\n        return pkCredentials;\n    }\n}\nexports.default = SoftCredentials;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeWebAuthn = exports.BrowserWebAuthn = void 0;\nexports.getWebAuthnProvider = getWebAuthnProvider;\nexports.createCredentialRequest = createCredentialRequest;\nconst SoftCredentials_1 = __importDefault(require(\"./SoftCredentials\"));\n// Browser implementation\nclass BrowserWebAuthn {\n    isAvailable() {\n        return typeof window !== \"undefined\" && typeof window.PublicKeyCredential !== \"undefined\";\n    }\n    async create(options) {\n        if (!this.isAvailable()) {\n            throw new Error(\"WebAuthn is not available in this environment\");\n        }\n        return (await navigator.credentials.create({ publicKey: options }));\n    }\n    async get(options) {\n        if (!this.isAvailable()) {\n            throw new Error(\"WebAuthn is not available in this environment\");\n        }\n        return (await navigator.credentials.get({ publicKey: options }));\n    }\n}\nexports.BrowserWebAuthn = BrowserWebAuthn;\n// Node.js implementation using SoftCredentials\nclass NodeWebAuthn {\n    constructor(origin = \"test\") {\n        this.origin = origin;\n    }\n    isAvailable() {\n        return true; // Always available in mock mode\n    }\n    async create(options) {\n        return await SoftCredentials_1.default.create({\n            publicKey: options,\n        }, this.origin);\n    }\n    async get(options) {\n        return await SoftCredentials_1.default.get({\n            publicKey: options,\n        }, this.origin);\n    }\n}\nexports.NodeWebAuthn = NodeWebAuthn;\n// Factory function\nfunction getWebAuthnProvider(options) {\n    if (typeof window !== \"undefined\") {\n        return new BrowserWebAuthn();\n    }\n    return new NodeWebAuthn(options?.origin);\n}\n// Helper to create credential request\nfunction createCredentialRequest(alg, prf = false) {\n    return SoftCredentials_1.default.createRequest(alg, prf);\n}\n","\"use strict\";\n/**\n * Post-Quantum Cryptography Operations\n *\n * This file contains implementations for post-quantum cryptographic algorithms\n * starting with DILITHIUM for digital signatures.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PQ_COSE_KEY_PARAMS = exports.PQ_COSE_KEY_TYPE = exports.PQ_COSE_ALG = void 0;\nexports.generateDilithiumKeyPair = generateDilithiumKeyPair;\nexports.signDilithium = signDilithium;\nexports.verifyDilithium = verifyDilithium;\nexports.createDilithiumCoseKey = createDilithiumCoseKey;\nexports.getDilithiumKeyInfo = getDilithiumKeyInfo;\nconst ml_dsa_js_1 = require(\"@noble/post-quantum/ml-dsa.js\");\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"./crypto\");\n/**\n * COSE algorithm identifiers for post-quantum algorithms\n * Note: These values are provisional and may need to be updated as standards evolve\n */\nexports.PQ_COSE_ALG = {\n    // DILITHIUM variants (using negative values as per COSE convention for new algorithms)\n    DILITHIUM2: -46, // Level 2 (128-bit security)\n    DILITHIUM3: -47, // Level 3 (192-bit security)\n    DILITHIUM5: -48, // Level 5 (256-bit security)\n};\n/**\n * COSE key type for DILITHIUM\n */\nexports.PQ_COSE_KEY_TYPE = {\n    DILITHIUM: 4, // Custom key type for DILITHIUM\n};\n/**\n * COSE key parameter identifiers for DILITHIUM\n */\nexports.PQ_COSE_KEY_PARAMS = {\n    DILITHIUM_MODE: -100, // Mode parameter (2, 3, or 5)\n    DILITHIUM_PK: -101, // Public key\n    DILITHIUM_SK: -102, // Secret key\n};\n/**\n * Generate a DILITHIUM Level 2 key pair\n * @returns Promise resolving to an object containing the key pair\n */\nfunction generateDilithiumKeyPair(seed) {\n    if (!seed)\n        seed = (0, crypto_1.randomBytes)(32);\n    const keyPair = ml_dsa_js_1.ml_dsa65.keygen(seed);\n    return {\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey),\n        secretKey: buffer_1.Buffer.from(keyPair.secretKey),\n    };\n}\n/**\n * Sign a message using DILITHIUM Level 2\n * @param message - The message to sign\n * @param privateKey - The DILITHIUM private key\n * @returns Promise resolving to signature as Uint8Array\n */\nfunction signDilithium(message, secretKey) {\n    return buffer_1.Buffer.from(ml_dsa_js_1.ml_dsa65.sign(secretKey, message));\n}\n/**\n * Verify a DILITHIUM Level 2 signature\n * @param message - The original message\n * @param signature - The signature to verify\n * @param publicKey - The DILITHIUM public key\n * @returns Promise resolving to boolean indicating if signature is valid\n */\nfunction verifyDilithium(message, signature, publicKey) {\n    return ml_dsa_js_1.ml_dsa65.verify(publicKey, message, signature);\n}\n/**\n * Create a COSE key representation for a DILITHIUM public key\n * @param publicKey - The DILITHIUM public key\n * @returns Map representing the COSE key\n */\nfunction createDilithiumCoseKey(publicKey) {\n    const coseKey = new Map();\n    // Standard COSE key parameters\n    coseKey.set(1, exports.PQ_COSE_KEY_TYPE.DILITHIUM); // kty: Key Type\n    coseKey.set(3, exports.PQ_COSE_ALG.DILITHIUM2); // alg: Algorithm\n    // DILITHIUM-specific parameters\n    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, 2); // Level 2\n    coseKey.set(exports.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, publicKey);\n    return coseKey;\n}\n/**\n * Get key size information for DILITHIUM\n * @returns Object with key size information\n */\nfunction getDilithiumKeyInfo() {\n    return {\n        publicKeySize: 1952, // Size in bytes for DILITHIUM2 public key\n        secretKeySize: 4032, // Size in bytes for DILITHIUM2 private key\n        signatureSize: 3309, // Size in bytes for DILITHIUM2 signature\n    };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst __1 = require(\"../\");\nconst buffer_1 = require(\"buffer/\");\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst crypto_1 = require(\"../src/crypto\");\nconst utils_1 = require(\"./utils\");\nconst testCertificate = (rogueCert) => {\n    try {\n        const result = __1.Challenger.deserializeCertificate(rogueCert);\n        return result;\n    }\n    catch (error) {\n        return {\n            state: -2,\n        };\n    }\n};\nconst delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));\nconst challengeNext = async (vaultysId, newCertificate, oldCertificate) => {\n    //console.log(newCertificate, oldCertificate);\n    const challenger = new __1.Challenger(vaultysId);\n    challenger.version = 1;\n    if (oldCertificate) {\n        await challenger.init(oldCertificate);\n    }\n    else if (!newCertificate) {\n        challenger.createChallenge(\"p2p\", \"test\", 1);\n    }\n    if (newCertificate)\n        await challenger.update(newCertificate);\n    return challenger.getCertificate();\n};\ndescribe(\"Symetric Proof of Relationship - SRG - v1\", () => {\n    it(\"Perform Protocol\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 1);\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(!challenger2.isComplete());\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 2);\n        // SYMETRIC PROOF\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Perform Protocol downgrading to v0\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 0);\n        //console.log(challenger1.challenge);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 1);\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(!challenger2.isComplete());\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 2);\n        // SYMETRIC PROOF\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Perform Stateless Protocol\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const init = await challengeNext(vaultysId1);\n        // console.log(\"init\", Challenger.deserializeCertificate(init));\n        const step1 = await challengeNext(vaultysId2, init);\n        // console.log(\"step1\", Challenger.deserializeCertificate(step1));\n        const complete = await challengeNext(vaultysId1, step1);\n        // console.log(\"complete\", Challenger.deserializeCertificate(complete));\n        const finalise = await challengeNext(vaultysId2, complete, step1);\n        assert_1.default.equal(complete.toString(\"base64\"), finalise.toString(\"base64\"));\n    });\n    it(\"Perform Protocol attacking protocol\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.protocol = \"hack\";\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        // console.log(challengerattack.challenge);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking service\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.service = \"hack\";\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        // console.log(challengerattack.challenge);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking nonce\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        // console.log(challengerattack.challenge);\n        // console.log(\"boom\");\n        await challenger2.update(challengerattack.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Nonce has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking timestamp\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        await delay(2); //new timestamp might be the same!\n        challengerattack.challenge.timestamp = Date.now();\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Timestamp has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered timestamp should have failed\");\n    });\n    it(\"Perform Protocol attacking with legit but different certificate\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await challenger2.update(challenger1.getCertificate());\n        const challenger3 = new __1.Challenger(vaultysId1);\n        const challenger4 = new __1.Challenger(vaultysId2);\n        challenger3.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger4.update(challenger3.getCertificate());\n        await challenger3.update(challenger4.getCertificate());\n        try {\n            await challenger4.update(challenger1.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Nonce has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered legit certificate should have failed\");\n    });\n    it(\"Fail for liveliness at first round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 50);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 50);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await delay(100);\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Fail for liveliness at second round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 50);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 50);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger2.update(challenger1.getCertificate());\n        await delay(100);\n        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Pass for liveliness at third round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 500);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 500);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await delay(200);\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Pass with time deviation of 59s in the future\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        if (!challenger1.challenge)\n            assert_1.default.fail();\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Pass with time deviation of 59s in the past\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        if (!challenger1.challenge)\n            assert_1.default.fail();\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Fail with time deviation of 60s in the future\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Fail with time deviation of 60s in the past\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    /*\n    it(\"Fail with tampered certificate (FIDO2)\", async () => {\n      const attestation1 = await navigator.credentials.create(\n        SoftCredentials.createRequest(-7),\n      );\n      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);\n      const challenger1 = new Challenger(vaultysId1);\n  \n      const attestation2 = await navigator.credentials.create(\n        SoftCredentials.createRequest(-8),\n      );\n      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"interesting\", \"stuff\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1\n        const t = testCertificate(rogueCert);\n        assert.notEqual(t.state, 2);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n  \n    it(\"Fail with tampered certificate all possibilities (FIDO2)\", async () => {\n      const vaultysId1 = await VaultysId.generateMachine();\n      const challenger1 = new Challenger(vaultysId1);\n      const vaultysId2 = await VaultysId.generateMachine();\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"interesting\", \"stuff\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        // TODO fix this malleability for\n        // timestampDS_ a974696d657374616d70cf000001884453195fa3\n        // timestampDS_ a974696d657374616d70d3000001884453195fa3\n        // or use another serialisation for identifying certificate.\n        if(i != 46 && i != rogueCert.length - 1) {\n          for(let j = 0; j < 256; j++){\n            if(j != back) {\n              rogueCert[i] = j;\n              const t = testCertificate(rogueCert);\n              if(t.state == 2) {\n                console.log(i, j, t);\n                console.log(\n                  Buffer.from(rogueCert).toString(\"utf-8\").slice(i-10, i+10),\n                  Buffer.from(rogueCert).toString(\"hex\").slice(i*2-20, i*2+20),\n                  Buffer.from(challenger2.getCertificate()).toString(\"utf-8\").slice(i-10, i+10),\n                  Buffer.from(challenger2.getCertificate()).toString(\"hex\").slice(i*2-20, i*2+20)\n                );\n              }\n              assert.notEqual(t.state, 2);\n            }\n          }\n        }\n        console.log(i, rogueCert.length);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n  \n    it(\"Fail with tampered certificate\", async () => {\n      const vaultysId1 = await VaultysId.generateMachine();\n      const challenger1 = new Challenger(vaultysId1);\n      const vaultysId2 = await VaultysId.generateMachine();\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"random\", \"test\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1\n        const t = testCertificate(rogueCert);\n        assert.notEqual(t.state, 2);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n    */\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst __1 = require(\"../\");\nconst buffer_1 = require(\"buffer/\");\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst crypto_1 = require(\"../src/crypto\");\nconst utils_1 = require(\"./utils\");\nconst cryptoChannel_1 = require(\"../src/cryptoChannel\");\nconst delay = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));\nconst challengeNext = async (vaultysId, newCertificate, oldCertificate) => {\n    //console.log(newCertificate, oldCertificate);\n    const challenger = new __1.Challenger(vaultysId);\n    challenger.version = 0;\n    if (oldCertificate) {\n        await challenger.init(oldCertificate);\n    }\n    else if (!newCertificate) {\n        challenger.createChallenge(\"p2p\", \"test\", 0);\n    }\n    if (newCertificate)\n        await challenger.update(newCertificate);\n    return challenger.getCertificate();\n};\ndescribe(\"Symetric Proof of Relationship - SRG - v0\", () => {\n    it(\"Perform Protocol\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 1);\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(!challenger2.isComplete());\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.equal(challenger1.state, 2);\n        assert_1.default.equal(challenger2.state, 2);\n        // SYMETRIC PROOF\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Perform Stateless Protocol\", async () => {\n        for (let i = 0; i < 10; i++) {\n            const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n            const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n            const init = await challengeNext(vaultysId1);\n            // console.log(\"init\", Challenger.deserializeCertificate(init));\n            const step1 = await challengeNext(vaultysId2, init);\n            // console.log(\"step1\", Challenger.deserializeCertificate(step1));\n            const complete = await challengeNext(vaultysId1, step1);\n            // console.log(\"complete\", Challenger.deserializeCertificate(complete));\n            const finalise = await challengeNext(vaultysId2, complete, step1);\n            assert_1.default.equal(complete.toString(\"base64\"), finalise.toString(\"base64\"));\n        }\n    });\n    it(\"Perform Protocol attacking protocol\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.protocol = \"hack\";\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        // console.log(challengerattack.challenge);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"The challenge was expecting protocol 'p2p' and service 'auth', received 'hack' and 'auth'\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking service\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.service = \"hack\";\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        // console.log(challengerattack.challenge);\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"The challenge was expecting protocol 'p2p' and service 'auth', received 'p2p' and 'hack'\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking nonce\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        challengerattack.challenge.nonce = (0, crypto_1.randomBytes)(16);\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        // console.log(challengerattack.challenge);\n        // console.log(\"boom\");\n        await challenger2.update(challengerattack.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Nonce has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered nonce should have failed\");\n    });\n    it(\"Perform Protocol attacking timestamp\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        await delay(2); //new timestamp might be the same!\n        challengerattack.challenge.timestamp = Date.now();\n        delete challengerattack.challenge?.pk2;\n        delete challengerattack.challenge?.sign2;\n        challengerattack.challenge.nonce = buffer_1.Buffer.from(challengerattack.challenge.nonce.subarray(0, 16));\n        await challenger2.update(challengerattack.getCertificate());\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, 1);\n        try {\n            await challenger1.update(challenger2.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Timestamp has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered timestamp should have failed\");\n    });\n    it(\"Perform Protocol attacking version\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        const challengerattack = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        assert_1.default.equal(challenger1.state, 0);\n        assert_1.default.equal(challenger2.state, -1);\n        await challengerattack.setChallenge(challenger1.getCertificate());\n        await delay(2); //new timestamp might be the same!\n        challengerattack.version = challengerattack.version ? 1 : 0;\n        challengerattack.challenge.version = challengerattack.challenge.version ? 1 : 0;\n        try {\n            await challenger2.update(challengerattack.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"challenge is not corresponding to the right id\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered version should have failed\");\n    });\n    it(\"Perform Protocol attacking with legit but different certificate\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await challenger2.update(challenger1.getCertificate());\n        const challenger3 = new __1.Challenger(vaultysId1);\n        const challenger4 = new __1.Challenger(vaultysId2);\n        challenger3.createChallenge(\"p2p\", \"auth\");\n        await challenger4.update(challenger3.getCertificate());\n        await challenger3.update(challenger4.getCertificate());\n        try {\n            await challenger4.update(challenger1.getCertificate());\n        }\n        catch (err) {\n            assert_1.default.equal(err?.message, \"Nonce has been tampered with\");\n            return;\n        }\n        assert_1.default.fail(\"The protocol with tampered legit certificate should have failed\");\n    });\n    it(\"Fail for liveliness at first round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 50);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 50);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        await delay(100);\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Fail for liveliness at second round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 50);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 50);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        await challenger2.update(challenger1.getCertificate());\n        await delay(100);\n        await assert_1.default.rejects(challenger1.update(challenger2.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Pass for liveliness at third round\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1, 500);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2, 500);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await delay(20);\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Pass with time deviation of 59s in the future\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        if (!challenger1.challenge)\n            assert_1.default.fail();\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 59000;\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Pass with time deviation of 59s in the past\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        if (!challenger1.challenge)\n            assert_1.default.fail();\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 59000;\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        await challenger2.update(challenger1.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Fail with time deviation of 60s in the future\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp + 60001;\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Fail with time deviation of 60s in the past\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\");\n        challenger1.challenge.timestamp = challenger1.challenge.timestamp - 60000;\n        await assert_1.default.rejects(challenger2.update(challenger1.getCertificate()), {\n            name: \"Error\",\n            message: \"challenge timestamp failed the liveliness\",\n        });\n    });\n    it(\"Should deserialize a succesful v0 certificate\", async () => {\n        const cert = \"iahwcm90b2NvbKNwMnCnc2VydmljZahyZWdpc3Rlcql0aW1lc3RhbXDPAAABko9gLwijcGsxxHQBhKF2AKFwxQAgthOolbL2HWtbnAkuAyLHAjfbnS8njgLhHlxWlosbC6uheMUAIBXMRt4jV1gxWK5/TF1jNx0kD+v2qKTWFnfEDQsrOeIvoWXFACCwkdnz8o6yhL86amqfB4/nUoznXnmSs9wAIIT30iGhaaNwazLEdACEoXYAoXDFACARZg0feo56ckkSEU8xc0G/xCH5vjeLeQjP9/KtRC4X76F4xQAg9qbrfdWleMqBsN8y7qPmZ1/ObCqFxeQmIopZBwJGfa2hZcUAIHKiC8fHbhLl902mhMbl/h04JvVnWLBCyAGb22orn5dVpW5vbmNlxCAofLkkt7f/YFen3ve05OcpDl8AFJRnejfZbMC6q37gOqVzaWduMcRAby4aZAta/aZL/8NxtqX8NnDUMTfXZ44qEdW5QVl3Gp/nh7sNDtdJfpF3XdJ1bJ7FtinGDDtTkRCzW5Hm9S+EAqVzaWduMsRA0xyketeALY1yA/KbPo7gTWTGdBVyxmG4u60kQJ2WtTDdjhVnCVzlb56xZtWhtGX/DJxw43yEehPyPxI/HvgwB6htZXRhZGF0YYA=\";\n        const result = __1.Challenger.deserializeCertificate(buffer_1.Buffer.from(cert, \"base64\"));\n        assert_1.default.equal(result.error, \"\");\n        assert_1.default.equal(result.state, 2);\n    });\n    it(\"Should deserialize a succesful v0 certificate 2\", async () => {\n        const message = \"QNGwy7yyIskbWees8qH39YHp6QpODl4Gsp970YFp3j+VjWbU2j1wAw7qLMWk0Ra0YeE6mVcENvohrXRfGdcM763qrYTgpFj72+jznW6szC+XxvDFkwCm9tba/qj6H+wpoDKphscI7UzJ8J1RoKytcLl3yg5BF6ikoJW0DMG58jE/T44tyEVhS0XVD5buSF6nGgam0Hge/rOMIh4Z0G6W5XQzEjMlobk7HYEV4nQAxRV8qaSLPtspF1ZcPgke2Q278n/KTwd65Nq+YYkr6cFPkxkmz9jZx9Zv0jKGiOw48MuirweOnD2AtvkpWq5fg6vi+pNZ/tymfIxwQ9LTnYbyKOwMR6/OzTulrbOBNftwDb2+PXLLT9Y=\";\n        const key = \"9ee1d044677cac34984b2da0acbc66d238e884a5e944cde54b96be77e3fc1e8e\";\n        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, \"base64\"), buffer_1.Buffer.from(key, \"hex\"));\n        // console.log(dearmorAndDecrypt(cert));\n        // console.log(decode(cert));\n        const result = __1.Challenger.deserializeCertificate(cert);\n        assert_1.default.equal(result.error, \"\");\n        assert_1.default.equal(result.state, 0);\n    });\n    it(\"Should deserialize a succesful v0 certificate 3\", async () => {\n        const message = \"Cf+KnycFC0odoGv9Yxjc2JvUgZSYBNmzBN1UomUz/3VzXds3K/Fr2odh9ZI4q86ZmFsKu/bIxsXhDNg2sM7PhESvgpAJte+3QfVD8e1pzSG4+mqQs2HSkXm5xo6gcPfoN7OyJfzUbaDW5ts1Cy9dIWxJpr8JcT6BUofVgoQk4loi8LPsDdsA4Kxk6FaAE05CeqvuglYayaOnOk/u+cQFHN9rBHe2cpHCrgQAr4Qa+MeLMo4GU7pB4Qd4nA7AQxDBXJqR+tVvPIA2GZWb/EW2OGDFU7YzRJJLP7RdXnjcsSYRkUzuCPpI7l7vfaVy8nxNqy9PkEIPlzyO3TCHOHqHWlEy2YN8O1Mx\";\n        const key = \"cc4dfd01327a30e10d9286344d485f2e4807ddb4c3e007f8b7fba20bb6c16985\";\n        const cert = (0, cryptoChannel_1.decrypt)(buffer_1.Buffer.from(message, \"base64\"), buffer_1.Buffer.from(key, \"hex\"));\n        //console.log(dearmorAndDecrypt(cert));\n        // console.log(decode(cert));\n        const result = __1.Challenger.deserializeCertificate(cert);\n        assert_1.default.equal(result.error, \"\");\n        assert_1.default.equal(result.state, 0);\n    });\n    // it(\"should deserialize old certificate\", () => {\n    //   const oldCert = \"X2J4X2lhaHdjbTkwYjJOdmJLTndNbkNuYzJWeWRtbGpaYVJoZFhSb3FYUnBiV1Z6ZEdGdGNNOEFBQUdXa2RIeHQ2TndhekhFZkFPRG9YWUFvV1BGQUUybEFRSURKaUFCSVZnZ0hBMUZiazh3QXJvZUczQkNOUWFHYXZ4bWpPRWwvRUREWkNXZkFGS05GTjBpV0NCcjUza3p6U0t6TUdER1BpUGRvcUxzTDF1b2Z2SllBbkF5Z3I3dDI3REJHcUZseFFBZ2RoMTRaMDlyWndrNjl6blVxU3lLZENJdnk1N0tGL25PdGFDdndKa2Jkd3lqY0dzeXhIUUJoS0YyQUtGd3hRQWdPck13SmNDNHpYemFzWWtTd2FFU2VmM1JRdC9DL3NPK2JSQmd2WFd1a095aGVNVUFJRWpEcWd3N3Z5SXRETzNGS0l0NFpVRHo5QTBSWW00NGNISk5lbW1CNkxKMW9XWEZBQ0R6bUsrUDBCbGZIMVBDTzduRStLQ1FOQ0FoSnJ5cXB5aCtNRlpuMlZOREthVnViMjVqWmNRZ1NPWE9NbkNwOHZIYlFoNmtGa0UrM2VnZEwrYTNMa2tndFBZa2VaZEMwWG1sYzJsbmJqSEUvNE9oYzhSSE1FVUNJUUNCcERKenpIRVpHdExxV0IxRVJlK3E4dW56RXJHNmlrU2hNbnBkcVRZc05BSWdBcnpNbHNtZjlqOGNjQWZsdG1Tb1dhWjRNeGtjOXJPbHI4aXQzemRHejhXaFk4U0dleUowZVhCbElqb2lkMlZpWVhWMGFHNHVaMlYwSWl3aVkyaGhiR3hsYm1kbElqb2lUMmd0T0dsd1l6TkpiR0puVUZGVE5FbEZTazlGWjNrNE56Vk1jVlJNZGxOV1FrMVhiRXBhY1VJelp5SXNJbTl5YVdkcGJpSTZJbWgwZEhBNkx5OXNiMk5oYkdodmMzUTZNekF3TUNJc0ltTnliM056VDNKcFoybHVJanBtWVd4elpYMmhZY1FsU1pZTjVZZ09qR2gwTkJjUFpIWmdXNC9rcnJtaWhqTEhtVnp6dW9NZGwyTWRBQUFBQUtWemFXZHVNc1JBVjJvL0hSdS9PSjBCMllVdXoyN0o3OThkWE5aTmV5VmlVclVLclBNeHpzd0dNeVloRy9Bc1QxWjJ3WWVHaUhlbVNyQ1NNeDRrSVpIcjNHdHhtVERvQnFodFpYUmhaR0YwWVlBPQ==\";\n    //   console.log(Buffer.from(oldCert, \"base64\").toString(\"utf-8\"));\n    //   const result = Challenger.deserializeCertificate(Buffer.from(oldCert, \"base64\"));\n    //   assert.equal(result.state, 2);\n    // });\n    /*\n    it(\"Fail with tampered certificate (FIDO2)\", async () => {\n      const attestation1 = await navigator.credentials.create(\n        SoftCredentials.createRequest(-7),\n      );\n      const vaultysId1 = await VaultysId.fido2FromAttestation(attestation1);\n      const challenger1 = new Challenger(vaultysId1);\n  \n      const attestation2 = await navigator.credentials.create(\n        SoftCredentials.createRequest(-8),\n      );\n      const vaultysId2 = await VaultysId.fido2FromAttestation(attestation2);\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"interesting\", \"stuff\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1\n        const t = testCertificate(rogueCert);\n        assert.notEqual(t.state, 2);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n  \n    it(\"Fail with tampered certificate all possibilities (FIDO2)\", async () => {\n      const vaultysId1 = await VaultysId.generateMachine();\n      const challenger1 = new Challenger(vaultysId1);\n      const vaultysId2 = await VaultysId.generateMachine();\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"interesting\", \"stuff\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        // TODO fix this malleability for\n        // timestampDS_ a974696d657374616d70cf000001884453195fa3\n        // timestampDS_ a974696d657374616d70d3000001884453195fa3\n        // or use another serialisation for identifying certificate.\n        if(i != 46 && i != rogueCert.length - 1) {\n          for(let j = 0; j < 256; j++){\n            if(j != back) {\n              rogueCert[i] = j;\n              const t = testCertificate(rogueCert);\n              if(t.state == 2) {\n                console.log(i, j, t);\n                console.log(\n                  Buffer.from(rogueCert).toString(\"utf-8\").slice(i-10, i+10),\n                  Buffer.from(rogueCert).toString(\"hex\").slice(i*2-20, i*2+20),\n                  Buffer.from(challenger2.getCertificate()).toString(\"utf-8\").slice(i-10, i+10),\n                  Buffer.from(challenger2.getCertificate()).toString(\"hex\").slice(i*2-20, i*2+20)\n                );\n              }\n              assert.notEqual(t.state, 2);\n            }\n          }\n        }\n        console.log(i, rogueCert.length);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n  \n    it(\"Fail with tampered certificate\", async () => {\n      const vaultysId1 = await VaultysId.generateMachine();\n      const challenger1 = new Challenger(vaultysId1);\n      const vaultysId2 = await VaultysId.generateMachine();\n      const challenger2 = new Challenger(vaultysId2);\n  \n      challenger1.createChallenge(\"random\", \"test\");\n      await challenger2.update(challenger1.getCertificate());\n      await challenger1.update(challenger2.getCertificate());\n      await challenger2.update(challenger1.getCertificate());\n      assert.ok(challenger1.isComplete());\n      assert.ok(challenger2.isComplete());\n      const rogueCert = challenger2.getCertificate();\n      for(let i = 0; i < rogueCert.length; i++) {\n        const back = rogueCert[i];\n        rogueCert[i] = back + Math.floor(Math.random() * 254) + 1\n        const t = testCertificate(rogueCert);\n        assert.notEqual(t.state, 2);\n        rogueCert[i] = back;\n      }\n    }).timeout(10000);\n    */\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nconst buffer_1 = require(\"buffer/\");\nconst MemoryChannel_1 = require(\"../src/MemoryChannel\");\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\ndescribe(\"Channel tests\", () => {\n    it(\"send/receive\", async () => {\n        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();\n        channel.send(buffer_1.Buffer.from(\"hello world\", \"utf-8\"));\n        const message = await channel.otherend?.receive();\n        assert_1.default.equal(\"hello world\", message?.toString(\"utf-8\"));\n    });\n});\n// describe(\"Channel pipe tests\", () => {\n//   it(\"should pipe data between two memory channels\", async () => {\n//     // Create endpoints for A and B\n//     const channelA = MemoryChannel.createBidirectionnal();\n//     const channelB = MemoryChannel.createBidirectionnal();\n//     console.log(\"started\");\n//     // Connect channels to receive endpoints\n//     const receiverA = channelA.otherend!;\n//     const receiverB = channelB.otherend!;\n//     channelA.setLogger(console.log);\n//     channelB.setLogger(console.log);\n//     // Start piping between the two channels\n//     const unpipe = pipeChannels(channelA, channelB);\n//     await delay(10);\n//     const messageAtB = receiverB.receive();\n//     // Send data from A to B\n//     channelA.send(Buffer.from(\"hello from A\", \"utf-8\"));\n//     // Receive on B's side\n//     console.log(await messageAtB);\n//     console.log(\"Data sent from A to B\");\n//     // Send data from B to A\n//     await channelB.send(Buffer.from(\"hello from B\", \"utf-8\"));\n//     // Receive on A's side\n//     const messageAtA = await receiverA.receive();\n//     // Clean up\n//     await unpipe();\n//     // Verify the data was correctly transmitted\n//     assert.equal(messageAtB.toString(\"utf-8\"), \"hello from A\");\n//     assert.equal(messageAtA.toString(\"utf-8\"), \"hello from B\");\n//   });\n//   it(\"should pipe data between encrypted memory channels\", async () => {\n//     // Create encrypted endpoints\n//     const channelA = MemoryChannel.createEncryptedBidirectionnal();\n//     const channelB = MemoryChannel.createEncryptedBidirectionnal();\n//     // Connect channels to receive endpoints\n//     const receiverA = channelA.otherend!;\n//     const receiverB = channelB.otherend!;\n//     // Start piping\n//     const unpipe = pipeChannels(channelA, channelB);\n//     // Send multiple messages from A to B\n//     await channelA.send(Buffer.from(\"message 1\", \"utf-8\"));\n//     await channelA.send(Buffer.from(\"message 2\", \"utf-8\"));\n//     // Receive on B\n//     const message1AtB = await receiverB.receive();\n//     const message2AtB = await receiverB.receive();\n//     // Clean up\n//     await unpipe();\n//     // Verify the data was correctly transmitted\n//     assert.equal(message1AtB.toString(\"utf-8\"), \"message 1\");\n//     assert.equal(message2AtB.toString(\"utf-8\"), \"message 2\");\n//   });\n//   it(\"should handle large data transfers\", async () => {\n//     // Create endpoints\n//     const channelA = MemoryChannel.createBidirectionnal();\n//     const channelB = MemoryChannel.createBidirectionnal();\n//     // Connect channels to receive endpoints\n//     const receiverB = channelB.otherend!;\n//     // Start piping\n//     const unpipe = pipeChannels(channelA, channelB);\n//     // Create a large buffer (1MB)\n//     const largeData = Buffer.alloc(1024 * 1024);\n//     largeData.fill(42);\n//     // Send large data from A to B\n//     await channelA.send(largeData);\n//     // Receive on B\n//     const receivedData = await receiverB.receive();\n//     // Clean up\n//     await unpipe();\n//     // Verify the data was correctly transmitted\n//     assert.equal(receivedData.length, largeData.length);\n//     assert.ok(receivedData.equals(largeData));\n//   });\n//   it(\"should handle bidirectional communication simultaneously\", async () => {\n//     // Create endpoints\n//     const channelA = MemoryChannel.createBidirectionnal();\n//     const channelB = MemoryChannel.createBidirectionnal();\n//     // Connect channels to receive endpoints\n//     const receiverA = channelA.otherend!;\n//     const receiverB = channelB.otherend!;\n//     // Start piping\n//     const unpipe = pipeChannels(channelA, channelB);\n//     // Send messages in both directions\n//     await Promise.all([channelA.send(Buffer.from(\"from A to B\", \"utf-8\")), channelB.send(Buffer.from(\"from B to A\", \"utf-8\"))]);\n//     // Receive in both directions\n//     const [messageAtB, messageAtA] = await Promise.all([receiverB.receive(), receiverA.receive()]);\n//     // Clean up\n//     await unpipe();\n//     // Verify bidirectional data transmission\n//     assert.equal(messageAtB.toString(\"utf-8\"), \"from A to B\");\n//     assert.equal(messageAtA.toString(\"utf-8\"), \"from B to A\");\n//   });\n// });\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer/\");\nconst assert_1 = __importDefault(require(\"assert\"));\nconst __1 = require(\"../\");\nconst utils_1 = require(\"./utils\");\nconst MemoryChannel_1 = require(\"../src/MemoryChannel\");\nconst MemoryStorage_1 = require(\"../src/MemoryStorage\");\nrequire(\"./shims\");\nconst crypto_1 = require(\"../src/crypto\");\nconst fetchFile = async (url) => {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error(`Failed to fetch file: ${response.statusText}`);\n    }\n    return await response.arrayBuffer();\n};\ndescribe(\"IdManager with files in browser\", () => {\n    it(\"Transfer data over encrypted Channel\", async () => {\n        for (let i = 0; i < 10; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => \"\");\n            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => \"\");\n            const manager1 = new __1.IdManager(id1, s1);\n            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            const inputBuffer = await fetchFile(\"assets/testfile.png\");\n            const input = new Blob([inputBuffer], { type: \"image/png\" });\n            const outputChunks = [];\n            const outputStream = new WritableStream({\n                write(chunk) {\n                    outputChunks.push(new Uint8Array(chunk));\n                },\n            });\n            const promise = manager2.download(channel, (0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));\n            await manager1.upload(channel.otherend, (0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));\n            await promise;\n            const outputBuffer = buffer_1.Buffer.concat(outputChunks);\n            const hash1 = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(inputBuffer));\n            const hash2 = (0, crypto_1.hash)(\"sha256\", outputBuffer);\n            assert_1.default.equal(hash1.toString(\"hex\"), hash2.toString(\"hex\"));\n        }\n    });\n    it(\"sign a File over Channel\", async () => {\n        for (let i = 0; i < 10; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, MemoryStorage_1.MemoryStorage)(() => \"\");\n            const s2 = (0, MemoryStorage_1.MemoryStorage)(() => \"\");\n            const manager1 = new __1.IdManager(id1, s1);\n            const manager2 = new __1.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            const inputBuffer = await fetchFile(\"assets/testfile.png\");\n            const file = { arrayBuffer: buffer_1.Buffer.from(inputBuffer), type: \"image/png\" };\n            manager1.acceptSignFile(channel);\n            const result = await manager2.requestSignFile(channel.otherend, file);\n            if (!result)\n                return assert_1.default.fail(\"no result of the sign file request\");\n            const challenge = new URL(result.challenge.toString(\"utf8\"));\n            assert_1.default.equal(challenge.protocol, \"vaultys:\");\n            assert_1.default.equal(challenge.host, \"signfile\");\n            assert_1.default.equal(challenge.searchParams.get(\"hash\"), \"a73d53246950a93ee956e413f50ed326e36f9a052dcd6fc5388ae19290931f32\");\n            assert_1.default.notEqual(challenge.searchParams.get(\"timestamp\"), null);\n            assert_1.default.ok(manager2.verifyFile(file, result, manager1.vaultysId));\n        }\n    });\n});\ndescribe(\"Channel tests for browser\", () => {\n    it(\"stream file\", async () => {\n        const channel = MemoryChannel_1.MemoryChannel.createBidirectionnal();\n        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);\n        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);\n        const inputBuffer = await fetchFile(\"assets/testfile.png\");\n        const input = new Blob([inputBuffer], { type: \"image/png\" });\n        const outputChunks = [];\n        const outputStream = new WritableStream({\n            write(chunk) {\n                outputChunks.push(new Uint8Array(chunk));\n            },\n        });\n        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));\n        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));\n        await promise;\n        const outputBuffer = buffer_1.Buffer.concat(outputChunks);\n        const hash1 = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(inputBuffer));\n        const hash2 = (0, crypto_1.hash)(\"sha256\", outputBuffer);\n        assert_1.default.equal(hash1.toString(\"hex\"), hash2.toString(\"hex\"));\n    });\n    it(\"stream file over encrypted channel\", async () => {\n        const channel = MemoryChannel_1.MemoryChannel.createEncryptedBidirectionnal();\n        const { download } = (0, MemoryChannel_1.StreamChannel)(channel);\n        const { upload } = (0, MemoryChannel_1.StreamChannel)(channel.otherend);\n        const inputBuffer = await fetchFile(\"assets/testfile.png\");\n        const input = new Blob([inputBuffer], { type: \"image/png\" });\n        const outputChunks = [];\n        const outputStream = new WritableStream({\n            write(chunk) {\n                outputChunks.push(new buffer_1.Buffer(chunk));\n            },\n        });\n        const promise = download((0, MemoryChannel_1.convertWebWritableStreamToNodeWritable)(outputStream));\n        await upload((0, MemoryChannel_1.convertWebReadableStreamToNodeReadable)(input.stream()));\n        await promise;\n        const outputBuffer = buffer_1.Buffer.concat(outputChunks);\n        const hash1 = (0, crypto_1.hash)(\"sha256\", buffer_1.Buffer.from(inputBuffer));\n        const hash2 = (0, crypto_1.hash)(\"sha256\", outputBuffer);\n        assert_1.default.equal(hash1.toString(\"hex\"), hash2.toString(\"hex\"));\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nconst __1 = require(\"..\");\nconst __2 = require(\"..\");\nrequire(\"./shims\");\nconst crypto_1 = require(\"../src/crypto\");\nconst utils_1 = require(\"./utils\");\ndescribe(\"IdManager\", () => {\n    it(\"serder a vaultys secret\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const secret = id1.getSecret();\n            const id2 = __2.VaultysId.fromSecret(secret);\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n            assert_1.default.equal(id2.id.toString(\"base64\"), id1.id.toString(\"base64\"));\n            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);\n            const hmac1 = await id1.hmac(\"test message\");\n            const hmac2 = await id2.hmac(\"test message\");\n            assert_1.default.notEqual(hmac1, undefined);\n            assert_1.default.equal(hmac1?.toString(\"base64\"), hmac2?.toString(\"base64\"));\n        }\n    });\n    it(\"serder a vaultys secret in base64\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const secret = id1.getSecret(\"base64\");\n            const id2 = __2.VaultysId.fromSecret(secret, \"base64\");\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n            assert_1.default.equal(id2.id.toString(\"base64\"), id1.id.toString(\"base64\"));\n            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);\n            const hmac1 = await id1.hmac(\"test message\");\n            const hmac2 = await id2.hmac(\"test message\");\n            assert_1.default.notEqual(hmac1, undefined);\n            assert_1.default.equal(hmac1?.toString(\"base64\"), hmac2?.toString(\"base64\"));\n        }\n    });\n    it(\"serder to public Idmanager\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const id2 = __2.VaultysId.fromId(id1.id);\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n            assert_1.default.equal(id2.id.toString(\"base64\"), id1.id.toString(\"base64\"));\n            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);\n            const hmac1 = await id1.hmac(\"test message\");\n            const hmac2 = await id2.hmac(\"test message\");\n            assert_1.default.notEqual(hmac1, undefined);\n            assert_1.default.equal(hmac2, undefined);\n        }\n    });\n    it(\"serder to public Idmanager stringified\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const id = JSON.stringify(id1.id);\n            const id2 = __2.VaultysId.fromId(JSON.parse(id));\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n            assert_1.default.equal(id2.id.toString(\"base64\"), id1.id.toString(\"base64\"));\n            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);\n        }\n    });\n    it(\"serder to public Idmanager as hex string\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const id2 = __2.VaultysId.fromId(id1.id.toString(\"hex\"));\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n        }\n    });\n    it(\"serder to public Idmanager as base64 string\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const id2 = __2.VaultysId.fromId(id1.id.toString(\"base64\"), undefined, \"base64\");\n            assert_1.default.equal(id2.fingerprint, id1.fingerprint);\n            assert_1.default.equal(id2.id.toString(\"base64\"), id1.id.toString(\"base64\"));\n            assert_1.default.deepStrictEqual(id2.didDocument, id1.didDocument);\n        }\n    });\n    it(\"sign unspecified data and log it in the store\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const s = (0, __2.MemoryStorage)(() => \"\");\n            const manager = new __2.IdManager(id1, s);\n            const signature = await manager.signChallenge(manager.vaultysId.id);\n            if (signature == null)\n                assert_1.default.fail();\n            const signatures = manager.getSignatures();\n            assert_1.default.equal(signatures.length, 1);\n            assert_1.default.equal(signatures[0].payload.challenge.toString(\"hex\"), manager.vaultysId.id.toString(\"hex\"));\n            assert_1.default.equal(signatures[0].payload.signature.toString(\"hex\"), signature.toString(\"hex\"));\n            assert_1.default.equal(signatures[0].type, \"UNKNOWN\");\n        }\n    });\n    it(\"sign random document hash and log it in the store\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const s = (0, __2.MemoryStorage)(() => \"\");\n            const file = { arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(1024)), type: \"random\" };\n            const h = (0, crypto_1.hash)(\"sha256\", file.arrayBuffer);\n            const manager = new __2.IdManager(id1, s);\n            const payload = await manager.signFile(file);\n            const signatures = manager.getSignatures();\n            assert_1.default.equal(signatures.length, 1);\n            const challenge = new URL(signatures[0].challenge);\n            assert_1.default.equal(challenge.searchParams.get(\"hash\"), h.toString(\"hex\"));\n            assert_1.default.ok(manager.verifyFile(file, signatures[0].payload, id1));\n            if (payload.signature == null)\n                assert_1.default.fail();\n            assert_1.default.equal(signatures[0].payload.signature.toString(\"hex\"), payload.signature.toString(\"hex\"));\n            //console.log(signatures[0]);\n            assert_1.default.equal(signatures[0].type, \"DOCUMENT\");\n        }\n    });\n    // it(\"sign login and log it in the store\", async () => {\n    //   const s = MemoryStorage(() => \"\");\n    //   const loginMock = 'vaultys://login?host=https://sso.vaultys.net/interaction/1UfGEF9HDQiIreFPS3wlI&nonce=9c0c7621a790c6e697032093aeca614d183319d663aa5cc1a085e052c7f904d5&timestamp=1665498137687&challenge=dummy'\n    //   const manager = new IdManager(await VaultysId.generatePerson(), s);\n    //   const payload = await manager.signLogin(loginMock);\n    //   const signatures = manager.getSignatures();\n    //   assert.equal(signatures.length, 1);\n    //   const challenge = new URL(signatures[0].challenge)\n    //   assert.equal(challenge.searchParams.get('hash'), fileHashMock.toString(\"hex\"));\n    //   assert.ok(manager.verifyFile(signatures[0].payload.challenge.toString(\"hex\"), signatures[0].payload.signature));\n    //   assert.equal(signatures[0].payload.signature.toString(\"hex\"), payload.signature.toString(\"hex\"));\n    //   //console.log(signatures[0]);\n    //   assert.equal(signatures[0].type, 'LOGIN');\n    // });\n});\ndescribe(\"SRG v0 challenge with IdManager\", () => {\n    it(\"pass a challenge\", async () => {\n        for (const id1 of await (0, utils_1.allVaultysIdType)()) {\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);\n            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);\n            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);\n            // console.log(s2.substore(\"contacts\"))\n            // assert.deepStrictEqual(s2.substore(\"contacts\").get(manager1.vaultysId.did).metadata, metadata1);\n            // assert.deepStrictEqual(s1.substore(\"contacts\").get(manager2.vaultysId.did).metadata, metadata2);\n            assert_1.default.equal(s1.substore(\"wot\").list().length, 1);\n            assert_1.default.equal(s2.substore(\"wot\").list().length, 1);\n            if (manager1.vaultysId.type === 0) {\n                assert_1.default.equal(manager2.apps.length, 1);\n                const app1 = manager2.getApp(manager1.vaultysId.did);\n                assert_1.default.equal(app1?.fingerprint, manager1.vaultysId.fingerprint);\n                assert_1.default.equal(app1?.keyManager.authType, manager1.vaultysId.keyManager.authType);\n                assert_1.default.equal(app1?.keyManager.encType, manager1.vaultysId.keyManager.encType);\n                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n            }\n            else {\n                assert_1.default.equal(manager2.contacts.length, 1);\n                const contact1 = manager2.getContact(manager1.vaultysId.did);\n                assert_1.default.equal(contact1?.fingerprint, manager1.vaultysId.fingerprint);\n                assert_1.default.equal(contact1?.keyManager.authType, manager1.vaultysId.keyManager.authType);\n                assert_1.default.equal(contact1?.keyManager.encType, manager1.vaultysId.keyManager.encType);\n                manager2.setContactMetadata(manager1.vaultysId.did, \"name\", \"salut\");\n                manager2.setContactMetadata(manager1.vaultysId.did, \"group\", \"pro\");\n                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, \"name\"), \"salut\");\n                assert_1.default.equal(manager2.getContactMetadata(manager1.vaultysId.did, \"group\"), \"pro\");\n                assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n                assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n            }\n        }\n    });\n    it(\"fail a challenge if user1 refuse\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            try {\n                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);\n            }\n            catch (e) {\n                assert_1.default.equal(e.message, \"Error: Contact refused\");\n            }\n        }\n    });\n    it(\"fail a challenge if user2 refuse\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            try {\n                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);\n            }\n            catch (e) {\n                assert_1.default.equal(e.message, \"Error: Contact refused\");\n            }\n        }\n    });\n    it(\"pass a challenge over encrypted Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                phone: \"f\",\n            };\n            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);\n            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);\n            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);\n            // assert.deepStrictEqual(s2.substore(\"contacts\").get(manager1.vaultysId.did).metadata, metadata1);\n            // assert.deepStrictEqual(s1.substore(\"contacts\").get(manager2.vaultysId.did).metadata, metadata2);\n            assert_1.default.equal(s1.substore(\"wot\").list().length, 1);\n            assert_1.default.equal(s2.substore(\"wot\").list().length, 1);\n            manager1.setContactMetadata(manager2.vaultysId.did, \"name\", \"salut\");\n            manager1.setContactMetadata(manager2.vaultysId.did, \"group\", \"pro\");\n            // assert.deepStrictEqual(\n            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),\n            //   metadata2\n            // );\n            // assert.deepStrictEqual(\n            //   manager1.getAllMetadata(manager2.vaultysId.did),\n            //   {\n            //     group: 'pro',\n            //     name: 'salut',\n            //     phone: 'f'\n            //   }\n            // );\n            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n        }\n    });\n    it(\"perform PRF over Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            // channel.setLogger((data) => console.log(data.toString(\"utf-8\")));\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            manager1.acceptPRF(channel);\n            const result = await manager2.requestPRF(channel.otherend, \"nostr\");\n            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac(\"prf|nostr|prf\"));\n        }\n    });\n    it(\"perform decrypt over Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            // channel.setLogger((data) => console.log(data.toString(\"utf-8\")));\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            const message = \"test decrypt on demand\";\n            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);\n            manager1.acceptDecrypt(channel);\n            //console.log(toDecrypt);\n            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, \"utf-8\"));\n            assert_1.default.deepEqual(result?.toString(\"utf-8\"), message);\n        }\n    });\n    describe(\"IdManager File Encryption/Decryption\", () => {\n        it(\"should encrypt and decrypt a file between two IdManagers\", async () => {\n            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // Create a sample file\n            const fileContent = (0, crypto_1.randomBytes)(1024);\n            const originalFile = {\n                arrayBuffer: __2.crypto.Buffer.from(fileContent),\n                type: \"application/octet-stream\",\n                name: \"test.bin\",\n            };\n            // Set up the decryption handler on manager2\n            manager2.acceptDecryptFile(channel.otherend);\n            // Request encryption from manager1 to manager2\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption failed\");\n            assert_1.default.equal(encryptedFile.type, originalFile.type, \"File type should be preserved\");\n            assert_1.default.equal(encryptedFile.name, originalFile.name, \"File name should be preserved\");\n            assert_1.default.ok(encryptedFile.arrayBuffer, \"Encrypted data should be present\");\n            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Encrypted data should be different from original\");\n            // Now decrypt the file\n            channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            manager2.acceptDecryptFile(channel.otherend);\n            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n            assert_1.default.ok(decryptedFile, \"Decryption failed\");\n            assert_1.default.equal(decryptedFile.type, originalFile.type, \"File type should be preserved after decryption\");\n            assert_1.default.equal(decryptedFile.name, originalFile.name, \"File name should be preserved after decryption\");\n            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Decrypted file should match the original\");\n        });\n        it(\"should work with different file types and sizes\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // Test with different file types and sizes\n            const testCases = [\n                { size: 10, type: \"text/plain\", name: \"small.txt\" },\n                { size: 1024, type: \"application/pdf\", name: \"medium.pdf\" },\n                { size: 4096, type: \"image/jpeg\", name: \"large.jpg\" },\n            ];\n            for (const testCase of testCases) {\n                const fileContent = (0, crypto_1.randomBytes)(testCase.size);\n                const originalFile = {\n                    arrayBuffer: __1.Buffer.from(fileContent),\n                    type: testCase.type,\n                    name: testCase.name,\n                };\n                manager2.acceptEncryptFile(channel.otherend);\n                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);\n                manager2.acceptDecryptFile(channel.otherend);\n                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);\n                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);\n                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);\n                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);\n            }\n        });\n        it(\"should handle acceptDecryptFile with custom acceptance function\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // First establish contact between the managers\n            const contactChannel = __2.MemoryChannel.createBidirectionnal();\n            if (!contactChannel.otherend)\n                assert_1.default.fail(\"Contact channel creation failed\");\n            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);\n            // Create a sample file\n            const originalFile = {\n                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(512)),\n                type: \"text/plain\",\n                name: \"test.txt\",\n            };\n            // Test with accepting function that returns true\n            let acceptCalled = false;\n            manager2.acceptDecryptFile(channel.otherend, async (contact) => {\n                acceptCalled = true;\n                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);\n                return true;\n            });\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption should succeed when accept returns true\");\n            assert_1.default.ok(acceptCalled, \"Accept function should be called\");\n            // Test with accepting function that returns false\n            acceptCalled = false;\n            manager2.acceptDecryptFile(channel.otherend, async () => {\n                acceptCalled = true;\n                return false;\n            });\n            const failedResult = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(acceptCalled, \"Accept function should be called even when rejecting\");\n            assert_1.default.equal(failedResult, null, \"Encryption should fail when accept returns false\");\n        });\n        it(\"should handle acceptEncryptFile with custom acceptance function\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // First establish contact between the managers\n            const contactChannel = __2.MemoryChannel.createBidirectionnal();\n            if (!contactChannel.otherend)\n                assert_1.default.fail(\"Contact channel creation failed\");\n            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);\n            // Create an encrypted file\n            let acceptCalled = false;\n            manager2.acceptEncryptFile(channel.otherend, async (contact) => {\n                acceptCalled = true;\n                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);\n                return true;\n            });\n            // Create a sample file and encrypt it\n            const originalFile = {\n                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(256)),\n                type: \"application/json\",\n                name: \"data.json\",\n            };\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption should succeed when accept returns true\");\n            assert_1.default.ok(acceptCalled, \"Accept function should be called\");\n            // Verify we can decrypt it back\n            manager2.acceptDecryptFile(channel.otherend);\n            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n            assert_1.default.ok(decryptedFile, \"Decryption should succeed\");\n            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Decrypted content should match original\");\n        });\n        it(\"should verify that acceptEncryptFile and acceptDecryptFile are the same function\", async () => {\n            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => \"\"));\n            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, \"acceptEncryptFile should be an alias of acceptDecryptFile\");\n        });\n    });\n    it(\"perform migration from version 0 to 1\", async () => {\n        const ids = [];\n        for (let i = 0; i < 2; i++) {\n            for (let i = 0; i < 4; i++) {\n                const vid = await (0, utils_1.createRandomVaultysId)();\n                const s1 = (0, __2.MemoryStorage)(() => \"\");\n                const id1 = new __2.IdManager(vid, s1);\n                for (let j = 0; j < 2; j++) {\n                    for (let i = 0; i < 4; i++) {\n                        const vid2 = await (0, utils_1.createRandomVaultysId)();\n                        const s2 = (0, __2.MemoryStorage)(() => \"\");\n                        const id2 = new __2.IdManager(vid2, s2);\n                        id1.saveContact(id2.vaultysId);\n                        id1.setContactMetadata(id2.vaultysId.did, \"test\", id2.vaultysId.did);\n                    }\n                }\n                ids.push(id1);\n            }\n        }\n        for (const id of ids) {\n            id.migrate(0);\n            assert_1.default.equal(id.contacts.length + id.apps.length, 8);\n            id.migrate(1);\n            assert_1.default.equal(id.contacts.length + id.apps.length, 8);\n        }\n    }).timeout(20000);\n});\ndescribe(\"SRG v1 challenge with IdManager\", () => {\n    it(\"pass a challenge\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            const challengers = await Promise.all([manager1.startSRP(channel, \"p2p\", \"auth\", metadata1), manager2.acceptSRP(channel.otherend, \"p2p\", \"auth\", metadata2)]);\n            //console.log(challengers);\n            // assert.equal(contacts[0].did, manager2.vaultysId.did);\n            // assert.equal(contacts[1].did, manager1.vaultysId.did);\n            ///console.log(s2, s1);\n            // assert.deepStrictEqual(s2.substore(\"contacts\").get(manager1.vaultysId.did).metadata, metadata1);\n            // assert.deepStrictEqual(s1.substore(\"contacts\").get(manager2.vaultysId.did).metadata, metadata2);\n            // assert.equal(s1.substore(\"wot\").list().length, 1);\n            // assert.equal(s2.substore(\"wot\").list().length, 1);\n            // console.log(Challenger.deserializeCertificate(s2.substore(\"wot\").get(s2.substore(\"wot\").list()[0])));\n            // if (manager1.vaultysId.type === 0) {\n            //   assert.equal(manager2.apps.length, 1);\n            //   assert.equal(manager2.getApp(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);\n            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n            // } else {\n            //   assert.equal(manager2.contacts.length, 1);\n            //   assert.equal(manager2.getContact(manager1.vaultysId.did)?.fingerprint, manager1.vaultysId.fingerprint);\n            //   manager2.setContactMetadata(manager1.vaultysId.did, \"name\", \"salut\");\n            //   manager2.setContactMetadata(manager1.vaultysId.did, \"group\", \"pro\");\n            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, \"name\"), \"salut\");\n            //   assert.equal(manager2.getContactMetadata(manager1.vaultysId.did, \"group\"), \"pro\");\n            //   assert.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n            //   assert.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n            // }\n        }\n    });\n    it(\"fail a challenge if user1 refuse\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            try {\n                await Promise.all([manager1.askContact(channel, metadata1, () => Promise.resolve(false)), manager2.acceptContact(channel.otherend, metadata2)]);\n            }\n            catch (e) {\n                assert_1.default.equal(e.message, \"Error: Contact refused\");\n            }\n        }\n    });\n    it(\"fail a challenge if user2 refuse\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateMachine(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n                phone: \"c\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                email: \"e\",\n                phone: \"f\",\n            };\n            try {\n                await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2, () => Promise.resolve(false))]);\n            }\n            catch (e) {\n                assert_1.default.equal(e.message, \"Error: Contact refused\");\n            }\n        }\n    });\n    it(\"pass a challenge over encrypted Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            const metadata1 = {\n                name: \"a\",\n                email: \"b\",\n            };\n            const metadata2 = {\n                name: \"d\",\n                phone: \"f\",\n            };\n            const contacts = await Promise.all([manager1.askContact(channel, metadata1), manager2.acceptContact(channel.otherend, metadata2)]);\n            assert_1.default.equal(contacts[0].did, manager2.vaultysId.did);\n            assert_1.default.equal(contacts[1].did, manager1.vaultysId.did);\n            // assert.deepStrictEqual(s2.substore(\"contacts\").get(manager1.vaultysId.did).metadata, metadata1);\n            // assert.deepStrictEqual(s1.substore(\"contacts\").get(manager2.vaultysId.did).metadata, metadata2);\n            assert_1.default.equal(s1.substore(\"wot\").list().length, 1);\n            assert_1.default.equal(s2.substore(\"wot\").list().length, 1);\n            manager1.setContactMetadata(manager2.vaultysId.did, \"name\", \"salut\");\n            manager1.setContactMetadata(manager2.vaultysId.did, \"group\", \"pro\");\n            // assert.deepStrictEqual(\n            //   manager1.getCertifiedMetadata(manager2.vaultysId.did),\n            //   metadata2\n            // );\n            // assert.deepStrictEqual(\n            //   manager1.getAllMetadata(manager2.vaultysId.did),\n            //   {\n            //     group: 'pro',\n            //     name: 'salut',\n            //     phone: 'f'\n            //   }\n            // );\n            assert_1.default.ok(await manager1.verifyRelationshipCertificate(manager2.vaultysId.did));\n            assert_1.default.ok(await manager2.verifyRelationshipCertificate(manager1.vaultysId.did));\n        }\n    });\n    it(\"perform PRF over Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            // channel.setLogger((data) => console.log(data.toString(\"utf-8\")));\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            manager1.acceptPRF(channel);\n            const result = await manager2.requestPRF(channel.otherend, \"nostr\");\n            assert_1.default.deepEqual(result, await manager1.vaultysId.hmac(\"prf|nostr|prf\"));\n        }\n    });\n    it(\"perform decrypt over Channel\", async () => {\n        for (let i = 0; i < 5; i++) {\n            const id1 = await (0, utils_1.createRandomVaultysId)();\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            // channel.setLogger((data) => console.log(data.toString(\"utf-8\")));\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(id1, s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await __2.VaultysId.generateOrganization(), s2);\n            const message = \"test decrypt on demand\";\n            const toDecrypt = await __2.VaultysId.encrypt(message, [manager1.vaultysId.id]);\n            manager1.acceptDecrypt(channel);\n            //console.log(toDecrypt);\n            const result = await manager2.requestDecrypt(channel.otherend, __1.Buffer.from(toDecrypt, \"utf-8\"));\n            assert_1.default.deepEqual(result?.toString(\"utf-8\"), message);\n        }\n    });\n    describe(\"IdManager File Encryption/Decryption\", () => {\n        it(\"should encrypt and decrypt a file between two IdManagers\", async () => {\n            let channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // Create a sample file\n            const fileContent = (0, crypto_1.randomBytes)(1024);\n            const originalFile = {\n                arrayBuffer: __2.crypto.Buffer.from(fileContent),\n                type: \"application/octet-stream\",\n                name: \"test.bin\",\n            };\n            // Set up the decryption handler on manager2\n            manager2.acceptDecryptFile(channel.otherend);\n            // Request encryption from manager1 to manager2\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption failed\");\n            assert_1.default.equal(encryptedFile.type, originalFile.type, \"File type should be preserved\");\n            assert_1.default.equal(encryptedFile.name, originalFile.name, \"File name should be preserved\");\n            assert_1.default.ok(encryptedFile.arrayBuffer, \"Encrypted data should be present\");\n            assert_1.default.notDeepEqual(encryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Encrypted data should be different from original\");\n            // Now decrypt the file\n            channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            manager2.acceptDecryptFile(channel.otherend);\n            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n            assert_1.default.ok(decryptedFile, \"Decryption failed\");\n            assert_1.default.equal(decryptedFile.type, originalFile.type, \"File type should be preserved after decryption\");\n            assert_1.default.equal(decryptedFile.name, originalFile.name, \"File name should be preserved after decryption\");\n            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Decrypted file should match the original\");\n        });\n        it(\"should work with different file types and sizes\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // Test with different file types and sizes\n            const testCases = [\n                { size: 10, type: \"text/plain\", name: \"small.txt\" },\n                { size: 1024, type: \"application/pdf\", name: \"medium.pdf\" },\n                { size: 4096, type: \"image/jpeg\", name: \"large.jpg\" },\n            ];\n            for (const testCase of testCases) {\n                const fileContent = (0, crypto_1.randomBytes)(testCase.size);\n                const originalFile = {\n                    arrayBuffer: __1.Buffer.from(fileContent),\n                    type: testCase.type,\n                    name: testCase.name,\n                };\n                manager2.acceptEncryptFile(channel.otherend);\n                const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n                assert_1.default.ok(encryptedFile, `Encryption failed for ${testCase.name}`);\n                manager2.acceptDecryptFile(channel.otherend);\n                const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n                assert_1.default.ok(decryptedFile, `Decryption failed for ${testCase.name}`);\n                assert_1.default.equal(decryptedFile.type, originalFile.type, `File type should be preserved for ${testCase.name}`);\n                assert_1.default.equal(decryptedFile.name, originalFile.name, `File name should be preserved for ${testCase.name}`);\n                assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, `Decrypted content should match original for ${testCase.name}`);\n            }\n        });\n        it(\"should handle acceptDecryptFile with custom acceptance function\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // First establish contact between the managers\n            const contactChannel = __2.MemoryChannel.createBidirectionnal();\n            if (!contactChannel.otherend)\n                assert_1.default.fail(\"Contact channel creation failed\");\n            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);\n            // Create a sample file\n            const originalFile = {\n                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(512)),\n                type: \"text/plain\",\n                name: \"test.txt\",\n            };\n            // Test with accepting function that returns true\n            let acceptCalled = false;\n            manager2.acceptDecryptFile(channel.otherend, async (contact) => {\n                acceptCalled = true;\n                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);\n                return true;\n            });\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption should succeed when accept returns true\");\n            assert_1.default.ok(acceptCalled, \"Accept function should be called\");\n            // Test with accepting function that returns false\n            acceptCalled = false;\n            manager2.acceptDecryptFile(channel.otherend, async () => {\n                acceptCalled = true;\n                return false;\n            });\n            const failedResult = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(acceptCalled, \"Accept function should be called even when rejecting\");\n            assert_1.default.equal(failedResult, null, \"Encryption should fail when accept returns false\");\n        });\n        it(\"should handle acceptEncryptFile with custom acceptance function\", async () => {\n            const channel = __2.MemoryChannel.createEncryptedBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail(\"Channel creation failed\");\n            const s1 = (0, __2.MemoryStorage)(() => \"\");\n            const s2 = (0, __2.MemoryStorage)(() => \"\");\n            const manager1 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s1);\n            manager1.setProtocolVersion(1);\n            const manager2 = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), s2);\n            // First establish contact between the managers\n            const contactChannel = __2.MemoryChannel.createBidirectionnal();\n            if (!contactChannel.otherend)\n                assert_1.default.fail(\"Contact channel creation failed\");\n            await Promise.all([manager1.askContact(contactChannel), manager2.acceptContact(contactChannel.otherend)]);\n            // Create an encrypted file\n            let acceptCalled = false;\n            manager2.acceptEncryptFile(channel.otherend, async (contact) => {\n                acceptCalled = true;\n                assert_1.default.equal(contact.toVersion(1).fingerprint, manager1.vaultysId.fingerprint);\n                return true;\n            });\n            // Create a sample file and encrypt it\n            const originalFile = {\n                arrayBuffer: __1.Buffer.from((0, crypto_1.randomBytes)(256)),\n                type: \"application/json\",\n                name: \"data.json\",\n            };\n            const encryptedFile = await manager1.requestEncryptFile(channel, originalFile);\n            assert_1.default.ok(encryptedFile, \"Encryption should succeed when accept returns true\");\n            assert_1.default.ok(acceptCalled, \"Accept function should be called\");\n            // Verify we can decrypt it back\n            manager2.acceptDecryptFile(channel.otherend);\n            const decryptedFile = await manager1.requestDecryptFile(channel, encryptedFile);\n            assert_1.default.ok(decryptedFile, \"Decryption should succeed\");\n            assert_1.default.deepEqual(decryptedFile.arrayBuffer, originalFile.arrayBuffer, \"Decrypted content should match original\");\n        });\n        it(\"should verify that acceptEncryptFile and acceptDecryptFile are the same function\", async () => {\n            const manager = new __2.IdManager(await (0, utils_1.createRandomVaultysId)(), (0, __2.MemoryStorage)(() => \"\"));\n            manager.setProtocolVersion(1);\n            assert_1.default.strictEqual(manager.acceptEncryptFile, manager.acceptDecryptFile, \"acceptEncryptFile should be an alias of acceptDecryptFile\");\n        });\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nconst buffer_1 = require(\"buffer/\");\n// import { publicDerivePath, privateDerivePath, HISCP } from \"../src/KeyManager\";\n// import * as bip32 from \"@stricahq/bip32ed25519\";\nconst __1 = require(\"../\");\nconst utils_1 = require(\"./utils\");\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n//// @ts-expect-error weird import for @stricahq/bip32ed25519\n// const bip32fix = bip32.default ?? bip32;\n// const writeVector = (km: KeyManager) => {\n//   return;\n//   console.log(\"## NOT Published\");\n//   console.log(\"### proof sk:\\n\", new bip32fix.Bip32PrivateKey(km.proofKey.secretKey!).toPrivateKey().toBytes().toString(\"hex\"));\n//   console.log(\"### proof pk:\\n\", new bip32fix.Bip32PrivateKey(km.proofKey.publicKey).toBip32PublicKey().toPublicKey().toBytes().toString(\"hex\"));\n//   console.log(\"### sk = derive(proof sk, m/0'):\\n\", new bip32fix.Bip32PrivateKey(km.signer.secretKey!).toPrivateKey().toBytes().toString(\"hex\"));\n//   console.log(\"## Published\");\n//   console.log(\"### proof = sha256(proof pk):\\n\", km.proof.toString(\"hex\"));\n//   console.log(\"### pk:\", km.signer.publicKey.toString(\"hex\"));\n// };\n// const writeCertificate = (hiscp: HISCP) => {\n//   return;\n//   const hiscpDisplay = {\n//     newId: hiscp.newId.toString(\"hex\"),\n//     proofKey: hiscp.proofKey.toString(\"hex\"),\n//     timestamp: hiscp.timestamp,\n//   };\n//   console.log(\"## HISCP Certificate\");\n//   console.log(\"### hiscp data:\\n\", JSON.stringify(hiscpDisplay, null, 2));\n//   console.log(\"### Signature of hiscp = [newID || proofKey || timestamp] by proof sk\\n\", hiscp.signature.toString(\"hex\"));\n// };\ndescribe(\"KeyManager tests\", () => {\n    // it(\"derive correctly keys (strica)\", async () => {\n    //   const node = await bip32fix.Bip32PrivateKey.fromEntropy(randomBytes(32));\n    //   const publicNode = node.toBip32PublicKey();\n    //   const derivedNode = privateDerivePath(node, \"m/1/2/3\");\n    //   const publicDerivedNode = publicDerivePath(publicNode, \"m/1/2/3\");\n    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString(\"hex\"), publicDerivedNode.toBytes().toString(\"hex\"));\n    // });\n    // it(\"derive correctly keys (noble)\", async () => {\n    //   const privateKey = ed.utils.randomPrivateKey();\n    //   const node = await Bip32PrivateKey.fromEntropy(randomBytes(32));\n    //   const publicNode = node.toBip32PublicKey();\n    //   const derivedNode = derivePath(node, \"1/2/3\");\n    //   const publicDerivedNode = derivePath(publicNode, \"m/1/2/3\");\n    //   assert.equal(derivedNode.toBip32PublicKey().toBytes().toString(\"hex\"), publicDerivedNode.toBytes().toString(\"hex\"));\n    // });\n    it(\"serder a KeyManager losing entropy\", async () => {\n        const km = await __1.KeyManager.generate_Id25519();\n        const secret = km.getSecret();\n        const km2 = __1.KeyManager.fromSecret(secret);\n        assert_1.default.equal(km.id.toString(\"hex\"), km2.id.toString(\"hex\"));\n    });\n    it(\"serder a private KeyManager to a public KeyManager\", async () => {\n        const km = await __1.KeyManager.generate_Id25519();\n        const id = km.id;\n        const publicKM = __1.KeyManager.fromId(id);\n        assert_1.default.equal(id.toString(\"hex\"), publicKM.id.toString(\"hex\"));\n    });\n    it(\"sign and verify a message\", async () => {\n        const signer = await __1.KeyManager.generate_Id25519();\n        const id = signer.id;\n        const verifier = __1.KeyManager.fromId(id);\n        const message = buffer_1.Buffer.from(\"this is a message to be verified man\", \"utf-8\");\n        const signature = await signer.sign(message);\n        if (!signature)\n            assert_1.default.fail();\n        assert_1.default.notEqual(signature, null);\n        assert_1.default.ok(verifier.verify(message, signature));\n    });\n    // it(\"create and verify a HISCP Certificate\", async () => {\n    //   const km = await KeyManager.generate_Id25519();\n    //   const hiscp = await km.createSwapingCertificate();\n    //   if (!hiscp) assert.fail();\n    //   const publicKM = KeyManager.fromId(km.id);\n    //   publicKM.verifySwapingCertificate(hiscp);\n    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));\n    // });\n    // it(\"create vector for HISCP\", async () => {\n    //   const km = await KeyManager.generate_Id25519();\n    //   writeVector(km);\n    //   const hiscp = await km.createSwapingCertificate();\n    //   if (!hiscp) assert.fail();\n    //   writeCertificate(hiscp);\n    //   const publicKM = KeyManager.fromId(km.id);\n    //   publicKM.verifySwapingCertificate(hiscp);\n    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));\n    // });\n    // it(\"create vector for HISCP Certificate Chaining\", async () => {\n    //   const km = await KeyManager.generate_Id25519();\n    //   writeVector(km);\n    //   const hiscp = await km.createSwapingCertificate();\n    //   if (!hiscp) assert.fail();\n    //   writeCertificate(hiscp);\n    //   const publicKM = KeyManager.fromId(km.id);\n    //   publicKM.verifySwapingCertificate(hiscp);\n    //   assert.ok(publicKM.verifySwapingCertificate(hiscp));\n    //   // create the new Keymanager iterating on the index\n    //   if (!km.entropy) assert.fail();\n    //   const newkm = await KeyManager.create_Id25519_fromEntropy(km.entropy, 1);\n    //   assert.equal(newkm.id.toString(\"hex\"), hiscp?.newId.toString(\"hex\"));\n    // });\n    it(\"signcrypt and decrypt messages\", async () => {\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        const eve = await __1.KeyManager.generate_Id25519();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);\n        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"encrypt and decrypt messages\", async () => {\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        const eve = await __1.KeyManager.generate_Id25519();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await __1.KeyManager.encrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        const decryptedBob = await bob.decrypt(ENCRYPTED);\n        const decryptedEve = await eve.decrypt(ENCRYPTED);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"signcrypt and blind decrypt messages\", async () => {\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        const eve = await __1.KeyManager.generate_Id25519();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        const decryptedBob = await bob.decrypt(ENCRYPTED);\n        const decryptedEve = await eve.decrypt(ENCRYPTED);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"VaultysId: signcrypt and decrypt messages\", async () => {\n        const alice = await (0, utils_1.createRandomVaultysId)();\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        const eve = await (0, utils_1.createRandomVaultysId)();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);\n        const decryptedEve = await eve.decrypt(ENCRYPTED, alice.id);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"VaultysId: encrypt and decrypt messages\", async () => {\n        const alice = await (0, utils_1.createRandomVaultysId)();\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        const eve = await (0, utils_1.createRandomVaultysId)();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await __1.VaultysId.encrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        const decryptedBob = await bob.decrypt(ENCRYPTED);\n        const decryptedEve = await eve.decrypt(ENCRYPTED);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"VaultysId: signcrypt and blind decrypt messages\", async () => {\n        const alice = await (0, utils_1.createRandomVaultysId)();\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        const eve = await (0, utils_1.createRandomVaultysId)();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id];\n        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        const decryptedBob = await bob.decrypt(ENCRYPTED);\n        const decryptedEve = await eve.decrypt(ENCRYPTED);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n    it(\"Decrypt a sample encrypted message\", async () => {\n        // const bob = await createRandomVaultysId();\n        // console.log(await VaultysId.encrypt(\"test\", [bob.id]));\n        // console.log(bob.getSecret(\"base64\"));\n        const message = \"BEGIN SALTPACK ENCRYPTED MESSAGE. keDIDMQWYvVR58B FTfTeD305hcoHcr Wi4X4pWBmPExHwE WaBDIrIPJ7pgJVE 2Yaxiu3jYK3Osf2 uhjKjQeNaUshMjT QrZdWGFObOEKXZS u5ZF9IyxzRQiBF8 vtIJhLH1kKcDJj4 IQGkhxNTmUljHeo ulEUOyGRt0K3CrR gVkJxxehI8H0GJy 0iJTgCMM7DEX4Jk qmUWofh3hNbfZcs G171PLnJVJ484sS ozpRNJIRMYpHD4g lEdwwVM3NfIoSW3 Cg6FKTrtiNoDgtN gvXoqM96taPvEal dAjNjMgXFcuPT2b U0CFssYXxGKzAnJ gevNrFwrZGLd78h. END SALTPACK ENCRYPTED MESSAGE.\";\n        const id = __1.VaultysId.fromSecret(\"AIShdgGhcMQg3KBa7NhKclRHgvQL/51gDBKkVt9ndZurKDM+wDY4uBSheMRgIEM+lQwxORCD8hOul7keOXea5fMYYghYYL2inBxdB1Uop0p+SGS0ju18I7OOTiMDGGKo7wzTR0xj5xxE9qpTHqHAbWi6fPFaYOXNTK1t6NwVTiNkJDrvqK1OvVrzHnOGoWXEIJRd5AQLlhofk5h7yIGMHzJt5kWUX/J+sTH4gQhGtW1S\", \"base64\");\n        const decrypted = await id.decrypt(message);\n        assert_1.default.equal(decrypted, \"test\");\n    });\n    it(\"should perform Diffie-Hellman key exchange between two KeyManager instances\", async () => {\n        // Create two key managers\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        // Alice performs DH with Bob\n        const aliceSharedSecret = await alice.performDiffieHellman(bob);\n        // Bob performs DH with Alice\n        const bobSharedSecret = await bob.performDiffieHellman(alice);\n        // Verify that they derived the same shared secret\n        assert_1.default.notEqual(aliceSharedSecret, null);\n        assert_1.default.notEqual(bobSharedSecret, null);\n        assert_1.default.equal(aliceSharedSecret?.toString(\"hex\"), bobSharedSecret?.toString(\"hex\"));\n    });\n    it(\"should perform Diffie-Hellman key exchange using static method\", async () => {\n        // Create two key managers\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        // Perform DH using static method\n        const sharedSecret1 = await __1.KeyManager.diffieHellman(alice, bob);\n        const sharedSecret2 = await __1.KeyManager.diffieHellman(bob, alice);\n        // Verify that the static method derives the same shared secret regardless of order\n        assert_1.default.notEqual(sharedSecret1, null);\n        assert_1.default.notEqual(sharedSecret2, null);\n        assert_1.default.equal(sharedSecret1?.toString(\"hex\"), sharedSecret2?.toString(\"hex\"));\n    });\n    it(\"should fail Diffie-Hellman key exchange with a public KeyManager\", async () => {\n        // Create two key managers\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bobPrivate = await __1.KeyManager.generate_Id25519();\n        // Create a public-only version of Bob's KeyManager\n        const bobPublic = __1.KeyManager.fromId(bobPrivate.id);\n        // Alice attempts DH with Bob's public KeyManager (should fail)\n        const aliceSharedSecret = await alice.performDiffieHellman(bobPublic);\n        // Bob's public KeyManager attempts DH with Alice (should fail)\n        const bobSharedSecret = await bobPublic.performDiffieHellman(alice);\n        // Verify that the operations failed\n        // assert.equal(aliceSharedSecret, null);\n        assert_1.default.equal(bobSharedSecret, null);\n    });\n    it(\"should be able to use DH shared secret for encryption and decryption\", async () => {\n        // Create two key managers\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        // Perform DH to get shared secret\n        const aliceSharedSecret = await alice.performDiffieHellman(bob);\n        assert_1.default.notEqual(aliceSharedSecret, null);\n        const nonce = tweetnacl_1.default.randomBytes(tweetnacl_1.default.box.nonceLength);\n        // Use the shared secret for encryption (using a simple XOR for demonstration)\n        const plaintext = buffer_1.Buffer.from(\"Secret message for testing\", \"utf-8\");\n        const encryptedMessage = tweetnacl_1.default.secretbox(plaintext, nonce, aliceSharedSecret);\n        // Bob also derives the shared secret\n        const bobSharedSecret = await bob.performDiffieHellman(alice);\n        assert_1.default.notEqual(bobSharedSecret, null);\n        // Bob decrypts the message\n        const decryptedMessage = buffer_1.Buffer.from(tweetnacl_1.default.secretbox.open(encryptedMessage, nonce, bobSharedSecret));\n        // Verify the decrypted message matches the original\n        assert_1.default.equal(decryptedMessage.toString(\"utf-8\"), plaintext.toString(\"utf-8\"));\n    });\n    it(\"should generate different shared secrets with different key pairs\", async () => {\n        // Create three key managers\n        const alice = await __1.KeyManager.generate_Id25519();\n        const bob = await __1.KeyManager.generate_Id25519();\n        const charlie = await __1.KeyManager.generate_Id25519();\n        // Alice-Bob shared secret\n        const secretAB = await alice.performDiffieHellman(bob);\n        // Alice-Charlie shared secret\n        const secretAC = await alice.performDiffieHellman(charlie);\n        // Bob-Charlie shared secret\n        const secretBC = await bob.performDiffieHellman(charlie);\n        // Verify all shared secrets are different\n        assert_1.default.notEqual(secretAB?.toString(\"hex\"), secretAC?.toString(\"hex\"));\n        assert_1.default.notEqual(secretAB?.toString(\"hex\"), secretBC?.toString(\"hex\"));\n        assert_1.default.notEqual(secretAC?.toString(\"hex\"), secretBC?.toString(\"hex\"));\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nconst pqCrypto_1 = require(\"../src/pqCrypto\");\nconst crypto_1 = require(\"../src/crypto\");\ndescribe(\"Post-Quantum Cryptography\", () => {\n    let keyPair;\n    const testMessage = crypto_1.Buffer.from(\"Hello, Post-Quantum World!\");\n    beforeEach(() => {\n        keyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();\n    });\n    describe(\"DILITHIUM Key Generation\", () => {\n        it(\"should generate different key pairs on each call\", async () => {\n            const keyPair1 = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            const keyPair2 = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            assert_1.default.notDeepEqual(keyPair1.publicKey, keyPair2.publicKey);\n            assert_1.default.notDeepEqual(keyPair1.secretKey, keyPair2.secretKey);\n        });\n        it(\"should generate keys with correct sizes\", async () => {\n            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();\n            assert_1.default.equal(keyPair.publicKey.length, keyInfo.publicKeySize);\n            assert_1.default.equal(keyPair.secretKey.length, keyInfo.secretKeySize);\n        });\n    });\n    describe(\"DILITHIUM Signing\", () => {\n        it(\"should sign a message successfully\", async () => {\n            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);\n            assert_1.default.equal(signature.length > 0, true);\n        });\n        it(\"should produce signatures of correct size\", async () => {\n            const signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);\n            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();\n            assert_1.default.equal(signature.length, keyInfo.signatureSize);\n        });\n        it(\"should produce different signatures for different messages\", async () => {\n            const message1 = crypto_1.Buffer.from(\"Message 1\");\n            const message2 = crypto_1.Buffer.from(\"Message 2\");\n            const signature1 = (0, pqCrypto_1.signDilithium)(message1, keyPair.secretKey);\n            const signature2 = (0, pqCrypto_1.signDilithium)(message2, keyPair.secretKey);\n            assert_1.default.notDeepEqual(signature1, signature2);\n        });\n    });\n    describe(\"DILITHIUM Verification\", () => {\n        let signature;\n        beforeEach(async () => {\n            signature = (0, pqCrypto_1.signDilithium)(testMessage, keyPair.secretKey);\n        });\n        it(\"should verify a valid signature\", async () => {\n            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, keyPair.publicKey);\n            assert_1.default.equal(isValid, true);\n        });\n        it(\"should reject an invalid signature\", async () => {\n            const invalidSignature = crypto_1.Buffer.alloc(signature.length, 0);\n            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, invalidSignature, keyPair.publicKey);\n            assert_1.default.equal(isValid, false);\n        });\n        it(\"should reject signature with wrong message\", async () => {\n            const wrongMessage = crypto_1.Buffer.from(\"Wrong message\");\n            const isValid = (0, pqCrypto_1.verifyDilithium)(wrongMessage, signature, keyPair.publicKey);\n            assert_1.default.equal(isValid, false);\n        });\n        it(\"should reject signature with wrong public key\", async () => {\n            const wrongKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, signature, wrongKeyPair.publicKey);\n            assert_1.default.equal(isValid, false);\n        });\n        it(\"should work with Uint8Array inputs\", async () => {\n            const messageArray = new Uint8Array(testMessage);\n            const signatureArray = new Uint8Array(signature);\n            const publicKeyArray = new Uint8Array(keyPair.publicKey);\n            const isValid = (0, pqCrypto_1.verifyDilithium)(messageArray, signatureArray, publicKeyArray);\n            assert_1.default.equal(isValid, true);\n        });\n        it(\"should handle corrupted signature gracefully\", async () => {\n            const corruptedSignature = crypto_1.Buffer.from(signature);\n            corruptedSignature[0] = corruptedSignature[0] ^ 0xff; // Flip bits\n            const isValid = (0, pqCrypto_1.verifyDilithium)(testMessage, corruptedSignature, keyPair.publicKey);\n            assert_1.default.equal(isValid, false);\n        });\n    });\n    describe(\"COSE Key Creation\", () => {\n        it(\"should create a valid COSE key\", () => {\n            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(keyPair.publicKey);\n            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);\n            assert_1.default.equal(coseKey.get(3), pqCrypto_1.PQ_COSE_ALG.DILITHIUM2);\n            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE), 2);\n            assert_1.default.deepEqual(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), keyPair.publicKey);\n        });\n        it(\"should work with Uint8Array input\", () => {\n            const publicKeyArray = new Uint8Array(keyPair.publicKey);\n            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(publicKeyArray);\n            assert_1.default.equal(coseKey.get(1), pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM);\n        });\n    });\n    describe(\"Key Info\", () => {\n        it(\"should return correct key size information\", () => {\n            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();\n            assert_1.default.equal(keyInfo.publicKeySize, 1952);\n            assert_1.default.equal(keyInfo.secretKeySize, 4032);\n            assert_1.default.equal(keyInfo.signatureSize, 3309);\n        });\n        it(\"should match actual generated key sizes\", async () => {\n            const keyInfo = (0, pqCrypto_1.getDilithiumKeyInfo)();\n            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            assert_1.default.equal(testKeyPair.publicKey.length, keyInfo.publicKeySize);\n            assert_1.default.equal(testKeyPair.secretKey.length, keyInfo.secretKeySize);\n        });\n    });\n    describe(\"Constants\", () => {\n        it(\"should have correct COSE algorithm identifiers\", () => {\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM2, -46);\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM3, -47);\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_ALG.DILITHIUM5, -48);\n        });\n        it(\"should have correct COSE key type\", () => {\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_TYPE.DILITHIUM, 4);\n        });\n        it(\"should have correct COSE key parameters\", () => {\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_MODE, -100);\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK, -101);\n            assert_1.default.equal(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_SK, -102);\n        });\n    });\n    describe(\"End-to-End Workflow\", () => {\n        it(\"should complete full sign-verify cycle\", async () => {\n            // Generate keys\n            const testKeyPair = (0, pqCrypto_1.generateDilithiumKeyPair)();\n            // Sign message\n            const message = crypto_1.Buffer.from(\"End-to-end test message\");\n            const signature = (0, pqCrypto_1.signDilithium)(message, testKeyPair.secretKey);\n            // Verify signature\n            const isValid = (0, pqCrypto_1.verifyDilithium)(message, signature, testKeyPair.publicKey);\n            // Create COSE key\n            const coseKey = (0, pqCrypto_1.createDilithiumCoseKey)(testKeyPair.publicKey);\n            assert_1.default.equal(isValid, true);\n            assert_1.default.equal(coseKey.get(pqCrypto_1.PQ_COSE_KEY_PARAMS.DILITHIUM_PK), testKeyPair.publicKey);\n        });\n        it(\"should handle multiple signatures with same key pair\", async () => {\n            const messages = [crypto_1.Buffer.from(\"Message 1\"), crypto_1.Buffer.from(\"Message 2\"), crypto_1.Buffer.from(\"Message 3\")];\n            const signatures = [];\n            // Sign all messages\n            for (const message of messages) {\n                const signature = (0, pqCrypto_1.signDilithium)(message, keyPair.secretKey);\n                signatures.push(signature);\n            }\n            // Verify all signatures\n            for (let i = 0; i < messages.length; i++) {\n                const isValid = (0, pqCrypto_1.verifyDilithium)(messages[i], signatures[i], keyPair.publicKey);\n                assert_1.default.equal(isValid, true);\n            }\n        });\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst VaultysId_1 = __importDefault(require(\"../src/VaultysId\"));\nconst crypto_1 = require(\"../src/crypto\");\nconst PQManager_1 = __importDefault(require(\"../src/PQManager\"));\ndescribe(\"PQC\", () => {\n    it(\"serder a VaultytsID secret - software\", async () => {\n        const vaultysId = await VaultysId_1.default.generatePerson(true);\n        if (!vaultysId)\n            assert_1.default.fail(\"VaultysId creation failed\");\n        assert_1.default.equal(vaultysId.id.length, 2034);\n        assert_1.default.equal(vaultysId.id.toString(\"hex\").length, 4068);\n        assert_1.default.equal(vaultysId.id.toString(\"base64\").length, 2712);\n        assert_1.default.equal(vaultysId.keyManager.signer.publicKey.length, 1952);\n        const id2 = VaultysId_1.default.fromSecret(vaultysId.getSecret());\n        assert_1.default.equal(vaultysId.id.toString(\"hex\"), id2.id.toString(\"hex\"));\n        assert_1.default.equal(vaultysId.keyManager instanceof PQManager_1.default, true);\n        assert_1.default.equal(id2.keyManager instanceof PQManager_1.default, true);\n    });\n    it(\"serder a VaultytsID - software\", async () => {\n        const vaultysId = await VaultysId_1.default.generateOrganization(true);\n        if (!vaultysId)\n            assert_1.default.fail(\"VaultysId creation failed\");\n        assert_1.default.equal(vaultysId.keyManager.signer.publicKey.length, 1952);\n        assert_1.default.equal(vaultysId.id.length, 2034);\n        const id2 = VaultysId_1.default.fromId(vaultysId.id);\n        assert_1.default.equal(vaultysId.id.toString(\"hex\"), id2.id.toString(\"hex\"));\n        assert_1.default.equal(vaultysId.keyManager instanceof PQManager_1.default, true);\n        assert_1.default.equal(id2.keyManager instanceof PQManager_1.default, true);\n    });\n    it(\"sign/verify with VaultytsID - software\", async () => {\n        const vaultysId = await VaultysId_1.default.generateMachine(true);\n        if (!vaultysId)\n            assert_1.default.fail(\"VaultysId creation failed\");\n        const challenge = (0, crypto_1.randomBytes)(32);\n        const signature = await vaultysId.signChallenge(challenge);\n        assert_1.default.equal(vaultysId.verifyChallenge(challenge, signature, false), true);\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst utils_1 = require(\"./utils\");\ndescribe(\"Saltpack\", () => {\n    it(\"Saltpack working with ID\", async () => {\n        const alice = await (0, utils_1.createRandomVaultysId)();\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        const eve = await (0, utils_1.createRandomVaultysId)();\n        const plaintext = \"This message is authentic!\";\n        const recipients = [bob.id, eve.id, alice.id.toString(\"hex\")];\n        const ENCRYPTED = await alice.signcrypt(plaintext, recipients);\n        if (!ENCRYPTED)\n            assert_1.default.fail();\n        assert_1.default.equal(ENCRYPTED.substring(0, 33), \"BEGIN SALTPACK ENCRYPTED MESSAGE.\");\n        const decryptedBob = await bob.decrypt(ENCRYPTED, alice.id);\n        const decryptedEve = await eve.decrypt(ENCRYPTED);\n        const decryptedAlice = await alice.decrypt(ENCRYPTED, alice.id);\n        assert_1.default.equal(decryptedEve, plaintext);\n        assert_1.default.equal(decryptedEve, decryptedBob);\n        assert_1.default.equal(decryptedEve, decryptedAlice);\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// nodejs polyfill\nconst SoftCredentials_1 = __importDefault(require(\"../src/platform/SoftCredentials\"));\nif (typeof window !== \"undefined\") {\n    window.global = window;\n    // @ts-ignore\n    window.process = { env: {} };\n}\nelse {\n    if (global.navigator) {\n        // node > 20\n        // @ts-ignore\n        global.navigator.credentials = SoftCredentials_1.default;\n    }\n    else {\n        // node <= 20\n        // @ts-ignore\n        global.navigator = {\n            // @ts-ignore\n            credentials: SoftCredentials_1.default,\n        };\n    }\n}\nif (!global.atob)\n    global.atob = (str) => Buffer.from(str, \"base64\").toString(\"latin1\");\nif (!global.btoa)\n    global.btoa = (str) => Buffer.from(str, \"latin1\").toString(\"base64\");\n// @ts-ignore\nglobal.CredentialUserInteractionRequest = () => global.CredentialUserInteractionRequested++;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SoftCredentials_1 = __importDefault(require(\"../src/platform/SoftCredentials\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst crypto_1 = require(\"../src/crypto\");\n// credentials request payload\nconst createRequest = (alg) => {\n    const challenge = (0, crypto_1.randomBytes)(32);\n    return {\n        publicKey: {\n            challenge,\n            rp: {\n                name: \"Tests ID\",\n                id: \"I am the new guy\",\n            },\n            user: {\n                id: Buffer.from(\"ertyu45678RUTYESEZTYSDYJTUE4576232453\", \"utf8\"),\n                name: \"john.smith@mail.com\",\n                displayName: \"John Smith\",\n            },\n            pubKeyCredParams: [\n                {\n                    type: \"public-key\",\n                    alg,\n                },\n            ],\n        },\n    };\n};\nlet attestation;\ndescribe(\"SoftCredentials\", () => {\n    it(\"create attestation (ECDSA)\", async () => {\n        attestation = await SoftCredentials_1.default.create(createRequest(-7));\n        //console.log(attestation);\n    });\n    it(\"create attestation (EdDSA)\", async () => {\n        await SoftCredentials_1.default.create(createRequest(-8));\n    });\n    it(\"get assertion and verify with attestation using ECDSA\", async () => {\n        const payload = {\n            publicKey: {\n                challenge: (0, crypto_1.randomBytes)(32),\n                allowCredentials: [\n                    {\n                        type: \"public-key\",\n                        id: attestation.rawId,\n                    },\n                ],\n            },\n        };\n        const assertion = await SoftCredentials_1.default.get(payload);\n        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(Buffer.from(assertion.response.clientDataJSON)), payload.publicKey.challenge.toString(\"base64\"));\n        const verified = SoftCredentials_1.default.verify(attestation, assertion);\n        assert_1.default.ok(verified);\n    });\n    it(\"verify assertion with attestation using github webauthn json coming from yubikey credentials\", async () => {\n        const attestationSafe = {\n            type: \"public-key\",\n            id: \"vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA\",\n            rawId: Buffer.from(\"vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA\", \"base64\"),\n            response: {\n                clientDataJSON: Buffer.from(\"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiZkl3bFU5NHNNcUsyMVNrX1BYbFIzU2hLU0JVc0t6dFVpX0pqNE5YampSOCIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ\", \"base64\"),\n                attestationObject: Buffer.from(\"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjh3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolBBAAAAAQAAAAAAAAAAAAAAAAAAAAAAgLy4xOjmwXw2QmUiRKrdR4Q6JLjujuRc7cew0n0LbO0BGo9Am469Eq8vo1binQwNzicM5PI4coI5uvulrJIbFjMgQ3DDLYrTErcGO4rPBu6QirlIqw2d_gCmWAKppxegqiIiwcUsbw5ddYlTjHAYJBcDi3_Kxqr9OXN5Oq9l2dEgpAEBAycgBiFYIO6J63OnkjzyQ--iXSbgm1oLSl3wzlDCy4ohwkbN-l4I\", \"base64\"),\n                transports: [\"nfc\", \"usb\", \"ble\", \"internal\", \"hybrid\"],\n            },\n            clientExtensionResults: {},\n        };\n        const assertion = {\n            type: \"public-key\",\n            id: \"vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA\",\n            rawId: Buffer.from(\"vLjE6ObBfDZCZSJEqt1HhDokuO6O5Fztx7DSfQts7QEaj0Cbjr0Sry-jVuKdDA3OJwzk8jhygjm6-6WskhsWMyBDcMMtitMStwY7is8G7pCKuUirDZ3-AKZYAqmnF6CqIiLBxSxvDl11iVOMcBgkFwOLf8rGqv05c3k6r2XZ0SA\", \"base64\"),\n            response: {\n                clientDataJSON: Buffer.from(\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQU9tZmdkbnV4cl8ydWw4T1pMekFXUk1SYkd0NXkzbHIxMURxcnF3UUdMVSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wucWp6OXprL3lhYlBleCJ9\", \"base64\"),\n                authenticatorData: Buffer.from(\"3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolABAAAAIQ\", \"base64\"),\n                signature: Buffer.from(\"_eq8EwX_twQyWjyiCvCDu5JLKEWpMxW9Pz0Qwpt8A5UcHJyGoGQMrssaws-jwqIpKxkVU7MBlHzHUgFULFn5Cw\", \"base64\"),\n                userHandle: null,\n            },\n            clientExtensionResults: {},\n        };\n        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), \"fIwlU94sMqK21Sk/PXlR3ShKSBUsKztUi/Jj4NXjjR8=\");\n        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), \"AOmfgdnuxr/2ul8OZLzAWRMRbGt5y3lr11DqrqwQGLU=\");\n        // @ts-expect-error mockup\n        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion);\n        assert_1.default.ok(verified);\n    });\n    // it(\"attestation response from yubikey should be verified\", async () => {\n    //   const response = {\n    //     clientDataJSON: Buffer.from(\"eyJjaGFsbGVuZ2UiOiJZTVdFVGYtUDc5aU1iLUJxZFRreVNOUmVPdmE3bksyaVZDOWZpQzhpR3ZZeXB1bkVPQ1pHWjYtWTVPVjFydk1pRGdBaldmRmk2VUMwV3lLR3NqQS1nQSIsIm9yaWdpbiI6Imh0dHBzOi8vd2ViYXV0aG4ub3JnIiwidHlwZSI6IndlYmF1dGhuLmNyZWF0ZSJ9\", \"base64\"),\n    //     attestationObject: Buffer.from(\"o2NmbXRmcGFja2VkZ2F0dFN0bXSjY2FsZyZjc2lnWEcwRQIhAIzOihC6Ba80o5JnoYOJJ_EtEVmWQcAvxVCnsCFnVRQZAiAfeIddLPsPl1FeSX8B5xZANcQKGNoO7pb0TZPnuJdebGN4NWOBWQKzMIICrzCCAZegAwIBAgIESFs9tjANBgkqhkiG9w0BAQsFADAhMR8wHQYDVQQDDBZZdWJpY28gRklETyBQcmV2aWV3IENBMB4XDTE4MDQxMjEwNTcxMFoXDTE4MTIzMTEwNTcxMFowbzELMAkGA1UEBhMCU0UxEjAQBgNVBAoMCVl1YmljbyBBQjEiMCAGA1UECwwZQXV0aGVudGljYXRvciBBdHRlc3RhdGlvbjEoMCYGA1UEAwwfWXViaWNvIFUyRiBFRSBTZXJpYWwgMTIxMzkzOTEyNjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABPss3TBDKMVySlDM5vYLrX0nqRtZ4eZvKXuJydQ9wrLHeIm08P-dAijLlG384BsZWJtngEqsl38oGJzNsyV0yiijbDBqMCIGCSsGAQQBgsQKAgQVMS4zLjYuMS40LjEuNDE0ODIuMS42MBMGCysGAQQBguUcAgEBBAQDAgQwMCEGCysGAQQBguUcAQEEBBIEEPigEfOMCk0VgAYXER-e3H0wDAYDVR0TAQH_BAIwADANBgkqhkiG9w0BAQsFAAOCAQEAMvPkvVjXQiuvSZmGCB8NqTvGqhxyEfkoU-vz63PaaTsG3jEzjl0C7PZ26VxCvqWPJdM3P3e7Kp18sj4RjEHUmkya2PPipOwBd3p0qMQSQ8MeziCPLQ9uvGGb4YShcvaprMv4c21b4piza-znHneNCmmq-ZS4Y23o-vYv085_BEwyLPcmPjSZ5qWysCq7rVvZ7OWwcU1zu5RhSZyUKl8dzK9lAzs5OdRH2fzEewsW2OkB_Ow_jBvAxqwLXXTHuwMFaRfpmBoZuQlcofSrnwJ8KA-K-e0dKTz2zC8EbZrWYrSpbrHKyqxeBT6DkUd8H4tgAd5lOr_yqrtVmIaRfq07NmhhdXRoRGF0YVjElWkIjx7O4yMpVANdvRDXyuORMFonUbVZu4_Xy7IpvdRBAAAAAPigEfOMCk0VgAYXER-e3H0AQMLC68jgMVzFOeLNnwklj81o1xzgSj6ZaDflB37Y-P66SLugWcTV6aZvNn-2Ool_RRDiinkufjdkwC3ssy5yXwClAQIDJiABIVggAYD1TSpf120DSVxen8ki56kF1bmT4EXO-P0JnSk5mMwiWCB3TlMZBRqPY6llzDcfHd-oW0EHdaFNgBdlGGFobpHKlw\", \"base64\"),\n    //   };\n    //   // @ts-expect-error mockup\n    //   const info = SoftCredentials.getCertificateInfo(response);\n    //   assert.deepStrictEqual(info, {\n    //     issuer: \"CN=Yubico FIDO Preview CA\",\n    //     issuerName: \"CN=Yubico FIDO Preview CA\",\n    //     subject: {\n    //       C: \"SE\",\n    //       O: \"Yubico AB\",\n    //       OU: \"Authenticator Attestation\",\n    //       CN: \"Yubico U2F EE Serial 1213939126\",\n    //     },\n    //     version: \"v3 (2)\",\n    //     basicConstraintsCA: false,\n    //   });\n    //   // @ts-expect-error mockup\n    //   assert.ok(await SoftCredentials.verifyPackedAttestation(response));\n    // });\n    // it(\"no attestation in response should be valid and not be verified\", async () => {\n    //   const response = {\n    //     attestationObject: Buffer.from(\"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjFk2rw5H3LiaP/1p3XV4I1wW43p60EG8RCpFuQTrBOPiRFAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQGV0qcd/M/uuCBaLC0jX8PRZ9e5cEZTKp9Ngf6NCKWSdWinmpK7FYog14m5kfAepzh93Z4hrGD8M57ljxoBKXL0pQECAyYgASFYIIqukdwfB/WgIxfpOO3tGOKIp+xPsx1TCc2UPjC7G7BlIlggNJL1zJSlN2EAFhnKSxihoY6HZXopi1Wte83dgWlosoQ=\", \"base64\"),\n    //     clientDataJSON: Buffer.from(\"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiWXpTYkpBbGIya0N6Qm1xa1U3cG9Nem92LXNONU5HcHRuWUFrUElkRWt4VSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5c2lkMi5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ==\", \"base64\"),\n    //   };\n    //   // @ts-expect-error mockup\n    //   const info = SoftCredentials.getCertificateInfo(response);\n    //   assert.equal(info, null);\n    //   // @ts-expect-error mockup\n    //   assert.ok(!(await SoftCredentials.verifyPackedAttestation(response)));\n    // });\n    it(\"verify assertion with attestation using github webauthn json coming from macosx credentials\", async () => {\n        const attestationSafe = {\n            type: \"public-key\",\n            id: \"AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww\",\n            rawId: Buffer.from(\"AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww\", \"base64\"),\n            response: {\n                clientDataJSON: Buffer.from(\"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYVJFMWVnWjZHMS1BRUVPSXpQbWxOckFnT1N5RWVWRG44OUtDREUxRGRPRSIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wveWFiUGV4In0\", \"base64\"),\n                attestationObject: Buffer.from(\"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVkBP95PnSmphYcbW5aQmrH4XxNTCSWKcxK2I6tg6rwoRqJQRWH4It6tzgACNbzGCmSLCyXx8FUDALsB0ZOqKwDT-cWVs5CONEISWspV32MwLtg4zUubj0ChAUtd9UrxNBmi-E3xgRklpMdTscGJhgCcIfjAgMANx5bSdj9RKVz_4oszDIH81EvIuBtDfhJQtNJiMcXi09lY7vVaDBpcLGnhM-LovZKjQvfDoH_G_1Zu98IoMCnnomTjiT-VCw_jfVb-DmFjU-x3Wv9U4i668_5h-W7HBZLoLiafYEu-n8tt12Gf1VT9frDUfMcmI5lubUOWTRjDpQECAyYgASFYIM3N0z1jSTixc7fNwxy1BtBUrNUOiPOm2j7Zlwx6s8eXIlggKB-zZiuYTAaAdPVQuN5EUQeRNX0kjS2oikGCJsymvH8\", \"base64\"),\n                transports: [\"internal\"],\n            },\n            clientExtensionResults: {},\n        };\n        const assertion = {\n            type: \"public-key\",\n            id: \"AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww\",\n            rawId: Buffer.from(\"AdGTqisA0_nFlbOQjjRCElrKVd9jMC7YOM1Lm49AoQFLXfVK8TQZovhN8YEZJaTHU7HBiYYAnCH4wIDADceW0nY_USlc_-KLMwyB_NRLyLgbQ34SULTSYjHF4tPZWO71WgwaXCxp4TPi6L2So0L3w6B_xv9WbvfCKDAp56Jk44k_lQsP431W_g5hY1Psd1r_VOIuuvP-YfluxwWS6C4mn2BLvp_Lbddhn9VU_X6w1HzHJiOZbm1Dlk0Yww\", \"base64\"),\n            response: {\n                clientDataJSON: Buffer.from(\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoibUlySjNsVWxsNXRadjhfa25kMEJEeU12VlVFcnhBY19CWWNkX2hOQ2lZZyIsIm9yaWdpbiI6Imh0dHBzOi8vdmF1bHR5cy5sb2NhLmx0IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ\", \"base64\"),\n                authenticatorData: Buffer.from(\"3k-dKamFhxtblpCasfhfE1MJJYpzErYjq2DqvChGolAFYgu7dQ\", \"base64\"),\n                signature: Buffer.from(\"MEQCIFyGZIbrLunau93lnx0vTkWQjr_CcTkjYhyZ1-szXRPeAiBXwyQRQhMn59eva_CRlZOTQ_TLAgxr3eCWbwa1dQBnTA\", \"base64\"),\n                userHandle: Buffer.from(\"ZGlkOnZhdWx0eXM6MzI2ZjUyY2VkNjRhYmE4YzQ4MWRkMDU3ZDFkODA0MGY0ZWE3MzZiMA\", \"base64\"),\n            },\n            clientExtensionResults: {},\n        };\n        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(attestationSafe.response.clientDataJSON), \"aRE1egZ6G1+AEEOIzPmlNrAgOSyEeVDn89KCDE1DdOE=\");\n        assert_1.default.equal(SoftCredentials_1.default.extractChallenge(assertion.response.clientDataJSON), \"mIrJ3lUll5tZv8/knd0BDyMvVUErxAc/BYcd/hNCiYg=\");\n        // @ts-expect-error mockup\n        const verified = SoftCredentials_1.default.verify(attestationSafe, assertion, true);\n        assert_1.default.ok(verified);\n    });\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allVaultysIdType = exports.createRandomVaultysId = void 0;\nconst __1 = require(\"../\");\nconst SoftCredentials_1 = __importDefault(require(\"../src/platform/SoftCredentials\"));\nconst pqCrypto_1 = require(\"../src/pqCrypto\");\nconst createRandomVaultysId = async () => {\n    const types = [0, 1, 2];\n    if (typeof window === \"undefined\") {\n        types.push(3);\n        types.push(4);\n    }\n    const pqc = Math.random() < 0.5;\n    const type = types[Math.floor(Math.random() * types.length)];\n    switch (type) {\n        case 0:\n            return __1.VaultysId.generateMachine(pqc);\n        case 1:\n            return __1.VaultysId.generatePerson(pqc);\n        case 2:\n            return __1.VaultysId.generateOrganization(pqc);\n        case 3:\n            const attestation1 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, false));\n            // @ts-expect-error mockup\n            return __1.VaultysId.fido2FromAttestation(attestation1);\n        case 4:\n            const attestation2 = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqc ? pqCrypto_1.PQ_COSE_ALG.DILITHIUM2 : Math.random() < 0.5 ? -8 : -7, true));\n            // @ts-expect-error mockup\n            return __1.VaultysId.fido2FromAttestation(attestation2);\n        default:\n            return __1.VaultysId.generatePerson();\n    }\n};\nexports.createRandomVaultysId = createRandomVaultysId;\nconst allVaultysIdType = async () => {\n    const result = [await __1.VaultysId.generateMachine(), await __1.VaultysId.generateMachine(true), await __1.VaultysId.generatePerson(), await __1.VaultysId.generatePerson(true)];\n    if (typeof window === \"undefined\") {\n        let attestation = await navigator.credentials.create(SoftCredentials_1.default.createRequest(pqCrypto_1.PQ_COSE_ALG.DILITHIUM2));\n        // @ts-expect-error mockup\n        result.push(await __1.VaultysId.fido2FromAttestation(attestation));\n        attestation = await navigator.credentials.create(SoftCredentials_1.default.createRequest(-7));\n        // @ts-expect-error mockup\n        result.push(await __1.VaultysId.fido2FromAttestation(attestation));\n        attestation = await navigator.credentials.create(SoftCredentials_1.default.createRequest(-8));\n        // @ts-expect-error mockup\n        result.push(await __1.VaultysId.fido2FromAttestation(attestation));\n    }\n    return result;\n};\nexports.allVaultysIdType = allVaultysIdType;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst __1 = require(\"../\");\nconst assert_1 = __importDefault(require(\"assert\"));\nrequire(\"./shims\");\nconst utils_1 = require(\"./utils\");\nconst generateWot = async (max = 4) => {\n    const result = [];\n    for (let i = 0; i < max; i++) {\n        const vaultysId = await __1.VaultysId.generatePerson();\n        const s = (0, __1.MemoryStorage)(() => \"\");\n        const jeanjacques = new __1.IdManager(vaultysId, s);\n        result.push(jeanjacques);\n    }\n    return result;\n};\nconst testCertificate = (rogueCert) => {\n    try {\n        const result = __1.Challenger.deserializeCertificate(rogueCert);\n        return result;\n    }\n    catch (error) {\n        return {\n            state: -2,\n        };\n    }\n};\ndescribe(\"VaultysId Migration\", () => {\n    it(\"create VaultysId  with version 1 by default\", async () => {\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        assert_1.default.equal(bob.version, 1);\n    });\n    it(\"Migrate VaultysId to Version 0\", async () => {\n        const bob = await (0, utils_1.createRandomVaultysId)();\n        bob.toVersion(0);\n        assert_1.default.equal(bob.version, 0);\n    });\n    it(\"Migrate IdManager to Version 0\", async () => {\n        const vaultysId = await (0, utils_1.createRandomVaultysId)();\n        const s = (0, __1.MemoryStorage)(() => \"\");\n        const bob = new __1.IdManager(vaultysId, s);\n        const wot = await generateWot();\n        for (let i = 0; i < wot.length; i++) {\n            const jeanjacques = wot[i];\n            const channel = __1.MemoryChannel.createBidirectionnal();\n            if (!channel.otherend)\n                assert_1.default.fail();\n            await Promise.all([jeanjacques.askContact(channel), bob.acceptContact(channel.otherend)]);\n        }\n        bob.migrate(0);\n        wot.forEach((jeanjacques) => {\n            jeanjacques.migrate(0);\n            // console.log(jeanjacques);\n            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);\n        });\n        assert_1.default.equal(bob.store.substore(\"wot\").list().length, wot.length);\n        assert_1.default.equal(bob.store.substore(\"contacts\").list().length, wot.length);\n        assert_1.default.equal(bob.vaultysId.version, 0);\n        bob.migrate(1);\n        wot.forEach((jeanjacques) => {\n            jeanjacques.migrate(1);\n            //console.log(jeanjacques);\n            assert_1.default.notEqual(bob.getContact(jeanjacques.vaultysId.did), null);\n        });\n        assert_1.default.equal(bob.store.substore(\"wot\").list().length, wot.length);\n        assert_1.default.equal(bob.store.substore(\"contacts\").list().length, wot.length);\n        assert_1.default.equal(bob.vaultysId.version, 1);\n    }).timeout(5000);\n});\ndescribe(\"Symetric Proof of Relationship - SRG - V0\", () => {\n    it(\"Perform Protocol with KeyManager\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 0);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(!challenger2.isComplete());\n        await challenger2.update(challenger1.getCertificate());\n        // SYMETRIC PROOF\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Succeed for different vaultysId versions\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2.toVersion(0));\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 0);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n});\ndescribe(\"Symetric Proof of Relationship - SRG - V1\", () => {\n    it(\"Perform Protocol with KeyManager\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1);\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.equal(challenger1.isComplete(), false);\n        assert_1.default.equal(challenger1.hasFailed(), false);\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(!challenger2.isComplete());\n        await challenger2.update(challenger1.getCertificate());\n        // SYMETRIC PROOF\n        assert_1.default.ok(challenger1.isComplete());\n        assert_1.default.ok(challenger2.isComplete());\n        assert_1.default.equal(challenger1.toString(), challenger2.toString());\n    });\n    it(\"Succeed for different vaultysId versions\", async () => {\n        const vaultysId1 = await (0, utils_1.createRandomVaultysId)();\n        const challenger1 = new __1.Challenger(vaultysId1.toVersion(0));\n        const vaultysId2 = await (0, utils_1.createRandomVaultysId)();\n        const challenger2 = new __1.Challenger(vaultysId2);\n        assert_1.default.ok(!challenger1.isComplete());\n        assert_1.default.ok(!challenger1.hasFailed());\n        challenger1.createChallenge(\"p2p\", \"auth\", 1);\n        await challenger2.update(challenger1.getCertificate());\n        await challenger1.update(challenger2.getCertificate());\n        await challenger2.update(challenger1.getCertificate());\n    });\n});\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(\"./test/shims.ts\");\n__webpack_require__(\"./test/pqc.test.ts\");\n__webpack_require__(\"./test/pqcManager.web.test.ts\");\n__webpack_require__(\"./test/challenger_v0.test.ts\");\n__webpack_require__(\"./test/challenger.test.ts\");\n__webpack_require__(\"./test/file.browser_test.ts\");\n__webpack_require__(\"./test/channel.test.ts\");\n__webpack_require__(\"./test/idManager.test.ts\");\n__webpack_require__(\"./test/saltpack.test.ts\");\n__webpack_require__(\"./test/softCredentials.test.ts\");\n__webpack_require__(\"./test/v0toV1.test.ts\");\nvar __webpack_exports__ = __webpack_require__(\"./test/keymanager.test.ts\");\n",""],"names":[],"sourceRoot":""}